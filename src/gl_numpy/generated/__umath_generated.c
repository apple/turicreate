/* Copyright Â© 2017 Apple Inc. All rights reserved.
 *
 * Use of this source code is governed by a BSD-3-clause license that can
 * be found in the LICENSE.txt file or at https://opensource.org/licenses/BSD-3-Clause
 */


/** Warning this file is autogenerated!!!

    Please make changes to the code generator program (numpy/core/code_generators/generate_umath.py)
**/

static PyUFuncGenericFunction _arg_functions[] = {CFLOAT__arg, CDOUBLE__arg, CLONGDOUBLE__arg};
static void * _arg_data[] = {(void *)NULL, (void *)NULL, (void *)NULL};
static char _arg_signatures[] = {NPY_CFLOAT, NPY_FLOAT, NPY_CDOUBLE, NPY_DOUBLE, NPY_CLONGDOUBLE, NPY_LONGDOUBLE};
static PyUFuncGenericFunction _ones_like_functions[] = {BOOL__ones_like, BYTE__ones_like, UBYTE__ones_like, SHORT__ones_like, USHORT__ones_like, INT__ones_like, UINT__ones_like, LONG__ones_like, ULONG__ones_like, LONGLONG__ones_like, ULONGLONG__ones_like, HALF__ones_like, FLOAT__ones_like, DOUBLE__ones_like, LONGDOUBLE__ones_like, CFLOAT__ones_like, CDOUBLE__ones_like, CLONGDOUBLE__ones_like, DATETIME__ones_like, TIMEDELTA__ones_like, NULL};
static void * _ones_like_data[] = {(void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL};
static char _ones_like_signatures[] = {NPY_BOOL, NPY_BOOL, NPY_BYTE, NPY_BYTE, NPY_UBYTE, NPY_UBYTE, NPY_SHORT, NPY_SHORT, NPY_USHORT, NPY_USHORT, NPY_INT, NPY_INT, NPY_UINT, NPY_UINT, NPY_LONG, NPY_LONG, NPY_ULONG, NPY_ULONG, NPY_LONGLONG, NPY_LONGLONG, NPY_ULONGLONG, NPY_ULONGLONG, NPY_HALF, NPY_HALF, NPY_FLOAT, NPY_FLOAT, NPY_DOUBLE, NPY_DOUBLE, NPY_LONGDOUBLE, NPY_LONGDOUBLE, NPY_CFLOAT, NPY_CFLOAT, NPY_CDOUBLE, NPY_CDOUBLE, NPY_CLONGDOUBLE, NPY_CLONGDOUBLE, NPY_DATETIME, NPY_DATETIME, NPY_TIMEDELTA, NPY_TIMEDELTA, NPY_OBJECT, NPY_OBJECT};
static PyUFuncGenericFunction absolute_functions[] = {BOOL_absolute, BYTE_absolute, UBYTE_absolute, SHORT_absolute, USHORT_absolute, INT_absolute, UINT_absolute, LONG_absolute, ULONG_absolute, LONGLONG_absolute, ULONGLONG_absolute, HALF_absolute, FLOAT_absolute, DOUBLE_absolute, LONGDOUBLE_absolute, TIMEDELTA_absolute, CFLOAT_absolute, CDOUBLE_absolute, CLONGDOUBLE_absolute, NULL};
static void * absolute_data[] = {(void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL};
static char absolute_signatures[] = {NPY_BOOL, NPY_BOOL, NPY_BYTE, NPY_BYTE, NPY_UBYTE, NPY_UBYTE, NPY_SHORT, NPY_SHORT, NPY_USHORT, NPY_USHORT, NPY_INT, NPY_INT, NPY_UINT, NPY_UINT, NPY_LONG, NPY_LONG, NPY_ULONG, NPY_ULONG, NPY_LONGLONG, NPY_LONGLONG, NPY_ULONGLONG, NPY_ULONGLONG, NPY_HALF, NPY_HALF, NPY_FLOAT, NPY_FLOAT, NPY_DOUBLE, NPY_DOUBLE, NPY_LONGDOUBLE, NPY_LONGDOUBLE, NPY_TIMEDELTA, NPY_TIMEDELTA, NPY_CFLOAT, NPY_FLOAT, NPY_CDOUBLE, NPY_DOUBLE, NPY_CLONGDOUBLE, NPY_LONGDOUBLE, NPY_OBJECT, NPY_OBJECT};
static PyUFuncGenericFunction add_functions[] = {BOOL_add, BYTE_add, UBYTE_add, SHORT_add, USHORT_add, INT_add, UINT_add, LONG_add, ULONG_add, LONGLONG_add, ULONGLONG_add, HALF_add, FLOAT_add, DOUBLE_add, LONGDOUBLE_add, CFLOAT_add, CDOUBLE_add, CLONGDOUBLE_add, DATETIME_Mm_M_add, TIMEDELTA_mm_m_add, DATETIME_mM_M_add, NULL};
static void * add_data[] = {(void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL};
static char add_signatures[] = {NPY_BOOL, NPY_BOOL, NPY_BOOL, NPY_BYTE, NPY_BYTE, NPY_BYTE, NPY_UBYTE, NPY_UBYTE, NPY_UBYTE, NPY_SHORT, NPY_SHORT, NPY_SHORT, NPY_USHORT, NPY_USHORT, NPY_USHORT, NPY_INT, NPY_INT, NPY_INT, NPY_UINT, NPY_UINT, NPY_UINT, NPY_LONG, NPY_LONG, NPY_LONG, NPY_ULONG, NPY_ULONG, NPY_ULONG, NPY_LONGLONG, NPY_LONGLONG, NPY_LONGLONG, NPY_ULONGLONG, NPY_ULONGLONG, NPY_ULONGLONG, NPY_HALF, NPY_HALF, NPY_HALF, NPY_FLOAT, NPY_FLOAT, NPY_FLOAT, NPY_DOUBLE, NPY_DOUBLE, NPY_DOUBLE, NPY_LONGDOUBLE, NPY_LONGDOUBLE, NPY_LONGDOUBLE, NPY_CFLOAT, NPY_CFLOAT, NPY_CFLOAT, NPY_CDOUBLE, NPY_CDOUBLE, NPY_CDOUBLE, NPY_CLONGDOUBLE, NPY_CLONGDOUBLE, NPY_CLONGDOUBLE, NPY_DATETIME, NPY_TIMEDELTA, NPY_DATETIME, NPY_TIMEDELTA, NPY_TIMEDELTA, NPY_TIMEDELTA, NPY_TIMEDELTA, NPY_DATETIME, NPY_DATETIME, NPY_OBJECT, NPY_OBJECT, NPY_OBJECT};
static PyUFuncGenericFunction arccos_functions[] = {NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL};
static void * arccos_data[] = {(void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)"arccos"};
static char arccos_signatures[] = {NPY_HALF, NPY_HALF, NPY_FLOAT, NPY_FLOAT, NPY_DOUBLE, NPY_DOUBLE, NPY_LONGDOUBLE, NPY_LONGDOUBLE, NPY_CFLOAT, NPY_CFLOAT, NPY_CDOUBLE, NPY_CDOUBLE, NPY_CLONGDOUBLE, NPY_CLONGDOUBLE, NPY_OBJECT, NPY_OBJECT};
static PyUFuncGenericFunction arccosh_functions[] = {NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL};
static void * arccosh_data[] = {(void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)"arccosh"};
static char arccosh_signatures[] = {NPY_HALF, NPY_HALF, NPY_FLOAT, NPY_FLOAT, NPY_DOUBLE, NPY_DOUBLE, NPY_LONGDOUBLE, NPY_LONGDOUBLE, NPY_CFLOAT, NPY_CFLOAT, NPY_CDOUBLE, NPY_CDOUBLE, NPY_CLONGDOUBLE, NPY_CLONGDOUBLE, NPY_OBJECT, NPY_OBJECT};
static PyUFuncGenericFunction arcsin_functions[] = {NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL};
static void * arcsin_data[] = {(void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)"arcsin"};
static char arcsin_signatures[] = {NPY_HALF, NPY_HALF, NPY_FLOAT, NPY_FLOAT, NPY_DOUBLE, NPY_DOUBLE, NPY_LONGDOUBLE, NPY_LONGDOUBLE, NPY_CFLOAT, NPY_CFLOAT, NPY_CDOUBLE, NPY_CDOUBLE, NPY_CLONGDOUBLE, NPY_CLONGDOUBLE, NPY_OBJECT, NPY_OBJECT};
static PyUFuncGenericFunction arcsinh_functions[] = {NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL};
static void * arcsinh_data[] = {(void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)"arcsinh"};
static char arcsinh_signatures[] = {NPY_HALF, NPY_HALF, NPY_FLOAT, NPY_FLOAT, NPY_DOUBLE, NPY_DOUBLE, NPY_LONGDOUBLE, NPY_LONGDOUBLE, NPY_CFLOAT, NPY_CFLOAT, NPY_CDOUBLE, NPY_CDOUBLE, NPY_CLONGDOUBLE, NPY_CLONGDOUBLE, NPY_OBJECT, NPY_OBJECT};
static PyUFuncGenericFunction arctan_functions[] = {NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL};
static void * arctan_data[] = {(void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)"arctan"};
static char arctan_signatures[] = {NPY_HALF, NPY_HALF, NPY_FLOAT, NPY_FLOAT, NPY_DOUBLE, NPY_DOUBLE, NPY_LONGDOUBLE, NPY_LONGDOUBLE, NPY_CFLOAT, NPY_CFLOAT, NPY_CDOUBLE, NPY_CDOUBLE, NPY_CLONGDOUBLE, NPY_CLONGDOUBLE, NPY_OBJECT, NPY_OBJECT};
static PyUFuncGenericFunction arctan2_functions[] = {NULL, NULL, NULL, NULL, NULL};
static void * arctan2_data[] = {(void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)"arctan2"};
static char arctan2_signatures[] = {NPY_HALF, NPY_HALF, NPY_HALF, NPY_FLOAT, NPY_FLOAT, NPY_FLOAT, NPY_DOUBLE, NPY_DOUBLE, NPY_DOUBLE, NPY_LONGDOUBLE, NPY_LONGDOUBLE, NPY_LONGDOUBLE, NPY_OBJECT, NPY_OBJECT, NPY_OBJECT};
static PyUFuncGenericFunction arctanh_functions[] = {NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL};
static void * arctanh_data[] = {(void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)"arctanh"};
static char arctanh_signatures[] = {NPY_HALF, NPY_HALF, NPY_FLOAT, NPY_FLOAT, NPY_DOUBLE, NPY_DOUBLE, NPY_LONGDOUBLE, NPY_LONGDOUBLE, NPY_CFLOAT, NPY_CFLOAT, NPY_CDOUBLE, NPY_CDOUBLE, NPY_CLONGDOUBLE, NPY_CLONGDOUBLE, NPY_OBJECT, NPY_OBJECT};
static PyUFuncGenericFunction bitwise_and_functions[] = {BOOL_bitwise_and, BYTE_bitwise_and, UBYTE_bitwise_and, SHORT_bitwise_and, USHORT_bitwise_and, INT_bitwise_and, UINT_bitwise_and, LONG_bitwise_and, ULONG_bitwise_and, LONGLONG_bitwise_and, ULONGLONG_bitwise_and, NULL};
static void * bitwise_and_data[] = {(void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL};
static char bitwise_and_signatures[] = {NPY_BOOL, NPY_BOOL, NPY_BOOL, NPY_BYTE, NPY_BYTE, NPY_BYTE, NPY_UBYTE, NPY_UBYTE, NPY_UBYTE, NPY_SHORT, NPY_SHORT, NPY_SHORT, NPY_USHORT, NPY_USHORT, NPY_USHORT, NPY_INT, NPY_INT, NPY_INT, NPY_UINT, NPY_UINT, NPY_UINT, NPY_LONG, NPY_LONG, NPY_LONG, NPY_ULONG, NPY_ULONG, NPY_ULONG, NPY_LONGLONG, NPY_LONGLONG, NPY_LONGLONG, NPY_ULONGLONG, NPY_ULONGLONG, NPY_ULONGLONG, NPY_OBJECT, NPY_OBJECT, NPY_OBJECT};
static PyUFuncGenericFunction bitwise_or_functions[] = {BOOL_bitwise_or, BYTE_bitwise_or, UBYTE_bitwise_or, SHORT_bitwise_or, USHORT_bitwise_or, INT_bitwise_or, UINT_bitwise_or, LONG_bitwise_or, ULONG_bitwise_or, LONGLONG_bitwise_or, ULONGLONG_bitwise_or, NULL};
static void * bitwise_or_data[] = {(void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL};
static char bitwise_or_signatures[] = {NPY_BOOL, NPY_BOOL, NPY_BOOL, NPY_BYTE, NPY_BYTE, NPY_BYTE, NPY_UBYTE, NPY_UBYTE, NPY_UBYTE, NPY_SHORT, NPY_SHORT, NPY_SHORT, NPY_USHORT, NPY_USHORT, NPY_USHORT, NPY_INT, NPY_INT, NPY_INT, NPY_UINT, NPY_UINT, NPY_UINT, NPY_LONG, NPY_LONG, NPY_LONG, NPY_ULONG, NPY_ULONG, NPY_ULONG, NPY_LONGLONG, NPY_LONGLONG, NPY_LONGLONG, NPY_ULONGLONG, NPY_ULONGLONG, NPY_ULONGLONG, NPY_OBJECT, NPY_OBJECT, NPY_OBJECT};
static PyUFuncGenericFunction bitwise_xor_functions[] = {BOOL_bitwise_xor, BYTE_bitwise_xor, UBYTE_bitwise_xor, SHORT_bitwise_xor, USHORT_bitwise_xor, INT_bitwise_xor, UINT_bitwise_xor, LONG_bitwise_xor, ULONG_bitwise_xor, LONGLONG_bitwise_xor, ULONGLONG_bitwise_xor, NULL};
static void * bitwise_xor_data[] = {(void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL};
static char bitwise_xor_signatures[] = {NPY_BOOL, NPY_BOOL, NPY_BOOL, NPY_BYTE, NPY_BYTE, NPY_BYTE, NPY_UBYTE, NPY_UBYTE, NPY_UBYTE, NPY_SHORT, NPY_SHORT, NPY_SHORT, NPY_USHORT, NPY_USHORT, NPY_USHORT, NPY_INT, NPY_INT, NPY_INT, NPY_UINT, NPY_UINT, NPY_UINT, NPY_LONG, NPY_LONG, NPY_LONG, NPY_ULONG, NPY_ULONG, NPY_ULONG, NPY_LONGLONG, NPY_LONGLONG, NPY_LONGLONG, NPY_ULONGLONG, NPY_ULONGLONG, NPY_ULONGLONG, NPY_OBJECT, NPY_OBJECT, NPY_OBJECT};
static PyUFuncGenericFunction cbrt_functions[] = {NULL, NULL, NULL, NULL, NULL};
static void * cbrt_data[] = {(void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)"cbrt"};
static char cbrt_signatures[] = {NPY_HALF, NPY_HALF, NPY_FLOAT, NPY_FLOAT, NPY_DOUBLE, NPY_DOUBLE, NPY_LONGDOUBLE, NPY_LONGDOUBLE, NPY_OBJECT, NPY_OBJECT};
static PyUFuncGenericFunction ceil_functions[] = {NULL, NULL, NULL, NULL, NULL};
static void * ceil_data[] = {(void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)"ceil"};
static char ceil_signatures[] = {NPY_HALF, NPY_HALF, NPY_FLOAT, NPY_FLOAT, NPY_DOUBLE, NPY_DOUBLE, NPY_LONGDOUBLE, NPY_LONGDOUBLE, NPY_OBJECT, NPY_OBJECT};
static PyUFuncGenericFunction conjugate_functions[] = {BYTE_conjugate, UBYTE_conjugate, SHORT_conjugate, USHORT_conjugate, INT_conjugate, UINT_conjugate, LONG_conjugate, ULONG_conjugate, LONGLONG_conjugate, ULONGLONG_conjugate, HALF_conjugate, FLOAT_conjugate, DOUBLE_conjugate, LONGDOUBLE_conjugate, CFLOAT_conjugate, CDOUBLE_conjugate, CLONGDOUBLE_conjugate, NULL};
static void * conjugate_data[] = {(void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)"conjugate"};
static char conjugate_signatures[] = {NPY_BYTE, NPY_BYTE, NPY_UBYTE, NPY_UBYTE, NPY_SHORT, NPY_SHORT, NPY_USHORT, NPY_USHORT, NPY_INT, NPY_INT, NPY_UINT, NPY_UINT, NPY_LONG, NPY_LONG, NPY_ULONG, NPY_ULONG, NPY_LONGLONG, NPY_LONGLONG, NPY_ULONGLONG, NPY_ULONGLONG, NPY_HALF, NPY_HALF, NPY_FLOAT, NPY_FLOAT, NPY_DOUBLE, NPY_DOUBLE, NPY_LONGDOUBLE, NPY_LONGDOUBLE, NPY_CFLOAT, NPY_CFLOAT, NPY_CDOUBLE, NPY_CDOUBLE, NPY_CLONGDOUBLE, NPY_CLONGDOUBLE, NPY_OBJECT, NPY_OBJECT};
static PyUFuncGenericFunction copysign_functions[] = {HALF_copysign, FLOAT_copysign, DOUBLE_copysign, LONGDOUBLE_copysign};
static void * copysign_data[] = {(void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL};
static char copysign_signatures[] = {NPY_HALF, NPY_HALF, NPY_HALF, NPY_FLOAT, NPY_FLOAT, NPY_FLOAT, NPY_DOUBLE, NPY_DOUBLE, NPY_DOUBLE, NPY_LONGDOUBLE, NPY_LONGDOUBLE, NPY_LONGDOUBLE};
static PyUFuncGenericFunction cos_functions[] = {NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL};
static void * cos_data[] = {(void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)"cos"};
static char cos_signatures[] = {NPY_HALF, NPY_HALF, NPY_FLOAT, NPY_FLOAT, NPY_DOUBLE, NPY_DOUBLE, NPY_LONGDOUBLE, NPY_LONGDOUBLE, NPY_CFLOAT, NPY_CFLOAT, NPY_CDOUBLE, NPY_CDOUBLE, NPY_CLONGDOUBLE, NPY_CLONGDOUBLE, NPY_OBJECT, NPY_OBJECT};
static PyUFuncGenericFunction cosh_functions[] = {NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL};
static void * cosh_data[] = {(void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)"cosh"};
static char cosh_signatures[] = {NPY_HALF, NPY_HALF, NPY_FLOAT, NPY_FLOAT, NPY_DOUBLE, NPY_DOUBLE, NPY_LONGDOUBLE, NPY_LONGDOUBLE, NPY_CFLOAT, NPY_CFLOAT, NPY_CDOUBLE, NPY_CDOUBLE, NPY_CLONGDOUBLE, NPY_CLONGDOUBLE, NPY_OBJECT, NPY_OBJECT};
static PyUFuncGenericFunction deg2rad_functions[] = {NULL, NULL, NULL, NULL, NULL};
static void * deg2rad_data[] = {(void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)"deg2rad"};
static char deg2rad_signatures[] = {NPY_HALF, NPY_HALF, NPY_FLOAT, NPY_FLOAT, NPY_DOUBLE, NPY_DOUBLE, NPY_LONGDOUBLE, NPY_LONGDOUBLE, NPY_OBJECT, NPY_OBJECT};
static PyUFuncGenericFunction degrees_functions[] = {NULL, NULL, NULL, NULL, NULL};
static void * degrees_data[] = {(void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)"degrees"};
static char degrees_signatures[] = {NPY_HALF, NPY_HALF, NPY_FLOAT, NPY_FLOAT, NPY_DOUBLE, NPY_DOUBLE, NPY_LONGDOUBLE, NPY_LONGDOUBLE, NPY_OBJECT, NPY_OBJECT};
static PyUFuncGenericFunction divide_functions[] = {BYTE_divide, UBYTE_divide, SHORT_divide, USHORT_divide, INT_divide, UINT_divide, LONG_divide, ULONG_divide, LONGLONG_divide, ULONGLONG_divide, HALF_divide, FLOAT_divide, DOUBLE_divide, LONGDOUBLE_divide, CFLOAT_divide, CDOUBLE_divide, CLONGDOUBLE_divide, TIMEDELTA_mq_m_divide, TIMEDELTA_md_m_divide, TIMEDELTA_mm_d_divide, NULL};
static void * divide_data[] = {(void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL};
static char divide_signatures[] = {NPY_BYTE, NPY_BYTE, NPY_BYTE, NPY_UBYTE, NPY_UBYTE, NPY_UBYTE, NPY_SHORT, NPY_SHORT, NPY_SHORT, NPY_USHORT, NPY_USHORT, NPY_USHORT, NPY_INT, NPY_INT, NPY_INT, NPY_UINT, NPY_UINT, NPY_UINT, NPY_LONG, NPY_LONG, NPY_LONG, NPY_ULONG, NPY_ULONG, NPY_ULONG, NPY_LONGLONG, NPY_LONGLONG, NPY_LONGLONG, NPY_ULONGLONG, NPY_ULONGLONG, NPY_ULONGLONG, NPY_HALF, NPY_HALF, NPY_HALF, NPY_FLOAT, NPY_FLOAT, NPY_FLOAT, NPY_DOUBLE, NPY_DOUBLE, NPY_DOUBLE, NPY_LONGDOUBLE, NPY_LONGDOUBLE, NPY_LONGDOUBLE, NPY_CFLOAT, NPY_CFLOAT, NPY_CFLOAT, NPY_CDOUBLE, NPY_CDOUBLE, NPY_CDOUBLE, NPY_CLONGDOUBLE, NPY_CLONGDOUBLE, NPY_CLONGDOUBLE, NPY_TIMEDELTA, NPY_LONGLONG, NPY_TIMEDELTA, NPY_TIMEDELTA, NPY_DOUBLE, NPY_TIMEDELTA, NPY_TIMEDELTA, NPY_TIMEDELTA, NPY_DOUBLE, NPY_OBJECT, NPY_OBJECT, NPY_OBJECT};
static PyUFuncGenericFunction equal_functions[] = {BOOL_equal, BYTE_equal, UBYTE_equal, SHORT_equal, USHORT_equal, INT_equal, UINT_equal, LONG_equal, ULONG_equal, LONGLONG_equal, ULONGLONG_equal, HALF_equal, FLOAT_equal, DOUBLE_equal, LONGDOUBLE_equal, CFLOAT_equal, CDOUBLE_equal, CLONGDOUBLE_equal, OBJECT_equal, DATETIME_equal, TIMEDELTA_equal};
static void * equal_data[] = {(void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL};
static char equal_signatures[] = {NPY_BOOL, NPY_BOOL, NPY_BOOL, NPY_BYTE, NPY_BYTE, NPY_BOOL, NPY_UBYTE, NPY_UBYTE, NPY_BOOL, NPY_SHORT, NPY_SHORT, NPY_BOOL, NPY_USHORT, NPY_USHORT, NPY_BOOL, NPY_INT, NPY_INT, NPY_BOOL, NPY_UINT, NPY_UINT, NPY_BOOL, NPY_LONG, NPY_LONG, NPY_BOOL, NPY_ULONG, NPY_ULONG, NPY_BOOL, NPY_LONGLONG, NPY_LONGLONG, NPY_BOOL, NPY_ULONGLONG, NPY_ULONGLONG, NPY_BOOL, NPY_HALF, NPY_HALF, NPY_BOOL, NPY_FLOAT, NPY_FLOAT, NPY_BOOL, NPY_DOUBLE, NPY_DOUBLE, NPY_BOOL, NPY_LONGDOUBLE, NPY_LONGDOUBLE, NPY_BOOL, NPY_CFLOAT, NPY_CFLOAT, NPY_BOOL, NPY_CDOUBLE, NPY_CDOUBLE, NPY_BOOL, NPY_CLONGDOUBLE, NPY_CLONGDOUBLE, NPY_BOOL, NPY_OBJECT, NPY_OBJECT, NPY_BOOL, NPY_DATETIME, NPY_DATETIME, NPY_BOOL, NPY_TIMEDELTA, NPY_TIMEDELTA, NPY_BOOL};
static PyUFuncGenericFunction exp_functions[] = {NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL};
static void * exp_data[] = {(void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)"exp"};
static char exp_signatures[] = {NPY_HALF, NPY_HALF, NPY_FLOAT, NPY_FLOAT, NPY_DOUBLE, NPY_DOUBLE, NPY_LONGDOUBLE, NPY_LONGDOUBLE, NPY_CFLOAT, NPY_CFLOAT, NPY_CDOUBLE, NPY_CDOUBLE, NPY_CLONGDOUBLE, NPY_CLONGDOUBLE, NPY_OBJECT, NPY_OBJECT};
static PyUFuncGenericFunction exp2_functions[] = {NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL};
static void * exp2_data[] = {(void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)"exp2"};
static char exp2_signatures[] = {NPY_HALF, NPY_HALF, NPY_FLOAT, NPY_FLOAT, NPY_DOUBLE, NPY_DOUBLE, NPY_LONGDOUBLE, NPY_LONGDOUBLE, NPY_CFLOAT, NPY_CFLOAT, NPY_CDOUBLE, NPY_CDOUBLE, NPY_CLONGDOUBLE, NPY_CLONGDOUBLE, NPY_OBJECT, NPY_OBJECT};
static PyUFuncGenericFunction expm1_functions[] = {NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL};
static void * expm1_data[] = {(void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)"expm1"};
static char expm1_signatures[] = {NPY_HALF, NPY_HALF, NPY_FLOAT, NPY_FLOAT, NPY_DOUBLE, NPY_DOUBLE, NPY_LONGDOUBLE, NPY_LONGDOUBLE, NPY_CFLOAT, NPY_CFLOAT, NPY_CDOUBLE, NPY_CDOUBLE, NPY_CLONGDOUBLE, NPY_CLONGDOUBLE, NPY_OBJECT, NPY_OBJECT};
static PyUFuncGenericFunction fabs_functions[] = {NULL, NULL, NULL, NULL, NULL};
static void * fabs_data[] = {(void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)"fabs"};
static char fabs_signatures[] = {NPY_HALF, NPY_HALF, NPY_FLOAT, NPY_FLOAT, NPY_DOUBLE, NPY_DOUBLE, NPY_LONGDOUBLE, NPY_LONGDOUBLE, NPY_OBJECT, NPY_OBJECT};
static PyUFuncGenericFunction floor_functions[] = {NULL, NULL, NULL, NULL, NULL};
static void * floor_data[] = {(void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)"floor"};
static char floor_signatures[] = {NPY_HALF, NPY_HALF, NPY_FLOAT, NPY_FLOAT, NPY_DOUBLE, NPY_DOUBLE, NPY_LONGDOUBLE, NPY_LONGDOUBLE, NPY_OBJECT, NPY_OBJECT};
static PyUFuncGenericFunction floor_divide_functions[] = {BYTE_floor_divide, UBYTE_floor_divide, SHORT_floor_divide, USHORT_floor_divide, INT_floor_divide, UINT_floor_divide, LONG_floor_divide, ULONG_floor_divide, LONGLONG_floor_divide, ULONGLONG_floor_divide, HALF_floor_divide, FLOAT_floor_divide, DOUBLE_floor_divide, LONGDOUBLE_floor_divide, CFLOAT_floor_divide, CDOUBLE_floor_divide, CLONGDOUBLE_floor_divide, TIMEDELTA_mq_m_floor_divide, TIMEDELTA_md_m_floor_divide, NULL};
static void * floor_divide_data[] = {(void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL};
static char floor_divide_signatures[] = {NPY_BYTE, NPY_BYTE, NPY_BYTE, NPY_UBYTE, NPY_UBYTE, NPY_UBYTE, NPY_SHORT, NPY_SHORT, NPY_SHORT, NPY_USHORT, NPY_USHORT, NPY_USHORT, NPY_INT, NPY_INT, NPY_INT, NPY_UINT, NPY_UINT, NPY_UINT, NPY_LONG, NPY_LONG, NPY_LONG, NPY_ULONG, NPY_ULONG, NPY_ULONG, NPY_LONGLONG, NPY_LONGLONG, NPY_LONGLONG, NPY_ULONGLONG, NPY_ULONGLONG, NPY_ULONGLONG, NPY_HALF, NPY_HALF, NPY_HALF, NPY_FLOAT, NPY_FLOAT, NPY_FLOAT, NPY_DOUBLE, NPY_DOUBLE, NPY_DOUBLE, NPY_LONGDOUBLE, NPY_LONGDOUBLE, NPY_LONGDOUBLE, NPY_CFLOAT, NPY_CFLOAT, NPY_CFLOAT, NPY_CDOUBLE, NPY_CDOUBLE, NPY_CDOUBLE, NPY_CLONGDOUBLE, NPY_CLONGDOUBLE, NPY_CLONGDOUBLE, NPY_TIMEDELTA, NPY_LONGLONG, NPY_TIMEDELTA, NPY_TIMEDELTA, NPY_DOUBLE, NPY_TIMEDELTA, NPY_OBJECT, NPY_OBJECT, NPY_OBJECT};
static PyUFuncGenericFunction fmax_functions[] = {BOOL_fmax, BYTE_fmax, UBYTE_fmax, SHORT_fmax, USHORT_fmax, INT_fmax, UINT_fmax, LONG_fmax, ULONG_fmax, LONGLONG_fmax, ULONGLONG_fmax, HALF_fmax, FLOAT_fmax, DOUBLE_fmax, LONGDOUBLE_fmax, CFLOAT_fmax, CDOUBLE_fmax, CLONGDOUBLE_fmax, DATETIME_fmax, TIMEDELTA_fmax, NULL};
static void * fmax_data[] = {(void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL};
static char fmax_signatures[] = {NPY_BOOL, NPY_BOOL, NPY_BOOL, NPY_BYTE, NPY_BYTE, NPY_BYTE, NPY_UBYTE, NPY_UBYTE, NPY_UBYTE, NPY_SHORT, NPY_SHORT, NPY_SHORT, NPY_USHORT, NPY_USHORT, NPY_USHORT, NPY_INT, NPY_INT, NPY_INT, NPY_UINT, NPY_UINT, NPY_UINT, NPY_LONG, NPY_LONG, NPY_LONG, NPY_ULONG, NPY_ULONG, NPY_ULONG, NPY_LONGLONG, NPY_LONGLONG, NPY_LONGLONG, NPY_ULONGLONG, NPY_ULONGLONG, NPY_ULONGLONG, NPY_HALF, NPY_HALF, NPY_HALF, NPY_FLOAT, NPY_FLOAT, NPY_FLOAT, NPY_DOUBLE, NPY_DOUBLE, NPY_DOUBLE, NPY_LONGDOUBLE, NPY_LONGDOUBLE, NPY_LONGDOUBLE, NPY_CFLOAT, NPY_CFLOAT, NPY_CFLOAT, NPY_CDOUBLE, NPY_CDOUBLE, NPY_CDOUBLE, NPY_CLONGDOUBLE, NPY_CLONGDOUBLE, NPY_CLONGDOUBLE, NPY_DATETIME, NPY_DATETIME, NPY_DATETIME, NPY_TIMEDELTA, NPY_TIMEDELTA, NPY_TIMEDELTA, NPY_OBJECT, NPY_OBJECT, NPY_OBJECT};
static PyUFuncGenericFunction fmin_functions[] = {BOOL_fmin, BYTE_fmin, UBYTE_fmin, SHORT_fmin, USHORT_fmin, INT_fmin, UINT_fmin, LONG_fmin, ULONG_fmin, LONGLONG_fmin, ULONGLONG_fmin, HALF_fmin, FLOAT_fmin, DOUBLE_fmin, LONGDOUBLE_fmin, CFLOAT_fmin, CDOUBLE_fmin, CLONGDOUBLE_fmin, DATETIME_fmin, TIMEDELTA_fmin, NULL};
static void * fmin_data[] = {(void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL};
static char fmin_signatures[] = {NPY_BOOL, NPY_BOOL, NPY_BOOL, NPY_BYTE, NPY_BYTE, NPY_BYTE, NPY_UBYTE, NPY_UBYTE, NPY_UBYTE, NPY_SHORT, NPY_SHORT, NPY_SHORT, NPY_USHORT, NPY_USHORT, NPY_USHORT, NPY_INT, NPY_INT, NPY_INT, NPY_UINT, NPY_UINT, NPY_UINT, NPY_LONG, NPY_LONG, NPY_LONG, NPY_ULONG, NPY_ULONG, NPY_ULONG, NPY_LONGLONG, NPY_LONGLONG, NPY_LONGLONG, NPY_ULONGLONG, NPY_ULONGLONG, NPY_ULONGLONG, NPY_HALF, NPY_HALF, NPY_HALF, NPY_FLOAT, NPY_FLOAT, NPY_FLOAT, NPY_DOUBLE, NPY_DOUBLE, NPY_DOUBLE, NPY_LONGDOUBLE, NPY_LONGDOUBLE, NPY_LONGDOUBLE, NPY_CFLOAT, NPY_CFLOAT, NPY_CFLOAT, NPY_CDOUBLE, NPY_CDOUBLE, NPY_CDOUBLE, NPY_CLONGDOUBLE, NPY_CLONGDOUBLE, NPY_CLONGDOUBLE, NPY_DATETIME, NPY_DATETIME, NPY_DATETIME, NPY_TIMEDELTA, NPY_TIMEDELTA, NPY_TIMEDELTA, NPY_OBJECT, NPY_OBJECT, NPY_OBJECT};
static PyUFuncGenericFunction fmod_functions[] = {BYTE_fmod, UBYTE_fmod, SHORT_fmod, USHORT_fmod, INT_fmod, UINT_fmod, LONG_fmod, ULONG_fmod, LONGLONG_fmod, ULONGLONG_fmod, NULL, NULL, NULL, NULL, NULL};
static void * fmod_data[] = {(void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)"fmod"};
static char fmod_signatures[] = {NPY_BYTE, NPY_BYTE, NPY_BYTE, NPY_UBYTE, NPY_UBYTE, NPY_UBYTE, NPY_SHORT, NPY_SHORT, NPY_SHORT, NPY_USHORT, NPY_USHORT, NPY_USHORT, NPY_INT, NPY_INT, NPY_INT, NPY_UINT, NPY_UINT, NPY_UINT, NPY_LONG, NPY_LONG, NPY_LONG, NPY_ULONG, NPY_ULONG, NPY_ULONG, NPY_LONGLONG, NPY_LONGLONG, NPY_LONGLONG, NPY_ULONGLONG, NPY_ULONGLONG, NPY_ULONGLONG, NPY_HALF, NPY_HALF, NPY_HALF, NPY_FLOAT, NPY_FLOAT, NPY_FLOAT, NPY_DOUBLE, NPY_DOUBLE, NPY_DOUBLE, NPY_LONGDOUBLE, NPY_LONGDOUBLE, NPY_LONGDOUBLE, NPY_OBJECT, NPY_OBJECT, NPY_OBJECT};
static PyUFuncGenericFunction frexp_functions[] = {HALF_frexp, FLOAT_frexp, DOUBLE_frexp, LONGDOUBLE_frexp};
static void * frexp_data[] = {(void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL};
static char frexp_signatures[] = {NPY_HALF, NPY_HALF, NPY_INT, NPY_FLOAT, NPY_FLOAT, NPY_INT, NPY_DOUBLE, NPY_DOUBLE, NPY_INT, NPY_LONGDOUBLE, NPY_LONGDOUBLE, NPY_INT};
static PyUFuncGenericFunction greater_functions[] = {BOOL_greater, BYTE_greater, UBYTE_greater, SHORT_greater, USHORT_greater, INT_greater, UINT_greater, LONG_greater, ULONG_greater, LONGLONG_greater, ULONGLONG_greater, HALF_greater, FLOAT_greater, DOUBLE_greater, LONGDOUBLE_greater, CFLOAT_greater, CDOUBLE_greater, CLONGDOUBLE_greater, OBJECT_greater, DATETIME_greater, TIMEDELTA_greater};
static void * greater_data[] = {(void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL};
static char greater_signatures[] = {NPY_BOOL, NPY_BOOL, NPY_BOOL, NPY_BYTE, NPY_BYTE, NPY_BOOL, NPY_UBYTE, NPY_UBYTE, NPY_BOOL, NPY_SHORT, NPY_SHORT, NPY_BOOL, NPY_USHORT, NPY_USHORT, NPY_BOOL, NPY_INT, NPY_INT, NPY_BOOL, NPY_UINT, NPY_UINT, NPY_BOOL, NPY_LONG, NPY_LONG, NPY_BOOL, NPY_ULONG, NPY_ULONG, NPY_BOOL, NPY_LONGLONG, NPY_LONGLONG, NPY_BOOL, NPY_ULONGLONG, NPY_ULONGLONG, NPY_BOOL, NPY_HALF, NPY_HALF, NPY_BOOL, NPY_FLOAT, NPY_FLOAT, NPY_BOOL, NPY_DOUBLE, NPY_DOUBLE, NPY_BOOL, NPY_LONGDOUBLE, NPY_LONGDOUBLE, NPY_BOOL, NPY_CFLOAT, NPY_CFLOAT, NPY_BOOL, NPY_CDOUBLE, NPY_CDOUBLE, NPY_BOOL, NPY_CLONGDOUBLE, NPY_CLONGDOUBLE, NPY_BOOL, NPY_OBJECT, NPY_OBJECT, NPY_BOOL, NPY_DATETIME, NPY_DATETIME, NPY_BOOL, NPY_TIMEDELTA, NPY_TIMEDELTA, NPY_BOOL};
static PyUFuncGenericFunction greater_equal_functions[] = {BOOL_greater_equal, BYTE_greater_equal, UBYTE_greater_equal, SHORT_greater_equal, USHORT_greater_equal, INT_greater_equal, UINT_greater_equal, LONG_greater_equal, ULONG_greater_equal, LONGLONG_greater_equal, ULONGLONG_greater_equal, HALF_greater_equal, FLOAT_greater_equal, DOUBLE_greater_equal, LONGDOUBLE_greater_equal, CFLOAT_greater_equal, CDOUBLE_greater_equal, CLONGDOUBLE_greater_equal, OBJECT_greater_equal, DATETIME_greater_equal, TIMEDELTA_greater_equal};
static void * greater_equal_data[] = {(void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL};
static char greater_equal_signatures[] = {NPY_BOOL, NPY_BOOL, NPY_BOOL, NPY_BYTE, NPY_BYTE, NPY_BOOL, NPY_UBYTE, NPY_UBYTE, NPY_BOOL, NPY_SHORT, NPY_SHORT, NPY_BOOL, NPY_USHORT, NPY_USHORT, NPY_BOOL, NPY_INT, NPY_INT, NPY_BOOL, NPY_UINT, NPY_UINT, NPY_BOOL, NPY_LONG, NPY_LONG, NPY_BOOL, NPY_ULONG, NPY_ULONG, NPY_BOOL, NPY_LONGLONG, NPY_LONGLONG, NPY_BOOL, NPY_ULONGLONG, NPY_ULONGLONG, NPY_BOOL, NPY_HALF, NPY_HALF, NPY_BOOL, NPY_FLOAT, NPY_FLOAT, NPY_BOOL, NPY_DOUBLE, NPY_DOUBLE, NPY_BOOL, NPY_LONGDOUBLE, NPY_LONGDOUBLE, NPY_BOOL, NPY_CFLOAT, NPY_CFLOAT, NPY_BOOL, NPY_CDOUBLE, NPY_CDOUBLE, NPY_BOOL, NPY_CLONGDOUBLE, NPY_CLONGDOUBLE, NPY_BOOL, NPY_OBJECT, NPY_OBJECT, NPY_BOOL, NPY_DATETIME, NPY_DATETIME, NPY_BOOL, NPY_TIMEDELTA, NPY_TIMEDELTA, NPY_BOOL};
static PyUFuncGenericFunction hypot_functions[] = {NULL, NULL, NULL, NULL, NULL};
static void * hypot_data[] = {(void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)"hypot"};
static char hypot_signatures[] = {NPY_HALF, NPY_HALF, NPY_HALF, NPY_FLOAT, NPY_FLOAT, NPY_FLOAT, NPY_DOUBLE, NPY_DOUBLE, NPY_DOUBLE, NPY_LONGDOUBLE, NPY_LONGDOUBLE, NPY_LONGDOUBLE, NPY_OBJECT, NPY_OBJECT, NPY_OBJECT};
static PyUFuncGenericFunction invert_functions[] = {BOOL_invert, BYTE_invert, UBYTE_invert, SHORT_invert, USHORT_invert, INT_invert, UINT_invert, LONG_invert, ULONG_invert, LONGLONG_invert, ULONGLONG_invert, NULL};
static void * invert_data[] = {(void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL};
static char invert_signatures[] = {NPY_BOOL, NPY_BOOL, NPY_BYTE, NPY_BYTE, NPY_UBYTE, NPY_UBYTE, NPY_SHORT, NPY_SHORT, NPY_USHORT, NPY_USHORT, NPY_INT, NPY_INT, NPY_UINT, NPY_UINT, NPY_LONG, NPY_LONG, NPY_ULONG, NPY_ULONG, NPY_LONGLONG, NPY_LONGLONG, NPY_ULONGLONG, NPY_ULONGLONG, NPY_OBJECT, NPY_OBJECT};
static PyUFuncGenericFunction isfinite_functions[] = {HALF_isfinite, FLOAT_isfinite, DOUBLE_isfinite, LONGDOUBLE_isfinite, CFLOAT_isfinite, CDOUBLE_isfinite, CLONGDOUBLE_isfinite};
static void * isfinite_data[] = {(void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL};
static char isfinite_signatures[] = {NPY_HALF, NPY_BOOL, NPY_FLOAT, NPY_BOOL, NPY_DOUBLE, NPY_BOOL, NPY_LONGDOUBLE, NPY_BOOL, NPY_CFLOAT, NPY_BOOL, NPY_CDOUBLE, NPY_BOOL, NPY_CLONGDOUBLE, NPY_BOOL};
static PyUFuncGenericFunction isinf_functions[] = {HALF_isinf, FLOAT_isinf, DOUBLE_isinf, LONGDOUBLE_isinf, CFLOAT_isinf, CDOUBLE_isinf, CLONGDOUBLE_isinf};
static void * isinf_data[] = {(void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL};
static char isinf_signatures[] = {NPY_HALF, NPY_BOOL, NPY_FLOAT, NPY_BOOL, NPY_DOUBLE, NPY_BOOL, NPY_LONGDOUBLE, NPY_BOOL, NPY_CFLOAT, NPY_BOOL, NPY_CDOUBLE, NPY_BOOL, NPY_CLONGDOUBLE, NPY_BOOL};
static PyUFuncGenericFunction isnan_functions[] = {HALF_isnan, FLOAT_isnan, DOUBLE_isnan, LONGDOUBLE_isnan, CFLOAT_isnan, CDOUBLE_isnan, CLONGDOUBLE_isnan};
static void * isnan_data[] = {(void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL};
static char isnan_signatures[] = {NPY_HALF, NPY_BOOL, NPY_FLOAT, NPY_BOOL, NPY_DOUBLE, NPY_BOOL, NPY_LONGDOUBLE, NPY_BOOL, NPY_CFLOAT, NPY_BOOL, NPY_CDOUBLE, NPY_BOOL, NPY_CLONGDOUBLE, NPY_BOOL};
static PyUFuncGenericFunction ldexp_functions[] = {HALF_ldexp, FLOAT_ldexp, HALF_ldexp_long, FLOAT_ldexp_long, DOUBLE_ldexp, DOUBLE_ldexp_long, LONGDOUBLE_ldexp, LONGDOUBLE_ldexp_long};
static void * ldexp_data[] = {(void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL};
static char ldexp_signatures[] = {NPY_HALF, NPY_INT, NPY_HALF, NPY_FLOAT, NPY_INT, NPY_FLOAT, NPY_HALF, NPY_LONG, NPY_HALF, NPY_FLOAT, NPY_LONG, NPY_FLOAT, NPY_DOUBLE, NPY_INT, NPY_DOUBLE, NPY_DOUBLE, NPY_LONG, NPY_DOUBLE, NPY_LONGDOUBLE, NPY_INT, NPY_LONGDOUBLE, NPY_LONGDOUBLE, NPY_LONG, NPY_LONGDOUBLE};
static PyUFuncGenericFunction left_shift_functions[] = {BYTE_left_shift, UBYTE_left_shift, SHORT_left_shift, USHORT_left_shift, INT_left_shift, UINT_left_shift, LONG_left_shift, ULONG_left_shift, LONGLONG_left_shift, ULONGLONG_left_shift, NULL};
static void * left_shift_data[] = {(void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL};
static char left_shift_signatures[] = {NPY_BYTE, NPY_BYTE, NPY_BYTE, NPY_UBYTE, NPY_UBYTE, NPY_UBYTE, NPY_SHORT, NPY_SHORT, NPY_SHORT, NPY_USHORT, NPY_USHORT, NPY_USHORT, NPY_INT, NPY_INT, NPY_INT, NPY_UINT, NPY_UINT, NPY_UINT, NPY_LONG, NPY_LONG, NPY_LONG, NPY_ULONG, NPY_ULONG, NPY_ULONG, NPY_LONGLONG, NPY_LONGLONG, NPY_LONGLONG, NPY_ULONGLONG, NPY_ULONGLONG, NPY_ULONGLONG, NPY_OBJECT, NPY_OBJECT, NPY_OBJECT};
static PyUFuncGenericFunction less_functions[] = {BOOL_less, BYTE_less, UBYTE_less, SHORT_less, USHORT_less, INT_less, UINT_less, LONG_less, ULONG_less, LONGLONG_less, ULONGLONG_less, HALF_less, FLOAT_less, DOUBLE_less, LONGDOUBLE_less, CFLOAT_less, CDOUBLE_less, CLONGDOUBLE_less, OBJECT_less, DATETIME_less, TIMEDELTA_less};
static void * less_data[] = {(void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL};
static char less_signatures[] = {NPY_BOOL, NPY_BOOL, NPY_BOOL, NPY_BYTE, NPY_BYTE, NPY_BOOL, NPY_UBYTE, NPY_UBYTE, NPY_BOOL, NPY_SHORT, NPY_SHORT, NPY_BOOL, NPY_USHORT, NPY_USHORT, NPY_BOOL, NPY_INT, NPY_INT, NPY_BOOL, NPY_UINT, NPY_UINT, NPY_BOOL, NPY_LONG, NPY_LONG, NPY_BOOL, NPY_ULONG, NPY_ULONG, NPY_BOOL, NPY_LONGLONG, NPY_LONGLONG, NPY_BOOL, NPY_ULONGLONG, NPY_ULONGLONG, NPY_BOOL, NPY_HALF, NPY_HALF, NPY_BOOL, NPY_FLOAT, NPY_FLOAT, NPY_BOOL, NPY_DOUBLE, NPY_DOUBLE, NPY_BOOL, NPY_LONGDOUBLE, NPY_LONGDOUBLE, NPY_BOOL, NPY_CFLOAT, NPY_CFLOAT, NPY_BOOL, NPY_CDOUBLE, NPY_CDOUBLE, NPY_BOOL, NPY_CLONGDOUBLE, NPY_CLONGDOUBLE, NPY_BOOL, NPY_OBJECT, NPY_OBJECT, NPY_BOOL, NPY_DATETIME, NPY_DATETIME, NPY_BOOL, NPY_TIMEDELTA, NPY_TIMEDELTA, NPY_BOOL};
static PyUFuncGenericFunction less_equal_functions[] = {BOOL_less_equal, BYTE_less_equal, UBYTE_less_equal, SHORT_less_equal, USHORT_less_equal, INT_less_equal, UINT_less_equal, LONG_less_equal, ULONG_less_equal, LONGLONG_less_equal, ULONGLONG_less_equal, HALF_less_equal, FLOAT_less_equal, DOUBLE_less_equal, LONGDOUBLE_less_equal, CFLOAT_less_equal, CDOUBLE_less_equal, CLONGDOUBLE_less_equal, OBJECT_less_equal, DATETIME_less_equal, TIMEDELTA_less_equal};
static void * less_equal_data[] = {(void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL};
static char less_equal_signatures[] = {NPY_BOOL, NPY_BOOL, NPY_BOOL, NPY_BYTE, NPY_BYTE, NPY_BOOL, NPY_UBYTE, NPY_UBYTE, NPY_BOOL, NPY_SHORT, NPY_SHORT, NPY_BOOL, NPY_USHORT, NPY_USHORT, NPY_BOOL, NPY_INT, NPY_INT, NPY_BOOL, NPY_UINT, NPY_UINT, NPY_BOOL, NPY_LONG, NPY_LONG, NPY_BOOL, NPY_ULONG, NPY_ULONG, NPY_BOOL, NPY_LONGLONG, NPY_LONGLONG, NPY_BOOL, NPY_ULONGLONG, NPY_ULONGLONG, NPY_BOOL, NPY_HALF, NPY_HALF, NPY_BOOL, NPY_FLOAT, NPY_FLOAT, NPY_BOOL, NPY_DOUBLE, NPY_DOUBLE, NPY_BOOL, NPY_LONGDOUBLE, NPY_LONGDOUBLE, NPY_BOOL, NPY_CFLOAT, NPY_CFLOAT, NPY_BOOL, NPY_CDOUBLE, NPY_CDOUBLE, NPY_BOOL, NPY_CLONGDOUBLE, NPY_CLONGDOUBLE, NPY_BOOL, NPY_OBJECT, NPY_OBJECT, NPY_BOOL, NPY_DATETIME, NPY_DATETIME, NPY_BOOL, NPY_TIMEDELTA, NPY_TIMEDELTA, NPY_BOOL};
static PyUFuncGenericFunction log_functions[] = {NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL};
static void * log_data[] = {(void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)"log"};
static char log_signatures[] = {NPY_HALF, NPY_HALF, NPY_FLOAT, NPY_FLOAT, NPY_DOUBLE, NPY_DOUBLE, NPY_LONGDOUBLE, NPY_LONGDOUBLE, NPY_CFLOAT, NPY_CFLOAT, NPY_CDOUBLE, NPY_CDOUBLE, NPY_CLONGDOUBLE, NPY_CLONGDOUBLE, NPY_OBJECT, NPY_OBJECT};
static PyUFuncGenericFunction log10_functions[] = {NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL};
static void * log10_data[] = {(void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)"log10"};
static char log10_signatures[] = {NPY_HALF, NPY_HALF, NPY_FLOAT, NPY_FLOAT, NPY_DOUBLE, NPY_DOUBLE, NPY_LONGDOUBLE, NPY_LONGDOUBLE, NPY_CFLOAT, NPY_CFLOAT, NPY_CDOUBLE, NPY_CDOUBLE, NPY_CLONGDOUBLE, NPY_CLONGDOUBLE, NPY_OBJECT, NPY_OBJECT};
static PyUFuncGenericFunction log1p_functions[] = {NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL};
static void * log1p_data[] = {(void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)"log1p"};
static char log1p_signatures[] = {NPY_HALF, NPY_HALF, NPY_FLOAT, NPY_FLOAT, NPY_DOUBLE, NPY_DOUBLE, NPY_LONGDOUBLE, NPY_LONGDOUBLE, NPY_CFLOAT, NPY_CFLOAT, NPY_CDOUBLE, NPY_CDOUBLE, NPY_CLONGDOUBLE, NPY_CLONGDOUBLE, NPY_OBJECT, NPY_OBJECT};
static PyUFuncGenericFunction log2_functions[] = {NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL};
static void * log2_data[] = {(void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)"log2"};
static char log2_signatures[] = {NPY_HALF, NPY_HALF, NPY_FLOAT, NPY_FLOAT, NPY_DOUBLE, NPY_DOUBLE, NPY_LONGDOUBLE, NPY_LONGDOUBLE, NPY_CFLOAT, NPY_CFLOAT, NPY_CDOUBLE, NPY_CDOUBLE, NPY_CLONGDOUBLE, NPY_CLONGDOUBLE, NPY_OBJECT, NPY_OBJECT};
static PyUFuncGenericFunction logaddexp_functions[] = {NULL, NULL, NULL, NULL};
static void * logaddexp_data[] = {(void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL};
static char logaddexp_signatures[] = {NPY_HALF, NPY_HALF, NPY_HALF, NPY_FLOAT, NPY_FLOAT, NPY_FLOAT, NPY_DOUBLE, NPY_DOUBLE, NPY_DOUBLE, NPY_LONGDOUBLE, NPY_LONGDOUBLE, NPY_LONGDOUBLE};
static PyUFuncGenericFunction logaddexp2_functions[] = {NULL, NULL, NULL, NULL};
static void * logaddexp2_data[] = {(void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL};
static char logaddexp2_signatures[] = {NPY_HALF, NPY_HALF, NPY_HALF, NPY_FLOAT, NPY_FLOAT, NPY_FLOAT, NPY_DOUBLE, NPY_DOUBLE, NPY_DOUBLE, NPY_LONGDOUBLE, NPY_LONGDOUBLE, NPY_LONGDOUBLE};
static PyUFuncGenericFunction logical_and_functions[] = {BOOL_logical_and, BYTE_logical_and, UBYTE_logical_and, SHORT_logical_and, USHORT_logical_and, INT_logical_and, UINT_logical_and, LONG_logical_and, ULONG_logical_and, LONGLONG_logical_and, ULONGLONG_logical_and, HALF_logical_and, FLOAT_logical_and, DOUBLE_logical_and, LONGDOUBLE_logical_and, CFLOAT_logical_and, CDOUBLE_logical_and, CLONGDOUBLE_logical_and, NULL};
static void * logical_and_data[] = {(void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL};
static char logical_and_signatures[] = {NPY_BOOL, NPY_BOOL, NPY_BOOL, NPY_BYTE, NPY_BYTE, NPY_BOOL, NPY_UBYTE, NPY_UBYTE, NPY_BOOL, NPY_SHORT, NPY_SHORT, NPY_BOOL, NPY_USHORT, NPY_USHORT, NPY_BOOL, NPY_INT, NPY_INT, NPY_BOOL, NPY_UINT, NPY_UINT, NPY_BOOL, NPY_LONG, NPY_LONG, NPY_BOOL, NPY_ULONG, NPY_ULONG, NPY_BOOL, NPY_LONGLONG, NPY_LONGLONG, NPY_BOOL, NPY_ULONGLONG, NPY_ULONGLONG, NPY_BOOL, NPY_HALF, NPY_HALF, NPY_BOOL, NPY_FLOAT, NPY_FLOAT, NPY_BOOL, NPY_DOUBLE, NPY_DOUBLE, NPY_BOOL, NPY_LONGDOUBLE, NPY_LONGDOUBLE, NPY_BOOL, NPY_CFLOAT, NPY_CFLOAT, NPY_BOOL, NPY_CDOUBLE, NPY_CDOUBLE, NPY_BOOL, NPY_CLONGDOUBLE, NPY_CLONGDOUBLE, NPY_BOOL, NPY_OBJECT, NPY_OBJECT, NPY_OBJECT};
static PyUFuncGenericFunction logical_not_functions[] = {BOOL_logical_not, BYTE_logical_not, UBYTE_logical_not, SHORT_logical_not, USHORT_logical_not, INT_logical_not, UINT_logical_not, LONG_logical_not, ULONG_logical_not, LONGLONG_logical_not, ULONGLONG_logical_not, HALF_logical_not, FLOAT_logical_not, DOUBLE_logical_not, LONGDOUBLE_logical_not, CFLOAT_logical_not, CDOUBLE_logical_not, CLONGDOUBLE_logical_not, NULL};
static void * logical_not_data[] = {(void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL};
static char logical_not_signatures[] = {NPY_BOOL, NPY_BOOL, NPY_BYTE, NPY_BOOL, NPY_UBYTE, NPY_BOOL, NPY_SHORT, NPY_BOOL, NPY_USHORT, NPY_BOOL, NPY_INT, NPY_BOOL, NPY_UINT, NPY_BOOL, NPY_LONG, NPY_BOOL, NPY_ULONG, NPY_BOOL, NPY_LONGLONG, NPY_BOOL, NPY_ULONGLONG, NPY_BOOL, NPY_HALF, NPY_BOOL, NPY_FLOAT, NPY_BOOL, NPY_DOUBLE, NPY_BOOL, NPY_LONGDOUBLE, NPY_BOOL, NPY_CFLOAT, NPY_BOOL, NPY_CDOUBLE, NPY_BOOL, NPY_CLONGDOUBLE, NPY_BOOL, NPY_OBJECT, NPY_OBJECT};
static PyUFuncGenericFunction logical_or_functions[] = {BOOL_logical_or, BYTE_logical_or, UBYTE_logical_or, SHORT_logical_or, USHORT_logical_or, INT_logical_or, UINT_logical_or, LONG_logical_or, ULONG_logical_or, LONGLONG_logical_or, ULONGLONG_logical_or, HALF_logical_or, FLOAT_logical_or, DOUBLE_logical_or, LONGDOUBLE_logical_or, CFLOAT_logical_or, CDOUBLE_logical_or, CLONGDOUBLE_logical_or, NULL};
static void * logical_or_data[] = {(void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL};
static char logical_or_signatures[] = {NPY_BOOL, NPY_BOOL, NPY_BOOL, NPY_BYTE, NPY_BYTE, NPY_BOOL, NPY_UBYTE, NPY_UBYTE, NPY_BOOL, NPY_SHORT, NPY_SHORT, NPY_BOOL, NPY_USHORT, NPY_USHORT, NPY_BOOL, NPY_INT, NPY_INT, NPY_BOOL, NPY_UINT, NPY_UINT, NPY_BOOL, NPY_LONG, NPY_LONG, NPY_BOOL, NPY_ULONG, NPY_ULONG, NPY_BOOL, NPY_LONGLONG, NPY_LONGLONG, NPY_BOOL, NPY_ULONGLONG, NPY_ULONGLONG, NPY_BOOL, NPY_HALF, NPY_HALF, NPY_BOOL, NPY_FLOAT, NPY_FLOAT, NPY_BOOL, NPY_DOUBLE, NPY_DOUBLE, NPY_BOOL, NPY_LONGDOUBLE, NPY_LONGDOUBLE, NPY_BOOL, NPY_CFLOAT, NPY_CFLOAT, NPY_BOOL, NPY_CDOUBLE, NPY_CDOUBLE, NPY_BOOL, NPY_CLONGDOUBLE, NPY_CLONGDOUBLE, NPY_BOOL, NPY_OBJECT, NPY_OBJECT, NPY_OBJECT};
static PyUFuncGenericFunction logical_xor_functions[] = {BOOL_logical_xor, BYTE_logical_xor, UBYTE_logical_xor, SHORT_logical_xor, USHORT_logical_xor, INT_logical_xor, UINT_logical_xor, LONG_logical_xor, ULONG_logical_xor, LONGLONG_logical_xor, ULONGLONG_logical_xor, HALF_logical_xor, FLOAT_logical_xor, DOUBLE_logical_xor, LONGDOUBLE_logical_xor, CFLOAT_logical_xor, CDOUBLE_logical_xor, CLONGDOUBLE_logical_xor, NULL};
static void * logical_xor_data[] = {(void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)"logical_xor"};
static char logical_xor_signatures[] = {NPY_BOOL, NPY_BOOL, NPY_BOOL, NPY_BYTE, NPY_BYTE, NPY_BOOL, NPY_UBYTE, NPY_UBYTE, NPY_BOOL, NPY_SHORT, NPY_SHORT, NPY_BOOL, NPY_USHORT, NPY_USHORT, NPY_BOOL, NPY_INT, NPY_INT, NPY_BOOL, NPY_UINT, NPY_UINT, NPY_BOOL, NPY_LONG, NPY_LONG, NPY_BOOL, NPY_ULONG, NPY_ULONG, NPY_BOOL, NPY_LONGLONG, NPY_LONGLONG, NPY_BOOL, NPY_ULONGLONG, NPY_ULONGLONG, NPY_BOOL, NPY_HALF, NPY_HALF, NPY_BOOL, NPY_FLOAT, NPY_FLOAT, NPY_BOOL, NPY_DOUBLE, NPY_DOUBLE, NPY_BOOL, NPY_LONGDOUBLE, NPY_LONGDOUBLE, NPY_BOOL, NPY_CFLOAT, NPY_CFLOAT, NPY_BOOL, NPY_CDOUBLE, NPY_CDOUBLE, NPY_BOOL, NPY_CLONGDOUBLE, NPY_CLONGDOUBLE, NPY_BOOL, NPY_OBJECT, NPY_OBJECT, NPY_OBJECT};
static PyUFuncGenericFunction maximum_functions[] = {BOOL_maximum, BYTE_maximum, UBYTE_maximum, SHORT_maximum, USHORT_maximum, INT_maximum, UINT_maximum, LONG_maximum, ULONG_maximum, LONGLONG_maximum, ULONGLONG_maximum, HALF_maximum, FLOAT_maximum, DOUBLE_maximum, LONGDOUBLE_maximum, CFLOAT_maximum, CDOUBLE_maximum, CLONGDOUBLE_maximum, DATETIME_maximum, TIMEDELTA_maximum, NULL};
static void * maximum_data[] = {(void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL};
static char maximum_signatures[] = {NPY_BOOL, NPY_BOOL, NPY_BOOL, NPY_BYTE, NPY_BYTE, NPY_BYTE, NPY_UBYTE, NPY_UBYTE, NPY_UBYTE, NPY_SHORT, NPY_SHORT, NPY_SHORT, NPY_USHORT, NPY_USHORT, NPY_USHORT, NPY_INT, NPY_INT, NPY_INT, NPY_UINT, NPY_UINT, NPY_UINT, NPY_LONG, NPY_LONG, NPY_LONG, NPY_ULONG, NPY_ULONG, NPY_ULONG, NPY_LONGLONG, NPY_LONGLONG, NPY_LONGLONG, NPY_ULONGLONG, NPY_ULONGLONG, NPY_ULONGLONG, NPY_HALF, NPY_HALF, NPY_HALF, NPY_FLOAT, NPY_FLOAT, NPY_FLOAT, NPY_DOUBLE, NPY_DOUBLE, NPY_DOUBLE, NPY_LONGDOUBLE, NPY_LONGDOUBLE, NPY_LONGDOUBLE, NPY_CFLOAT, NPY_CFLOAT, NPY_CFLOAT, NPY_CDOUBLE, NPY_CDOUBLE, NPY_CDOUBLE, NPY_CLONGDOUBLE, NPY_CLONGDOUBLE, NPY_CLONGDOUBLE, NPY_DATETIME, NPY_DATETIME, NPY_DATETIME, NPY_TIMEDELTA, NPY_TIMEDELTA, NPY_TIMEDELTA, NPY_OBJECT, NPY_OBJECT, NPY_OBJECT};
static PyUFuncGenericFunction minimum_functions[] = {BOOL_minimum, BYTE_minimum, UBYTE_minimum, SHORT_minimum, USHORT_minimum, INT_minimum, UINT_minimum, LONG_minimum, ULONG_minimum, LONGLONG_minimum, ULONGLONG_minimum, HALF_minimum, FLOAT_minimum, DOUBLE_minimum, LONGDOUBLE_minimum, CFLOAT_minimum, CDOUBLE_minimum, CLONGDOUBLE_minimum, DATETIME_minimum, TIMEDELTA_minimum, NULL};
static void * minimum_data[] = {(void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL};
static char minimum_signatures[] = {NPY_BOOL, NPY_BOOL, NPY_BOOL, NPY_BYTE, NPY_BYTE, NPY_BYTE, NPY_UBYTE, NPY_UBYTE, NPY_UBYTE, NPY_SHORT, NPY_SHORT, NPY_SHORT, NPY_USHORT, NPY_USHORT, NPY_USHORT, NPY_INT, NPY_INT, NPY_INT, NPY_UINT, NPY_UINT, NPY_UINT, NPY_LONG, NPY_LONG, NPY_LONG, NPY_ULONG, NPY_ULONG, NPY_ULONG, NPY_LONGLONG, NPY_LONGLONG, NPY_LONGLONG, NPY_ULONGLONG, NPY_ULONGLONG, NPY_ULONGLONG, NPY_HALF, NPY_HALF, NPY_HALF, NPY_FLOAT, NPY_FLOAT, NPY_FLOAT, NPY_DOUBLE, NPY_DOUBLE, NPY_DOUBLE, NPY_LONGDOUBLE, NPY_LONGDOUBLE, NPY_LONGDOUBLE, NPY_CFLOAT, NPY_CFLOAT, NPY_CFLOAT, NPY_CDOUBLE, NPY_CDOUBLE, NPY_CDOUBLE, NPY_CLONGDOUBLE, NPY_CLONGDOUBLE, NPY_CLONGDOUBLE, NPY_DATETIME, NPY_DATETIME, NPY_DATETIME, NPY_TIMEDELTA, NPY_TIMEDELTA, NPY_TIMEDELTA, NPY_OBJECT, NPY_OBJECT, NPY_OBJECT};
static PyUFuncGenericFunction modf_functions[] = {HALF_modf, FLOAT_modf, DOUBLE_modf, LONGDOUBLE_modf};
static void * modf_data[] = {(void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL};
static char modf_signatures[] = {NPY_HALF, NPY_HALF, NPY_HALF, NPY_FLOAT, NPY_FLOAT, NPY_FLOAT, NPY_DOUBLE, NPY_DOUBLE, NPY_DOUBLE, NPY_LONGDOUBLE, NPY_LONGDOUBLE, NPY_LONGDOUBLE};
static PyUFuncGenericFunction multiply_functions[] = {BOOL_multiply, BYTE_multiply, UBYTE_multiply, SHORT_multiply, USHORT_multiply, INT_multiply, UINT_multiply, LONG_multiply, ULONG_multiply, LONGLONG_multiply, ULONGLONG_multiply, HALF_multiply, FLOAT_multiply, DOUBLE_multiply, LONGDOUBLE_multiply, CFLOAT_multiply, CDOUBLE_multiply, CLONGDOUBLE_multiply, TIMEDELTA_mq_m_multiply, TIMEDELTA_qm_m_multiply, TIMEDELTA_md_m_multiply, TIMEDELTA_dm_m_multiply, NULL};
static void * multiply_data[] = {(void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL};
static char multiply_signatures[] = {NPY_BOOL, NPY_BOOL, NPY_BOOL, NPY_BYTE, NPY_BYTE, NPY_BYTE, NPY_UBYTE, NPY_UBYTE, NPY_UBYTE, NPY_SHORT, NPY_SHORT, NPY_SHORT, NPY_USHORT, NPY_USHORT, NPY_USHORT, NPY_INT, NPY_INT, NPY_INT, NPY_UINT, NPY_UINT, NPY_UINT, NPY_LONG, NPY_LONG, NPY_LONG, NPY_ULONG, NPY_ULONG, NPY_ULONG, NPY_LONGLONG, NPY_LONGLONG, NPY_LONGLONG, NPY_ULONGLONG, NPY_ULONGLONG, NPY_ULONGLONG, NPY_HALF, NPY_HALF, NPY_HALF, NPY_FLOAT, NPY_FLOAT, NPY_FLOAT, NPY_DOUBLE, NPY_DOUBLE, NPY_DOUBLE, NPY_LONGDOUBLE, NPY_LONGDOUBLE, NPY_LONGDOUBLE, NPY_CFLOAT, NPY_CFLOAT, NPY_CFLOAT, NPY_CDOUBLE, NPY_CDOUBLE, NPY_CDOUBLE, NPY_CLONGDOUBLE, NPY_CLONGDOUBLE, NPY_CLONGDOUBLE, NPY_TIMEDELTA, NPY_LONGLONG, NPY_TIMEDELTA, NPY_LONGLONG, NPY_TIMEDELTA, NPY_TIMEDELTA, NPY_TIMEDELTA, NPY_DOUBLE, NPY_TIMEDELTA, NPY_DOUBLE, NPY_TIMEDELTA, NPY_TIMEDELTA, NPY_OBJECT, NPY_OBJECT, NPY_OBJECT};
static PyUFuncGenericFunction negative_functions[] = {BOOL_negative, BYTE_negative, UBYTE_negative, SHORT_negative, USHORT_negative, INT_negative, UINT_negative, LONG_negative, ULONG_negative, LONGLONG_negative, ULONGLONG_negative, HALF_negative, FLOAT_negative, DOUBLE_negative, LONGDOUBLE_negative, TIMEDELTA_negative, NULL, NULL, NULL, NULL};
static void * negative_data[] = {(void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL};
static char negative_signatures[] = {NPY_BOOL, NPY_BOOL, NPY_BYTE, NPY_BYTE, NPY_UBYTE, NPY_UBYTE, NPY_SHORT, NPY_SHORT, NPY_USHORT, NPY_USHORT, NPY_INT, NPY_INT, NPY_UINT, NPY_UINT, NPY_LONG, NPY_LONG, NPY_ULONG, NPY_ULONG, NPY_LONGLONG, NPY_LONGLONG, NPY_ULONGLONG, NPY_ULONGLONG, NPY_HALF, NPY_HALF, NPY_FLOAT, NPY_FLOAT, NPY_DOUBLE, NPY_DOUBLE, NPY_LONGDOUBLE, NPY_LONGDOUBLE, NPY_TIMEDELTA, NPY_TIMEDELTA, NPY_CFLOAT, NPY_CFLOAT, NPY_CDOUBLE, NPY_CDOUBLE, NPY_CLONGDOUBLE, NPY_CLONGDOUBLE, NPY_OBJECT, NPY_OBJECT};
static PyUFuncGenericFunction nextafter_functions[] = {HALF_nextafter, FLOAT_nextafter, DOUBLE_nextafter, LONGDOUBLE_nextafter};
static void * nextafter_data[] = {(void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL};
static char nextafter_signatures[] = {NPY_HALF, NPY_HALF, NPY_HALF, NPY_FLOAT, NPY_FLOAT, NPY_FLOAT, NPY_DOUBLE, NPY_DOUBLE, NPY_DOUBLE, NPY_LONGDOUBLE, NPY_LONGDOUBLE, NPY_LONGDOUBLE};
static PyUFuncGenericFunction not_equal_functions[] = {BOOL_not_equal, BYTE_not_equal, UBYTE_not_equal, SHORT_not_equal, USHORT_not_equal, INT_not_equal, UINT_not_equal, LONG_not_equal, ULONG_not_equal, LONGLONG_not_equal, ULONGLONG_not_equal, HALF_not_equal, FLOAT_not_equal, DOUBLE_not_equal, LONGDOUBLE_not_equal, CFLOAT_not_equal, CDOUBLE_not_equal, CLONGDOUBLE_not_equal, OBJECT_not_equal, DATETIME_not_equal, TIMEDELTA_not_equal};
static void * not_equal_data[] = {(void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL};
static char not_equal_signatures[] = {NPY_BOOL, NPY_BOOL, NPY_BOOL, NPY_BYTE, NPY_BYTE, NPY_BOOL, NPY_UBYTE, NPY_UBYTE, NPY_BOOL, NPY_SHORT, NPY_SHORT, NPY_BOOL, NPY_USHORT, NPY_USHORT, NPY_BOOL, NPY_INT, NPY_INT, NPY_BOOL, NPY_UINT, NPY_UINT, NPY_BOOL, NPY_LONG, NPY_LONG, NPY_BOOL, NPY_ULONG, NPY_ULONG, NPY_BOOL, NPY_LONGLONG, NPY_LONGLONG, NPY_BOOL, NPY_ULONGLONG, NPY_ULONGLONG, NPY_BOOL, NPY_HALF, NPY_HALF, NPY_BOOL, NPY_FLOAT, NPY_FLOAT, NPY_BOOL, NPY_DOUBLE, NPY_DOUBLE, NPY_BOOL, NPY_LONGDOUBLE, NPY_LONGDOUBLE, NPY_BOOL, NPY_CFLOAT, NPY_CFLOAT, NPY_BOOL, NPY_CDOUBLE, NPY_CDOUBLE, NPY_BOOL, NPY_CLONGDOUBLE, NPY_CLONGDOUBLE, NPY_BOOL, NPY_OBJECT, NPY_OBJECT, NPY_BOOL, NPY_DATETIME, NPY_DATETIME, NPY_BOOL, NPY_TIMEDELTA, NPY_TIMEDELTA, NPY_BOOL};
static PyUFuncGenericFunction power_functions[] = {BYTE_power, UBYTE_power, SHORT_power, USHORT_power, INT_power, UINT_power, LONG_power, ULONG_power, LONGLONG_power, ULONGLONG_power, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL};
static void * power_data[] = {(void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL};
static char power_signatures[] = {NPY_BYTE, NPY_BYTE, NPY_BYTE, NPY_UBYTE, NPY_UBYTE, NPY_UBYTE, NPY_SHORT, NPY_SHORT, NPY_SHORT, NPY_USHORT, NPY_USHORT, NPY_USHORT, NPY_INT, NPY_INT, NPY_INT, NPY_UINT, NPY_UINT, NPY_UINT, NPY_LONG, NPY_LONG, NPY_LONG, NPY_ULONG, NPY_ULONG, NPY_ULONG, NPY_LONGLONG, NPY_LONGLONG, NPY_LONGLONG, NPY_ULONGLONG, NPY_ULONGLONG, NPY_ULONGLONG, NPY_HALF, NPY_HALF, NPY_HALF, NPY_FLOAT, NPY_FLOAT, NPY_FLOAT, NPY_DOUBLE, NPY_DOUBLE, NPY_DOUBLE, NPY_LONGDOUBLE, NPY_LONGDOUBLE, NPY_LONGDOUBLE, NPY_CFLOAT, NPY_CFLOAT, NPY_CFLOAT, NPY_CDOUBLE, NPY_CDOUBLE, NPY_CDOUBLE, NPY_CLONGDOUBLE, NPY_CLONGDOUBLE, NPY_CLONGDOUBLE, NPY_OBJECT, NPY_OBJECT, NPY_OBJECT};
static PyUFuncGenericFunction rad2deg_functions[] = {NULL, NULL, NULL, NULL, NULL};
static void * rad2deg_data[] = {(void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)"rad2deg"};
static char rad2deg_signatures[] = {NPY_HALF, NPY_HALF, NPY_FLOAT, NPY_FLOAT, NPY_DOUBLE, NPY_DOUBLE, NPY_LONGDOUBLE, NPY_LONGDOUBLE, NPY_OBJECT, NPY_OBJECT};
static PyUFuncGenericFunction radians_functions[] = {NULL, NULL, NULL, NULL, NULL};
static void * radians_data[] = {(void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)"radians"};
static char radians_signatures[] = {NPY_HALF, NPY_HALF, NPY_FLOAT, NPY_FLOAT, NPY_DOUBLE, NPY_DOUBLE, NPY_LONGDOUBLE, NPY_LONGDOUBLE, NPY_OBJECT, NPY_OBJECT};
static PyUFuncGenericFunction reciprocal_functions[] = {BYTE_reciprocal, UBYTE_reciprocal, SHORT_reciprocal, USHORT_reciprocal, INT_reciprocal, UINT_reciprocal, LONG_reciprocal, ULONG_reciprocal, LONGLONG_reciprocal, ULONGLONG_reciprocal, HALF_reciprocal, FLOAT_reciprocal, DOUBLE_reciprocal, LONGDOUBLE_reciprocal, CFLOAT_reciprocal, CDOUBLE_reciprocal, CLONGDOUBLE_reciprocal, NULL};
static void * reciprocal_data[] = {(void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL};
static char reciprocal_signatures[] = {NPY_BYTE, NPY_BYTE, NPY_UBYTE, NPY_UBYTE, NPY_SHORT, NPY_SHORT, NPY_USHORT, NPY_USHORT, NPY_INT, NPY_INT, NPY_UINT, NPY_UINT, NPY_LONG, NPY_LONG, NPY_ULONG, NPY_ULONG, NPY_LONGLONG, NPY_LONGLONG, NPY_ULONGLONG, NPY_ULONGLONG, NPY_HALF, NPY_HALF, NPY_FLOAT, NPY_FLOAT, NPY_DOUBLE, NPY_DOUBLE, NPY_LONGDOUBLE, NPY_LONGDOUBLE, NPY_CFLOAT, NPY_CFLOAT, NPY_CDOUBLE, NPY_CDOUBLE, NPY_CLONGDOUBLE, NPY_CLONGDOUBLE, NPY_OBJECT, NPY_OBJECT};
static PyUFuncGenericFunction remainder_functions[] = {BYTE_remainder, UBYTE_remainder, SHORT_remainder, USHORT_remainder, INT_remainder, UINT_remainder, LONG_remainder, ULONG_remainder, LONGLONG_remainder, ULONGLONG_remainder, HALF_remainder, FLOAT_remainder, DOUBLE_remainder, LONGDOUBLE_remainder, NULL};
static void * remainder_data[] = {(void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL};
static char remainder_signatures[] = {NPY_BYTE, NPY_BYTE, NPY_BYTE, NPY_UBYTE, NPY_UBYTE, NPY_UBYTE, NPY_SHORT, NPY_SHORT, NPY_SHORT, NPY_USHORT, NPY_USHORT, NPY_USHORT, NPY_INT, NPY_INT, NPY_INT, NPY_UINT, NPY_UINT, NPY_UINT, NPY_LONG, NPY_LONG, NPY_LONG, NPY_ULONG, NPY_ULONG, NPY_ULONG, NPY_LONGLONG, NPY_LONGLONG, NPY_LONGLONG, NPY_ULONGLONG, NPY_ULONGLONG, NPY_ULONGLONG, NPY_HALF, NPY_HALF, NPY_HALF, NPY_FLOAT, NPY_FLOAT, NPY_FLOAT, NPY_DOUBLE, NPY_DOUBLE, NPY_DOUBLE, NPY_LONGDOUBLE, NPY_LONGDOUBLE, NPY_LONGDOUBLE, NPY_OBJECT, NPY_OBJECT, NPY_OBJECT};
static PyUFuncGenericFunction right_shift_functions[] = {BYTE_right_shift, UBYTE_right_shift, SHORT_right_shift, USHORT_right_shift, INT_right_shift, UINT_right_shift, LONG_right_shift, ULONG_right_shift, LONGLONG_right_shift, ULONGLONG_right_shift, NULL};
static void * right_shift_data[] = {(void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL};
static char right_shift_signatures[] = {NPY_BYTE, NPY_BYTE, NPY_BYTE, NPY_UBYTE, NPY_UBYTE, NPY_UBYTE, NPY_SHORT, NPY_SHORT, NPY_SHORT, NPY_USHORT, NPY_USHORT, NPY_USHORT, NPY_INT, NPY_INT, NPY_INT, NPY_UINT, NPY_UINT, NPY_UINT, NPY_LONG, NPY_LONG, NPY_LONG, NPY_ULONG, NPY_ULONG, NPY_ULONG, NPY_LONGLONG, NPY_LONGLONG, NPY_LONGLONG, NPY_ULONGLONG, NPY_ULONGLONG, NPY_ULONGLONG, NPY_OBJECT, NPY_OBJECT, NPY_OBJECT};
static PyUFuncGenericFunction rint_functions[] = {NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL};
static void * rint_data[] = {(void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)"rint"};
static char rint_signatures[] = {NPY_HALF, NPY_HALF, NPY_FLOAT, NPY_FLOAT, NPY_DOUBLE, NPY_DOUBLE, NPY_LONGDOUBLE, NPY_LONGDOUBLE, NPY_CFLOAT, NPY_CFLOAT, NPY_CDOUBLE, NPY_CDOUBLE, NPY_CLONGDOUBLE, NPY_CLONGDOUBLE, NPY_OBJECT, NPY_OBJECT};
static PyUFuncGenericFunction sign_functions[] = {BYTE_sign, UBYTE_sign, SHORT_sign, USHORT_sign, INT_sign, UINT_sign, LONG_sign, ULONG_sign, LONGLONG_sign, ULONGLONG_sign, HALF_sign, FLOAT_sign, DOUBLE_sign, LONGDOUBLE_sign, CFLOAT_sign, CDOUBLE_sign, CLONGDOUBLE_sign, OBJECT_sign, TIMEDELTA_sign};
static void * sign_data[] = {(void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL};
static char sign_signatures[] = {NPY_BYTE, NPY_BYTE, NPY_UBYTE, NPY_UBYTE, NPY_SHORT, NPY_SHORT, NPY_USHORT, NPY_USHORT, NPY_INT, NPY_INT, NPY_UINT, NPY_UINT, NPY_LONG, NPY_LONG, NPY_ULONG, NPY_ULONG, NPY_LONGLONG, NPY_LONGLONG, NPY_ULONGLONG, NPY_ULONGLONG, NPY_HALF, NPY_HALF, NPY_FLOAT, NPY_FLOAT, NPY_DOUBLE, NPY_DOUBLE, NPY_LONGDOUBLE, NPY_LONGDOUBLE, NPY_CFLOAT, NPY_CFLOAT, NPY_CDOUBLE, NPY_CDOUBLE, NPY_CLONGDOUBLE, NPY_CLONGDOUBLE, NPY_OBJECT, NPY_OBJECT, NPY_TIMEDELTA, NPY_TIMEDELTA};
static PyUFuncGenericFunction signbit_functions[] = {HALF_signbit, FLOAT_signbit, DOUBLE_signbit, LONGDOUBLE_signbit};
static void * signbit_data[] = {(void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL};
static char signbit_signatures[] = {NPY_HALF, NPY_BOOL, NPY_FLOAT, NPY_BOOL, NPY_DOUBLE, NPY_BOOL, NPY_LONGDOUBLE, NPY_BOOL};
static PyUFuncGenericFunction sin_functions[] = {NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL};
static void * sin_data[] = {(void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)"sin"};
static char sin_signatures[] = {NPY_HALF, NPY_HALF, NPY_FLOAT, NPY_FLOAT, NPY_DOUBLE, NPY_DOUBLE, NPY_LONGDOUBLE, NPY_LONGDOUBLE, NPY_CFLOAT, NPY_CFLOAT, NPY_CDOUBLE, NPY_CDOUBLE, NPY_CLONGDOUBLE, NPY_CLONGDOUBLE, NPY_OBJECT, NPY_OBJECT};
static PyUFuncGenericFunction sinh_functions[] = {NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL};
static void * sinh_data[] = {(void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)"sinh"};
static char sinh_signatures[] = {NPY_HALF, NPY_HALF, NPY_FLOAT, NPY_FLOAT, NPY_DOUBLE, NPY_DOUBLE, NPY_LONGDOUBLE, NPY_LONGDOUBLE, NPY_CFLOAT, NPY_CFLOAT, NPY_CDOUBLE, NPY_CDOUBLE, NPY_CLONGDOUBLE, NPY_CLONGDOUBLE, NPY_OBJECT, NPY_OBJECT};
static PyUFuncGenericFunction spacing_functions[] = {HALF_spacing, FLOAT_spacing, DOUBLE_spacing, LONGDOUBLE_spacing};
static void * spacing_data[] = {(void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL};
static char spacing_signatures[] = {NPY_HALF, NPY_HALF, NPY_FLOAT, NPY_FLOAT, NPY_DOUBLE, NPY_DOUBLE, NPY_LONGDOUBLE, NPY_LONGDOUBLE};
static PyUFuncGenericFunction sqrt_functions[] = {FLOAT_sqrt, DOUBLE_sqrt, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL};
static void * sqrt_data[] = {(void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)"sqrt"};
static char sqrt_signatures[] = {NPY_FLOAT, NPY_FLOAT, NPY_DOUBLE, NPY_DOUBLE, NPY_HALF, NPY_HALF, NPY_FLOAT, NPY_FLOAT, NPY_DOUBLE, NPY_DOUBLE, NPY_LONGDOUBLE, NPY_LONGDOUBLE, NPY_CFLOAT, NPY_CFLOAT, NPY_CDOUBLE, NPY_CDOUBLE, NPY_CLONGDOUBLE, NPY_CLONGDOUBLE, NPY_OBJECT, NPY_OBJECT};
static PyUFuncGenericFunction square_functions[] = {BYTE_square, UBYTE_square, SHORT_square, USHORT_square, INT_square, UINT_square, LONG_square, ULONG_square, LONGLONG_square, ULONGLONG_square, HALF_square, FLOAT_square, DOUBLE_square, LONGDOUBLE_square, CFLOAT_square, CDOUBLE_square, CLONGDOUBLE_square, NULL};
static void * square_data[] = {(void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL};
static char square_signatures[] = {NPY_BYTE, NPY_BYTE, NPY_UBYTE, NPY_UBYTE, NPY_SHORT, NPY_SHORT, NPY_USHORT, NPY_USHORT, NPY_INT, NPY_INT, NPY_UINT, NPY_UINT, NPY_LONG, NPY_LONG, NPY_ULONG, NPY_ULONG, NPY_LONGLONG, NPY_LONGLONG, NPY_ULONGLONG, NPY_ULONGLONG, NPY_HALF, NPY_HALF, NPY_FLOAT, NPY_FLOAT, NPY_DOUBLE, NPY_DOUBLE, NPY_LONGDOUBLE, NPY_LONGDOUBLE, NPY_CFLOAT, NPY_CFLOAT, NPY_CDOUBLE, NPY_CDOUBLE, NPY_CLONGDOUBLE, NPY_CLONGDOUBLE, NPY_OBJECT, NPY_OBJECT};
static PyUFuncGenericFunction subtract_functions[] = {BOOL_subtract, BYTE_subtract, UBYTE_subtract, SHORT_subtract, USHORT_subtract, INT_subtract, UINT_subtract, LONG_subtract, ULONG_subtract, LONGLONG_subtract, ULONGLONG_subtract, HALF_subtract, FLOAT_subtract, DOUBLE_subtract, LONGDOUBLE_subtract, CFLOAT_subtract, CDOUBLE_subtract, CLONGDOUBLE_subtract, DATETIME_Mm_M_subtract, TIMEDELTA_mm_m_subtract, DATETIME_MM_m_subtract, NULL};
static void * subtract_data[] = {(void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL};
static char subtract_signatures[] = {NPY_BOOL, NPY_BOOL, NPY_BOOL, NPY_BYTE, NPY_BYTE, NPY_BYTE, NPY_UBYTE, NPY_UBYTE, NPY_UBYTE, NPY_SHORT, NPY_SHORT, NPY_SHORT, NPY_USHORT, NPY_USHORT, NPY_USHORT, NPY_INT, NPY_INT, NPY_INT, NPY_UINT, NPY_UINT, NPY_UINT, NPY_LONG, NPY_LONG, NPY_LONG, NPY_ULONG, NPY_ULONG, NPY_ULONG, NPY_LONGLONG, NPY_LONGLONG, NPY_LONGLONG, NPY_ULONGLONG, NPY_ULONGLONG, NPY_ULONGLONG, NPY_HALF, NPY_HALF, NPY_HALF, NPY_FLOAT, NPY_FLOAT, NPY_FLOAT, NPY_DOUBLE, NPY_DOUBLE, NPY_DOUBLE, NPY_LONGDOUBLE, NPY_LONGDOUBLE, NPY_LONGDOUBLE, NPY_CFLOAT, NPY_CFLOAT, NPY_CFLOAT, NPY_CDOUBLE, NPY_CDOUBLE, NPY_CDOUBLE, NPY_CLONGDOUBLE, NPY_CLONGDOUBLE, NPY_CLONGDOUBLE, NPY_DATETIME, NPY_TIMEDELTA, NPY_DATETIME, NPY_TIMEDELTA, NPY_TIMEDELTA, NPY_TIMEDELTA, NPY_DATETIME, NPY_DATETIME, NPY_TIMEDELTA, NPY_OBJECT, NPY_OBJECT, NPY_OBJECT};
static PyUFuncGenericFunction tan_functions[] = {NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL};
static void * tan_data[] = {(void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)"tan"};
static char tan_signatures[] = {NPY_HALF, NPY_HALF, NPY_FLOAT, NPY_FLOAT, NPY_DOUBLE, NPY_DOUBLE, NPY_LONGDOUBLE, NPY_LONGDOUBLE, NPY_CFLOAT, NPY_CFLOAT, NPY_CDOUBLE, NPY_CDOUBLE, NPY_CLONGDOUBLE, NPY_CLONGDOUBLE, NPY_OBJECT, NPY_OBJECT};
static PyUFuncGenericFunction tanh_functions[] = {NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL};
static void * tanh_data[] = {(void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)"tanh"};
static char tanh_signatures[] = {NPY_HALF, NPY_HALF, NPY_FLOAT, NPY_FLOAT, NPY_DOUBLE, NPY_DOUBLE, NPY_LONGDOUBLE, NPY_LONGDOUBLE, NPY_CFLOAT, NPY_CFLOAT, NPY_CDOUBLE, NPY_CDOUBLE, NPY_CLONGDOUBLE, NPY_CLONGDOUBLE, NPY_OBJECT, NPY_OBJECT};
static PyUFuncGenericFunction true_divide_functions[] = {BYTE_true_divide, UBYTE_true_divide, SHORT_true_divide, USHORT_true_divide, INT_true_divide, UINT_true_divide, LONG_true_divide, ULONG_true_divide, LONGLONG_true_divide, ULONGLONG_true_divide, HALF_true_divide, FLOAT_true_divide, DOUBLE_true_divide, LONGDOUBLE_true_divide, CFLOAT_true_divide, CDOUBLE_true_divide, CLONGDOUBLE_true_divide, TIMEDELTA_mq_m_true_divide, TIMEDELTA_md_m_true_divide, TIMEDELTA_mm_d_true_divide, NULL};
static void * true_divide_data[] = {(void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL};
static char true_divide_signatures[] = {NPY_BYTE, NPY_BYTE, NPY_DOUBLE, NPY_UBYTE, NPY_UBYTE, NPY_DOUBLE, NPY_SHORT, NPY_SHORT, NPY_DOUBLE, NPY_USHORT, NPY_USHORT, NPY_DOUBLE, NPY_INT, NPY_INT, NPY_DOUBLE, NPY_UINT, NPY_UINT, NPY_DOUBLE, NPY_LONG, NPY_LONG, NPY_DOUBLE, NPY_ULONG, NPY_ULONG, NPY_DOUBLE, NPY_LONGLONG, NPY_LONGLONG, NPY_DOUBLE, NPY_ULONGLONG, NPY_ULONGLONG, NPY_DOUBLE, NPY_HALF, NPY_HALF, NPY_HALF, NPY_FLOAT, NPY_FLOAT, NPY_FLOAT, NPY_DOUBLE, NPY_DOUBLE, NPY_DOUBLE, NPY_LONGDOUBLE, NPY_LONGDOUBLE, NPY_LONGDOUBLE, NPY_CFLOAT, NPY_CFLOAT, NPY_CFLOAT, NPY_CDOUBLE, NPY_CDOUBLE, NPY_CDOUBLE, NPY_CLONGDOUBLE, NPY_CLONGDOUBLE, NPY_CLONGDOUBLE, NPY_TIMEDELTA, NPY_LONGLONG, NPY_TIMEDELTA, NPY_TIMEDELTA, NPY_DOUBLE, NPY_TIMEDELTA, NPY_TIMEDELTA, NPY_TIMEDELTA, NPY_DOUBLE, NPY_OBJECT, NPY_OBJECT, NPY_OBJECT};
static PyUFuncGenericFunction trunc_functions[] = {NULL, NULL, NULL, NULL, NULL};
static void * trunc_data[] = {(void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL, (void *)"trunc"};
static char trunc_signatures[] = {NPY_HALF, NPY_HALF, NPY_FLOAT, NPY_FLOAT, NPY_DOUBLE, NPY_DOUBLE, NPY_LONGDOUBLE, NPY_LONGDOUBLE, NPY_OBJECT, NPY_OBJECT};

static void
InitOperators(PyObject *dictionary) {
    PyObject *f;

    _ones_like_functions[20] = PyUFunc_O_O;
    _ones_like_data[20] = (void *) Py_get_one;
    absolute_functions[19] = PyUFunc_O_O;
    absolute_data[19] = (void *) PyNumber_Absolute;
    add_functions[21] = PyUFunc_OO_O;
    add_data[21] = (void *) PyNumber_Add;
    arccos_functions[0] = PyUFunc_e_e_As_f_f;
    arccos_data[0] = (void *) npy_acosf;
    arccos_functions[1] = PyUFunc_f_f;
    arccos_data[1] = (void *) npy_acosf;
    arccos_functions[2] = PyUFunc_d_d;
    arccos_data[2] = (void *) npy_acos;
    arccos_functions[3] = PyUFunc_g_g;
    arccos_data[3] = (void *) npy_acosl;
    arccos_functions[4] = PyUFunc_F_F;
    arccos_data[4] = (void *) nc_acosf;
    arccos_functions[5] = PyUFunc_D_D;
    arccos_data[5] = (void *) nc_acos;
    arccos_functions[6] = PyUFunc_G_G;
    arccos_data[6] = (void *) nc_acosl;
    arccos_functions[7] = PyUFunc_O_O_method;
    arccosh_functions[0] = PyUFunc_e_e_As_f_f;
    arccosh_data[0] = (void *) npy_acoshf;
    arccosh_functions[1] = PyUFunc_f_f;
    arccosh_data[1] = (void *) npy_acoshf;
    arccosh_functions[2] = PyUFunc_d_d;
    arccosh_data[2] = (void *) npy_acosh;
    arccosh_functions[3] = PyUFunc_g_g;
    arccosh_data[3] = (void *) npy_acoshl;
    arccosh_functions[4] = PyUFunc_F_F;
    arccosh_data[4] = (void *) nc_acoshf;
    arccosh_functions[5] = PyUFunc_D_D;
    arccosh_data[5] = (void *) nc_acosh;
    arccosh_functions[6] = PyUFunc_G_G;
    arccosh_data[6] = (void *) nc_acoshl;
    arccosh_functions[7] = PyUFunc_O_O_method;
    arcsin_functions[0] = PyUFunc_e_e_As_f_f;
    arcsin_data[0] = (void *) npy_asinf;
    arcsin_functions[1] = PyUFunc_f_f;
    arcsin_data[1] = (void *) npy_asinf;
    arcsin_functions[2] = PyUFunc_d_d;
    arcsin_data[2] = (void *) npy_asin;
    arcsin_functions[3] = PyUFunc_g_g;
    arcsin_data[3] = (void *) npy_asinl;
    arcsin_functions[4] = PyUFunc_F_F;
    arcsin_data[4] = (void *) nc_asinf;
    arcsin_functions[5] = PyUFunc_D_D;
    arcsin_data[5] = (void *) nc_asin;
    arcsin_functions[6] = PyUFunc_G_G;
    arcsin_data[6] = (void *) nc_asinl;
    arcsin_functions[7] = PyUFunc_O_O_method;
    arcsinh_functions[0] = PyUFunc_e_e_As_f_f;
    arcsinh_data[0] = (void *) npy_asinhf;
    arcsinh_functions[1] = PyUFunc_f_f;
    arcsinh_data[1] = (void *) npy_asinhf;
    arcsinh_functions[2] = PyUFunc_d_d;
    arcsinh_data[2] = (void *) npy_asinh;
    arcsinh_functions[3] = PyUFunc_g_g;
    arcsinh_data[3] = (void *) npy_asinhl;
    arcsinh_functions[4] = PyUFunc_F_F;
    arcsinh_data[4] = (void *) nc_asinhf;
    arcsinh_functions[5] = PyUFunc_D_D;
    arcsinh_data[5] = (void *) nc_asinh;
    arcsinh_functions[6] = PyUFunc_G_G;
    arcsinh_data[6] = (void *) nc_asinhl;
    arcsinh_functions[7] = PyUFunc_O_O_method;
    arctan_functions[0] = PyUFunc_e_e_As_f_f;
    arctan_data[0] = (void *) npy_atanf;
    arctan_functions[1] = PyUFunc_f_f;
    arctan_data[1] = (void *) npy_atanf;
    arctan_functions[2] = PyUFunc_d_d;
    arctan_data[2] = (void *) npy_atan;
    arctan_functions[3] = PyUFunc_g_g;
    arctan_data[3] = (void *) npy_atanl;
    arctan_functions[4] = PyUFunc_F_F;
    arctan_data[4] = (void *) nc_atanf;
    arctan_functions[5] = PyUFunc_D_D;
    arctan_data[5] = (void *) nc_atan;
    arctan_functions[6] = PyUFunc_G_G;
    arctan_data[6] = (void *) nc_atanl;
    arctan_functions[7] = PyUFunc_O_O_method;
    arctan2_functions[0] = PyUFunc_ee_e_As_ff_f;
    arctan2_data[0] = (void *) npy_atan2f;
    arctan2_functions[1] = PyUFunc_ff_f;
    arctan2_data[1] = (void *) npy_atan2f;
    arctan2_functions[2] = PyUFunc_dd_d;
    arctan2_data[2] = (void *) npy_atan2;
    arctan2_functions[3] = PyUFunc_gg_g;
    arctan2_data[3] = (void *) npy_atan2l;
    arctan2_functions[4] = PyUFunc_OO_O_method;
    arctanh_functions[0] = PyUFunc_e_e_As_f_f;
    arctanh_data[0] = (void *) npy_atanhf;
    arctanh_functions[1] = PyUFunc_f_f;
    arctanh_data[1] = (void *) npy_atanhf;
    arctanh_functions[2] = PyUFunc_d_d;
    arctanh_data[2] = (void *) npy_atanh;
    arctanh_functions[3] = PyUFunc_g_g;
    arctanh_data[3] = (void *) npy_atanhl;
    arctanh_functions[4] = PyUFunc_F_F;
    arctanh_data[4] = (void *) nc_atanhf;
    arctanh_functions[5] = PyUFunc_D_D;
    arctanh_data[5] = (void *) nc_atanh;
    arctanh_functions[6] = PyUFunc_G_G;
    arctanh_data[6] = (void *) nc_atanhl;
    arctanh_functions[7] = PyUFunc_O_O_method;
    bitwise_and_functions[11] = PyUFunc_OO_O;
    bitwise_and_data[11] = (void *) PyNumber_And;
    bitwise_or_functions[11] = PyUFunc_OO_O;
    bitwise_or_data[11] = (void *) PyNumber_Or;
    bitwise_xor_functions[11] = PyUFunc_OO_O;
    bitwise_xor_data[11] = (void *) PyNumber_Xor;
    cbrt_functions[0] = PyUFunc_e_e_As_f_f;
    cbrt_data[0] = (void *) npy_cbrtf;
    cbrt_functions[1] = PyUFunc_f_f;
    cbrt_data[1] = (void *) npy_cbrtf;
    cbrt_functions[2] = PyUFunc_d_d;
    cbrt_data[2] = (void *) npy_cbrt;
    cbrt_functions[3] = PyUFunc_g_g;
    cbrt_data[3] = (void *) npy_cbrtl;
    cbrt_functions[4] = PyUFunc_O_O_method;
    ceil_functions[0] = PyUFunc_e_e_As_f_f;
    ceil_data[0] = (void *) npy_ceilf;
    ceil_functions[1] = PyUFunc_f_f;
    ceil_data[1] = (void *) npy_ceilf;
    ceil_functions[2] = PyUFunc_d_d;
    ceil_data[2] = (void *) npy_ceil;
    ceil_functions[3] = PyUFunc_g_g;
    ceil_data[3] = (void *) npy_ceill;
    ceil_functions[4] = PyUFunc_O_O_method;
    conjugate_functions[17] = PyUFunc_O_O_method;
    cos_functions[0] = PyUFunc_e_e_As_f_f;
    cos_data[0] = (void *) npy_cosf;
    cos_functions[1] = PyUFunc_f_f;
    cos_data[1] = (void *) npy_cosf;
    cos_functions[2] = PyUFunc_d_d;
    cos_data[2] = (void *) npy_cos;
    cos_functions[3] = PyUFunc_g_g;
    cos_data[3] = (void *) npy_cosl;
    cos_functions[4] = PyUFunc_F_F;
    cos_data[4] = (void *) nc_cosf;
    cos_functions[5] = PyUFunc_D_D;
    cos_data[5] = (void *) nc_cos;
    cos_functions[6] = PyUFunc_G_G;
    cos_data[6] = (void *) nc_cosl;
    cos_functions[7] = PyUFunc_O_O_method;
    cosh_functions[0] = PyUFunc_e_e_As_f_f;
    cosh_data[0] = (void *) npy_coshf;
    cosh_functions[1] = PyUFunc_f_f;
    cosh_data[1] = (void *) npy_coshf;
    cosh_functions[2] = PyUFunc_d_d;
    cosh_data[2] = (void *) npy_cosh;
    cosh_functions[3] = PyUFunc_g_g;
    cosh_data[3] = (void *) npy_coshl;
    cosh_functions[4] = PyUFunc_F_F;
    cosh_data[4] = (void *) nc_coshf;
    cosh_functions[5] = PyUFunc_D_D;
    cosh_data[5] = (void *) nc_cosh;
    cosh_functions[6] = PyUFunc_G_G;
    cosh_data[6] = (void *) nc_coshl;
    cosh_functions[7] = PyUFunc_O_O_method;
    deg2rad_functions[0] = PyUFunc_e_e_As_f_f;
    deg2rad_data[0] = (void *) npy_deg2radf;
    deg2rad_functions[1] = PyUFunc_f_f;
    deg2rad_data[1] = (void *) npy_deg2radf;
    deg2rad_functions[2] = PyUFunc_d_d;
    deg2rad_data[2] = (void *) npy_deg2rad;
    deg2rad_functions[3] = PyUFunc_g_g;
    deg2rad_data[3] = (void *) npy_deg2radl;
    deg2rad_functions[4] = PyUFunc_O_O_method;
    degrees_functions[0] = PyUFunc_e_e_As_f_f;
    degrees_data[0] = (void *) npy_degreesf;
    degrees_functions[1] = PyUFunc_f_f;
    degrees_data[1] = (void *) npy_degreesf;
    degrees_functions[2] = PyUFunc_d_d;
    degrees_data[2] = (void *) npy_degrees;
    degrees_functions[3] = PyUFunc_g_g;
    degrees_data[3] = (void *) npy_degreesl;
    degrees_functions[4] = PyUFunc_O_O_method;
    divide_functions[20] = PyUFunc_OO_O;
    divide_data[20] = (void *) PyNumber_Divide;
    exp_functions[0] = PyUFunc_e_e_As_f_f;
    exp_data[0] = (void *) npy_expf;
    exp_functions[1] = PyUFunc_f_f;
    exp_data[1] = (void *) npy_expf;
    exp_functions[2] = PyUFunc_d_d;
    exp_data[2] = (void *) npy_exp;
    exp_functions[3] = PyUFunc_g_g;
    exp_data[3] = (void *) npy_expl;
    exp_functions[4] = PyUFunc_F_F;
    exp_data[4] = (void *) nc_expf;
    exp_functions[5] = PyUFunc_D_D;
    exp_data[5] = (void *) nc_exp;
    exp_functions[6] = PyUFunc_G_G;
    exp_data[6] = (void *) nc_expl;
    exp_functions[7] = PyUFunc_O_O_method;
    exp2_functions[0] = PyUFunc_e_e_As_f_f;
    exp2_data[0] = (void *) npy_exp2f;
    exp2_functions[1] = PyUFunc_f_f;
    exp2_data[1] = (void *) npy_exp2f;
    exp2_functions[2] = PyUFunc_d_d;
    exp2_data[2] = (void *) npy_exp2;
    exp2_functions[3] = PyUFunc_g_g;
    exp2_data[3] = (void *) npy_exp2l;
    exp2_functions[4] = PyUFunc_F_F;
    exp2_data[4] = (void *) nc_exp2f;
    exp2_functions[5] = PyUFunc_D_D;
    exp2_data[5] = (void *) nc_exp2;
    exp2_functions[6] = PyUFunc_G_G;
    exp2_data[6] = (void *) nc_exp2l;
    exp2_functions[7] = PyUFunc_O_O_method;
    expm1_functions[0] = PyUFunc_e_e_As_f_f;
    expm1_data[0] = (void *) npy_expm1f;
    expm1_functions[1] = PyUFunc_f_f;
    expm1_data[1] = (void *) npy_expm1f;
    expm1_functions[2] = PyUFunc_d_d;
    expm1_data[2] = (void *) npy_expm1;
    expm1_functions[3] = PyUFunc_g_g;
    expm1_data[3] = (void *) npy_expm1l;
    expm1_functions[4] = PyUFunc_F_F;
    expm1_data[4] = (void *) nc_expm1f;
    expm1_functions[5] = PyUFunc_D_D;
    expm1_data[5] = (void *) nc_expm1;
    expm1_functions[6] = PyUFunc_G_G;
    expm1_data[6] = (void *) nc_expm1l;
    expm1_functions[7] = PyUFunc_O_O_method;
    fabs_functions[0] = PyUFunc_e_e_As_f_f;
    fabs_data[0] = (void *) npy_fabsf;
    fabs_functions[1] = PyUFunc_f_f;
    fabs_data[1] = (void *) npy_fabsf;
    fabs_functions[2] = PyUFunc_d_d;
    fabs_data[2] = (void *) npy_fabs;
    fabs_functions[3] = PyUFunc_g_g;
    fabs_data[3] = (void *) npy_fabsl;
    fabs_functions[4] = PyUFunc_O_O_method;
    floor_functions[0] = PyUFunc_e_e_As_f_f;
    floor_data[0] = (void *) npy_floorf;
    floor_functions[1] = PyUFunc_f_f;
    floor_data[1] = (void *) npy_floorf;
    floor_functions[2] = PyUFunc_d_d;
    floor_data[2] = (void *) npy_floor;
    floor_functions[3] = PyUFunc_g_g;
    floor_data[3] = (void *) npy_floorl;
    floor_functions[4] = PyUFunc_O_O_method;
    floor_divide_functions[19] = PyUFunc_OO_O;
    floor_divide_data[19] = (void *) PyNumber_FloorDivide;
    fmax_functions[20] = PyUFunc_OO_O;
    fmax_data[20] = (void *) npy_ObjectMax;
    fmin_functions[20] = PyUFunc_OO_O;
    fmin_data[20] = (void *) npy_ObjectMin;
    fmod_functions[10] = PyUFunc_ee_e_As_ff_f;
    fmod_data[10] = (void *) npy_fmodf;
    fmod_functions[11] = PyUFunc_ff_f;
    fmod_data[11] = (void *) npy_fmodf;
    fmod_functions[12] = PyUFunc_dd_d;
    fmod_data[12] = (void *) npy_fmod;
    fmod_functions[13] = PyUFunc_gg_g;
    fmod_data[13] = (void *) npy_fmodl;
    fmod_functions[14] = PyUFunc_OO_O_method;
    hypot_functions[0] = PyUFunc_ee_e_As_ff_f;
    hypot_data[0] = (void *) npy_hypotf;
    hypot_functions[1] = PyUFunc_ff_f;
    hypot_data[1] = (void *) npy_hypotf;
    hypot_functions[2] = PyUFunc_dd_d;
    hypot_data[2] = (void *) npy_hypot;
    hypot_functions[3] = PyUFunc_gg_g;
    hypot_data[3] = (void *) npy_hypotl;
    hypot_functions[4] = PyUFunc_OO_O_method;
    invert_functions[11] = PyUFunc_O_O;
    invert_data[11] = (void *) PyNumber_Invert;
    left_shift_functions[10] = PyUFunc_OO_O;
    left_shift_data[10] = (void *) PyNumber_Lshift;
    log_functions[0] = PyUFunc_e_e_As_f_f;
    log_data[0] = (void *) npy_logf;
    log_functions[1] = PyUFunc_f_f;
    log_data[1] = (void *) npy_logf;
    log_functions[2] = PyUFunc_d_d;
    log_data[2] = (void *) npy_log;
    log_functions[3] = PyUFunc_g_g;
    log_data[3] = (void *) npy_logl;
    log_functions[4] = PyUFunc_F_F;
    log_data[4] = (void *) nc_logf;
    log_functions[5] = PyUFunc_D_D;
    log_data[5] = (void *) nc_log;
    log_functions[6] = PyUFunc_G_G;
    log_data[6] = (void *) nc_logl;
    log_functions[7] = PyUFunc_O_O_method;
    log10_functions[0] = PyUFunc_e_e_As_f_f;
    log10_data[0] = (void *) npy_log10f;
    log10_functions[1] = PyUFunc_f_f;
    log10_data[1] = (void *) npy_log10f;
    log10_functions[2] = PyUFunc_d_d;
    log10_data[2] = (void *) npy_log10;
    log10_functions[3] = PyUFunc_g_g;
    log10_data[3] = (void *) npy_log10l;
    log10_functions[4] = PyUFunc_F_F;
    log10_data[4] = (void *) nc_log10f;
    log10_functions[5] = PyUFunc_D_D;
    log10_data[5] = (void *) nc_log10;
    log10_functions[6] = PyUFunc_G_G;
    log10_data[6] = (void *) nc_log10l;
    log10_functions[7] = PyUFunc_O_O_method;
    log1p_functions[0] = PyUFunc_e_e_As_f_f;
    log1p_data[0] = (void *) npy_log1pf;
    log1p_functions[1] = PyUFunc_f_f;
    log1p_data[1] = (void *) npy_log1pf;
    log1p_functions[2] = PyUFunc_d_d;
    log1p_data[2] = (void *) npy_log1p;
    log1p_functions[3] = PyUFunc_g_g;
    log1p_data[3] = (void *) npy_log1pl;
    log1p_functions[4] = PyUFunc_F_F;
    log1p_data[4] = (void *) nc_log1pf;
    log1p_functions[5] = PyUFunc_D_D;
    log1p_data[5] = (void *) nc_log1p;
    log1p_functions[6] = PyUFunc_G_G;
    log1p_data[6] = (void *) nc_log1pl;
    log1p_functions[7] = PyUFunc_O_O_method;
    log2_functions[0] = PyUFunc_e_e_As_f_f;
    log2_data[0] = (void *) npy_log2f;
    log2_functions[1] = PyUFunc_f_f;
    log2_data[1] = (void *) npy_log2f;
    log2_functions[2] = PyUFunc_d_d;
    log2_data[2] = (void *) npy_log2;
    log2_functions[3] = PyUFunc_g_g;
    log2_data[3] = (void *) npy_log2l;
    log2_functions[4] = PyUFunc_F_F;
    log2_data[4] = (void *) nc_log2f;
    log2_functions[5] = PyUFunc_D_D;
    log2_data[5] = (void *) nc_log2;
    log2_functions[6] = PyUFunc_G_G;
    log2_data[6] = (void *) nc_log2l;
    log2_functions[7] = PyUFunc_O_O_method;
    logaddexp_functions[0] = PyUFunc_ee_e_As_ff_f;
    logaddexp_data[0] = (void *) npy_logaddexpf;
    logaddexp_functions[1] = PyUFunc_ff_f;
    logaddexp_data[1] = (void *) npy_logaddexpf;
    logaddexp_functions[2] = PyUFunc_dd_d;
    logaddexp_data[2] = (void *) npy_logaddexp;
    logaddexp_functions[3] = PyUFunc_gg_g;
    logaddexp_data[3] = (void *) npy_logaddexpl;
    logaddexp2_functions[0] = PyUFunc_ee_e_As_ff_f;
    logaddexp2_data[0] = (void *) npy_logaddexp2f;
    logaddexp2_functions[1] = PyUFunc_ff_f;
    logaddexp2_data[1] = (void *) npy_logaddexp2f;
    logaddexp2_functions[2] = PyUFunc_dd_d;
    logaddexp2_data[2] = (void *) npy_logaddexp2;
    logaddexp2_functions[3] = PyUFunc_gg_g;
    logaddexp2_data[3] = (void *) npy_logaddexp2l;
    logical_and_functions[18] = PyUFunc_OO_O;
    logical_and_data[18] = (void *) npy_ObjectLogicalAnd;
    logical_not_functions[18] = PyUFunc_O_O;
    logical_not_data[18] = (void *) npy_ObjectLogicalNot;
    logical_or_functions[18] = PyUFunc_OO_O;
    logical_or_data[18] = (void *) npy_ObjectLogicalOr;
    logical_xor_functions[18] = PyUFunc_OO_O_method;
    maximum_functions[20] = PyUFunc_OO_O;
    maximum_data[20] = (void *) npy_ObjectMax;
    minimum_functions[20] = PyUFunc_OO_O;
    minimum_data[20] = (void *) npy_ObjectMin;
    multiply_functions[22] = PyUFunc_OO_O;
    multiply_data[22] = (void *) PyNumber_Multiply;
    negative_functions[16] = PyUFunc_F_F;
    negative_data[16] = (void *) nc_negf;
    negative_functions[17] = PyUFunc_D_D;
    negative_data[17] = (void *) nc_neg;
    negative_functions[18] = PyUFunc_G_G;
    negative_data[18] = (void *) nc_negl;
    negative_functions[19] = PyUFunc_O_O;
    negative_data[19] = (void *) PyNumber_Negative;
    power_functions[10] = PyUFunc_ee_e_As_ff_f;
    power_data[10] = (void *) npy_powf;
    power_functions[11] = PyUFunc_ff_f;
    power_data[11] = (void *) npy_powf;
    power_functions[12] = PyUFunc_dd_d;
    power_data[12] = (void *) npy_pow;
    power_functions[13] = PyUFunc_gg_g;
    power_data[13] = (void *) npy_powl;
    power_functions[14] = PyUFunc_FF_F;
    power_data[14] = (void *) nc_powf;
    power_functions[15] = PyUFunc_DD_D;
    power_data[15] = (void *) nc_pow;
    power_functions[16] = PyUFunc_GG_G;
    power_data[16] = (void *) nc_powl;
    power_functions[17] = PyUFunc_OO_O;
    power_data[17] = (void *) npy_ObjectPower;
    rad2deg_functions[0] = PyUFunc_e_e_As_f_f;
    rad2deg_data[0] = (void *) npy_rad2degf;
    rad2deg_functions[1] = PyUFunc_f_f;
    rad2deg_data[1] = (void *) npy_rad2degf;
    rad2deg_functions[2] = PyUFunc_d_d;
    rad2deg_data[2] = (void *) npy_rad2deg;
    rad2deg_functions[3] = PyUFunc_g_g;
    rad2deg_data[3] = (void *) npy_rad2degl;
    rad2deg_functions[4] = PyUFunc_O_O_method;
    radians_functions[0] = PyUFunc_e_e_As_f_f;
    radians_data[0] = (void *) npy_radiansf;
    radians_functions[1] = PyUFunc_f_f;
    radians_data[1] = (void *) npy_radiansf;
    radians_functions[2] = PyUFunc_d_d;
    radians_data[2] = (void *) npy_radians;
    radians_functions[3] = PyUFunc_g_g;
    radians_data[3] = (void *) npy_radiansl;
    radians_functions[4] = PyUFunc_O_O_method;
    reciprocal_functions[17] = PyUFunc_O_O;
    reciprocal_data[17] = (void *) Py_reciprocal;
    remainder_functions[14] = PyUFunc_OO_O;
    remainder_data[14] = (void *) PyNumber_Remainder;
    right_shift_functions[10] = PyUFunc_OO_O;
    right_shift_data[10] = (void *) PyNumber_Rshift;
    rint_functions[0] = PyUFunc_e_e_As_f_f;
    rint_data[0] = (void *) npy_rintf;
    rint_functions[1] = PyUFunc_f_f;
    rint_data[1] = (void *) npy_rintf;
    rint_functions[2] = PyUFunc_d_d;
    rint_data[2] = (void *) npy_rint;
    rint_functions[3] = PyUFunc_g_g;
    rint_data[3] = (void *) npy_rintl;
    rint_functions[4] = PyUFunc_F_F;
    rint_data[4] = (void *) nc_rintf;
    rint_functions[5] = PyUFunc_D_D;
    rint_data[5] = (void *) nc_rint;
    rint_functions[6] = PyUFunc_G_G;
    rint_data[6] = (void *) nc_rintl;
    rint_functions[7] = PyUFunc_O_O_method;
    sin_functions[0] = PyUFunc_e_e_As_f_f;
    sin_data[0] = (void *) npy_sinf;
    sin_functions[1] = PyUFunc_f_f;
    sin_data[1] = (void *) npy_sinf;
    sin_functions[2] = PyUFunc_d_d;
    sin_data[2] = (void *) npy_sin;
    sin_functions[3] = PyUFunc_g_g;
    sin_data[3] = (void *) npy_sinl;
    sin_functions[4] = PyUFunc_F_F;
    sin_data[4] = (void *) nc_sinf;
    sin_functions[5] = PyUFunc_D_D;
    sin_data[5] = (void *) nc_sin;
    sin_functions[6] = PyUFunc_G_G;
    sin_data[6] = (void *) nc_sinl;
    sin_functions[7] = PyUFunc_O_O_method;
    sinh_functions[0] = PyUFunc_e_e_As_f_f;
    sinh_data[0] = (void *) npy_sinhf;
    sinh_functions[1] = PyUFunc_f_f;
    sinh_data[1] = (void *) npy_sinhf;
    sinh_functions[2] = PyUFunc_d_d;
    sinh_data[2] = (void *) npy_sinh;
    sinh_functions[3] = PyUFunc_g_g;
    sinh_data[3] = (void *) npy_sinhl;
    sinh_functions[4] = PyUFunc_F_F;
    sinh_data[4] = (void *) nc_sinhf;
    sinh_functions[5] = PyUFunc_D_D;
    sinh_data[5] = (void *) nc_sinh;
    sinh_functions[6] = PyUFunc_G_G;
    sinh_data[6] = (void *) nc_sinhl;
    sinh_functions[7] = PyUFunc_O_O_method;
    sqrt_functions[2] = PyUFunc_e_e_As_f_f;
    sqrt_data[2] = (void *) npy_sqrtf;
    sqrt_functions[3] = PyUFunc_f_f;
    sqrt_data[3] = (void *) npy_sqrtf;
    sqrt_functions[4] = PyUFunc_d_d;
    sqrt_data[4] = (void *) npy_sqrt;
    sqrt_functions[5] = PyUFunc_g_g;
    sqrt_data[5] = (void *) npy_sqrtl;
    sqrt_functions[6] = PyUFunc_F_F;
    sqrt_data[6] = (void *) nc_sqrtf;
    sqrt_functions[7] = PyUFunc_D_D;
    sqrt_data[7] = (void *) nc_sqrt;
    sqrt_functions[8] = PyUFunc_G_G;
    sqrt_data[8] = (void *) nc_sqrtl;
    sqrt_functions[9] = PyUFunc_O_O_method;
    square_functions[17] = PyUFunc_O_O;
    square_data[17] = (void *) Py_square;
    subtract_functions[21] = PyUFunc_OO_O;
    subtract_data[21] = (void *) PyNumber_Subtract;
    tan_functions[0] = PyUFunc_e_e_As_f_f;
    tan_data[0] = (void *) npy_tanf;
    tan_functions[1] = PyUFunc_f_f;
    tan_data[1] = (void *) npy_tanf;
    tan_functions[2] = PyUFunc_d_d;
    tan_data[2] = (void *) npy_tan;
    tan_functions[3] = PyUFunc_g_g;
    tan_data[3] = (void *) npy_tanl;
    tan_functions[4] = PyUFunc_F_F;
    tan_data[4] = (void *) nc_tanf;
    tan_functions[5] = PyUFunc_D_D;
    tan_data[5] = (void *) nc_tan;
    tan_functions[6] = PyUFunc_G_G;
    tan_data[6] = (void *) nc_tanl;
    tan_functions[7] = PyUFunc_O_O_method;
    tanh_functions[0] = PyUFunc_e_e_As_f_f;
    tanh_data[0] = (void *) npy_tanhf;
    tanh_functions[1] = PyUFunc_f_f;
    tanh_data[1] = (void *) npy_tanhf;
    tanh_functions[2] = PyUFunc_d_d;
    tanh_data[2] = (void *) npy_tanh;
    tanh_functions[3] = PyUFunc_g_g;
    tanh_data[3] = (void *) npy_tanhl;
    tanh_functions[4] = PyUFunc_F_F;
    tanh_data[4] = (void *) nc_tanhf;
    tanh_functions[5] = PyUFunc_D_D;
    tanh_data[5] = (void *) nc_tanh;
    tanh_functions[6] = PyUFunc_G_G;
    tanh_data[6] = (void *) nc_tanhl;
    tanh_functions[7] = PyUFunc_O_O_method;
    true_divide_functions[20] = PyUFunc_OO_O;
    true_divide_data[20] = (void *) PyNumber_TrueDivide;
    trunc_functions[0] = PyUFunc_e_e_As_f_f;
    trunc_data[0] = (void *) npy_truncf;
    trunc_functions[1] = PyUFunc_f_f;
    trunc_data[1] = (void *) npy_truncf;
    trunc_functions[2] = PyUFunc_d_d;
    trunc_data[2] = (void *) npy_trunc;
    trunc_functions[3] = PyUFunc_g_g;
    trunc_data[3] = (void *) npy_truncl;
    trunc_functions[4] = PyUFunc_O_O_method;
    f = PyUFunc_FromFuncAndData(_arg_functions, _arg_data, _arg_signatures, 3,
                                    1, 1, PyUFunc_None, "_arg",
                                    "DO NOT USE, ONLY FOR TESTING", 0);
    PyDict_SetItemString(dictionary, "_arg", f);
    Py_DECREF(f);
    f = PyUFunc_FromFuncAndData(_ones_like_functions, _ones_like_data, _ones_like_signatures, 21,
                                    1, 1, PyUFunc_None, "_ones_like",
                                    "This function used to be the numpy.ones_like, but now a specific\n""function for that has been written for consistency with the other\n""*_like functions. It is only used internally in a limited fashion now.\n""\n""See Also\n""--------\n""ones_like", 0);
    ((PyUFuncObject *)f)->type_resolver = &PyUFunc_OnesLikeTypeResolver;
    PyDict_SetItemString(dictionary, "_ones_like", f);
    Py_DECREF(f);
    f = PyUFunc_FromFuncAndData(absolute_functions, absolute_data, absolute_signatures, 20,
                                    1, 1, PyUFunc_None, "absolute",
                                    "Calculate the absolute value element-wise.\n""\n""Parameters\n""----------\n""x : array_like\n""    Input array.\n""\n""Returns\n""-------\n""absolute : ndarray\n""    An ndarray containing the absolute value of\n""    each element in `x`.  For complex input, ``a + ib``, the\n""    absolute value is :math:`\\sqrt{ a^2 + b^2 }`.\n""\n""Examples\n""--------\n"">>> x = np.array([-1.2, 1.2])\n"">>> np.absolute(x)\n""array([ 1.2,  1.2])\n"">>> np.absolute(1.2 + 1j)\n""1.5620499351813308\n""\n""Plot the function over ``[-10, 10]``:\n""\n"">>> import matplotlib.pyplot as plt\n""\n"">>> x = np.linspace(start=-10, stop=10, num=101)\n"">>> plt.plot(x, np.absolute(x))\n"">>> plt.show()\n""\n""Plot the function over the complex plane:\n""\n"">>> xx = x + 1j * x[:, np.newaxis]\n"">>> plt.imshow(np.abs(xx), extent=[-10, 10, -10, 10])\n"">>> plt.show()", 0);
    ((PyUFuncObject *)f)->type_resolver = &PyUFunc_AbsoluteTypeResolver;
    PyDict_SetItemString(dictionary, "absolute", f);
    Py_DECREF(f);
    f = PyUFunc_FromFuncAndData(add_functions, add_data, add_signatures, 22,
                                    2, 1, PyUFunc_Zero, "add",
                                    "Add arguments element-wise.\n""\n""Parameters\n""----------\n""x1, x2 : array_like\n""    The arrays to be added.  If ``x1.shape != x2.shape``, they must be\n""    broadcastable to a common shape (which may be the shape of one or\n""    the other).\n""\n""Returns\n""-------\n""add : ndarray or scalar\n""    The sum of `x1` and `x2`, element-wise.  Returns a scalar if\n""    both  `x1` and `x2` are scalars.\n""\n""Notes\n""-----\n""Equivalent to `x1` + `x2` in terms of array broadcasting.\n""\n""Examples\n""--------\n"">>> np.add(1.0, 4.0)\n""5.0\n"">>> x1 = np.arange(9.0).reshape((3, 3))\n"">>> x2 = np.arange(3.0)\n"">>> np.add(x1, x2)\n""array([[  0.,   2.,   4.],\n""       [  3.,   5.,   7.],\n""       [  6.,   8.,  10.]])", 0);
    ((PyUFuncObject *)f)->type_resolver = &PyUFunc_AdditionTypeResolver;
    PyDict_SetItemString(dictionary, "add", f);
    Py_DECREF(f);
    f = PyUFunc_FromFuncAndData(arccos_functions, arccos_data, arccos_signatures, 8,
                                    1, 1, PyUFunc_None, "arccos",
                                    "Trigonometric inverse cosine, element-wise.\n""\n""The inverse of `cos` so that, if ``y = cos(x)``, then ``x = arccos(y)``.\n""\n""Parameters\n""----------\n""x : array_like\n""    `x`-coordinate on the unit circle.\n""    For real arguments, the domain is [-1, 1].\n""\n""out : ndarray, optional\n""    Array of the same shape as `a`, to store results in. See\n""    `doc.ufuncs` (Section \"Output arguments\") for more details.\n""\n""Returns\n""-------\n""angle : ndarray\n""    The angle of the ray intersecting the unit circle at the given\n""    `x`-coordinate in radians [0, pi]. If `x` is a scalar then a\n""    scalar is returned, otherwise an array of the same shape as `x`\n""    is returned.\n""\n""See Also\n""--------\n""cos, arctan, arcsin, emath.arccos\n""\n""Notes\n""-----\n""`arccos` is a multivalued function: for each `x` there are infinitely\n""many numbers `z` such that `cos(z) = x`. The convention is to return\n""the angle `z` whose real part lies in `[0, pi]`.\n""\n""For real-valued input data types, `arccos` always returns real output.\n""For each value that cannot be expressed as a real number or infinity,\n""it yields ``nan`` and sets the `invalid` floating point error flag.\n""\n""For complex-valued input, `arccos` is a complex analytic function that\n""has branch cuts `[-inf, -1]` and `[1, inf]` and is continuous from\n""above on the former and from below on the latter.\n""\n""The inverse `cos` is also known as `acos` or cos^-1.\n""\n""References\n""----------\n""M. Abramowitz and I.A. Stegun, \"Handbook of Mathematical Functions\",\n""10th printing, 1964, pp. 79. http://www.math.sfu.ca/~cbm/aands/\n""\n""Examples\n""--------\n""We expect the arccos of 1 to be 0, and of -1 to be pi:\n""\n"">>> np.arccos([1, -1])\n""array([ 0.        ,  3.14159265])\n""\n""Plot arccos:\n""\n"">>> import matplotlib.pyplot as plt\n"">>> x = np.linspace(-1, 1, num=100)\n"">>> plt.plot(x, np.arccos(x))\n"">>> plt.axis(\'tight\')\n"">>> plt.show()", 0);
    PyDict_SetItemString(dictionary, "arccos", f);
    Py_DECREF(f);
    f = PyUFunc_FromFuncAndData(arccosh_functions, arccosh_data, arccosh_signatures, 8,
                                    1, 1, PyUFunc_None, "arccosh",
                                    "Inverse hyperbolic cosine, element-wise.\n""\n""Parameters\n""----------\n""x : array_like\n""    Input array.\n""out : ndarray, optional\n""    Array of the same shape as `x`, to store results in.\n""    See `doc.ufuncs` (Section \"Output arguments\") for details.\n""\n""\n""Returns\n""-------\n""arccosh : ndarray\n""    Array of the same shape as `x`.\n""\n""See Also\n""--------\n""\n""cosh, arcsinh, sinh, arctanh, tanh\n""\n""Notes\n""-----\n""`arccosh` is a multivalued function: for each `x` there are infinitely\n""many numbers `z` such that `cosh(z) = x`. The convention is to return the\n""`z` whose imaginary part lies in `[-pi, pi]` and the real part in\n""``[0, inf]``.\n""\n""For real-valued input data types, `arccosh` always returns real output.\n""For each value that cannot be expressed as a real number or infinity, it\n""yields ``nan`` and sets the `invalid` floating point error flag.\n""\n""For complex-valued input, `arccosh` is a complex analytical function that\n""has a branch cut `[-inf, 1]` and is continuous from above on it.\n""\n""References\n""----------\n"".. [1] M. Abramowitz and I.A. Stegun, \"Handbook of Mathematical Functions\",\n""       10th printing, 1964, pp. 86. http://www.math.sfu.ca/~cbm/aands/\n"".. [2] Wikipedia, \"Inverse hyperbolic function\",\n""       http://en.wikipedia.org/wiki/Arccosh\n""\n""Examples\n""--------\n"">>> np.arccosh([np.e, 10.0])\n""array([ 1.65745445,  2.99322285])\n"">>> np.arccosh(1)\n""0.0", 0);
    PyDict_SetItemString(dictionary, "arccosh", f);
    Py_DECREF(f);
    f = PyUFunc_FromFuncAndData(arcsin_functions, arcsin_data, arcsin_signatures, 8,
                                    1, 1, PyUFunc_None, "arcsin",
                                    "Inverse sine, element-wise.\n""\n""Parameters\n""----------\n""x : array_like\n""    `y`-coordinate on the unit circle.\n""\n""out : ndarray, optional\n""    Array of the same shape as `x`, in which to store the results.\n""    See `doc.ufuncs` (Section \"Output arguments\") for more details.\n""\n""Returns\n""-------\n""angle : ndarray\n""    The inverse sine of each element in `x`, in radians and in the\n""    closed interval ``[-pi/2, pi/2]``.  If `x` is a scalar, a scalar\n""    is returned, otherwise an array.\n""\n""See Also\n""--------\n""sin, cos, arccos, tan, arctan, arctan2, emath.arcsin\n""\n""Notes\n""-----\n""`arcsin` is a multivalued function: for each `x` there are infinitely\n""many numbers `z` such that :math:`sin(z) = x`.  The convention is to\n""return the angle `z` whose real part lies in [-pi/2, pi/2].\n""\n""For real-valued input data types, *arcsin* always returns real output.\n""For each value that cannot be expressed as a real number or infinity,\n""it yields ``nan`` and sets the `invalid` floating point error flag.\n""\n""For complex-valued input, `arcsin` is a complex analytic function that\n""has, by convention, the branch cuts [-inf, -1] and [1, inf]  and is\n""continuous from above on the former and from below on the latter.\n""\n""The inverse sine is also known as `asin` or sin^{-1}.\n""\n""References\n""----------\n""Abramowitz, M. and Stegun, I. A., *Handbook of Mathematical Functions*,\n""10th printing, New York: Dover, 1964, pp. 79ff.\n""http://www.math.sfu.ca/~cbm/aands/\n""\n""Examples\n""--------\n"">>> np.arcsin(1)     # pi/2\n""1.5707963267948966\n"">>> np.arcsin(-1)    # -pi/2\n""-1.5707963267948966\n"">>> np.arcsin(0)\n""0.0", 0);
    PyDict_SetItemString(dictionary, "arcsin", f);
    Py_DECREF(f);
    f = PyUFunc_FromFuncAndData(arcsinh_functions, arcsinh_data, arcsinh_signatures, 8,
                                    1, 1, PyUFunc_None, "arcsinh",
                                    "Inverse hyperbolic sine element-wise.\n""\n""Parameters\n""----------\n""x : array_like\n""    Input array.\n""out : ndarray, optional\n""    Array into which the output is placed. Its type is preserved and it\n""    must be of the right shape to hold the output. See `doc.ufuncs`.\n""\n""Returns\n""-------\n""out : ndarray\n""    Array of of the same shape as `x`.\n""\n""Notes\n""-----\n""`arcsinh` is a multivalued function: for each `x` there are infinitely\n""many numbers `z` such that `sinh(z) = x`. The convention is to return the\n""`z` whose imaginary part lies in `[-pi/2, pi/2]`.\n""\n""For real-valued input data types, `arcsinh` always returns real output.\n""For each value that cannot be expressed as a real number or infinity, it\n""returns ``nan`` and sets the `invalid` floating point error flag.\n""\n""For complex-valued input, `arccos` is a complex analytical function that\n""has branch cuts `[1j, infj]` and `[-1j, -infj]` and is continuous from\n""the right on the former and from the left on the latter.\n""\n""The inverse hyperbolic sine is also known as `asinh` or ``sinh^-1``.\n""\n""References\n""----------\n"".. [1] M. Abramowitz and I.A. Stegun, \"Handbook of Mathematical Functions\",\n""       10th printing, 1964, pp. 86. http://www.math.sfu.ca/~cbm/aands/\n"".. [2] Wikipedia, \"Inverse hyperbolic function\",\n""       http://en.wikipedia.org/wiki/Arcsinh\n""\n""Examples\n""--------\n"">>> np.arcsinh(np.array([np.e, 10.0]))\n""array([ 1.72538256,  2.99822295])", 0);
    PyDict_SetItemString(dictionary, "arcsinh", f);
    Py_DECREF(f);
    f = PyUFunc_FromFuncAndData(arctan_functions, arctan_data, arctan_signatures, 8,
                                    1, 1, PyUFunc_None, "arctan",
                                    "Trigonometric inverse tangent, element-wise.\n""\n""The inverse of tan, so that if ``y = tan(x)`` then ``x = arctan(y)``.\n""\n""Parameters\n""----------\n""x : array_like\n""    Input values.  `arctan` is applied to each element of `x`.\n""\n""Returns\n""-------\n""out : ndarray\n""    Out has the same shape as `x`.  Its real part is in\n""    ``[-pi/2, pi/2]`` (``arctan(+/-inf)`` returns ``+/-pi/2``).\n""    It is a scalar if `x` is a scalar.\n""\n""See Also\n""--------\n""arctan2 : The \"four quadrant\" arctan of the angle formed by (`x`, `y`)\n""    and the positive `x`-axis.\n""angle : Argument of complex values.\n""\n""Notes\n""-----\n""`arctan` is a multi-valued function: for each `x` there are infinitely\n""many numbers `z` such that tan(`z`) = `x`.  The convention is to return\n""the angle `z` whose real part lies in [-pi/2, pi/2].\n""\n""For real-valued input data types, `arctan` always returns real output.\n""For each value that cannot be expressed as a real number or infinity,\n""it yields ``nan`` and sets the `invalid` floating point error flag.\n""\n""For complex-valued input, `arctan` is a complex analytic function that\n""has [`1j, infj`] and [`-1j, -infj`] as branch cuts, and is continuous\n""from the left on the former and from the right on the latter.\n""\n""The inverse tangent is also known as `atan` or tan^{-1}.\n""\n""References\n""----------\n""Abramowitz, M. and Stegun, I. A., *Handbook of Mathematical Functions*,\n""10th printing, New York: Dover, 1964, pp. 79.\n""http://www.math.sfu.ca/~cbm/aands/\n""\n""Examples\n""--------\n""We expect the arctan of 0 to be 0, and of 1 to be pi/4:\n""\n"">>> np.arctan([0, 1])\n""array([ 0.        ,  0.78539816])\n""\n"">>> np.pi/4\n""0.78539816339744828\n""\n""Plot arctan:\n""\n"">>> import matplotlib.pyplot as plt\n"">>> x = np.linspace(-10, 10)\n"">>> plt.plot(x, np.arctan(x))\n"">>> plt.axis(\'tight\')\n"">>> plt.show()", 0);
    PyDict_SetItemString(dictionary, "arctan", f);
    Py_DECREF(f);
    f = PyUFunc_FromFuncAndData(arctan2_functions, arctan2_data, arctan2_signatures, 5,
                                    2, 1, PyUFunc_None, "arctan2",
                                    "Element-wise arc tangent of ``x1/x2`` choosing the quadrant correctly.\n""\n""The quadrant (i.e., branch) is chosen so that ``arctan2(x1, x2)`` is\n""the signed angle in radians between the ray ending at the origin and\n""passing through the point (1,0), and the ray ending at the origin and\n""passing through the point (`x2`, `x1`).  (Note the role reversal: the\n""\"`y`-coordinate\" is the first function parameter, the \"`x`-coordinate\"\n""is the second.)  By IEEE convention, this function is defined for\n""`x2` = +/-0 and for either or both of `x1` and `x2` = +/-inf (see\n""Notes for specific values).\n""\n""This function is not defined for complex-valued arguments; for the\n""so-called argument of complex values, use `angle`.\n""\n""Parameters\n""----------\n""x1 : array_like, real-valued\n""    `y`-coordinates.\n""x2 : array_like, real-valued\n""    `x`-coordinates. `x2` must be broadcastable to match the shape of\n""    `x1` or vice versa.\n""\n""Returns\n""-------\n""angle : ndarray\n""    Array of angles in radians, in the range ``[-pi, pi]``.\n""\n""See Also\n""--------\n""arctan, tan, angle\n""\n""Notes\n""-----\n""*arctan2* is identical to the `atan2` function of the underlying\n""C library.  The following special values are defined in the C\n""standard: [1]_\n""\n""====== ====== ================\n""`x1`   `x2`   `arctan2(x1,x2)`\n""====== ====== ================\n""+/- 0  +0     +/- 0\n""+/- 0  -0     +/- pi\n"" > 0   +/-inf +0 / +pi\n"" < 0   +/-inf -0 / -pi\n""+/-inf +inf   +/- (pi/4)\n""+/-inf -inf   +/- (3*pi/4)\n""====== ====== ================\n""\n""Note that +0 and -0 are distinct floating point numbers, as are +inf\n""and -inf.\n""\n""References\n""----------\n"".. [1] ISO/IEC standard 9899:1999, \"Programming language C.\"\n""\n""Examples\n""--------\n""Consider four points in different quadrants:\n""\n"">>> x = np.array([-1, +1, +1, -1])\n"">>> y = np.array([-1, -1, +1, +1])\n"">>> np.arctan2(y, x) * 180 / np.pi\n""array([-135.,  -45.,   45.,  135.])\n""\n""Note the order of the parameters. `arctan2` is defined also when `x2` = 0\n""and at several other special points, obtaining values in\n""the range ``[-pi, pi]``:\n""\n"">>> np.arctan2([1., -1.], [0., 0.])\n""array([ 1.57079633, -1.57079633])\n"">>> np.arctan2([0., 0., np.inf], [+0., -0., np.inf])\n""array([ 0.        ,  3.14159265,  0.78539816])", 0);
    PyDict_SetItemString(dictionary, "arctan2", f);
    Py_DECREF(f);
    f = PyUFunc_FromFuncAndData(arctanh_functions, arctanh_data, arctanh_signatures, 8,
                                    1, 1, PyUFunc_None, "arctanh",
                                    "Inverse hyperbolic tangent element-wise.\n""\n""Parameters\n""----------\n""x : array_like\n""    Input array.\n""\n""Returns\n""-------\n""out : ndarray\n""    Array of the same shape as `x`.\n""\n""See Also\n""--------\n""emath.arctanh\n""\n""Notes\n""-----\n""`arctanh` is a multivalued function: for each `x` there are infinitely\n""many numbers `z` such that `tanh(z) = x`. The convention is to return\n""the `z` whose imaginary part lies in `[-pi/2, pi/2]`.\n""\n""For real-valued input data types, `arctanh` always returns real output.\n""For each value that cannot be expressed as a real number or infinity,\n""it yields ``nan`` and sets the `invalid` floating point error flag.\n""\n""For complex-valued input, `arctanh` is a complex analytical function\n""that has branch cuts `[-1, -inf]` and `[1, inf]` and is continuous from\n""above on the former and from below on the latter.\n""\n""The inverse hyperbolic tangent is also known as `atanh` or ``tanh^-1``.\n""\n""References\n""----------\n"".. [1] M. Abramowitz and I.A. Stegun, \"Handbook of Mathematical Functions\",\n""       10th printing, 1964, pp. 86. http://www.math.sfu.ca/~cbm/aands/\n"".. [2] Wikipedia, \"Inverse hyperbolic function\",\n""       http://en.wikipedia.org/wiki/Arctanh\n""\n""Examples\n""--------\n"">>> np.arctanh([0, -0.5])\n""array([ 0.        , -0.54930614])", 0);
    PyDict_SetItemString(dictionary, "arctanh", f);
    Py_DECREF(f);
    f = PyUFunc_FromFuncAndData(bitwise_and_functions, bitwise_and_data, bitwise_and_signatures, 12,
                                    2, 1, PyUFunc_One, "bitwise_and",
                                    "Compute the bit-wise AND of two arrays element-wise.\n""\n""Computes the bit-wise AND of the underlying binary representation of\n""the integers in the input arrays. This ufunc implements the C/Python\n""operator ``&``.\n""\n""Parameters\n""----------\n""x1, x2 : array_like\n""    Only integer and boolean types are handled.\n""\n""Returns\n""-------\n""out : array_like\n""    Result.\n""\n""See Also\n""--------\n""logical_and\n""bitwise_or\n""bitwise_xor\n""binary_repr :\n""    Return the binary representation of the input number as a string.\n""\n""Examples\n""--------\n""The number 13 is represented by ``00001101``.  Likewise, 17 is\n""represented by ``00010001``.  The bit-wise AND of 13 and 17 is\n""therefore ``000000001``, or 1:\n""\n"">>> np.bitwise_and(13, 17)\n""1\n""\n"">>> np.bitwise_and(14, 13)\n""12\n"">>> np.binary_repr(12)\n""\'1100\'\n"">>> np.bitwise_and([14,3], 13)\n""array([12,  1])\n""\n"">>> np.bitwise_and([11,7], [4,25])\n""array([0, 1])\n"">>> np.bitwise_and(np.array([2,5,255]), np.array([3,14,16]))\n""array([ 2,  4, 16])\n"">>> np.bitwise_and([True, True], [False, True])\n""array([False,  True], dtype=bool)", 0);
    PyDict_SetItemString(dictionary, "bitwise_and", f);
    Py_DECREF(f);
    f = PyUFunc_FromFuncAndData(bitwise_or_functions, bitwise_or_data, bitwise_or_signatures, 12,
                                    2, 1, PyUFunc_Zero, "bitwise_or",
                                    "Compute the bit-wise OR of two arrays element-wise.\n""\n""Computes the bit-wise OR of the underlying binary representation of\n""the integers in the input arrays. This ufunc implements the C/Python\n""operator ``|``.\n""\n""Parameters\n""----------\n""x1, x2 : array_like\n""    Only integer and boolean types are handled.\n""out : ndarray, optional\n""    Array into which the output is placed. Its type is preserved and it\n""    must be of the right shape to hold the output. See doc.ufuncs.\n""\n""Returns\n""-------\n""out : array_like\n""    Result.\n""\n""See Also\n""--------\n""logical_or\n""bitwise_and\n""bitwise_xor\n""binary_repr :\n""    Return the binary representation of the input number as a string.\n""\n""Examples\n""--------\n""The number 13 has the binaray representation ``00001101``. Likewise,\n""16 is represented by ``00010000``.  The bit-wise OR of 13 and 16 is\n""then ``000111011``, or 29:\n""\n"">>> np.bitwise_or(13, 16)\n""29\n"">>> np.binary_repr(29)\n""\'11101\'\n""\n"">>> np.bitwise_or(32, 2)\n""34\n"">>> np.bitwise_or([33, 4], 1)\n""array([33,  5])\n"">>> np.bitwise_or([33, 4], [1, 2])\n""array([33,  6])\n""\n"">>> np.bitwise_or(np.array([2, 5, 255]), np.array([4, 4, 4]))\n""array([  6,   5, 255])\n"">>> np.array([2, 5, 255]) | np.array([4, 4, 4])\n""array([  6,   5, 255])\n"">>> np.bitwise_or(np.array([2, 5, 255, 2147483647L], dtype=np.int32),\n""...               np.array([4, 4, 4, 2147483647L], dtype=np.int32))\n""array([         6,          5,        255, 2147483647])\n"">>> np.bitwise_or([True, True], [False, True])\n""array([ True,  True], dtype=bool)", 0);
    PyDict_SetItemString(dictionary, "bitwise_or", f);
    Py_DECREF(f);
    f = PyUFunc_FromFuncAndData(bitwise_xor_functions, bitwise_xor_data, bitwise_xor_signatures, 12,
                                    2, 1, PyUFunc_None, "bitwise_xor",
                                    "Compute the bit-wise XOR of two arrays element-wise.\n""\n""Computes the bit-wise XOR of the underlying binary representation of\n""the integers in the input arrays. This ufunc implements the C/Python\n""operator ``^``.\n""\n""Parameters\n""----------\n""x1, x2 : array_like\n""    Only integer and boolean types are handled.\n""\n""Returns\n""-------\n""out : array_like\n""    Result.\n""\n""See Also\n""--------\n""logical_xor\n""bitwise_and\n""bitwise_or\n""binary_repr :\n""    Return the binary representation of the input number as a string.\n""\n""Examples\n""--------\n""The number 13 is represented by ``00001101``. Likewise, 17 is\n""represented by ``00010001``.  The bit-wise XOR of 13 and 17 is\n""therefore ``00011100``, or 28:\n""\n"">>> np.bitwise_xor(13, 17)\n""28\n"">>> np.binary_repr(28)\n""\'11100\'\n""\n"">>> np.bitwise_xor(31, 5)\n""26\n"">>> np.bitwise_xor([31,3], 5)\n""array([26,  6])\n""\n"">>> np.bitwise_xor([31,3], [5,6])\n""array([26,  5])\n"">>> np.bitwise_xor([True, True], [False, True])\n""array([ True, False], dtype=bool)", 0);
    PyDict_SetItemString(dictionary, "bitwise_xor", f);
    Py_DECREF(f);
    f = PyUFunc_FromFuncAndData(cbrt_functions, cbrt_data, cbrt_signatures, 5,
                                    1, 1, PyUFunc_None, "cbrt",
                                    "Return the cube-root of an array, element-wise.\n""\n"".. versionadded:: 1.10.0\n""\n""Parameters\n""----------\n""x : array_like\n""    The values whose cube-roots are required.\n""out : ndarray, optional\n""    Alternate array object in which to put the result; if provided, it\n""    must have the same shape as `x`\n""\n""Returns\n""-------\n""y : ndarray\n""    An array of the same shape as `x`, containing the cube\n""    cube-root of each element in `x`.\n""    If `out` was provided, `y` is a reference to it.\n""\n""\n""Examples\n""--------\n"">>> np.cbrt([1,8,27])\n""array([ 1.,  2.,  3.])", 0);
    PyDict_SetItemString(dictionary, "cbrt", f);
    Py_DECREF(f);
    f = PyUFunc_FromFuncAndData(ceil_functions, ceil_data, ceil_signatures, 5,
                                    1, 1, PyUFunc_None, "ceil",
                                    "Return the ceiling of the input, element-wise.\n""\n""The ceil of the scalar `x` is the smallest integer `i`, such that\n""`i >= x`.  It is often denoted as :math:`\\lceil x \\rceil`.\n""\n""Parameters\n""----------\n""x : array_like\n""    Input data.\n""\n""Returns\n""-------\n""y : ndarray or scalar\n""    The ceiling of each element in `x`, with `float` dtype.\n""\n""See Also\n""--------\n""floor, trunc, rint\n""\n""Examples\n""--------\n"">>> a = np.array([-1.7, -1.5, -0.2, 0.2, 1.5, 1.7, 2.0])\n"">>> np.ceil(a)\n""array([-1., -1., -0.,  1.,  2.,  2.,  2.])", 0);
    PyDict_SetItemString(dictionary, "ceil", f);
    Py_DECREF(f);
    f = PyUFunc_FromFuncAndData(conjugate_functions, conjugate_data, conjugate_signatures, 18,
                                    1, 1, PyUFunc_None, "conjugate",
                                    "Return the complex conjugate, element-wise.\n""\n""The complex conjugate of a complex number is obtained by changing the\n""sign of its imaginary part.\n""\n""Parameters\n""----------\n""x : array_like\n""    Input value.\n""\n""Returns\n""-------\n""y : ndarray\n""    The complex conjugate of `x`, with same dtype as `y`.\n""\n""Examples\n""--------\n"">>> np.conjugate(1+2j)\n""(1-2j)\n""\n"">>> x = np.eye(2) + 1j * np.eye(2)\n"">>> np.conjugate(x)\n""array([[ 1.-1.j,  0.-0.j],\n""       [ 0.-0.j,  1.-1.j]])", 0);
    PyDict_SetItemString(dictionary, "conjugate", f);
    Py_DECREF(f);
    f = PyUFunc_FromFuncAndData(copysign_functions, copysign_data, copysign_signatures, 4,
                                    2, 1, PyUFunc_None, "copysign",
                                    "Change the sign of x1 to that of x2, element-wise.\n""\n""If both arguments are arrays or sequences, they have to be of the same\n""length. If `x2` is a scalar, its sign will be copied to all elements of\n""`x1`.\n""\n""Parameters\n""----------\n""x1 : array_like\n""    Values to change the sign of.\n""x2 : array_like\n""    The sign of `x2` is copied to `x1`.\n""out : ndarray, optional\n""    Array into which the output is placed. Its type is preserved and it\n""    must be of the right shape to hold the output. See doc.ufuncs.\n""\n""Returns\n""-------\n""out : array_like\n""    The values of `x1` with the sign of `x2`.\n""\n""Examples\n""--------\n"">>> np.copysign(1.3, -1)\n""-1.3\n"">>> 1/np.copysign(0, 1)\n""inf\n"">>> 1/np.copysign(0, -1)\n""-inf\n""\n"">>> np.copysign([-1, 0, 1], -1.1)\n""array([-1., -0., -1.])\n"">>> np.copysign([-1, 0, 1], np.arange(3)-1)\n""array([-1.,  0.,  1.])", 0);
    PyDict_SetItemString(dictionary, "copysign", f);
    Py_DECREF(f);
    f = PyUFunc_FromFuncAndData(cos_functions, cos_data, cos_signatures, 8,
                                    1, 1, PyUFunc_None, "cos",
                                    "Cosine element-wise.\n""\n""Parameters\n""----------\n""x : array_like\n""    Input array in radians.\n""out : ndarray, optional\n""    Output array of same shape as `x`.\n""\n""Returns\n""-------\n""y : ndarray\n""    The corresponding cosine values.\n""\n""Raises\n""------\n""ValueError: invalid return array shape\n""    if `out` is provided and `out.shape` != `x.shape` (See Examples)\n""\n""Notes\n""-----\n""If `out` is provided, the function writes the result into it,\n""and returns a reference to `out`.  (See Examples)\n""\n""References\n""----------\n""M. Abramowitz and I. A. Stegun, Handbook of Mathematical Functions.\n""New York, NY: Dover, 1972.\n""\n""Examples\n""--------\n"">>> np.cos(np.array([0, np.pi/2, np.pi]))\n""array([  1.00000000e+00,   6.12303177e-17,  -1.00000000e+00])\n"">>>\n"">>> # Example of providing the optional output parameter\n"">>> out2 = np.cos([0.1], out1)\n"">>> out2 is out1\n""True\n"">>>\n"">>> # Example of ValueError due to provision of shape mis-matched `out`\n"">>> np.cos(np.zeros((3,3)),np.zeros((2,2)))\n""Traceback (most recent call last):\n""  File \"<stdin>\", line 1, in <module>\n""ValueError: invalid return array shape", 0);
    PyDict_SetItemString(dictionary, "cos", f);
    Py_DECREF(f);
    f = PyUFunc_FromFuncAndData(cosh_functions, cosh_data, cosh_signatures, 8,
                                    1, 1, PyUFunc_None, "cosh",
                                    "Hyperbolic cosine, element-wise.\n""\n""Equivalent to ``1/2 * (np.exp(x) + np.exp(-x))`` and ``np.cos(1j*x)``.\n""\n""Parameters\n""----------\n""x : array_like\n""    Input array.\n""\n""Returns\n""-------\n""out : ndarray\n""    Output array of same shape as `x`.\n""\n""Examples\n""--------\n"">>> np.cosh(0)\n""1.0\n""\n""The hyperbolic cosine describes the shape of a hanging cable:\n""\n"">>> import matplotlib.pyplot as plt\n"">>> x = np.linspace(-4, 4, 1000)\n"">>> plt.plot(x, np.cosh(x))\n"">>> plt.show()", 0);
    PyDict_SetItemString(dictionary, "cosh", f);
    Py_DECREF(f);
    f = PyUFunc_FromFuncAndData(deg2rad_functions, deg2rad_data, deg2rad_signatures, 5,
                                    1, 1, PyUFunc_None, "deg2rad",
                                    "Convert angles from degrees to radians.\n""\n""Parameters\n""----------\n""x : array_like\n""    Angles in degrees.\n""\n""Returns\n""-------\n""y : ndarray\n""    The corresponding angle in radians.\n""\n""See Also\n""--------\n""rad2deg : Convert angles from radians to degrees.\n""unwrap : Remove large jumps in angle by wrapping.\n""\n""Notes\n""-----\n"".. versionadded:: 1.3.0\n""\n""``deg2rad(x)`` is ``x * pi / 180``.\n""\n""Examples\n""--------\n"">>> np.deg2rad(180)\n""3.1415926535897931", 0);
    PyDict_SetItemString(dictionary, "deg2rad", f);
    Py_DECREF(f);
    f = PyUFunc_FromFuncAndData(degrees_functions, degrees_data, degrees_signatures, 5,
                                    1, 1, PyUFunc_None, "degrees",
                                    "Convert angles from radians to degrees.\n""\n""Parameters\n""----------\n""x : array_like\n""    Input array in radians.\n""out : ndarray, optional\n""    Output array of same shape as x.\n""\n""Returns\n""-------\n""y : ndarray of floats\n""    The corresponding degree values; if `out` was supplied this is a\n""    reference to it.\n""\n""See Also\n""--------\n""rad2deg : equivalent function\n""\n""Examples\n""--------\n""Convert a radian array to degrees\n""\n"">>> rad = np.arange(12.)*np.pi/6\n"">>> np.degrees(rad)\n""array([   0.,   30.,   60.,   90.,  120.,  150.,  180.,  210.,  240.,\n""        270.,  300.,  330.])\n""\n"">>> out = np.zeros((rad.shape))\n"">>> r = degrees(rad, out)\n"">>> np.all(r == out)\n""True", 0);
    PyDict_SetItemString(dictionary, "degrees", f);
    Py_DECREF(f);
    f = PyUFunc_FromFuncAndData(divide_functions, divide_data, divide_signatures, 21,
                                    2, 1, PyUFunc_None, "divide",
                                    "Divide arguments element-wise.\n""\n""Parameters\n""----------\n""x1 : array_like\n""    Dividend array.\n""x2 : array_like\n""    Divisor array.\n""out : ndarray, optional\n""    Array into which the output is placed. Its type is preserved and it\n""    must be of the right shape to hold the output. See doc.ufuncs.\n""\n""Returns\n""-------\n""y : ndarray or scalar\n""    The quotient ``x1/x2``, element-wise. Returns a scalar if\n""    both ``x1`` and ``x2`` are scalars.\n""\n""See Also\n""--------\n""seterr : Set whether to raise or warn on overflow, underflow and\n""         division by zero.\n""\n""Notes\n""-----\n""Equivalent to ``x1`` / ``x2`` in terms of array-broadcasting.\n""\n""Behavior on division by zero can be changed using ``seterr``.\n""\n""In Python 2, when both ``x1`` and ``x2`` are of an integer type,\n""``divide`` will behave like ``floor_divide``. In Python 3, it behaves\n""like ``true_divide``.\n""\n""Examples\n""--------\n"">>> np.divide(2.0, 4.0)\n""0.5\n"">>> x1 = np.arange(9.0).reshape((3, 3))\n"">>> x2 = np.arange(3.0)\n"">>> np.divide(x1, x2)\n""array([[ NaN,  1. ,  1. ],\n""       [ Inf,  4. ,  2.5],\n""       [ Inf,  7. ,  4. ]])\n""\n""Note the behavior with integer types (Python 2 only):\n""\n"">>> np.divide(2, 4)\n""0\n"">>> np.divide(2, 4.)\n""0.5\n""\n""Division by zero always yields zero in integer arithmetic (again,\n""Python 2 only), and does not raise an exception or a warning:\n""\n"">>> np.divide(np.array([0, 1], dtype=int), np.array([0, 0], dtype=int))\n""array([0, 0])\n""\n""Division by zero can, however, be caught using ``seterr``:\n""\n"">>> old_err_state = np.seterr(divide=\'raise\')\n"">>> np.divide(1, 0)\n""Traceback (most recent call last):\n""  File \"<stdin>\", line 1, in <module>\n""FloatingPointError: divide by zero encountered in divide\n""\n"">>> ignored_states = np.seterr(**old_err_state)\n"">>> np.divide(1, 0)\n""0", 0);
    ((PyUFuncObject *)f)->type_resolver = &PyUFunc_DivisionTypeResolver;
    PyDict_SetItemString(dictionary, "divide", f);
    Py_DECREF(f);
    f = PyUFunc_FromFuncAndData(equal_functions, equal_data, equal_signatures, 21,
                                    2, 1, PyUFunc_None, "equal",
                                    "Return (x1 == x2) element-wise.\n""\n""Parameters\n""----------\n""x1, x2 : array_like\n""    Input arrays of the same shape.\n""\n""Returns\n""-------\n""out : ndarray or bool\n""    Output array of bools, or a single bool if x1 and x2 are scalars.\n""\n""See Also\n""--------\n""not_equal, greater_equal, less_equal, greater, less\n""\n""Examples\n""--------\n"">>> np.equal([0, 1, 3], np.arange(3))\n""array([ True,  True, False], dtype=bool)\n""\n""What is compared are values, not types. So an int (1) and an array of\n""length one can evaluate as True:\n""\n"">>> np.equal(1, np.ones(1))\n""array([ True], dtype=bool)", 0);
    ((PyUFuncObject *)f)->type_resolver = &PyUFunc_SimpleBinaryComparisonTypeResolver;
    PyDict_SetItemString(dictionary, "equal", f);
    Py_DECREF(f);
    f = PyUFunc_FromFuncAndData(exp_functions, exp_data, exp_signatures, 8,
                                    1, 1, PyUFunc_None, "exp",
                                    "Calculate the exponential of all elements in the input array.\n""\n""Parameters\n""----------\n""x : array_like\n""    Input values.\n""\n""Returns\n""-------\n""out : ndarray\n""    Output array, element-wise exponential of `x`.\n""\n""See Also\n""--------\n""expm1 : Calculate ``exp(x) - 1`` for all elements in the array.\n""exp2  : Calculate ``2**x`` for all elements in the array.\n""\n""Notes\n""-----\n""The irrational number ``e`` is also known as Euler\'s number.  It is\n""approximately 2.718281, and is the base of the natural logarithm,\n""``ln`` (this means that, if :math:`x = \\ln y = \\log_e y`,\n""then :math:`e^x = y`. For real input, ``exp(x)`` is always positive.\n""\n""For complex arguments, ``x = a + ib``, we can write\n"":math:`e^x = e^a e^{ib}`.  The first term, :math:`e^a`, is already\n""known (it is the real argument, described above).  The second term,\n"":math:`e^{ib}`, is :math:`\\cos b + i \\sin b`, a function with\n""magnitude 1 and a periodic phase.\n""\n""References\n""----------\n"".. [1] Wikipedia, \"Exponential function\",\n""       http://en.wikipedia.org/wiki/Exponential_function\n"".. [2] M. Abramovitz and I. A. Stegun, \"Handbook of Mathematical Functions\n""       with Formulas, Graphs, and Mathematical Tables,\" Dover, 1964, p. 69,\n""       http://www.math.sfu.ca/~cbm/aands/page_69.htm\n""\n""Examples\n""--------\n""Plot the magnitude and phase of ``exp(x)`` in the complex plane:\n""\n"">>> import matplotlib.pyplot as plt\n""\n"">>> x = np.linspace(-2*np.pi, 2*np.pi, 100)\n"">>> xx = x + 1j * x[:, np.newaxis] # a + ib over complex plane\n"">>> out = np.exp(xx)\n""\n"">>> plt.subplot(121)\n"">>> plt.imshow(np.abs(out),\n""...            extent=[-2*np.pi, 2*np.pi, -2*np.pi, 2*np.pi])\n"">>> plt.title(\'Magnitude of exp(x)\')\n""\n"">>> plt.subplot(122)\n"">>> plt.imshow(np.angle(out),\n""...            extent=[-2*np.pi, 2*np.pi, -2*np.pi, 2*np.pi])\n"">>> plt.title(\'Phase (angle) of exp(x)\')\n"">>> plt.show()", 0);
    PyDict_SetItemString(dictionary, "exp", f);
    Py_DECREF(f);
    f = PyUFunc_FromFuncAndData(exp2_functions, exp2_data, exp2_signatures, 8,
                                    1, 1, PyUFunc_None, "exp2",
                                    "Calculate `2**p` for all `p` in the input array.\n""\n""Parameters\n""----------\n""x : array_like\n""    Input values.\n""\n""out : ndarray, optional\n""    Array to insert results into.\n""\n""Returns\n""-------\n""out : ndarray\n""    Element-wise 2 to the power `x`.\n""\n""See Also\n""--------\n""power\n""\n""Notes\n""-----\n"".. versionadded:: 1.3.0\n""\n""\n""\n""Examples\n""--------\n"">>> np.exp2([2, 3])\n""array([ 4.,  8.])", 0);
    PyDict_SetItemString(dictionary, "exp2", f);
    Py_DECREF(f);
    f = PyUFunc_FromFuncAndData(expm1_functions, expm1_data, expm1_signatures, 8,
                                    1, 1, PyUFunc_None, "expm1",
                                    "Calculate ``exp(x) - 1`` for all elements in the array.\n""\n""Parameters\n""----------\n""x : array_like\n""   Input values.\n""\n""Returns\n""-------\n""out : ndarray\n""    Element-wise exponential minus one: ``out = exp(x) - 1``.\n""\n""See Also\n""--------\n""log1p : ``log(1 + x)``, the inverse of expm1.\n""\n""\n""Notes\n""-----\n""This function provides greater precision than ``exp(x) - 1``\n""for small values of ``x``.\n""\n""Examples\n""--------\n""The true value of ``exp(1e-10) - 1`` is ``1.00000000005e-10`` to\n""about 32 significant digits. This example shows the superiority of\n""expm1 in this case.\n""\n"">>> np.expm1(1e-10)\n""1.00000000005e-10\n"">>> np.exp(1e-10) - 1\n""1.000000082740371e-10", 0);
    PyDict_SetItemString(dictionary, "expm1", f);
    Py_DECREF(f);
    f = PyUFunc_FromFuncAndData(fabs_functions, fabs_data, fabs_signatures, 5,
                                    1, 1, PyUFunc_None, "fabs",
                                    "Compute the absolute values element-wise.\n""\n""This function returns the absolute values (positive magnitude) of the\n""data in `x`. Complex values are not handled, use `absolute` to find the\n""absolute values of complex data.\n""\n""Parameters\n""----------\n""x : array_like\n""    The array of numbers for which the absolute values are required. If\n""    `x` is a scalar, the result `y` will also be a scalar.\n""out : ndarray, optional\n""    Array into which the output is placed. Its type is preserved and it\n""    must be of the right shape to hold the output. See doc.ufuncs.\n""\n""Returns\n""-------\n""y : ndarray or scalar\n""    The absolute values of `x`, the returned values are always floats.\n""\n""See Also\n""--------\n""absolute : Absolute values including `complex` types.\n""\n""Examples\n""--------\n"">>> np.fabs(-1)\n""1.0\n"">>> np.fabs([-1.2, 1.2])\n""array([ 1.2,  1.2])", 0);
    PyDict_SetItemString(dictionary, "fabs", f);
    Py_DECREF(f);
    f = PyUFunc_FromFuncAndData(floor_functions, floor_data, floor_signatures, 5,
                                    1, 1, PyUFunc_None, "floor",
                                    "Return the floor of the input, element-wise.\n""\n""The floor of the scalar `x` is the largest integer `i`, such that\n""`i <= x`.  It is often denoted as :math:`\\lfloor x \\rfloor`.\n""\n""Parameters\n""----------\n""x : array_like\n""    Input data.\n""\n""Returns\n""-------\n""y : ndarray or scalar\n""    The floor of each element in `x`.\n""\n""See Also\n""--------\n""ceil, trunc, rint\n""\n""Notes\n""-----\n""Some spreadsheet programs calculate the \"floor-towards-zero\", in other\n""words ``floor(-2.5) == -2``.  NumPy instead uses the definition of\n""`floor` where `floor(-2.5) == -3`.\n""\n""Examples\n""--------\n"">>> a = np.array([-1.7, -1.5, -0.2, 0.2, 1.5, 1.7, 2.0])\n"">>> np.floor(a)\n""array([-2., -2., -1.,  0.,  1.,  1.,  2.])", 0);
    PyDict_SetItemString(dictionary, "floor", f);
    Py_DECREF(f);
    f = PyUFunc_FromFuncAndData(floor_divide_functions, floor_divide_data, floor_divide_signatures, 20,
                                    2, 1, PyUFunc_None, "floor_divide",
                                    "Return the largest integer smaller or equal to the division of the\n""inputs.\n""\n""Parameters\n""----------\n""x1 : array_like\n""    Numerator.\n""x2 : array_like\n""    Denominator.\n""\n""Returns\n""-------\n""y : ndarray\n""    y = floor(`x1`/`x2`)\n""\n""\n""See Also\n""--------\n""divide : Standard division.\n""floor : Round a number to the nearest integer toward minus infinity.\n""ceil : Round a number to the nearest integer toward infinity.\n""\n""Examples\n""--------\n"">>> np.floor_divide(7,3)\n""2\n"">>> np.floor_divide([1., 2., 3., 4.], 2.5)\n""array([ 0.,  0.,  1.,  1.])", 0);
    ((PyUFuncObject *)f)->type_resolver = &PyUFunc_DivisionTypeResolver;
    PyDict_SetItemString(dictionary, "floor_divide", f);
    Py_DECREF(f);
    f = PyUFunc_FromFuncAndData(fmax_functions, fmax_data, fmax_signatures, 21,
                                    2, 1, PyUFunc_ReorderableNone, "fmax",
                                    "Element-wise maximum of array elements.\n""\n""Compare two arrays and returns a new array containing the element-wise\n""maxima. If one of the elements being compared is a NaN, then the\n""non-nan element is returned. If both elements are NaNs then the first\n""is returned.  The latter distinction is important for complex NaNs,\n""which are defined as at least one of the real or imaginary parts being\n""a NaN. The net effect is that NaNs are ignored when possible.\n""\n""Parameters\n""----------\n""x1, x2 : array_like\n""    The arrays holding the elements to be compared. They must have\n""    the same shape.\n""\n""Returns\n""-------\n""y : ndarray or scalar\n""    The maximum of `x1` and `x2`, element-wise.  Returns scalar if\n""    both  `x1` and `x2` are scalars.\n""\n""See Also\n""--------\n""fmin :\n""    Element-wise minimum of two arrays, ignores NaNs.\n""maximum :\n""    Element-wise maximum of two arrays, propagates NaNs.\n""amax :\n""    The maximum value of an array along a given axis, propagates NaNs.\n""nanmax :\n""    The maximum value of an array along a given axis, ignores NaNs.\n""\n""minimum, amin, nanmin\n""\n""Notes\n""-----\n"".. versionadded:: 1.3.0\n""\n""The fmax is equivalent to ``np.where(x1 >= x2, x1, x2)`` when neither\n""x1 nor x2 are NaNs, but it is faster and does proper broadcasting.\n""\n""Examples\n""--------\n"">>> np.fmax([2, 3, 4], [1, 5, 2])\n""array([ 2.,  5.,  4.])\n""\n"">>> np.fmax(np.eye(2), [0.5, 2])\n""array([[ 1. ,  2. ],\n""       [ 0.5,  2. ]])\n""\n"">>> np.fmax([np.nan, 0, np.nan],[0, np.nan, np.nan])\n""array([  0.,   0.,  NaN])", 0);
    ((PyUFuncObject *)f)->type_resolver = &PyUFunc_SimpleBinaryOperationTypeResolver;
    PyDict_SetItemString(dictionary, "fmax", f);
    Py_DECREF(f);
    f = PyUFunc_FromFuncAndData(fmin_functions, fmin_data, fmin_signatures, 21,
                                    2, 1, PyUFunc_ReorderableNone, "fmin",
                                    "Element-wise minimum of array elements.\n""\n""Compare two arrays and returns a new array containing the element-wise\n""minima. If one of the elements being compared is a NaN, then the\n""non-nan element is returned. If both elements are NaNs then the first\n""is returned.  The latter distinction is important for complex NaNs,\n""which are defined as at least one of the real or imaginary parts being\n""a NaN. The net effect is that NaNs are ignored when possible.\n""\n""Parameters\n""----------\n""x1, x2 : array_like\n""    The arrays holding the elements to be compared. They must have\n""    the same shape.\n""\n""Returns\n""-------\n""y : ndarray or scalar\n""    The minimum of `x1` and `x2`, element-wise.  Returns scalar if\n""    both  `x1` and `x2` are scalars.\n""\n""See Also\n""--------\n""fmax :\n""    Element-wise maximum of two arrays, ignores NaNs.\n""minimum :\n""    Element-wise minimum of two arrays, propagates NaNs.\n""amin :\n""    The minimum value of an array along a given axis, propagates NaNs.\n""nanmin :\n""    The minimum value of an array along a given axis, ignores NaNs.\n""\n""maximum, amax, nanmax\n""\n""Notes\n""-----\n"".. versionadded:: 1.3.0\n""\n""The fmin is equivalent to ``np.where(x1 <= x2, x1, x2)`` when neither\n""x1 nor x2 are NaNs, but it is faster and does proper broadcasting.\n""\n""Examples\n""--------\n"">>> np.fmin([2, 3, 4], [1, 5, 2])\n""array([2, 5, 4])\n""\n"">>> np.fmin(np.eye(2), [0.5, 2])\n""array([[ 1. ,  2. ],\n""       [ 0.5,  2. ]])\n""\n"">>> np.fmin([np.nan, 0, np.nan],[0, np.nan, np.nan])\n""array([  0.,   0.,  NaN])", 0);
    ((PyUFuncObject *)f)->type_resolver = &PyUFunc_SimpleBinaryOperationTypeResolver;
    PyDict_SetItemString(dictionary, "fmin", f);
    Py_DECREF(f);
    f = PyUFunc_FromFuncAndData(fmod_functions, fmod_data, fmod_signatures, 15,
                                    2, 1, PyUFunc_None, "fmod",
                                    "Return the element-wise remainder of division.\n""\n""This is the NumPy implementation of the C library function fmod, the\n""remainder has the same sign as the dividend `x1`. It is equivalent to\n""the Matlab(TM) ``rem`` function and should not be confused with the\n""Python modulus operator ``x1 % x2``.\n""\n""Parameters\n""----------\n""x1 : array_like\n""  Dividend.\n""x2 : array_like\n""  Divisor.\n""\n""Returns\n""-------\n""y : array_like\n""  The remainder of the division of `x1` by `x2`.\n""\n""See Also\n""--------\n""remainder : Equivalent to the Python ``%`` operator.\n""divide\n""\n""Notes\n""-----\n""The result of the modulo operation for negative dividend and divisors\n""is bound by conventions. For `fmod`, the sign of result is the sign of\n""the dividend, while for `remainder` the sign of the result is the sign\n""of the divisor. The `fmod` function is equivalent to the Matlab(TM)\n""``rem`` function.\n""\n""Examples\n""--------\n"">>> np.fmod([-3, -2, -1, 1, 2, 3], 2)\n""array([-1,  0, -1,  1,  0,  1])\n"">>> np.remainder([-3, -2, -1, 1, 2, 3], 2)\n""array([1, 0, 1, 1, 0, 1])\n""\n"">>> np.fmod([5, 3], [2, 2.])\n""array([ 1.,  1.])\n"">>> a = np.arange(-3, 3).reshape(3, 2)\n"">>> a\n""array([[-3, -2],\n""       [-1,  0],\n""       [ 1,  2]])\n"">>> np.fmod(a, [2,2])\n""array([[-1,  0],\n""       [-1,  0],\n""       [ 1,  0]])", 0);
    PyDict_SetItemString(dictionary, "fmod", f);
    Py_DECREF(f);
    f = PyUFunc_FromFuncAndData(frexp_functions, frexp_data, frexp_signatures, 4,
                                    1, 2, PyUFunc_None, "frexp",
                                    "Decompose the elements of x into mantissa and twos exponent.\n""\n""Returns (`mantissa`, `exponent`), where `x = mantissa * 2**exponent``.\n""The mantissa is lies in the open interval(-1, 1), while the twos\n""exponent is a signed integer.\n""\n""Parameters\n""----------\n""x : array_like\n""    Array of numbers to be decomposed.\n""out1 : ndarray, optional\n""    Output array for the mantissa. Must have the same shape as `x`.\n""out2 : ndarray, optional\n""    Output array for the exponent. Must have the same shape as `x`.\n""\n""Returns\n""-------\n""(mantissa, exponent) : tuple of ndarrays, (float, int)\n""    `mantissa` is a float array with values between -1 and 1.\n""    `exponent` is an int array which represents the exponent of 2.\n""\n""See Also\n""--------\n""ldexp : Compute ``y = x1 * 2**x2``, the inverse of `frexp`.\n""\n""Notes\n""-----\n""Complex dtypes are not supported, they will raise a TypeError.\n""\n""Examples\n""--------\n"">>> x = np.arange(9)\n"">>> y1, y2 = np.frexp(x)\n"">>> y1\n""array([ 0.   ,  0.5  ,  0.5  ,  0.75 ,  0.5  ,  0.625,  0.75 ,  0.875,\n""        0.5  ])\n"">>> y2\n""array([0, 1, 2, 2, 3, 3, 3, 3, 4])\n"">>> y1 * 2**y2\n""array([ 0.,  1.,  2.,  3.,  4.,  5.,  6.,  7.,  8.])", 0);
    PyDict_SetItemString(dictionary, "frexp", f);
    Py_DECREF(f);
    f = PyUFunc_FromFuncAndData(greater_functions, greater_data, greater_signatures, 21,
                                    2, 1, PyUFunc_None, "greater",
                                    "Return the truth value of (x1 > x2) element-wise.\n""\n""Parameters\n""----------\n""x1, x2 : array_like\n""    Input arrays.  If ``x1.shape != x2.shape``, they must be\n""    broadcastable to a common shape (which may be the shape of one or\n""    the other).\n""\n""Returns\n""-------\n""out : bool or ndarray of bool\n""    Array of bools, or a single bool if `x1` and `x2` are scalars.\n""\n""\n""See Also\n""--------\n""greater_equal, less, less_equal, equal, not_equal\n""\n""Examples\n""--------\n"">>> np.greater([4,2],[2,2])\n""array([ True, False], dtype=bool)\n""\n""If the inputs are ndarrays, then np.greater is equivalent to \'>\'.\n""\n"">>> a = np.array([4,2])\n"">>> b = np.array([2,2])\n"">>> a > b\n""array([ True, False], dtype=bool)", 0);
    ((PyUFuncObject *)f)->type_resolver = &PyUFunc_SimpleBinaryComparisonTypeResolver;
    PyDict_SetItemString(dictionary, "greater", f);
    Py_DECREF(f);
    f = PyUFunc_FromFuncAndData(greater_equal_functions, greater_equal_data, greater_equal_signatures, 21,
                                    2, 1, PyUFunc_None, "greater_equal",
                                    "Return the truth value of (x1 >= x2) element-wise.\n""\n""Parameters\n""----------\n""x1, x2 : array_like\n""    Input arrays.  If ``x1.shape != x2.shape``, they must be\n""    broadcastable to a common shape (which may be the shape of one or\n""    the other).\n""\n""Returns\n""-------\n""out : bool or ndarray of bool\n""    Array of bools, or a single bool if `x1` and `x2` are scalars.\n""\n""See Also\n""--------\n""greater, less, less_equal, equal, not_equal\n""\n""Examples\n""--------\n"">>> np.greater_equal([4, 2, 1], [2, 2, 2])\n""array([ True, True, False], dtype=bool)", 0);
    ((PyUFuncObject *)f)->type_resolver = &PyUFunc_SimpleBinaryComparisonTypeResolver;
    PyDict_SetItemString(dictionary, "greater_equal", f);
    Py_DECREF(f);
    f = PyUFunc_FromFuncAndData(hypot_functions, hypot_data, hypot_signatures, 5,
                                    2, 1, PyUFunc_None, "hypot",
                                    "Given the \"legs\" of a right triangle, return its hypotenuse.\n""\n""Equivalent to ``sqrt(x1**2 + x2**2)``, element-wise.  If `x1` or\n""`x2` is scalar_like (i.e., unambiguously cast-able to a scalar type),\n""it is broadcast for use with each element of the other argument.\n""(See Examples)\n""\n""Parameters\n""----------\n""x1, x2 : array_like\n""    Leg of the triangle(s).\n""out : ndarray, optional\n""    Array into which the output is placed. Its type is preserved and it\n""    must be of the right shape to hold the output. See doc.ufuncs.\n""\n""Returns\n""-------\n""z : ndarray\n""    The hypotenuse of the triangle(s).\n""\n""Examples\n""--------\n"">>> np.hypot(3*np.ones((3, 3)), 4*np.ones((3, 3)))\n""array([[ 5.,  5.,  5.],\n""       [ 5.,  5.,  5.],\n""       [ 5.,  5.,  5.]])\n""\n""Example showing broadcast of scalar_like argument:\n""\n"">>> np.hypot(3*np.ones((3, 3)), [4])\n""array([[ 5.,  5.,  5.],\n""       [ 5.,  5.,  5.],\n""       [ 5.,  5.,  5.]])", 0);
    PyDict_SetItemString(dictionary, "hypot", f);
    Py_DECREF(f);
    f = PyUFunc_FromFuncAndData(invert_functions, invert_data, invert_signatures, 12,
                                    1, 1, PyUFunc_None, "invert",
                                    "Compute bit-wise inversion, or bit-wise NOT, element-wise.\n""\n""Computes the bit-wise NOT of the underlying binary representation of\n""the integers in the input arrays. This ufunc implements the C/Python\n""operator ``~``.\n""\n""For signed integer inputs, the two\'s complement is returned.  In a\n""two\'s-complement system negative numbers are represented by the two\'s\n""complement of the absolute value. This is the most common method of\n""representing signed integers on computers [1]_. A N-bit\n""two\'s-complement system can represent every integer in the range\n"":math:`-2^{N-1}` to :math:`+2^{N-1}-1`.\n""\n""Parameters\n""----------\n""x1 : array_like\n""    Only integer and boolean types are handled.\n""\n""Returns\n""-------\n""out : array_like\n""    Result.\n""\n""See Also\n""--------\n""bitwise_and, bitwise_or, bitwise_xor\n""logical_not\n""binary_repr :\n""    Return the binary representation of the input number as a string.\n""\n""Notes\n""-----\n""`bitwise_not` is an alias for `invert`:\n""\n"">>> np.bitwise_not is np.invert\n""True\n""\n""References\n""----------\n"".. [1] Wikipedia, \"Two\'s complement\",\n""    http://en.wikipedia.org/wiki/Two\'s_complement\n""\n""Examples\n""--------\n""We\'ve seen that 13 is represented by ``00001101``.\n""The invert or bit-wise NOT of 13 is then:\n""\n"">>> np.invert(np.array([13], dtype=uint8))\n""array([242], dtype=uint8)\n"">>> np.binary_repr(x, width=8)\n""\'00001101\'\n"">>> np.binary_repr(242, width=8)\n""\'11110010\'\n""\n""The result depends on the bit-width:\n""\n"">>> np.invert(np.array([13], dtype=uint16))\n""array([65522], dtype=uint16)\n"">>> np.binary_repr(x, width=16)\n""\'0000000000001101\'\n"">>> np.binary_repr(65522, width=16)\n""\'1111111111110010\'\n""\n""When using signed integer types the result is the two\'s complement of\n""the result for the unsigned type:\n""\n"">>> np.invert(np.array([13], dtype=int8))\n""array([-14], dtype=int8)\n"">>> np.binary_repr(-14, width=8)\n""\'11110010\'\n""\n""Booleans are accepted as well:\n""\n"">>> np.invert(array([True, False]))\n""array([False,  True], dtype=bool)", 0);
    PyDict_SetItemString(dictionary, "invert", f);
    Py_DECREF(f);
    f = PyUFunc_FromFuncAndData(isfinite_functions, isfinite_data, isfinite_signatures, 7,
                                    1, 1, PyUFunc_None, "isfinite",
                                    "Test element-wise for finiteness (not infinity or not Not a Number).\n""\n""The result is returned as a boolean array.\n""\n""Parameters\n""----------\n""x : array_like\n""    Input values.\n""out : ndarray, optional\n""    Array into which the output is placed. Its type is preserved and it\n""    must be of the right shape to hold the output. See `doc.ufuncs`.\n""\n""Returns\n""-------\n""y : ndarray, bool\n""    For scalar input, the result is a new boolean with value True\n""    if the input is finite; otherwise the value is False (input is\n""    either positive infinity, negative infinity or Not a Number).\n""\n""    For array input, the result is a boolean array with the same\n""    dimensions as the input and the values are True if the\n""    corresponding element of the input is finite; otherwise the values\n""    are False (element is either positive infinity, negative infinity\n""    or Not a Number).\n""\n""See Also\n""--------\n""isinf, isneginf, isposinf, isnan\n""\n""Notes\n""-----\n""Not a Number, positive infinity and negative infinity are considered\n""to be non-finite.\n""\n""Numpy uses the IEEE Standard for Binary Floating-Point for Arithmetic\n""(IEEE 754). This means that Not a Number is not equivalent to infinity.\n""Also that positive infinity is not equivalent to negative infinity. But\n""infinity is equivalent to positive infinity.  Errors result if the\n""second argument is also supplied when `x` is a scalar input, or if\n""first and second arguments have different shapes.\n""\n""Examples\n""--------\n"">>> np.isfinite(1)\n""True\n"">>> np.isfinite(0)\n""True\n"">>> np.isfinite(np.nan)\n""False\n"">>> np.isfinite(np.inf)\n""False\n"">>> np.isfinite(np.NINF)\n""False\n"">>> np.isfinite([np.log(-1.),1.,np.log(0)])\n""array([False,  True, False], dtype=bool)\n""\n"">>> x = np.array([-np.inf, 0., np.inf])\n"">>> y = np.array([2, 2, 2])\n"">>> np.isfinite(x, y)\n""array([0, 1, 0])\n"">>> y\n""array([0, 1, 0])", 0);
    PyDict_SetItemString(dictionary, "isfinite", f);
    Py_DECREF(f);
    f = PyUFunc_FromFuncAndData(isinf_functions, isinf_data, isinf_signatures, 7,
                                    1, 1, PyUFunc_None, "isinf",
                                    "Test element-wise for positive or negative infinity.\n""\n""Returns a boolean array of the same shape as `x`, True where ``x ==\n""+/-inf``, otherwise False.\n""\n""Parameters\n""----------\n""x : array_like\n""    Input values\n""out : array_like, optional\n""    An array with the same shape as `x` to store the result.\n""\n""Returns\n""-------\n""y : bool (scalar) or boolean ndarray\n""    For scalar input, the result is a new boolean with value True if\n""    the input is positive or negative infinity; otherwise the value is\n""    False.\n""\n""    For array input, the result is a boolean array with the same shape\n""    as the input and the values are True where the corresponding\n""    element of the input is positive or negative infinity; elsewhere\n""    the values are False.  If a second argument was supplied the result\n""    is stored there.  If the type of that array is a numeric type the\n""    result is represented as zeros and ones, if the type is boolean\n""    then as False and True, respectively.  The return value `y` is then\n""    a reference to that array.\n""\n""See Also\n""--------\n""isneginf, isposinf, isnan, isfinite\n""\n""Notes\n""-----\n""Numpy uses the IEEE Standard for Binary Floating-Point for Arithmetic\n""(IEEE 754).\n""\n""Errors result if the second argument is supplied when the first\n""argument is a scalar, or if the first and second arguments have\n""different shapes.\n""\n""Examples\n""--------\n"">>> np.isinf(np.inf)\n""True\n"">>> np.isinf(np.nan)\n""False\n"">>> np.isinf(np.NINF)\n""True\n"">>> np.isinf([np.inf, -np.inf, 1.0, np.nan])\n""array([ True,  True, False, False], dtype=bool)\n""\n"">>> x = np.array([-np.inf, 0., np.inf])\n"">>> y = np.array([2, 2, 2])\n"">>> np.isinf(x, y)\n""array([1, 0, 1])\n"">>> y\n""array([1, 0, 1])", 0);
    PyDict_SetItemString(dictionary, "isinf", f);
    Py_DECREF(f);
    f = PyUFunc_FromFuncAndData(isnan_functions, isnan_data, isnan_signatures, 7,
                                    1, 1, PyUFunc_None, "isnan",
                                    "Test element-wise for NaN and return result as a boolean array.\n""\n""Parameters\n""----------\n""x : array_like\n""    Input array.\n""\n""Returns\n""-------\n""y : ndarray or bool\n""    For scalar input, the result is a new boolean with value True if\n""    the input is NaN; otherwise the value is False.\n""\n""    For array input, the result is a boolean array of the same\n""    dimensions as the input and the values are True if the\n""    corresponding element of the input is NaN; otherwise the values are\n""    False.\n""\n""See Also\n""--------\n""isinf, isneginf, isposinf, isfinite\n""\n""Notes\n""-----\n""Numpy uses the IEEE Standard for Binary Floating-Point for Arithmetic\n""(IEEE 754). This means that Not a Number is not equivalent to infinity.\n""\n""Examples\n""--------\n"">>> np.isnan(np.nan)\n""True\n"">>> np.isnan(np.inf)\n""False\n"">>> np.isnan([np.log(-1.),1.,np.log(0)])\n""array([ True, False, False], dtype=bool)", 0);
    PyDict_SetItemString(dictionary, "isnan", f);
    Py_DECREF(f);
    f = PyUFunc_FromFuncAndData(ldexp_functions, ldexp_data, ldexp_signatures, 8,
                                    2, 1, PyUFunc_None, "ldexp",
                                    "Returns x1 * 2**x2, element-wise.\n""\n""The mantissas `x1` and twos exponents `x2` are used to construct\n""floating point numbers ``x1 * 2**x2``.\n""\n""Parameters\n""----------\n""x1 : array_like\n""    Array of multipliers.\n""x2 : array_like, int\n""    Array of twos exponents.\n""out : ndarray, optional\n""    Output array for the result.\n""\n""Returns\n""-------\n""y : ndarray or scalar\n""    The result of ``x1 * 2**x2``.\n""\n""See Also\n""--------\n""frexp : Return (y1, y2) from ``x = y1 * 2**y2``, inverse to `ldexp`.\n""\n""Notes\n""-----\n""Complex dtypes are not supported, they will raise a TypeError.\n""\n""`ldexp` is useful as the inverse of `frexp`, if used by itself it is\n""more clear to simply use the expression ``x1 * 2**x2``.\n""\n""Examples\n""--------\n"">>> np.ldexp(5, np.arange(4))\n""array([  5.,  10.,  20.,  40.], dtype=float32)\n""\n"">>> x = np.arange(6)\n"">>> np.ldexp(*np.frexp(x))\n""array([ 0.,  1.,  2.,  3.,  4.,  5.])", 0);
    PyDict_SetItemString(dictionary, "ldexp", f);
    Py_DECREF(f);
    f = PyUFunc_FromFuncAndData(left_shift_functions, left_shift_data, left_shift_signatures, 11,
                                    2, 1, PyUFunc_None, "left_shift",
                                    "Shift the bits of an integer to the left.\n""\n""Bits are shifted to the left by appending `x2` 0s at the right of `x1`.\n""Since the internal representation of numbers is in binary format, this\n""operation is equivalent to multiplying `x1` by ``2**x2``.\n""\n""Parameters\n""----------\n""x1 : array_like of integer type\n""    Input values.\n""x2 : array_like of integer type\n""    Number of zeros to append to `x1`. Has to be non-negative.\n""\n""Returns\n""-------\n""out : array of integer type\n""    Return `x1` with bits shifted `x2` times to the left.\n""\n""See Also\n""--------\n""right_shift : Shift the bits of an integer to the right.\n""binary_repr : Return the binary representation of the input number\n""    as a string.\n""\n""Examples\n""--------\n"">>> np.binary_repr(5)\n""\'101\'\n"">>> np.left_shift(5, 2)\n""20\n"">>> np.binary_repr(20)\n""\'10100\'\n""\n"">>> np.left_shift(5, [1,2,3])\n""array([10, 20, 40])", 0);
    PyDict_SetItemString(dictionary, "left_shift", f);
    Py_DECREF(f);
    f = PyUFunc_FromFuncAndData(less_functions, less_data, less_signatures, 21,
                                    2, 1, PyUFunc_None, "less",
                                    "Return the truth value of (x1 < x2) element-wise.\n""\n""Parameters\n""----------\n""x1, x2 : array_like\n""    Input arrays.  If ``x1.shape != x2.shape``, they must be\n""    broadcastable to a common shape (which may be the shape of one or\n""    the other).\n""\n""Returns\n""-------\n""out : bool or ndarray of bool\n""    Array of bools, or a single bool if `x1` and `x2` are scalars.\n""\n""See Also\n""--------\n""greater, less_equal, greater_equal, equal, not_equal\n""\n""Examples\n""--------\n"">>> np.less([1, 2], [2, 2])\n""array([ True, False], dtype=bool)", 0);
    ((PyUFuncObject *)f)->type_resolver = &PyUFunc_SimpleBinaryComparisonTypeResolver;
    PyDict_SetItemString(dictionary, "less", f);
    Py_DECREF(f);
    f = PyUFunc_FromFuncAndData(less_equal_functions, less_equal_data, less_equal_signatures, 21,
                                    2, 1, PyUFunc_None, "less_equal",
                                    "Return the truth value of (x1 =< x2) element-wise.\n""\n""Parameters\n""----------\n""x1, x2 : array_like\n""    Input arrays.  If ``x1.shape != x2.shape``, they must be\n""    broadcastable to a common shape (which may be the shape of one or\n""    the other).\n""\n""Returns\n""-------\n""out : bool or ndarray of bool\n""    Array of bools, or a single bool if `x1` and `x2` are scalars.\n""\n""See Also\n""--------\n""greater, less, greater_equal, equal, not_equal\n""\n""Examples\n""--------\n"">>> np.less_equal([4, 2, 1], [2, 2, 2])\n""array([False,  True,  True], dtype=bool)", 0);
    ((PyUFuncObject *)f)->type_resolver = &PyUFunc_SimpleBinaryComparisonTypeResolver;
    PyDict_SetItemString(dictionary, "less_equal", f);
    Py_DECREF(f);
    f = PyUFunc_FromFuncAndData(log_functions, log_data, log_signatures, 8,
                                    1, 1, PyUFunc_None, "log",
                                    "Natural logarithm, element-wise.\n""\n""The natural logarithm `log` is the inverse of the exponential function,\n""so that `log(exp(x)) = x`. The natural logarithm is logarithm in base\n""`e`.\n""\n""Parameters\n""----------\n""x : array_like\n""    Input value.\n""\n""Returns\n""-------\n""y : ndarray\n""    The natural logarithm of `x`, element-wise.\n""\n""See Also\n""--------\n""log10, log2, log1p, emath.log\n""\n""Notes\n""-----\n""Logarithm is a multivalued function: for each `x` there is an infinite\n""number of `z` such that `exp(z) = x`. The convention is to return the\n""`z` whose imaginary part lies in `[-pi, pi]`.\n""\n""For real-valued input data types, `log` always returns real output. For\n""each value that cannot be expressed as a real number or infinity, it\n""yields ``nan`` and sets the `invalid` floating point error flag.\n""\n""For complex-valued input, `log` is a complex analytical function that\n""has a branch cut `[-inf, 0]` and is continuous from above on it. `log`\n""handles the floating-point negative zero as an infinitesimal negative\n""number, conforming to the C99 standard.\n""\n""References\n""----------\n"".. [1] M. Abramowitz and I.A. Stegun, \"Handbook of Mathematical Functions\",\n""       10th printing, 1964, pp. 67. http://www.math.sfu.ca/~cbm/aands/\n"".. [2] Wikipedia, \"Logarithm\". http://en.wikipedia.org/wiki/Logarithm\n""\n""Examples\n""--------\n"">>> np.log([1, np.e, np.e**2, 0])\n""array([  0.,   1.,   2., -Inf])", 0);
    PyDict_SetItemString(dictionary, "log", f);
    Py_DECREF(f);
    f = PyUFunc_FromFuncAndData(log10_functions, log10_data, log10_signatures, 8,
                                    1, 1, PyUFunc_None, "log10",
                                    "Return the base 10 logarithm of the input array, element-wise.\n""\n""Parameters\n""----------\n""x : array_like\n""    Input values.\n""\n""Returns\n""-------\n""y : ndarray\n""    The logarithm to the base 10 of `x`, element-wise. NaNs are\n""    returned where x is negative.\n""\n""See Also\n""--------\n""emath.log10\n""\n""Notes\n""-----\n""Logarithm is a multivalued function: for each `x` there is an infinite\n""number of `z` such that `10**z = x`. The convention is to return the\n""`z` whose imaginary part lies in `[-pi, pi]`.\n""\n""For real-valued input data types, `log10` always returns real output.\n""For each value that cannot be expressed as a real number or infinity,\n""it yields ``nan`` and sets the `invalid` floating point error flag.\n""\n""For complex-valued input, `log10` is a complex analytical function that\n""has a branch cut `[-inf, 0]` and is continuous from above on it.\n""`log10` handles the floating-point negative zero as an infinitesimal\n""negative number, conforming to the C99 standard.\n""\n""References\n""----------\n"".. [1] M. Abramowitz and I.A. Stegun, \"Handbook of Mathematical Functions\",\n""       10th printing, 1964, pp. 67. http://www.math.sfu.ca/~cbm/aands/\n"".. [2] Wikipedia, \"Logarithm\". http://en.wikipedia.org/wiki/Logarithm\n""\n""Examples\n""--------\n"">>> np.log10([1e-15, -3.])\n""array([-15.,  NaN])", 0);
    PyDict_SetItemString(dictionary, "log10", f);
    Py_DECREF(f);
    f = PyUFunc_FromFuncAndData(log1p_functions, log1p_data, log1p_signatures, 8,
                                    1, 1, PyUFunc_None, "log1p",
                                    "Return the natural logarithm of one plus the input array, element-wise.\n""\n""Calculates ``log(1 + x)``.\n""\n""Parameters\n""----------\n""x : array_like\n""    Input values.\n""\n""Returns\n""-------\n""y : ndarray\n""    Natural logarithm of `1 + x`, element-wise.\n""\n""See Also\n""--------\n""expm1 : ``exp(x) - 1``, the inverse of `log1p`.\n""\n""Notes\n""-----\n""For real-valued input, `log1p` is accurate also for `x` so small\n""that `1 + x == 1` in floating-point accuracy.\n""\n""Logarithm is a multivalued function: for each `x` there is an infinite\n""number of `z` such that `exp(z) = 1 + x`. The convention is to return\n""the `z` whose imaginary part lies in `[-pi, pi]`.\n""\n""For real-valued input data types, `log1p` always returns real output.\n""For each value that cannot be expressed as a real number or infinity,\n""it yields ``nan`` and sets the `invalid` floating point error flag.\n""\n""For complex-valued input, `log1p` is a complex analytical function that\n""has a branch cut `[-inf, -1]` and is continuous from above on it.\n""`log1p` handles the floating-point negative zero as an infinitesimal\n""negative number, conforming to the C99 standard.\n""\n""References\n""----------\n"".. [1] M. Abramowitz and I.A. Stegun, \"Handbook of Mathematical Functions\",\n""       10th printing, 1964, pp. 67. http://www.math.sfu.ca/~cbm/aands/\n"".. [2] Wikipedia, \"Logarithm\". http://en.wikipedia.org/wiki/Logarithm\n""\n""Examples\n""--------\n"">>> np.log1p(1e-99)\n""1e-99\n"">>> np.log(1 + 1e-99)\n""0.0", 0);
    PyDict_SetItemString(dictionary, "log1p", f);
    Py_DECREF(f);
    f = PyUFunc_FromFuncAndData(log2_functions, log2_data, log2_signatures, 8,
                                    1, 1, PyUFunc_None, "log2",
                                    "Base-2 logarithm of `x`.\n""\n""Parameters\n""----------\n""x : array_like\n""    Input values.\n""\n""Returns\n""-------\n""y : ndarray\n""    Base-2 logarithm of `x`.\n""\n""See Also\n""--------\n""log, log10, log1p, emath.log2\n""\n""Notes\n""-----\n"".. versionadded:: 1.3.0\n""\n""Logarithm is a multivalued function: for each `x` there is an infinite\n""number of `z` such that `2**z = x`. The convention is to return the `z`\n""whose imaginary part lies in `[-pi, pi]`.\n""\n""For real-valued input data types, `log2` always returns real output.\n""For each value that cannot be expressed as a real number or infinity,\n""it yields ``nan`` and sets the `invalid` floating point error flag.\n""\n""For complex-valued input, `log2` is a complex analytical function that\n""has a branch cut `[-inf, 0]` and is continuous from above on it. `log2`\n""handles the floating-point negative zero as an infinitesimal negative\n""number, conforming to the C99 standard.\n""\n""Examples\n""--------\n"">>> x = np.array([0, 1, 2, 2**4])\n"">>> np.log2(x)\n""array([-Inf,   0.,   1.,   4.])\n""\n"">>> xi = np.array([0+1.j, 1, 2+0.j, 4.j])\n"">>> np.log2(xi)\n""array([ 0.+2.26618007j,  0.+0.j        ,  1.+0.j        ,  2.+2.26618007j])", 0);
    PyDict_SetItemString(dictionary, "log2", f);
    Py_DECREF(f);
    f = PyUFunc_FromFuncAndData(logaddexp_functions, logaddexp_data, logaddexp_signatures, 4,
                                    2, 1, PyUFunc_None, "logaddexp",
                                    "Logarithm of the sum of exponentiations of the inputs.\n""\n""Calculates ``log(exp(x1) + exp(x2))``. This function is useful in\n""statistics where the calculated probabilities of events may be so small\n""as to exceed the range of normal floating point numbers.  In such cases\n""the logarithm of the calculated probability is stored. This function\n""allows adding probabilities stored in such a fashion.\n""\n""Parameters\n""----------\n""x1, x2 : array_like\n""    Input values.\n""\n""Returns\n""-------\n""result : ndarray\n""    Logarithm of ``exp(x1) + exp(x2)``.\n""\n""See Also\n""--------\n""logaddexp2: Logarithm of the sum of exponentiations of inputs in base 2.\n""\n""Notes\n""-----\n"".. versionadded:: 1.3.0\n""\n""Examples\n""--------\n"">>> prob1 = np.log(1e-50)\n"">>> prob2 = np.log(2.5e-50)\n"">>> prob12 = np.logaddexp(prob1, prob2)\n"">>> prob12\n""-113.87649168120691\n"">>> np.exp(prob12)\n""3.5000000000000057e-50", 0);
    PyDict_SetItemString(dictionary, "logaddexp", f);
    Py_DECREF(f);
    f = PyUFunc_FromFuncAndData(logaddexp2_functions, logaddexp2_data, logaddexp2_signatures, 4,
                                    2, 1, PyUFunc_None, "logaddexp2",
                                    "Logarithm of the sum of exponentiations of the inputs in base-2.\n""\n""Calculates ``log2(2**x1 + 2**x2)``. This function is useful in machine\n""learning when the calculated probabilities of events may be so small as\n""to exceed the range of normal floating point numbers.  In such cases\n""the base-2 logarithm of the calculated probability can be used instead.\n""This function allows adding probabilities stored in such a fashion.\n""\n""Parameters\n""----------\n""x1, x2 : array_like\n""    Input values.\n""out : ndarray, optional\n""    Array to store results in.\n""\n""Returns\n""-------\n""result : ndarray\n""    Base-2 logarithm of ``2**x1 + 2**x2``.\n""\n""See Also\n""--------\n""logaddexp: Logarithm of the sum of exponentiations of the inputs.\n""\n""Notes\n""-----\n"".. versionadded:: 1.3.0\n""\n""Examples\n""--------\n"">>> prob1 = np.log2(1e-50)\n"">>> prob2 = np.log2(2.5e-50)\n"">>> prob12 = np.logaddexp2(prob1, prob2)\n"">>> prob1, prob2, prob12\n""(-166.09640474436813, -164.77447664948076, -164.28904982231052)\n"">>> 2**prob12\n""3.4999999999999914e-50", 0);
    PyDict_SetItemString(dictionary, "logaddexp2", f);
    Py_DECREF(f);
    f = PyUFunc_FromFuncAndData(logical_and_functions, logical_and_data, logical_and_signatures, 19,
                                    2, 1, PyUFunc_One, "logical_and",
                                    "Compute the truth value of x1 AND x2 element-wise.\n""\n""Parameters\n""----------\n""x1, x2 : array_like\n""    Input arrays. `x1` and `x2` must be of the same shape.\n""\n""\n""Returns\n""-------\n""y : ndarray or bool\n""    Boolean result with the same shape as `x1` and `x2` of the logical\n""    AND operation on corresponding elements of `x1` and `x2`.\n""\n""See Also\n""--------\n""logical_or, logical_not, logical_xor\n""bitwise_and\n""\n""Examples\n""--------\n"">>> np.logical_and(True, False)\n""False\n"">>> np.logical_and([True, False], [False, False])\n""array([False, False], dtype=bool)\n""\n"">>> x = np.arange(5)\n"">>> np.logical_and(x>1, x<4)\n""array([False, False,  True,  True, False], dtype=bool)", 0);
    ((PyUFuncObject *)f)->type_resolver = &PyUFunc_SimpleBinaryComparisonTypeResolver;
    PyDict_SetItemString(dictionary, "logical_and", f);
    Py_DECREF(f);
    f = PyUFunc_FromFuncAndData(logical_not_functions, logical_not_data, logical_not_signatures, 19,
                                    1, 1, PyUFunc_None, "logical_not",
                                    "Compute the truth value of NOT x element-wise.\n""\n""Parameters\n""----------\n""x : array_like\n""    Logical NOT is applied to the elements of `x`.\n""\n""Returns\n""-------\n""y : bool or ndarray of bool\n""    Boolean result with the same shape as `x` of the NOT operation\n""    on elements of `x`.\n""\n""See Also\n""--------\n""logical_and, logical_or, logical_xor\n""\n""Examples\n""--------\n"">>> np.logical_not(3)\n""False\n"">>> np.logical_not([True, False, 0, 1])\n""array([False,  True,  True, False], dtype=bool)\n""\n"">>> x = np.arange(5)\n"">>> np.logical_not(x<3)\n""array([False, False, False,  True,  True], dtype=bool)", 0);
    PyDict_SetItemString(dictionary, "logical_not", f);
    Py_DECREF(f);
    f = PyUFunc_FromFuncAndData(logical_or_functions, logical_or_data, logical_or_signatures, 19,
                                    2, 1, PyUFunc_Zero, "logical_or",
                                    "Compute the truth value of x1 OR x2 element-wise.\n""\n""Parameters\n""----------\n""x1, x2 : array_like\n""    Logical OR is applied to the elements of `x1` and `x2`.\n""    They have to be of the same shape.\n""\n""Returns\n""-------\n""y : ndarray or bool\n""    Boolean result with the same shape as `x1` and `x2` of the logical\n""    OR operation on elements of `x1` and `x2`.\n""\n""See Also\n""--------\n""logical_and, logical_not, logical_xor\n""bitwise_or\n""\n""Examples\n""--------\n"">>> np.logical_or(True, False)\n""True\n"">>> np.logical_or([True, False], [False, False])\n""array([ True, False], dtype=bool)\n""\n"">>> x = np.arange(5)\n"">>> np.logical_or(x < 1, x > 3)\n""array([ True, False, False, False,  True], dtype=bool)", 0);
    ((PyUFuncObject *)f)->type_resolver = &PyUFunc_SimpleBinaryComparisonTypeResolver;
    PyDict_SetItemString(dictionary, "logical_or", f);
    Py_DECREF(f);
    f = PyUFunc_FromFuncAndData(logical_xor_functions, logical_xor_data, logical_xor_signatures, 19,
                                    2, 1, PyUFunc_None, "logical_xor",
                                    "Compute the truth value of x1 XOR x2, element-wise.\n""\n""Parameters\n""----------\n""x1, x2 : array_like\n""    Logical XOR is applied to the elements of `x1` and `x2`.  They must\n""    be broadcastable to the same shape.\n""\n""Returns\n""-------\n""y : bool or ndarray of bool\n""    Boolean result of the logical XOR operation applied to the elements\n""    of `x1` and `x2`; the shape is determined by whether or not\n""    broadcasting of one or both arrays was required.\n""\n""See Also\n""--------\n""logical_and, logical_or, logical_not, bitwise_xor\n""\n""Examples\n""--------\n"">>> np.logical_xor(True, False)\n""True\n"">>> np.logical_xor([True, True, False, False], [True, False, True, False])\n""array([False,  True,  True, False], dtype=bool)\n""\n"">>> x = np.arange(5)\n"">>> np.logical_xor(x < 1, x > 3)\n""array([ True, False, False, False,  True], dtype=bool)\n""\n""Simple example showing support of broadcasting\n""\n"">>> np.logical_xor(0, np.eye(2))\n""array([[ True, False],\n""       [False,  True]], dtype=bool)", 0);
    ((PyUFuncObject *)f)->type_resolver = &PyUFunc_SimpleBinaryComparisonTypeResolver;
    PyDict_SetItemString(dictionary, "logical_xor", f);
    Py_DECREF(f);
    f = PyUFunc_FromFuncAndData(maximum_functions, maximum_data, maximum_signatures, 21,
                                    2, 1, PyUFunc_ReorderableNone, "maximum",
                                    "Element-wise maximum of array elements.\n""\n""Compare two arrays and returns a new array containing the element-wise\n""maxima. If one of the elements being compared is a NaN, then that\n""element is returned. If both elements are NaNs then the first is\n""returned. The latter distinction is important for complex NaNs, which\n""are defined as at least one of the real or imaginary parts being a NaN.\n""The net effect is that NaNs are propagated.\n""\n""Parameters\n""----------\n""x1, x2 : array_like\n""    The arrays holding the elements to be compared. They must have\n""    the same shape, or shapes that can be broadcast to a single shape.\n""\n""Returns\n""-------\n""y : ndarray or scalar\n""    The maximum of `x1` and `x2`, element-wise.  Returns scalar if\n""    both  `x1` and `x2` are scalars.\n""\n""See Also\n""--------\n""minimum :\n""    Element-wise minimum of two arrays, propagates NaNs.\n""fmax :\n""    Element-wise maximum of two arrays, ignores NaNs.\n""amax :\n""    The maximum value of an array along a given axis, propagates NaNs.\n""nanmax :\n""    The maximum value of an array along a given axis, ignores NaNs.\n""\n""fmin, amin, nanmin\n""\n""Notes\n""-----\n""The maximum is equivalent to ``np.where(x1 >= x2, x1, x2)`` when\n""neither x1 nor x2 are nans, but it is faster and does proper\n""broadcasting.\n""\n""Examples\n""--------\n"">>> np.maximum([2, 3, 4], [1, 5, 2])\n""array([2, 5, 4])\n""\n"">>> np.maximum(np.eye(2), [0.5, 2]) # broadcasting\n""array([[ 1. ,  2. ],\n""       [ 0.5,  2. ]])\n""\n"">>> np.maximum([np.nan, 0, np.nan], [0, np.nan, np.nan])\n""array([ NaN,  NaN,  NaN])\n"">>> np.maximum(np.Inf, 1)\n""inf", 0);
    ((PyUFuncObject *)f)->type_resolver = &PyUFunc_SimpleBinaryOperationTypeResolver;
    PyDict_SetItemString(dictionary, "maximum", f);
    Py_DECREF(f);
    f = PyUFunc_FromFuncAndData(minimum_functions, minimum_data, minimum_signatures, 21,
                                    2, 1, PyUFunc_ReorderableNone, "minimum",
                                    "Element-wise minimum of array elements.\n""\n""Compare two arrays and returns a new array containing the element-wise\n""minima. If one of the elements being compared is a NaN, then that\n""element is returned. If both elements are NaNs then the first is\n""returned. The latter distinction is important for complex NaNs, which\n""are defined as at least one of the real or imaginary parts being a NaN.\n""The net effect is that NaNs are propagated.\n""\n""Parameters\n""----------\n""x1, x2 : array_like\n""    The arrays holding the elements to be compared. They must have\n""    the same shape, or shapes that can be broadcast to a single shape.\n""\n""Returns\n""-------\n""y : ndarray or scalar\n""    The minimum of `x1` and `x2`, element-wise.  Returns scalar if\n""    both  `x1` and `x2` are scalars.\n""\n""See Also\n""--------\n""maximum :\n""    Element-wise maximum of two arrays, propagates NaNs.\n""fmin :\n""    Element-wise minimum of two arrays, ignores NaNs.\n""amin :\n""    The minimum value of an array along a given axis, propagates NaNs.\n""nanmin :\n""    The minimum value of an array along a given axis, ignores NaNs.\n""\n""fmax, amax, nanmax\n""\n""Notes\n""-----\n""The minimum is equivalent to ``np.where(x1 <= x2, x1, x2)`` when\n""neither x1 nor x2 are NaNs, but it is faster and does proper\n""broadcasting.\n""\n""Examples\n""--------\n"">>> np.minimum([2, 3, 4], [1, 5, 2])\n""array([1, 3, 2])\n""\n"">>> np.minimum(np.eye(2), [0.5, 2]) # broadcasting\n""array([[ 0.5,  0. ],\n""       [ 0. ,  1. ]])\n""\n"">>> np.minimum([np.nan, 0, np.nan],[0, np.nan, np.nan])\n""array([ NaN,  NaN,  NaN])\n"">>> np.minimum(-np.Inf, 1)\n""-inf", 0);
    ((PyUFuncObject *)f)->type_resolver = &PyUFunc_SimpleBinaryOperationTypeResolver;
    PyDict_SetItemString(dictionary, "minimum", f);
    Py_DECREF(f);
    f = PyUFunc_FromFuncAndData(modf_functions, modf_data, modf_signatures, 4,
                                    1, 2, PyUFunc_None, "modf",
                                    "Return the fractional and integral parts of an array, element-wise.\n""\n""The fractional and integral parts are negative if the given number is\n""negative.\n""\n""Parameters\n""----------\n""x : array_like\n""    Input array.\n""\n""Returns\n""-------\n""y1 : ndarray\n""    Fractional part of `x`.\n""y2 : ndarray\n""    Integral part of `x`.\n""\n""Notes\n""-----\n""For integer input the return values are floats.\n""\n""Examples\n""--------\n"">>> np.modf([0, 3.5])\n""(array([ 0. ,  0.5]), array([ 0.,  3.]))\n"">>> np.modf(-0.5)\n""(-0.5, -0)", 0);
    PyDict_SetItemString(dictionary, "modf", f);
    Py_DECREF(f);
    f = PyUFunc_FromFuncAndData(multiply_functions, multiply_data, multiply_signatures, 23,
                                    2, 1, PyUFunc_One, "multiply",
                                    "Multiply arguments element-wise.\n""\n""Parameters\n""----------\n""x1, x2 : array_like\n""    Input arrays to be multiplied.\n""\n""Returns\n""-------\n""y : ndarray\n""    The product of `x1` and `x2`, element-wise. Returns a scalar if\n""    both  `x1` and `x2` are scalars.\n""\n""Notes\n""-----\n""Equivalent to `x1` * `x2` in terms of array broadcasting.\n""\n""Examples\n""--------\n"">>> np.multiply(2.0, 4.0)\n""8.0\n""\n"">>> x1 = np.arange(9.0).reshape((3, 3))\n"">>> x2 = np.arange(3.0)\n"">>> np.multiply(x1, x2)\n""array([[  0.,   1.,   4.],\n""       [  0.,   4.,  10.],\n""       [  0.,   7.,  16.]])", 0);
    ((PyUFuncObject *)f)->type_resolver = &PyUFunc_MultiplicationTypeResolver;
    PyDict_SetItemString(dictionary, "multiply", f);
    Py_DECREF(f);
    f = PyUFunc_FromFuncAndData(negative_functions, negative_data, negative_signatures, 20,
                                    1, 1, PyUFunc_None, "negative",
                                    "Numerical negative, element-wise.\n""\n""Parameters\n""----------\n""x : array_like or scalar\n""    Input array.\n""\n""Returns\n""-------\n""y : ndarray or scalar\n""    Returned array or scalar: `y = -x`.\n""\n""Examples\n""--------\n"">>> np.negative([1.,-1.])\n""array([-1.,  1.])", 0);
    ((PyUFuncObject *)f)->type_resolver = &PyUFunc_NegativeTypeResolver;
    PyDict_SetItemString(dictionary, "negative", f);
    Py_DECREF(f);
    f = PyUFunc_FromFuncAndData(nextafter_functions, nextafter_data, nextafter_signatures, 4,
                                    2, 1, PyUFunc_None, "nextafter",
                                    "Return the next floating-point value after x1 towards x2, element-wise.\n""\n""Parameters\n""----------\n""x1 : array_like\n""    Values to find the next representable value of.\n""x2 : array_like\n""    The direction where to look for the next representable value of `x1`.\n""out : ndarray, optional\n""    Array into which the output is placed. Its type is preserved and it\n""    must be of the right shape to hold the output. See `doc.ufuncs`.\n""\n""Returns\n""-------\n""out : array_like\n""    The next representable values of `x1` in the direction of `x2`.\n""\n""Examples\n""--------\n"">>> eps = np.finfo(np.float64).eps\n"">>> np.nextafter(1, 2) == eps + 1\n""True\n"">>> np.nextafter([1, 2], [2, 1]) == [eps + 1, 2 - eps]\n""array([ True,  True], dtype=bool)", 0);
    PyDict_SetItemString(dictionary, "nextafter", f);
    Py_DECREF(f);
    f = PyUFunc_FromFuncAndData(not_equal_functions, not_equal_data, not_equal_signatures, 21,
                                    2, 1, PyUFunc_None, "not_equal",
                                    "Return (x1 != x2) element-wise.\n""\n""Parameters\n""----------\n""x1, x2 : array_like\n""  Input arrays.\n""out : ndarray, optional\n""  A placeholder the same shape as `x1` to store the result.\n""  See `doc.ufuncs` (Section \"Output arguments\") for more details.\n""\n""Returns\n""-------\n""not_equal : ndarray bool, scalar bool\n""  For each element in `x1, x2`, return True if `x1` is not equal\n""  to `x2` and False otherwise.\n""\n""\n""See Also\n""--------\n""equal, greater, greater_equal, less, less_equal\n""\n""Examples\n""--------\n"">>> np.not_equal([1.,2.], [1., 3.])\n""array([False,  True], dtype=bool)\n"">>> np.not_equal([1, 2], [[1, 3],[1, 4]])\n""array([[False,  True],\n""       [False,  True]], dtype=bool)", 0);
    ((PyUFuncObject *)f)->type_resolver = &PyUFunc_SimpleBinaryComparisonTypeResolver;
    PyDict_SetItemString(dictionary, "not_equal", f);
    Py_DECREF(f);
    f = PyUFunc_FromFuncAndData(power_functions, power_data, power_signatures, 18,
                                    2, 1, PyUFunc_None, "power",
                                    "First array elements raised to powers from second array, element-wise.\n""\n""Raise each base in `x1` to the positionally-corresponding power in\n""`x2`.  `x1` and `x2` must be broadcastable to the same shape.\n""\n""Parameters\n""----------\n""x1 : array_like\n""    The bases.\n""x2 : array_like\n""    The exponents.\n""\n""Returns\n""-------\n""y : ndarray\n""    The bases in `x1` raised to the exponents in `x2`.\n""\n""Examples\n""--------\n""Cube each element in a list.\n""\n"">>> x1 = range(6)\n"">>> x1\n""[0, 1, 2, 3, 4, 5]\n"">>> np.power(x1, 3)\n""array([  0,   1,   8,  27,  64, 125])\n""\n""Raise the bases to different exponents.\n""\n"">>> x2 = [1.0, 2.0, 3.0, 3.0, 2.0, 1.0]\n"">>> np.power(x1, x2)\n""array([  0.,   1.,   8.,  27.,  16.,   5.])\n""\n""The effect of broadcasting.\n""\n"">>> x2 = np.array([[1, 2, 3, 3, 2, 1], [1, 2, 3, 3, 2, 1]])\n"">>> x2\n""array([[1, 2, 3, 3, 2, 1],\n""       [1, 2, 3, 3, 2, 1]])\n"">>> np.power(x1, x2)\n""array([[ 0,  1,  8, 27, 16,  5],\n""       [ 0,  1,  8, 27, 16,  5]])", 0);
    PyDict_SetItemString(dictionary, "power", f);
    Py_DECREF(f);
    f = PyUFunc_FromFuncAndData(rad2deg_functions, rad2deg_data, rad2deg_signatures, 5,
                                    1, 1, PyUFunc_None, "rad2deg",
                                    "Convert angles from radians to degrees.\n""\n""Parameters\n""----------\n""x : array_like\n""    Angle in radians.\n""out : ndarray, optional\n""    Array into which the output is placed. Its type is preserved and it\n""    must be of the right shape to hold the output. See doc.ufuncs.\n""\n""Returns\n""-------\n""y : ndarray\n""    The corresponding angle in degrees.\n""\n""See Also\n""--------\n""deg2rad : Convert angles from degrees to radians.\n""unwrap : Remove large jumps in angle by wrapping.\n""\n""Notes\n""-----\n"".. versionadded:: 1.3.0\n""\n""rad2deg(x) is ``180 * x / pi``.\n""\n""Examples\n""--------\n"">>> np.rad2deg(np.pi/2)\n""90.0", 0);
    PyDict_SetItemString(dictionary, "rad2deg", f);
    Py_DECREF(f);
    f = PyUFunc_FromFuncAndData(radians_functions, radians_data, radians_signatures, 5,
                                    1, 1, PyUFunc_None, "radians",
                                    "Convert angles from degrees to radians.\n""\n""Parameters\n""----------\n""x : array_like\n""    Input array in degrees.\n""out : ndarray, optional\n""    Output array of same shape as `x`.\n""\n""Returns\n""-------\n""y : ndarray\n""    The corresponding radian values.\n""\n""See Also\n""--------\n""deg2rad : equivalent function\n""\n""Examples\n""--------\n""Convert a degree array to radians\n""\n"">>> deg = np.arange(12.) * 30.\n"">>> np.radians(deg)\n""array([ 0.        ,  0.52359878,  1.04719755,  1.57079633,  2.0943951 ,\n""        2.61799388,  3.14159265,  3.66519143,  4.1887902 ,  4.71238898,\n""        5.23598776,  5.75958653])\n""\n"">>> out = np.zeros((deg.shape))\n"">>> ret = np.radians(deg, out)\n"">>> ret is out\n""True", 0);
    PyDict_SetItemString(dictionary, "radians", f);
    Py_DECREF(f);
    f = PyUFunc_FromFuncAndData(reciprocal_functions, reciprocal_data, reciprocal_signatures, 18,
                                    1, 1, PyUFunc_None, "reciprocal",
                                    "Return the reciprocal of the argument, element-wise.\n""\n""Calculates ``1/x``.\n""\n""Parameters\n""----------\n""x : array_like\n""    Input array.\n""\n""Returns\n""-------\n""y : ndarray\n""    Return array.\n""\n""Notes\n""-----\n"".. note::\n""    This function is not designed to work with integers.\n""\n""For integer arguments with absolute value larger than 1 the result is\n""always zero because of the way Python handles integer division.  For\n""integer zero the result is an overflow.\n""\n""Examples\n""--------\n"">>> np.reciprocal(2.)\n""0.5\n"">>> np.reciprocal([1, 2., 3.33])\n""array([ 1.       ,  0.5      ,  0.3003003])", 0);
    PyDict_SetItemString(dictionary, "reciprocal", f);
    Py_DECREF(f);
    f = PyUFunc_FromFuncAndData(remainder_functions, remainder_data, remainder_signatures, 15,
                                    2, 1, PyUFunc_None, "remainder",
                                    "Return element-wise remainder of division.\n""\n""Computes ``x1 - floor(x1 / x2) * x2``, the result has the same sign as\n""the divisor `x2`. It is equivalent to the Python modulus operator\n""``x1 % x2`` and should not be confused with the Matlab(TM) ``rem``\n""function.\n""\n""Parameters\n""----------\n""x1 : array_like\n""    Dividend array.\n""x2 : array_like\n""    Divisor array.\n""out : ndarray, optional\n""    Array into which the output is placed. Its type is preserved and it\n""    must be of the right shape to hold the output. See doc.ufuncs.\n""\n""Returns\n""-------\n""y : ndarray\n""    The remainder of the quotient ``x1/x2``, element-wise. Returns a\n""    scalar if both  `x1` and `x2` are scalars.\n""\n""See Also\n""--------\n""fmod : Equivalent of the Matlab(TM) ``rem`` function.\n""divide, floor\n""\n""Notes\n""-----\n""Returns 0 when `x2` is 0 and both `x1` and `x2` are (arrays of)\n""integers.\n""\n""Examples\n""--------\n"">>> np.remainder([4, 7], [2, 3])\n""array([0, 1])\n"">>> np.remainder(np.arange(7), 5)\n""array([0, 1, 2, 3, 4, 0, 1])", 0);
    PyDict_SetItemString(dictionary, "remainder", f);
    Py_DECREF(f);
    f = PyUFunc_FromFuncAndData(right_shift_functions, right_shift_data, right_shift_signatures, 11,
                                    2, 1, PyUFunc_None, "right_shift",
                                    "Shift the bits of an integer to the right.\n""\n""Bits are shifted to the right `x2`.  Because the internal\n""representation of numbers is in binary format, this operation is\n""equivalent to dividing `x1` by ``2**x2``.\n""\n""Parameters\n""----------\n""x1 : array_like, int\n""    Input values.\n""x2 : array_like, int\n""    Number of bits to remove at the right of `x1`.\n""\n""Returns\n""-------\n""out : ndarray, int\n""    Return `x1` with bits shifted `x2` times to the right.\n""\n""See Also\n""--------\n""left_shift : Shift the bits of an integer to the left.\n""binary_repr : Return the binary representation of the input number\n""    as a string.\n""\n""Examples\n""--------\n"">>> np.binary_repr(10)\n""\'1010\'\n"">>> np.right_shift(10, 1)\n""5\n"">>> np.binary_repr(5)\n""\'101\'\n""\n"">>> np.right_shift(10, [1,2,3])\n""array([5, 2, 1])", 0);
    PyDict_SetItemString(dictionary, "right_shift", f);
    Py_DECREF(f);
    f = PyUFunc_FromFuncAndData(rint_functions, rint_data, rint_signatures, 8,
                                    1, 1, PyUFunc_None, "rint",
                                    "Round elements of the array to the nearest integer.\n""\n""Parameters\n""----------\n""x : array_like\n""    Input array.\n""\n""Returns\n""-------\n""out : ndarray or scalar\n""    Output array is same shape and type as `x`.\n""\n""See Also\n""--------\n""ceil, floor, trunc\n""\n""Examples\n""--------\n"">>> a = np.array([-1.7, -1.5, -0.2, 0.2, 1.5, 1.7, 2.0])\n"">>> np.rint(a)\n""array([-2., -2., -0.,  0.,  2.,  2.,  2.])", 0);
    PyDict_SetItemString(dictionary, "rint", f);
    Py_DECREF(f);
    f = PyUFunc_FromFuncAndData(sign_functions, sign_data, sign_signatures, 19,
                                    1, 1, PyUFunc_None, "sign",
                                    "Returns an element-wise indication of the sign of a number.\n""\n""The `sign` function returns ``-1 if x < 0, 0 if x==0, 1 if x > 0``.\n""\n""Parameters\n""----------\n""x : array_like\n""  Input values.\n""\n""Returns\n""-------\n""y : ndarray\n""  The sign of `x`.\n""\n""Examples\n""--------\n"">>> np.sign([-5., 4.5])\n""array([-1.,  1.])\n"">>> np.sign(0)\n""0", 0);
    ((PyUFuncObject *)f)->type_resolver = &PyUFunc_SimpleUnaryOperationTypeResolver;
    PyDict_SetItemString(dictionary, "sign", f);
    Py_DECREF(f);
    f = PyUFunc_FromFuncAndData(signbit_functions, signbit_data, signbit_signatures, 4,
                                    1, 1, PyUFunc_None, "signbit",
                                    "Returns element-wise True where signbit is set (less than zero).\n""\n""Parameters\n""----------\n""x : array_like\n""    The input value(s).\n""out : ndarray, optional\n""    Array into which the output is placed. Its type is preserved and it\n""    must be of the right shape to hold the output.  See `doc.ufuncs`.\n""\n""Returns\n""-------\n""result : ndarray of bool\n""    Output array, or reference to `out` if that was supplied.\n""\n""Examples\n""--------\n"">>> np.signbit(-1.2)\n""True\n"">>> np.signbit(np.array([1, -2.3, 2.1]))\n""array([False,  True, False], dtype=bool)", 0);
    PyDict_SetItemString(dictionary, "signbit", f);
    Py_DECREF(f);
    f = PyUFunc_FromFuncAndData(sin_functions, sin_data, sin_signatures, 8,
                                    1, 1, PyUFunc_None, "sin",
                                    "Trigonometric sine, element-wise.\n""\n""Parameters\n""----------\n""x : array_like\n""    Angle, in radians (:math:`2 \\pi` rad equals 360 degrees).\n""\n""Returns\n""-------\n""y : array_like\n""    The sine of each element of x.\n""\n""See Also\n""--------\n""arcsin, sinh, cos\n""\n""Notes\n""-----\n""The sine is one of the fundamental functions of trigonometry (the\n""mathematical study of triangles).  Consider a circle of radius 1\n""centered on the origin.  A ray comes in from the :math:`+x` axis, makes\n""an angle at the origin (measured counter-clockwise from that axis), and\n""departs from the origin.  The :math:`y` coordinate of the outgoing\n""ray\'s intersection with the unit circle is the sine of that angle.  It\n""ranges from -1 for :math:`x=3\\pi / 2` to +1 for :math:`\\pi / 2.`  The\n""function has zeroes where the angle is a multiple of :math:`\\pi`.\n""Sines of angles between :math:`\\pi` and :math:`2\\pi` are negative.\n""The numerous properties of the sine and related functions are included\n""in any standard trigonometry text.\n""\n""Examples\n""--------\n""Print sine of one angle:\n""\n"">>> np.sin(np.pi/2.)\n""1.0\n""\n""Print sines of an array of angles given in degrees:\n""\n"">>> np.sin(np.array((0., 30., 45., 60., 90.)) * np.pi / 180. )\n""array([ 0.        ,  0.5       ,  0.70710678,  0.8660254 ,  1.        ])\n""\n""Plot the sine function:\n""\n"">>> import matplotlib.pylab as plt\n"">>> x = np.linspace(-np.pi, np.pi, 201)\n"">>> plt.plot(x, np.sin(x))\n"">>> plt.xlabel(\'Angle [rad]\')\n"">>> plt.ylabel(\'sin(x)\')\n"">>> plt.axis(\'tight\')\n"">>> plt.show()", 0);
    PyDict_SetItemString(dictionary, "sin", f);
    Py_DECREF(f);
    f = PyUFunc_FromFuncAndData(sinh_functions, sinh_data, sinh_signatures, 8,
                                    1, 1, PyUFunc_None, "sinh",
                                    "Hyperbolic sine, element-wise.\n""\n""Equivalent to ``1/2 * (np.exp(x) - np.exp(-x))`` or\n""``-1j * np.sin(1j*x)``.\n""\n""Parameters\n""----------\n""x : array_like\n""    Input array.\n""out : ndarray, optional\n""    Output array of same shape as `x`.\n""\n""Returns\n""-------\n""y : ndarray\n""    The corresponding hyperbolic sine values.\n""\n""Raises\n""------\n""ValueError: invalid return array shape\n""    if `out` is provided and `out.shape` != `x.shape` (See Examples)\n""\n""Notes\n""-----\n""If `out` is provided, the function writes the result into it,\n""and returns a reference to `out`.  (See Examples)\n""\n""References\n""----------\n""M. Abramowitz and I. A. Stegun, Handbook of Mathematical Functions.\n""New York, NY: Dover, 1972, pg. 83.\n""\n""Examples\n""--------\n"">>> np.sinh(0)\n""0.0\n"">>> np.sinh(np.pi*1j/2)\n""1j\n"">>> np.sinh(np.pi*1j) # (exact value is 0)\n""1.2246063538223773e-016j\n"">>> # Discrepancy due to vagaries of floating point arithmetic.\n""\n"">>> # Example of providing the optional output parameter\n"">>> out2 = np.sinh([0.1], out1)\n"">>> out2 is out1\n""True\n""\n"">>> # Example of ValueError due to provision of shape mis-matched `out`\n"">>> np.sinh(np.zeros((3,3)),np.zeros((2,2)))\n""Traceback (most recent call last):\n""  File \"<stdin>\", line 1, in <module>\n""ValueError: invalid return array shape", 0);
    PyDict_SetItemString(dictionary, "sinh", f);
    Py_DECREF(f);
    f = PyUFunc_FromFuncAndData(spacing_functions, spacing_data, spacing_signatures, 4,
                                    1, 1, PyUFunc_None, "spacing",
                                    "Return the distance between x and the nearest adjacent number.\n""\n""Parameters\n""----------\n""x1 : array_like\n""    Values to find the spacing of.\n""\n""Returns\n""-------\n""out : array_like\n""    The spacing of values of `x1`.\n""\n""Notes\n""-----\n""It can be considered as a generalization of EPS:\n""``spacing(np.float64(1)) == np.finfo(np.float64).eps``, and there\n""should not be any representable number between ``x + spacing(x)`` and\n""x for any finite x.\n""\n""Spacing of +- inf and NaN is NaN.\n""\n""Examples\n""--------\n"">>> np.spacing(1) == np.finfo(np.float64).eps\n""True", 0);
    PyDict_SetItemString(dictionary, "spacing", f);
    Py_DECREF(f);
    f = PyUFunc_FromFuncAndData(sqrt_functions, sqrt_data, sqrt_signatures, 10,
                                    1, 1, PyUFunc_None, "sqrt",
                                    "Return the positive square-root of an array, element-wise.\n""\n""Parameters\n""----------\n""x : array_like\n""    The values whose square-roots are required.\n""out : ndarray, optional\n""    Alternate array object in which to put the result; if provided, it\n""    must have the same shape as `x`\n""\n""Returns\n""-------\n""y : ndarray\n""    An array of the same shape as `x`, containing the positive\n""    square-root of each element in `x`.  If any element in `x` is\n""    complex, a complex array is returned (and the square-roots of\n""    negative reals are calculated).  If all of the elements in `x`\n""    are real, so is `y`, with negative elements returning ``nan``.\n""    If `out` was provided, `y` is a reference to it.\n""\n""See Also\n""--------\n""lib.scimath.sqrt\n""    A version which returns complex numbers when given negative reals.\n""\n""Notes\n""-----\n""*sqrt* has--consistent with common convention--as its branch cut the\n""real \"interval\" [`-inf`, 0), and is continuous from above on it.\n""A branch cut is a curve in the complex plane across which a given\n""complex function fails to be continuous.\n""\n""Examples\n""--------\n"">>> np.sqrt([1,4,9])\n""array([ 1.,  2.,  3.])\n""\n"">>> np.sqrt([4, -1, -3+4J])\n""array([ 2.+0.j,  0.+1.j,  1.+2.j])\n""\n"">>> np.sqrt([4, -1, numpy.inf])\n""array([  2.,  NaN,  Inf])", 0);
    PyDict_SetItemString(dictionary, "sqrt", f);
    Py_DECREF(f);
    f = PyUFunc_FromFuncAndData(square_functions, square_data, square_signatures, 18,
                                    1, 1, PyUFunc_None, "square",
                                    "Return the element-wise square of the input.\n""\n""Parameters\n""----------\n""x : array_like\n""    Input data.\n""\n""Returns\n""-------\n""out : ndarray\n""    Element-wise `x*x`, of the same shape and dtype as `x`.\n""    Returns scalar if `x` is a scalar.\n""\n""See Also\n""--------\n""numpy.linalg.matrix_power\n""sqrt\n""power\n""\n""Examples\n""--------\n"">>> np.square([-1j, 1])\n""array([-1.-0.j,  1.+0.j])", 0);
    PyDict_SetItemString(dictionary, "square", f);
    Py_DECREF(f);
    f = PyUFunc_FromFuncAndData(subtract_functions, subtract_data, subtract_signatures, 22,
                                    2, 1, PyUFunc_None, "subtract",
                                    "Subtract arguments, element-wise.\n""\n""Parameters\n""----------\n""x1, x2 : array_like\n""    The arrays to be subtracted from each other.\n""\n""Returns\n""-------\n""y : ndarray\n""    The difference of `x1` and `x2`, element-wise.  Returns a scalar if\n""    both  `x1` and `x2` are scalars.\n""\n""Notes\n""-----\n""Equivalent to ``x1 - x2`` in terms of array broadcasting.\n""\n""Examples\n""--------\n"">>> np.subtract(1.0, 4.0)\n""-3.0\n""\n"">>> x1 = np.arange(9.0).reshape((3, 3))\n"">>> x2 = np.arange(3.0)\n"">>> np.subtract(x1, x2)\n""array([[ 0.,  0.,  0.],\n""       [ 3.,  3.,  3.],\n""       [ 6.,  6.,  6.]])", 0);
    ((PyUFuncObject *)f)->type_resolver = &PyUFunc_SubtractionTypeResolver;
    PyDict_SetItemString(dictionary, "subtract", f);
    Py_DECREF(f);
    f = PyUFunc_FromFuncAndData(tan_functions, tan_data, tan_signatures, 8,
                                    1, 1, PyUFunc_None, "tan",
                                    "Compute tangent element-wise.\n""\n""Equivalent to ``np.sin(x)/np.cos(x)`` element-wise.\n""\n""Parameters\n""----------\n""x : array_like\n""  Input array.\n""out : ndarray, optional\n""    Output array of same shape as `x`.\n""\n""Returns\n""-------\n""y : ndarray\n""  The corresponding tangent values.\n""\n""Raises\n""------\n""ValueError: invalid return array shape\n""    if `out` is provided and `out.shape` != `x.shape` (See Examples)\n""\n""Notes\n""-----\n""If `out` is provided, the function writes the result into it,\n""and returns a reference to `out`.  (See Examples)\n""\n""References\n""----------\n""M. Abramowitz and I. A. Stegun, Handbook of Mathematical Functions.\n""New York, NY: Dover, 1972.\n""\n""Examples\n""--------\n"">>> from math import pi\n"">>> np.tan(np.array([-pi,pi/2,pi]))\n""array([  1.22460635e-16,   1.63317787e+16,  -1.22460635e-16])\n"">>>\n"">>> # Example of providing the optional output parameter illustrating\n"">>> # that what is returned is a reference to said parameter\n"">>> out2 = np.cos([0.1], out1)\n"">>> out2 is out1\n""True\n"">>>\n"">>> # Example of ValueError due to provision of shape mis-matched `out`\n"">>> np.cos(np.zeros((3,3)),np.zeros((2,2)))\n""Traceback (most recent call last):\n""  File \"<stdin>\", line 1, in <module>\n""ValueError: invalid return array shape", 0);
    PyDict_SetItemString(dictionary, "tan", f);
    Py_DECREF(f);
    f = PyUFunc_FromFuncAndData(tanh_functions, tanh_data, tanh_signatures, 8,
                                    1, 1, PyUFunc_None, "tanh",
                                    "Compute hyperbolic tangent element-wise.\n""\n""Equivalent to ``np.sinh(x)/np.cosh(x)`` or ``-1j * np.tan(1j*x)``.\n""\n""Parameters\n""----------\n""x : array_like\n""    Input array.\n""out : ndarray, optional\n""    Output array of same shape as `x`.\n""\n""Returns\n""-------\n""y : ndarray\n""    The corresponding hyperbolic tangent values.\n""\n""Raises\n""------\n""ValueError: invalid return array shape\n""    if `out` is provided and `out.shape` != `x.shape` (See Examples)\n""\n""Notes\n""-----\n""If `out` is provided, the function writes the result into it,\n""and returns a reference to `out`.  (See Examples)\n""\n""References\n""----------\n"".. [1] M. Abramowitz and I. A. Stegun, Handbook of Mathematical Functions.\n""       New York, NY: Dover, 1972, pg. 83.\n""       http://www.math.sfu.ca/~cbm/aands/\n""\n"".. [2] Wikipedia, \"Hyperbolic function\",\n""       http://en.wikipedia.org/wiki/Hyperbolic_function\n""\n""Examples\n""--------\n"">>> np.tanh((0, np.pi*1j, np.pi*1j/2))\n""array([ 0. +0.00000000e+00j,  0. -1.22460635e-16j,  0. +1.63317787e+16j])\n""\n"">>> # Example of providing the optional output parameter illustrating\n"">>> # that what is returned is a reference to said parameter\n"">>> out2 = np.tanh([0.1], out1)\n"">>> out2 is out1\n""True\n""\n"">>> # Example of ValueError due to provision of shape mis-matched `out`\n"">>> np.tanh(np.zeros((3,3)),np.zeros((2,2)))\n""Traceback (most recent call last):\n""  File \"<stdin>\", line 1, in <module>\n""ValueError: invalid return array shape", 0);
    PyDict_SetItemString(dictionary, "tanh", f);
    Py_DECREF(f);
    f = PyUFunc_FromFuncAndData(true_divide_functions, true_divide_data, true_divide_signatures, 21,
                                    2, 1, PyUFunc_None, "true_divide",
                                    "Returns a true division of the inputs, element-wise.\n""\n""Instead of the Python traditional \'floor division\', this returns a true\n""division.  True division adjusts the output type to present the best\n""answer, regardless of input types.\n""\n""Parameters\n""----------\n""x1 : array_like\n""    Dividend array.\n""x2 : array_like\n""    Divisor array.\n""\n""Returns\n""-------\n""out : ndarray\n""    Result is scalar if both inputs are scalar, ndarray otherwise.\n""\n""Notes\n""-----\n""The floor division operator ``//`` was added in Python 2.2 making\n""``//`` and ``/`` equivalent operators.  The default floor division\n""operation of ``/`` can be replaced by true division with ``from\n""__future__ import division``.\n""\n""In Python 3.0, ``//`` is the floor division operator and ``/`` the\n""true division operator.  The ``true_divide(x1, x2)`` function is\n""equivalent to true division in Python.\n""\n""Examples\n""--------\n"">>> x = np.arange(5)\n"">>> np.true_divide(x, 4)\n""array([ 0.  ,  0.25,  0.5 ,  0.75,  1.  ])\n""\n"">>> x/4\n""array([0, 0, 0, 0, 1])\n"">>> x//4\n""array([0, 0, 0, 0, 1])\n""\n"">>> from __future__ import division\n"">>> x/4\n""array([ 0.  ,  0.25,  0.5 ,  0.75,  1.  ])\n"">>> x//4\n""array([0, 0, 0, 0, 1])", 0);
    ((PyUFuncObject *)f)->type_resolver = &PyUFunc_DivisionTypeResolver;
    PyDict_SetItemString(dictionary, "true_divide", f);
    Py_DECREF(f);
    f = PyUFunc_FromFuncAndData(trunc_functions, trunc_data, trunc_signatures, 5,
                                    1, 1, PyUFunc_None, "trunc",
                                    "Return the truncated value of the input, element-wise.\n""\n""The truncated value of the scalar `x` is the nearest integer `i` which\n""is closer to zero than `x` is. In short, the fractional part of the\n""signed number `x` is discarded.\n""\n""Parameters\n""----------\n""x : array_like\n""    Input data.\n""\n""Returns\n""-------\n""y : ndarray or scalar\n""    The truncated value of each element in `x`.\n""\n""See Also\n""--------\n""ceil, floor, rint\n""\n""Notes\n""-----\n"".. versionadded:: 1.3.0\n""\n""Examples\n""--------\n"">>> a = np.array([-1.7, -1.5, -0.2, 0.2, 1.5, 1.7, 2.0])\n"">>> np.trunc(a)\n""array([-1., -1., -0.,  0.,  1.,  1.,  2.])", 0);
    PyDict_SetItemString(dictionary, "trunc", f);
    Py_DECREF(f);
}
