// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: SVM.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "SVM.pb.h"

#include <algorithm>

#include <protobuf/stubs/common.h>
#include <protobuf/stubs/port.h>
#include <protobuf/stubs/once.h>
#include <protobuf/io/coded_stream.h>
#include <protobuf/wire_format_lite_inl.h>
#include <protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)

namespace CoreML {
namespace Specification {

void protobuf_ShutdownFile_SVM_2eproto() {
  LinearKernel_default_instance_.Shutdown();
  RBFKernel_default_instance_.Shutdown();
  PolyKernel_default_instance_.Shutdown();
  SigmoidKernel_default_instance_.Shutdown();
  Kernel_default_instance_.Shutdown();
  SparseNode_default_instance_.Shutdown();
  SparseVector_default_instance_.Shutdown();
  SparseSupportVectors_default_instance_.Shutdown();
  DenseVector_default_instance_.Shutdown();
  DenseSupportVectors_default_instance_.Shutdown();
  Coefficients_default_instance_.Shutdown();
  SupportVectorRegressor_default_instance_.Shutdown();
  SupportVectorClassifier_default_instance_.Shutdown();
}

void protobuf_InitDefaults_SVM_2eproto_impl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::CoreML::Specification::protobuf_InitDefaults_DataStructures_2eproto();
  LinearKernel_default_instance_.DefaultConstruct();
  RBFKernel_default_instance_.DefaultConstruct();
  PolyKernel_default_instance_.DefaultConstruct();
  SigmoidKernel_default_instance_.DefaultConstruct();
  Kernel_default_instance_.DefaultConstruct();
  SparseNode_default_instance_.DefaultConstruct();
  SparseVector_default_instance_.DefaultConstruct();
  SparseSupportVectors_default_instance_.DefaultConstruct();
  DenseVector_default_instance_.DefaultConstruct();
  DenseSupportVectors_default_instance_.DefaultConstruct();
  Coefficients_default_instance_.DefaultConstruct();
  SupportVectorRegressor_default_instance_.DefaultConstruct();
  SupportVectorClassifier_default_instance_.DefaultConstruct();
  LinearKernel_default_instance_.get_mutable()->InitAsDefaultInstance();
  RBFKernel_default_instance_.get_mutable()->InitAsDefaultInstance();
  PolyKernel_default_instance_.get_mutable()->InitAsDefaultInstance();
  SigmoidKernel_default_instance_.get_mutable()->InitAsDefaultInstance();
  Kernel_default_instance_.get_mutable()->InitAsDefaultInstance();
  SparseNode_default_instance_.get_mutable()->InitAsDefaultInstance();
  SparseVector_default_instance_.get_mutable()->InitAsDefaultInstance();
  SparseSupportVectors_default_instance_.get_mutable()->InitAsDefaultInstance();
  DenseVector_default_instance_.get_mutable()->InitAsDefaultInstance();
  DenseSupportVectors_default_instance_.get_mutable()->InitAsDefaultInstance();
  Coefficients_default_instance_.get_mutable()->InitAsDefaultInstance();
  SupportVectorRegressor_default_instance_.get_mutable()->InitAsDefaultInstance();
  SupportVectorClassifier_default_instance_.get_mutable()->InitAsDefaultInstance();
}

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_InitDefaults_SVM_2eproto_once_);
void protobuf_InitDefaults_SVM_2eproto() {
  ::google::protobuf::GoogleOnceInit(&protobuf_InitDefaults_SVM_2eproto_once_,
                 &protobuf_InitDefaults_SVM_2eproto_impl);
}
void protobuf_AddDesc_SVM_2eproto_impl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  protobuf_InitDefaults_SVM_2eproto();
  ::CoreML::Specification::protobuf_AddDesc_DataStructures_2eproto();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_SVM_2eproto);
}

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AddDesc_SVM_2eproto_once_);
void protobuf_AddDesc_SVM_2eproto() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AddDesc_SVM_2eproto_once_,
                 &protobuf_AddDesc_SVM_2eproto_impl);
}
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_SVM_2eproto {
  StaticDescriptorInitializer_SVM_2eproto() {
    protobuf_AddDesc_SVM_2eproto();
  }
} static_descriptor_initializer_SVM_2eproto_;
#endif  // GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER

namespace {

static void MergeFromFail(int line) GOOGLE_ATTRIBUTE_COLD GOOGLE_ATTRIBUTE_NORETURN;
static void MergeFromFail(int line) {
  ::google::protobuf::internal::MergeFromFail(__FILE__, line);
}

}  // namespace


// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

LinearKernel::LinearKernel()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  if (this != internal_default_instance()) protobuf_InitDefaults_SVM_2eproto();
  SharedCtor();
  // @@protoc_insertion_point(constructor:CoreML.Specification.LinearKernel)
}

void LinearKernel::InitAsDefaultInstance() {
}

LinearKernel::LinearKernel(const LinearKernel& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  UnsafeMergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.LinearKernel)
}

void LinearKernel::SharedCtor() {
  _cached_size_ = 0;
}

LinearKernel::~LinearKernel() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.LinearKernel)
  SharedDtor();
}

void LinearKernel::SharedDtor() {
}

void LinearKernel::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const LinearKernel& LinearKernel::default_instance() {
  protobuf_InitDefaults_SVM_2eproto();
  return *internal_default_instance();
}

::google::protobuf::internal::ExplicitlyConstructed<LinearKernel> LinearKernel_default_instance_;

LinearKernel* LinearKernel::New(::google::protobuf::Arena* arena) const {
  LinearKernel* n = new LinearKernel;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void LinearKernel::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.LinearKernel)
}

bool LinearKernel::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CoreML.Specification.LinearKernel)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
  }
success:
  // @@protoc_insertion_point(parse_success:CoreML.Specification.LinearKernel)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CoreML.Specification.LinearKernel)
  return false;
#undef DO_
}

void LinearKernel::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CoreML.Specification.LinearKernel)
  // @@protoc_insertion_point(serialize_end:CoreML.Specification.LinearKernel)
}

size_t LinearKernel::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.LinearKernel)
  size_t total_size = 0;

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LinearKernel::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const LinearKernel*>(&from));
}

void LinearKernel::MergeFrom(const LinearKernel& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.LinearKernel)
  if (GOOGLE_PREDICT_TRUE(&from != this)) {
    UnsafeMergeFrom(from);
  } else {
    MergeFromFail(__LINE__);
  }
}

void LinearKernel::UnsafeMergeFrom(const LinearKernel& from) {
  GOOGLE_DCHECK(&from != this);
}

void LinearKernel::CopyFrom(const LinearKernel& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.LinearKernel)
  if (&from == this) return;
  Clear();
  UnsafeMergeFrom(from);
}

bool LinearKernel::IsInitialized() const {

  return true;
}

void LinearKernel::Swap(LinearKernel* other) {
  if (other == this) return;
  InternalSwap(other);
}
void LinearKernel::InternalSwap(LinearKernel* other) {
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string LinearKernel::GetTypeName() const {
  return "CoreML.Specification.LinearKernel";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// LinearKernel

inline const LinearKernel* LinearKernel::internal_default_instance() {
  return &LinearKernel_default_instance_.get();
}
#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int RBFKernel::kGammaFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

RBFKernel::RBFKernel()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  if (this != internal_default_instance()) protobuf_InitDefaults_SVM_2eproto();
  SharedCtor();
  // @@protoc_insertion_point(constructor:CoreML.Specification.RBFKernel)
}

void RBFKernel::InitAsDefaultInstance() {
}

RBFKernel::RBFKernel(const RBFKernel& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  UnsafeMergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.RBFKernel)
}

void RBFKernel::SharedCtor() {
  gamma_ = 0;
  _cached_size_ = 0;
}

RBFKernel::~RBFKernel() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.RBFKernel)
  SharedDtor();
}

void RBFKernel::SharedDtor() {
}

void RBFKernel::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RBFKernel& RBFKernel::default_instance() {
  protobuf_InitDefaults_SVM_2eproto();
  return *internal_default_instance();
}

::google::protobuf::internal::ExplicitlyConstructed<RBFKernel> RBFKernel_default_instance_;

RBFKernel* RBFKernel::New(::google::protobuf::Arena* arena) const {
  RBFKernel* n = new RBFKernel;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void RBFKernel::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.RBFKernel)
  gamma_ = 0;
}

bool RBFKernel::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CoreML.Specification.RBFKernel)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional double gamma = 1;
      case 1: {
        if (tag == 9) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &gamma_)));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CoreML.Specification.RBFKernel)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CoreML.Specification.RBFKernel)
  return false;
#undef DO_
}

void RBFKernel::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CoreML.Specification.RBFKernel)
  // optional double gamma = 1;
  if (this->gamma() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(1, this->gamma(), output);
  }

  // @@protoc_insertion_point(serialize_end:CoreML.Specification.RBFKernel)
}

size_t RBFKernel::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.RBFKernel)
  size_t total_size = 0;

  // optional double gamma = 1;
  if (this->gamma() != 0) {
    total_size += 1 + 8;
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RBFKernel::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RBFKernel*>(&from));
}

void RBFKernel::MergeFrom(const RBFKernel& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.RBFKernel)
  if (GOOGLE_PREDICT_TRUE(&from != this)) {
    UnsafeMergeFrom(from);
  } else {
    MergeFromFail(__LINE__);
  }
}

void RBFKernel::UnsafeMergeFrom(const RBFKernel& from) {
  GOOGLE_DCHECK(&from != this);
  if (from.gamma() != 0) {
    set_gamma(from.gamma());
  }
}

void RBFKernel::CopyFrom(const RBFKernel& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.RBFKernel)
  if (&from == this) return;
  Clear();
  UnsafeMergeFrom(from);
}

bool RBFKernel::IsInitialized() const {

  return true;
}

void RBFKernel::Swap(RBFKernel* other) {
  if (other == this) return;
  InternalSwap(other);
}
void RBFKernel::InternalSwap(RBFKernel* other) {
  std::swap(gamma_, other->gamma_);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string RBFKernel::GetTypeName() const {
  return "CoreML.Specification.RBFKernel";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// RBFKernel

// optional double gamma = 1;
void RBFKernel::clear_gamma() {
  gamma_ = 0;
}
double RBFKernel::gamma() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.RBFKernel.gamma)
  return gamma_;
}
void RBFKernel::set_gamma(double value) {
  
  gamma_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.RBFKernel.gamma)
}

inline const RBFKernel* RBFKernel::internal_default_instance() {
  return &RBFKernel_default_instance_.get();
}
#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int PolyKernel::kDegreeFieldNumber;
const int PolyKernel::kCFieldNumber;
const int PolyKernel::kGammaFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

PolyKernel::PolyKernel()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  if (this != internal_default_instance()) protobuf_InitDefaults_SVM_2eproto();
  SharedCtor();
  // @@protoc_insertion_point(constructor:CoreML.Specification.PolyKernel)
}

void PolyKernel::InitAsDefaultInstance() {
}

PolyKernel::PolyKernel(const PolyKernel& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  UnsafeMergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.PolyKernel)
}

void PolyKernel::SharedCtor() {
  ::memset(&c_, 0, reinterpret_cast<char*>(&degree_) -
    reinterpret_cast<char*>(&c_) + sizeof(degree_));
  _cached_size_ = 0;
}

PolyKernel::~PolyKernel() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.PolyKernel)
  SharedDtor();
}

void PolyKernel::SharedDtor() {
}

void PolyKernel::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const PolyKernel& PolyKernel::default_instance() {
  protobuf_InitDefaults_SVM_2eproto();
  return *internal_default_instance();
}

::google::protobuf::internal::ExplicitlyConstructed<PolyKernel> PolyKernel_default_instance_;

PolyKernel* PolyKernel::New(::google::protobuf::Arena* arena) const {
  PolyKernel* n = new PolyKernel;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void PolyKernel::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.PolyKernel)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(PolyKernel, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<PolyKernel*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&(first), 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(c_, degree_);

#undef ZR_HELPER_
#undef ZR_

}

bool PolyKernel::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CoreML.Specification.PolyKernel)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 degree = 1;
      case 1: {
        if (tag == 8) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &degree_)));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(17)) goto parse_c;
        break;
      }

      // optional double c = 2;
      case 2: {
        if (tag == 17) {
         parse_c:

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &c_)));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(25)) goto parse_gamma;
        break;
      }

      // optional double gamma = 3;
      case 3: {
        if (tag == 25) {
         parse_gamma:

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &gamma_)));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CoreML.Specification.PolyKernel)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CoreML.Specification.PolyKernel)
  return false;
#undef DO_
}

void PolyKernel::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CoreML.Specification.PolyKernel)
  // optional int32 degree = 1;
  if (this->degree() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->degree(), output);
  }

  // optional double c = 2;
  if (this->c() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->c(), output);
  }

  // optional double gamma = 3;
  if (this->gamma() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(3, this->gamma(), output);
  }

  // @@protoc_insertion_point(serialize_end:CoreML.Specification.PolyKernel)
}

size_t PolyKernel::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.PolyKernel)
  size_t total_size = 0;

  // optional int32 degree = 1;
  if (this->degree() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->degree());
  }

  // optional double c = 2;
  if (this->c() != 0) {
    total_size += 1 + 8;
  }

  // optional double gamma = 3;
  if (this->gamma() != 0) {
    total_size += 1 + 8;
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PolyKernel::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const PolyKernel*>(&from));
}

void PolyKernel::MergeFrom(const PolyKernel& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.PolyKernel)
  if (GOOGLE_PREDICT_TRUE(&from != this)) {
    UnsafeMergeFrom(from);
  } else {
    MergeFromFail(__LINE__);
  }
}

void PolyKernel::UnsafeMergeFrom(const PolyKernel& from) {
  GOOGLE_DCHECK(&from != this);
  if (from.degree() != 0) {
    set_degree(from.degree());
  }
  if (from.c() != 0) {
    set_c(from.c());
  }
  if (from.gamma() != 0) {
    set_gamma(from.gamma());
  }
}

void PolyKernel::CopyFrom(const PolyKernel& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.PolyKernel)
  if (&from == this) return;
  Clear();
  UnsafeMergeFrom(from);
}

bool PolyKernel::IsInitialized() const {

  return true;
}

void PolyKernel::Swap(PolyKernel* other) {
  if (other == this) return;
  InternalSwap(other);
}
void PolyKernel::InternalSwap(PolyKernel* other) {
  std::swap(degree_, other->degree_);
  std::swap(c_, other->c_);
  std::swap(gamma_, other->gamma_);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string PolyKernel::GetTypeName() const {
  return "CoreML.Specification.PolyKernel";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// PolyKernel

// optional int32 degree = 1;
void PolyKernel::clear_degree() {
  degree_ = 0;
}
::google::protobuf::int32 PolyKernel::degree() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.PolyKernel.degree)
  return degree_;
}
void PolyKernel::set_degree(::google::protobuf::int32 value) {
  
  degree_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.PolyKernel.degree)
}

// optional double c = 2;
void PolyKernel::clear_c() {
  c_ = 0;
}
double PolyKernel::c() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.PolyKernel.c)
  return c_;
}
void PolyKernel::set_c(double value) {
  
  c_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.PolyKernel.c)
}

// optional double gamma = 3;
void PolyKernel::clear_gamma() {
  gamma_ = 0;
}
double PolyKernel::gamma() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.PolyKernel.gamma)
  return gamma_;
}
void PolyKernel::set_gamma(double value) {
  
  gamma_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.PolyKernel.gamma)
}

inline const PolyKernel* PolyKernel::internal_default_instance() {
  return &PolyKernel_default_instance_.get();
}
#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int SigmoidKernel::kGammaFieldNumber;
const int SigmoidKernel::kCFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

SigmoidKernel::SigmoidKernel()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  if (this != internal_default_instance()) protobuf_InitDefaults_SVM_2eproto();
  SharedCtor();
  // @@protoc_insertion_point(constructor:CoreML.Specification.SigmoidKernel)
}

void SigmoidKernel::InitAsDefaultInstance() {
}

SigmoidKernel::SigmoidKernel(const SigmoidKernel& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  UnsafeMergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.SigmoidKernel)
}

void SigmoidKernel::SharedCtor() {
  ::memset(&gamma_, 0, reinterpret_cast<char*>(&c_) -
    reinterpret_cast<char*>(&gamma_) + sizeof(c_));
  _cached_size_ = 0;
}

SigmoidKernel::~SigmoidKernel() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.SigmoidKernel)
  SharedDtor();
}

void SigmoidKernel::SharedDtor() {
}

void SigmoidKernel::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const SigmoidKernel& SigmoidKernel::default_instance() {
  protobuf_InitDefaults_SVM_2eproto();
  return *internal_default_instance();
}

::google::protobuf::internal::ExplicitlyConstructed<SigmoidKernel> SigmoidKernel_default_instance_;

SigmoidKernel* SigmoidKernel::New(::google::protobuf::Arena* arena) const {
  SigmoidKernel* n = new SigmoidKernel;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void SigmoidKernel::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.SigmoidKernel)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(SigmoidKernel, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<SigmoidKernel*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&(first), 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(gamma_, c_);

#undef ZR_HELPER_
#undef ZR_

}

bool SigmoidKernel::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CoreML.Specification.SigmoidKernel)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional double gamma = 1;
      case 1: {
        if (tag == 9) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &gamma_)));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(17)) goto parse_c;
        break;
      }

      // optional double c = 2;
      case 2: {
        if (tag == 17) {
         parse_c:

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &c_)));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CoreML.Specification.SigmoidKernel)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CoreML.Specification.SigmoidKernel)
  return false;
#undef DO_
}

void SigmoidKernel::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CoreML.Specification.SigmoidKernel)
  // optional double gamma = 1;
  if (this->gamma() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(1, this->gamma(), output);
  }

  // optional double c = 2;
  if (this->c() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->c(), output);
  }

  // @@protoc_insertion_point(serialize_end:CoreML.Specification.SigmoidKernel)
}

size_t SigmoidKernel::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.SigmoidKernel)
  size_t total_size = 0;

  // optional double gamma = 1;
  if (this->gamma() != 0) {
    total_size += 1 + 8;
  }

  // optional double c = 2;
  if (this->c() != 0) {
    total_size += 1 + 8;
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SigmoidKernel::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const SigmoidKernel*>(&from));
}

void SigmoidKernel::MergeFrom(const SigmoidKernel& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.SigmoidKernel)
  if (GOOGLE_PREDICT_TRUE(&from != this)) {
    UnsafeMergeFrom(from);
  } else {
    MergeFromFail(__LINE__);
  }
}

void SigmoidKernel::UnsafeMergeFrom(const SigmoidKernel& from) {
  GOOGLE_DCHECK(&from != this);
  if (from.gamma() != 0) {
    set_gamma(from.gamma());
  }
  if (from.c() != 0) {
    set_c(from.c());
  }
}

void SigmoidKernel::CopyFrom(const SigmoidKernel& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.SigmoidKernel)
  if (&from == this) return;
  Clear();
  UnsafeMergeFrom(from);
}

bool SigmoidKernel::IsInitialized() const {

  return true;
}

void SigmoidKernel::Swap(SigmoidKernel* other) {
  if (other == this) return;
  InternalSwap(other);
}
void SigmoidKernel::InternalSwap(SigmoidKernel* other) {
  std::swap(gamma_, other->gamma_);
  std::swap(c_, other->c_);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string SigmoidKernel::GetTypeName() const {
  return "CoreML.Specification.SigmoidKernel";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// SigmoidKernel

// optional double gamma = 1;
void SigmoidKernel::clear_gamma() {
  gamma_ = 0;
}
double SigmoidKernel::gamma() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.SigmoidKernel.gamma)
  return gamma_;
}
void SigmoidKernel::set_gamma(double value) {
  
  gamma_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.SigmoidKernel.gamma)
}

// optional double c = 2;
void SigmoidKernel::clear_c() {
  c_ = 0;
}
double SigmoidKernel::c() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.SigmoidKernel.c)
  return c_;
}
void SigmoidKernel::set_c(double value) {
  
  c_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.SigmoidKernel.c)
}

inline const SigmoidKernel* SigmoidKernel::internal_default_instance() {
  return &SigmoidKernel_default_instance_.get();
}
#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Kernel::kLinearKernelFieldNumber;
const int Kernel::kRbfKernelFieldNumber;
const int Kernel::kPolyKernelFieldNumber;
const int Kernel::kSigmoidKernelFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Kernel::Kernel()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  if (this != internal_default_instance()) protobuf_InitDefaults_SVM_2eproto();
  SharedCtor();
  // @@protoc_insertion_point(constructor:CoreML.Specification.Kernel)
}

void Kernel::InitAsDefaultInstance() {
}

Kernel::Kernel(const Kernel& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  UnsafeMergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.Kernel)
}

void Kernel::SharedCtor() {
  clear_has_kernel();
  _cached_size_ = 0;
}

Kernel::~Kernel() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.Kernel)
  SharedDtor();
}

void Kernel::SharedDtor() {
  if (has_kernel()) {
    clear_kernel();
  }
}

void Kernel::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Kernel& Kernel::default_instance() {
  protobuf_InitDefaults_SVM_2eproto();
  return *internal_default_instance();
}

::google::protobuf::internal::ExplicitlyConstructed<Kernel> Kernel_default_instance_;

Kernel* Kernel::New(::google::protobuf::Arena* arena) const {
  Kernel* n = new Kernel;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Kernel::clear_kernel() {
// @@protoc_insertion_point(one_of_clear_start:CoreML.Specification.Kernel)
  switch (kernel_case()) {
    case kLinearKernel: {
      delete kernel_.linearkernel_;
      break;
    }
    case kRbfKernel: {
      delete kernel_.rbfkernel_;
      break;
    }
    case kPolyKernel: {
      delete kernel_.polykernel_;
      break;
    }
    case kSigmoidKernel: {
      delete kernel_.sigmoidkernel_;
      break;
    }
    case KERNEL_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = KERNEL_NOT_SET;
}


void Kernel::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.Kernel)
  clear_kernel();
}

bool Kernel::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CoreML.Specification.Kernel)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .CoreML.Specification.LinearKernel linearKernel = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_linearkernel()));
        } else {
          goto handle_unusual;
        }
        goto after_sigmoidkernel;
        break;
      }

      // optional .CoreML.Specification.RBFKernel rbfKernel = 2;
      case 2: {
        if (tag == 18) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_rbfkernel()));
        } else {
          goto handle_unusual;
        }
        goto after_sigmoidkernel;
        break;
      }

      // optional .CoreML.Specification.PolyKernel polyKernel = 3;
      case 3: {
        if (tag == 26) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_polykernel()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_sigmoidKernel;
        break;
      }

      // optional .CoreML.Specification.SigmoidKernel sigmoidKernel = 4;
      case 4: {
        if (tag == 34) {
         parse_sigmoidKernel:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_sigmoidkernel()));
        } else {
          goto handle_unusual;
        }
       after_sigmoidkernel:
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CoreML.Specification.Kernel)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CoreML.Specification.Kernel)
  return false;
#undef DO_
}

void Kernel::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CoreML.Specification.Kernel)
  // optional .CoreML.Specification.LinearKernel linearKernel = 1;
  if (has_linearkernel()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, *kernel_.linearkernel_, output);
  }

  // optional .CoreML.Specification.RBFKernel rbfKernel = 2;
  if (has_rbfkernel()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, *kernel_.rbfkernel_, output);
  }

  // optional .CoreML.Specification.PolyKernel polyKernel = 3;
  if (has_polykernel()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, *kernel_.polykernel_, output);
  }

  // optional .CoreML.Specification.SigmoidKernel sigmoidKernel = 4;
  if (has_sigmoidkernel()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4, *kernel_.sigmoidkernel_, output);
  }

  // @@protoc_insertion_point(serialize_end:CoreML.Specification.Kernel)
}

size_t Kernel::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.Kernel)
  size_t total_size = 0;

  switch (kernel_case()) {
    // optional .CoreML.Specification.LinearKernel linearKernel = 1;
    case kLinearKernel: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *kernel_.linearkernel_);
      break;
    }
    // optional .CoreML.Specification.RBFKernel rbfKernel = 2;
    case kRbfKernel: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *kernel_.rbfkernel_);
      break;
    }
    // optional .CoreML.Specification.PolyKernel polyKernel = 3;
    case kPolyKernel: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *kernel_.polykernel_);
      break;
    }
    // optional .CoreML.Specification.SigmoidKernel sigmoidKernel = 4;
    case kSigmoidKernel: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *kernel_.sigmoidkernel_);
      break;
    }
    case KERNEL_NOT_SET: {
      break;
    }
  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Kernel::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Kernel*>(&from));
}

void Kernel::MergeFrom(const Kernel& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.Kernel)
  if (GOOGLE_PREDICT_TRUE(&from != this)) {
    UnsafeMergeFrom(from);
  } else {
    MergeFromFail(__LINE__);
  }
}

void Kernel::UnsafeMergeFrom(const Kernel& from) {
  GOOGLE_DCHECK(&from != this);
  switch (from.kernel_case()) {
    case kLinearKernel: {
      mutable_linearkernel()->::CoreML::Specification::LinearKernel::MergeFrom(from.linearkernel());
      break;
    }
    case kRbfKernel: {
      mutable_rbfkernel()->::CoreML::Specification::RBFKernel::MergeFrom(from.rbfkernel());
      break;
    }
    case kPolyKernel: {
      mutable_polykernel()->::CoreML::Specification::PolyKernel::MergeFrom(from.polykernel());
      break;
    }
    case kSigmoidKernel: {
      mutable_sigmoidkernel()->::CoreML::Specification::SigmoidKernel::MergeFrom(from.sigmoidkernel());
      break;
    }
    case KERNEL_NOT_SET: {
      break;
    }
  }
}

void Kernel::CopyFrom(const Kernel& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.Kernel)
  if (&from == this) return;
  Clear();
  UnsafeMergeFrom(from);
}

bool Kernel::IsInitialized() const {

  return true;
}

void Kernel::Swap(Kernel* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Kernel::InternalSwap(Kernel* other) {
  std::swap(kernel_, other->kernel_);
  std::swap(_oneof_case_[0], other->_oneof_case_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string Kernel::GetTypeName() const {
  return "CoreML.Specification.Kernel";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Kernel

// optional .CoreML.Specification.LinearKernel linearKernel = 1;
bool Kernel::has_linearkernel() const {
  return kernel_case() == kLinearKernel;
}
void Kernel::set_has_linearkernel() {
  _oneof_case_[0] = kLinearKernel;
}
void Kernel::clear_linearkernel() {
  if (has_linearkernel()) {
    delete kernel_.linearkernel_;
    clear_has_kernel();
  }
}
 const ::CoreML::Specification::LinearKernel& Kernel::linearkernel() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.Kernel.linearKernel)
  return has_linearkernel()
      ? *kernel_.linearkernel_
      : ::CoreML::Specification::LinearKernel::default_instance();
}
::CoreML::Specification::LinearKernel* Kernel::mutable_linearkernel() {
  if (!has_linearkernel()) {
    clear_kernel();
    set_has_linearkernel();
    kernel_.linearkernel_ = new ::CoreML::Specification::LinearKernel;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.Kernel.linearKernel)
  return kernel_.linearkernel_;
}
::CoreML::Specification::LinearKernel* Kernel::release_linearkernel() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.Kernel.linearKernel)
  if (has_linearkernel()) {
    clear_has_kernel();
    ::CoreML::Specification::LinearKernel* temp = kernel_.linearkernel_;
    kernel_.linearkernel_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void Kernel::set_allocated_linearkernel(::CoreML::Specification::LinearKernel* linearkernel) {
  clear_kernel();
  if (linearkernel) {
    set_has_linearkernel();
    kernel_.linearkernel_ = linearkernel;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.Kernel.linearKernel)
}

// optional .CoreML.Specification.RBFKernel rbfKernel = 2;
bool Kernel::has_rbfkernel() const {
  return kernel_case() == kRbfKernel;
}
void Kernel::set_has_rbfkernel() {
  _oneof_case_[0] = kRbfKernel;
}
void Kernel::clear_rbfkernel() {
  if (has_rbfkernel()) {
    delete kernel_.rbfkernel_;
    clear_has_kernel();
  }
}
 const ::CoreML::Specification::RBFKernel& Kernel::rbfkernel() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.Kernel.rbfKernel)
  return has_rbfkernel()
      ? *kernel_.rbfkernel_
      : ::CoreML::Specification::RBFKernel::default_instance();
}
::CoreML::Specification::RBFKernel* Kernel::mutable_rbfkernel() {
  if (!has_rbfkernel()) {
    clear_kernel();
    set_has_rbfkernel();
    kernel_.rbfkernel_ = new ::CoreML::Specification::RBFKernel;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.Kernel.rbfKernel)
  return kernel_.rbfkernel_;
}
::CoreML::Specification::RBFKernel* Kernel::release_rbfkernel() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.Kernel.rbfKernel)
  if (has_rbfkernel()) {
    clear_has_kernel();
    ::CoreML::Specification::RBFKernel* temp = kernel_.rbfkernel_;
    kernel_.rbfkernel_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void Kernel::set_allocated_rbfkernel(::CoreML::Specification::RBFKernel* rbfkernel) {
  clear_kernel();
  if (rbfkernel) {
    set_has_rbfkernel();
    kernel_.rbfkernel_ = rbfkernel;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.Kernel.rbfKernel)
}

// optional .CoreML.Specification.PolyKernel polyKernel = 3;
bool Kernel::has_polykernel() const {
  return kernel_case() == kPolyKernel;
}
void Kernel::set_has_polykernel() {
  _oneof_case_[0] = kPolyKernel;
}
void Kernel::clear_polykernel() {
  if (has_polykernel()) {
    delete kernel_.polykernel_;
    clear_has_kernel();
  }
}
 const ::CoreML::Specification::PolyKernel& Kernel::polykernel() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.Kernel.polyKernel)
  return has_polykernel()
      ? *kernel_.polykernel_
      : ::CoreML::Specification::PolyKernel::default_instance();
}
::CoreML::Specification::PolyKernel* Kernel::mutable_polykernel() {
  if (!has_polykernel()) {
    clear_kernel();
    set_has_polykernel();
    kernel_.polykernel_ = new ::CoreML::Specification::PolyKernel;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.Kernel.polyKernel)
  return kernel_.polykernel_;
}
::CoreML::Specification::PolyKernel* Kernel::release_polykernel() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.Kernel.polyKernel)
  if (has_polykernel()) {
    clear_has_kernel();
    ::CoreML::Specification::PolyKernel* temp = kernel_.polykernel_;
    kernel_.polykernel_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void Kernel::set_allocated_polykernel(::CoreML::Specification::PolyKernel* polykernel) {
  clear_kernel();
  if (polykernel) {
    set_has_polykernel();
    kernel_.polykernel_ = polykernel;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.Kernel.polyKernel)
}

// optional .CoreML.Specification.SigmoidKernel sigmoidKernel = 4;
bool Kernel::has_sigmoidkernel() const {
  return kernel_case() == kSigmoidKernel;
}
void Kernel::set_has_sigmoidkernel() {
  _oneof_case_[0] = kSigmoidKernel;
}
void Kernel::clear_sigmoidkernel() {
  if (has_sigmoidkernel()) {
    delete kernel_.sigmoidkernel_;
    clear_has_kernel();
  }
}
 const ::CoreML::Specification::SigmoidKernel& Kernel::sigmoidkernel() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.Kernel.sigmoidKernel)
  return has_sigmoidkernel()
      ? *kernel_.sigmoidkernel_
      : ::CoreML::Specification::SigmoidKernel::default_instance();
}
::CoreML::Specification::SigmoidKernel* Kernel::mutable_sigmoidkernel() {
  if (!has_sigmoidkernel()) {
    clear_kernel();
    set_has_sigmoidkernel();
    kernel_.sigmoidkernel_ = new ::CoreML::Specification::SigmoidKernel;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.Kernel.sigmoidKernel)
  return kernel_.sigmoidkernel_;
}
::CoreML::Specification::SigmoidKernel* Kernel::release_sigmoidkernel() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.Kernel.sigmoidKernel)
  if (has_sigmoidkernel()) {
    clear_has_kernel();
    ::CoreML::Specification::SigmoidKernel* temp = kernel_.sigmoidkernel_;
    kernel_.sigmoidkernel_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void Kernel::set_allocated_sigmoidkernel(::CoreML::Specification::SigmoidKernel* sigmoidkernel) {
  clear_kernel();
  if (sigmoidkernel) {
    set_has_sigmoidkernel();
    kernel_.sigmoidkernel_ = sigmoidkernel;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.Kernel.sigmoidKernel)
}

bool Kernel::has_kernel() const {
  return kernel_case() != KERNEL_NOT_SET;
}
void Kernel::clear_has_kernel() {
  _oneof_case_[0] = KERNEL_NOT_SET;
}
Kernel::KernelCase Kernel::kernel_case() const {
  return Kernel::KernelCase(_oneof_case_[0]);
}
inline const Kernel* Kernel::internal_default_instance() {
  return &Kernel_default_instance_.get();
}
#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int SparseNode::kIndexFieldNumber;
const int SparseNode::kValueFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

SparseNode::SparseNode()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  if (this != internal_default_instance()) protobuf_InitDefaults_SVM_2eproto();
  SharedCtor();
  // @@protoc_insertion_point(constructor:CoreML.Specification.SparseNode)
}

void SparseNode::InitAsDefaultInstance() {
}

SparseNode::SparseNode(const SparseNode& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  UnsafeMergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.SparseNode)
}

void SparseNode::SharedCtor() {
  ::memset(&value_, 0, reinterpret_cast<char*>(&index_) -
    reinterpret_cast<char*>(&value_) + sizeof(index_));
  _cached_size_ = 0;
}

SparseNode::~SparseNode() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.SparseNode)
  SharedDtor();
}

void SparseNode::SharedDtor() {
}

void SparseNode::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const SparseNode& SparseNode::default_instance() {
  protobuf_InitDefaults_SVM_2eproto();
  return *internal_default_instance();
}

::google::protobuf::internal::ExplicitlyConstructed<SparseNode> SparseNode_default_instance_;

SparseNode* SparseNode::New(::google::protobuf::Arena* arena) const {
  SparseNode* n = new SparseNode;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void SparseNode::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.SparseNode)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(SparseNode, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<SparseNode*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&(first), 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(value_, index_);

#undef ZR_HELPER_
#undef ZR_

}

bool SparseNode::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CoreML.Specification.SparseNode)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 index = 1;
      case 1: {
        if (tag == 8) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &index_)));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(17)) goto parse_value;
        break;
      }

      // optional double value = 2;
      case 2: {
        if (tag == 17) {
         parse_value:

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &value_)));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CoreML.Specification.SparseNode)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CoreML.Specification.SparseNode)
  return false;
#undef DO_
}

void SparseNode::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CoreML.Specification.SparseNode)
  // optional int32 index = 1;
  if (this->index() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->index(), output);
  }

  // optional double value = 2;
  if (this->value() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->value(), output);
  }

  // @@protoc_insertion_point(serialize_end:CoreML.Specification.SparseNode)
}

size_t SparseNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.SparseNode)
  size_t total_size = 0;

  // optional int32 index = 1;
  if (this->index() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->index());
  }

  // optional double value = 2;
  if (this->value() != 0) {
    total_size += 1 + 8;
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SparseNode::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const SparseNode*>(&from));
}

void SparseNode::MergeFrom(const SparseNode& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.SparseNode)
  if (GOOGLE_PREDICT_TRUE(&from != this)) {
    UnsafeMergeFrom(from);
  } else {
    MergeFromFail(__LINE__);
  }
}

void SparseNode::UnsafeMergeFrom(const SparseNode& from) {
  GOOGLE_DCHECK(&from != this);
  if (from.index() != 0) {
    set_index(from.index());
  }
  if (from.value() != 0) {
    set_value(from.value());
  }
}

void SparseNode::CopyFrom(const SparseNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.SparseNode)
  if (&from == this) return;
  Clear();
  UnsafeMergeFrom(from);
}

bool SparseNode::IsInitialized() const {

  return true;
}

void SparseNode::Swap(SparseNode* other) {
  if (other == this) return;
  InternalSwap(other);
}
void SparseNode::InternalSwap(SparseNode* other) {
  std::swap(index_, other->index_);
  std::swap(value_, other->value_);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string SparseNode::GetTypeName() const {
  return "CoreML.Specification.SparseNode";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// SparseNode

// optional int32 index = 1;
void SparseNode::clear_index() {
  index_ = 0;
}
::google::protobuf::int32 SparseNode::index() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.SparseNode.index)
  return index_;
}
void SparseNode::set_index(::google::protobuf::int32 value) {
  
  index_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.SparseNode.index)
}

// optional double value = 2;
void SparseNode::clear_value() {
  value_ = 0;
}
double SparseNode::value() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.SparseNode.value)
  return value_;
}
void SparseNode::set_value(double value) {
  
  value_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.SparseNode.value)
}

inline const SparseNode* SparseNode::internal_default_instance() {
  return &SparseNode_default_instance_.get();
}
#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int SparseVector::kNodesFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

SparseVector::SparseVector()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  if (this != internal_default_instance()) protobuf_InitDefaults_SVM_2eproto();
  SharedCtor();
  // @@protoc_insertion_point(constructor:CoreML.Specification.SparseVector)
}

void SparseVector::InitAsDefaultInstance() {
}

SparseVector::SparseVector(const SparseVector& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  UnsafeMergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.SparseVector)
}

void SparseVector::SharedCtor() {
  _cached_size_ = 0;
}

SparseVector::~SparseVector() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.SparseVector)
  SharedDtor();
}

void SparseVector::SharedDtor() {
}

void SparseVector::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const SparseVector& SparseVector::default_instance() {
  protobuf_InitDefaults_SVM_2eproto();
  return *internal_default_instance();
}

::google::protobuf::internal::ExplicitlyConstructed<SparseVector> SparseVector_default_instance_;

SparseVector* SparseVector::New(::google::protobuf::Arena* arena) const {
  SparseVector* n = new SparseVector;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void SparseVector::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.SparseVector)
  nodes_.Clear();
}

bool SparseVector::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CoreML.Specification.SparseVector)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .CoreML.Specification.SparseNode nodes = 1;
      case 1: {
        if (tag == 10) {
          DO_(input->IncrementRecursionDepth());
         parse_loop_nodes:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_nodes()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_loop_nodes;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CoreML.Specification.SparseVector)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CoreML.Specification.SparseVector)
  return false;
#undef DO_
}

void SparseVector::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CoreML.Specification.SparseVector)
  // repeated .CoreML.Specification.SparseNode nodes = 1;
  for (unsigned int i = 0, n = this->nodes_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->nodes(i), output);
  }

  // @@protoc_insertion_point(serialize_end:CoreML.Specification.SparseVector)
}

size_t SparseVector::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.SparseVector)
  size_t total_size = 0;

  // repeated .CoreML.Specification.SparseNode nodes = 1;
  {
    unsigned int count = this->nodes_size();
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->nodes(i));
    }
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SparseVector::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const SparseVector*>(&from));
}

void SparseVector::MergeFrom(const SparseVector& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.SparseVector)
  if (GOOGLE_PREDICT_TRUE(&from != this)) {
    UnsafeMergeFrom(from);
  } else {
    MergeFromFail(__LINE__);
  }
}

void SparseVector::UnsafeMergeFrom(const SparseVector& from) {
  GOOGLE_DCHECK(&from != this);
  nodes_.MergeFrom(from.nodes_);
}

void SparseVector::CopyFrom(const SparseVector& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.SparseVector)
  if (&from == this) return;
  Clear();
  UnsafeMergeFrom(from);
}

bool SparseVector::IsInitialized() const {

  return true;
}

void SparseVector::Swap(SparseVector* other) {
  if (other == this) return;
  InternalSwap(other);
}
void SparseVector::InternalSwap(SparseVector* other) {
  nodes_.UnsafeArenaSwap(&other->nodes_);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string SparseVector::GetTypeName() const {
  return "CoreML.Specification.SparseVector";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// SparseVector

// repeated .CoreML.Specification.SparseNode nodes = 1;
int SparseVector::nodes_size() const {
  return nodes_.size();
}
void SparseVector::clear_nodes() {
  nodes_.Clear();
}
const ::CoreML::Specification::SparseNode& SparseVector::nodes(int index) const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.SparseVector.nodes)
  return nodes_.Get(index);
}
::CoreML::Specification::SparseNode* SparseVector::mutable_nodes(int index) {
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.SparseVector.nodes)
  return nodes_.Mutable(index);
}
::CoreML::Specification::SparseNode* SparseVector::add_nodes() {
  // @@protoc_insertion_point(field_add:CoreML.Specification.SparseVector.nodes)
  return nodes_.Add();
}
::google::protobuf::RepeatedPtrField< ::CoreML::Specification::SparseNode >*
SparseVector::mutable_nodes() {
  // @@protoc_insertion_point(field_mutable_list:CoreML.Specification.SparseVector.nodes)
  return &nodes_;
}
const ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::SparseNode >&
SparseVector::nodes() const {
  // @@protoc_insertion_point(field_list:CoreML.Specification.SparseVector.nodes)
  return nodes_;
}

inline const SparseVector* SparseVector::internal_default_instance() {
  return &SparseVector_default_instance_.get();
}
#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int SparseSupportVectors::kVectorsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

SparseSupportVectors::SparseSupportVectors()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  if (this != internal_default_instance()) protobuf_InitDefaults_SVM_2eproto();
  SharedCtor();
  // @@protoc_insertion_point(constructor:CoreML.Specification.SparseSupportVectors)
}

void SparseSupportVectors::InitAsDefaultInstance() {
}

SparseSupportVectors::SparseSupportVectors(const SparseSupportVectors& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  UnsafeMergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.SparseSupportVectors)
}

void SparseSupportVectors::SharedCtor() {
  _cached_size_ = 0;
}

SparseSupportVectors::~SparseSupportVectors() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.SparseSupportVectors)
  SharedDtor();
}

void SparseSupportVectors::SharedDtor() {
}

void SparseSupportVectors::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const SparseSupportVectors& SparseSupportVectors::default_instance() {
  protobuf_InitDefaults_SVM_2eproto();
  return *internal_default_instance();
}

::google::protobuf::internal::ExplicitlyConstructed<SparseSupportVectors> SparseSupportVectors_default_instance_;

SparseSupportVectors* SparseSupportVectors::New(::google::protobuf::Arena* arena) const {
  SparseSupportVectors* n = new SparseSupportVectors;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void SparseSupportVectors::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.SparseSupportVectors)
  vectors_.Clear();
}

bool SparseSupportVectors::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CoreML.Specification.SparseSupportVectors)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .CoreML.Specification.SparseVector vectors = 1;
      case 1: {
        if (tag == 10) {
          DO_(input->IncrementRecursionDepth());
         parse_loop_vectors:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_vectors()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_loop_vectors;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CoreML.Specification.SparseSupportVectors)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CoreML.Specification.SparseSupportVectors)
  return false;
#undef DO_
}

void SparseSupportVectors::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CoreML.Specification.SparseSupportVectors)
  // repeated .CoreML.Specification.SparseVector vectors = 1;
  for (unsigned int i = 0, n = this->vectors_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->vectors(i), output);
  }

  // @@protoc_insertion_point(serialize_end:CoreML.Specification.SparseSupportVectors)
}

size_t SparseSupportVectors::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.SparseSupportVectors)
  size_t total_size = 0;

  // repeated .CoreML.Specification.SparseVector vectors = 1;
  {
    unsigned int count = this->vectors_size();
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->vectors(i));
    }
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SparseSupportVectors::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const SparseSupportVectors*>(&from));
}

void SparseSupportVectors::MergeFrom(const SparseSupportVectors& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.SparseSupportVectors)
  if (GOOGLE_PREDICT_TRUE(&from != this)) {
    UnsafeMergeFrom(from);
  } else {
    MergeFromFail(__LINE__);
  }
}

void SparseSupportVectors::UnsafeMergeFrom(const SparseSupportVectors& from) {
  GOOGLE_DCHECK(&from != this);
  vectors_.MergeFrom(from.vectors_);
}

void SparseSupportVectors::CopyFrom(const SparseSupportVectors& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.SparseSupportVectors)
  if (&from == this) return;
  Clear();
  UnsafeMergeFrom(from);
}

bool SparseSupportVectors::IsInitialized() const {

  return true;
}

void SparseSupportVectors::Swap(SparseSupportVectors* other) {
  if (other == this) return;
  InternalSwap(other);
}
void SparseSupportVectors::InternalSwap(SparseSupportVectors* other) {
  vectors_.UnsafeArenaSwap(&other->vectors_);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string SparseSupportVectors::GetTypeName() const {
  return "CoreML.Specification.SparseSupportVectors";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// SparseSupportVectors

// repeated .CoreML.Specification.SparseVector vectors = 1;
int SparseSupportVectors::vectors_size() const {
  return vectors_.size();
}
void SparseSupportVectors::clear_vectors() {
  vectors_.Clear();
}
const ::CoreML::Specification::SparseVector& SparseSupportVectors::vectors(int index) const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.SparseSupportVectors.vectors)
  return vectors_.Get(index);
}
::CoreML::Specification::SparseVector* SparseSupportVectors::mutable_vectors(int index) {
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.SparseSupportVectors.vectors)
  return vectors_.Mutable(index);
}
::CoreML::Specification::SparseVector* SparseSupportVectors::add_vectors() {
  // @@protoc_insertion_point(field_add:CoreML.Specification.SparseSupportVectors.vectors)
  return vectors_.Add();
}
::google::protobuf::RepeatedPtrField< ::CoreML::Specification::SparseVector >*
SparseSupportVectors::mutable_vectors() {
  // @@protoc_insertion_point(field_mutable_list:CoreML.Specification.SparseSupportVectors.vectors)
  return &vectors_;
}
const ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::SparseVector >&
SparseSupportVectors::vectors() const {
  // @@protoc_insertion_point(field_list:CoreML.Specification.SparseSupportVectors.vectors)
  return vectors_;
}

inline const SparseSupportVectors* SparseSupportVectors::internal_default_instance() {
  return &SparseSupportVectors_default_instance_.get();
}
#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int DenseVector::kValuesFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

DenseVector::DenseVector()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  if (this != internal_default_instance()) protobuf_InitDefaults_SVM_2eproto();
  SharedCtor();
  // @@protoc_insertion_point(constructor:CoreML.Specification.DenseVector)
}

void DenseVector::InitAsDefaultInstance() {
}

DenseVector::DenseVector(const DenseVector& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  UnsafeMergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.DenseVector)
}

void DenseVector::SharedCtor() {
  _cached_size_ = 0;
}

DenseVector::~DenseVector() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.DenseVector)
  SharedDtor();
}

void DenseVector::SharedDtor() {
}

void DenseVector::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const DenseVector& DenseVector::default_instance() {
  protobuf_InitDefaults_SVM_2eproto();
  return *internal_default_instance();
}

::google::protobuf::internal::ExplicitlyConstructed<DenseVector> DenseVector_default_instance_;

DenseVector* DenseVector::New(::google::protobuf::Arena* arena) const {
  DenseVector* n = new DenseVector;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void DenseVector::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.DenseVector)
  values_.Clear();
}

bool DenseVector::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CoreML.Specification.DenseVector)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated double values = 1;
      case 1: {
        if (tag == 10) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, this->mutable_values())));
        } else if (tag == 9) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitiveNoInline<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 1, 10, input, this->mutable_values())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CoreML.Specification.DenseVector)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CoreML.Specification.DenseVector)
  return false;
#undef DO_
}

void DenseVector::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CoreML.Specification.DenseVector)
  // repeated double values = 1;
  if (this->values_size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteTag(1, ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED, output);
    output->WriteVarint32(_values_cached_byte_size_);
  }
  for (int i = 0; i < this->values_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteDoubleNoTag(
      this->values(i), output);
  }

  // @@protoc_insertion_point(serialize_end:CoreML.Specification.DenseVector)
}

size_t DenseVector::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.DenseVector)
  size_t total_size = 0;

  // repeated double values = 1;
  {
    size_t data_size = 0;
    unsigned int count = this->values_size();
    data_size = 8UL * count;
    if (data_size > 0) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(data_size);
    }
    int cached_size = ::google::protobuf::internal::ToCachedSize(data_size);
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _values_cached_byte_size_ = cached_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    total_size += data_size;
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DenseVector::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const DenseVector*>(&from));
}

void DenseVector::MergeFrom(const DenseVector& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.DenseVector)
  if (GOOGLE_PREDICT_TRUE(&from != this)) {
    UnsafeMergeFrom(from);
  } else {
    MergeFromFail(__LINE__);
  }
}

void DenseVector::UnsafeMergeFrom(const DenseVector& from) {
  GOOGLE_DCHECK(&from != this);
  values_.UnsafeMergeFrom(from.values_);
}

void DenseVector::CopyFrom(const DenseVector& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.DenseVector)
  if (&from == this) return;
  Clear();
  UnsafeMergeFrom(from);
}

bool DenseVector::IsInitialized() const {

  return true;
}

void DenseVector::Swap(DenseVector* other) {
  if (other == this) return;
  InternalSwap(other);
}
void DenseVector::InternalSwap(DenseVector* other) {
  values_.UnsafeArenaSwap(&other->values_);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string DenseVector::GetTypeName() const {
  return "CoreML.Specification.DenseVector";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// DenseVector

// repeated double values = 1;
int DenseVector::values_size() const {
  return values_.size();
}
void DenseVector::clear_values() {
  values_.Clear();
}
double DenseVector::values(int index) const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.DenseVector.values)
  return values_.Get(index);
}
void DenseVector::set_values(int index, double value) {
  values_.Set(index, value);
  // @@protoc_insertion_point(field_set:CoreML.Specification.DenseVector.values)
}
void DenseVector::add_values(double value) {
  values_.Add(value);
  // @@protoc_insertion_point(field_add:CoreML.Specification.DenseVector.values)
}
const ::google::protobuf::RepeatedField< double >&
DenseVector::values() const {
  // @@protoc_insertion_point(field_list:CoreML.Specification.DenseVector.values)
  return values_;
}
::google::protobuf::RepeatedField< double >*
DenseVector::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:CoreML.Specification.DenseVector.values)
  return &values_;
}

inline const DenseVector* DenseVector::internal_default_instance() {
  return &DenseVector_default_instance_.get();
}
#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int DenseSupportVectors::kVectorsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

DenseSupportVectors::DenseSupportVectors()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  if (this != internal_default_instance()) protobuf_InitDefaults_SVM_2eproto();
  SharedCtor();
  // @@protoc_insertion_point(constructor:CoreML.Specification.DenseSupportVectors)
}

void DenseSupportVectors::InitAsDefaultInstance() {
}

DenseSupportVectors::DenseSupportVectors(const DenseSupportVectors& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  UnsafeMergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.DenseSupportVectors)
}

void DenseSupportVectors::SharedCtor() {
  _cached_size_ = 0;
}

DenseSupportVectors::~DenseSupportVectors() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.DenseSupportVectors)
  SharedDtor();
}

void DenseSupportVectors::SharedDtor() {
}

void DenseSupportVectors::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const DenseSupportVectors& DenseSupportVectors::default_instance() {
  protobuf_InitDefaults_SVM_2eproto();
  return *internal_default_instance();
}

::google::protobuf::internal::ExplicitlyConstructed<DenseSupportVectors> DenseSupportVectors_default_instance_;

DenseSupportVectors* DenseSupportVectors::New(::google::protobuf::Arena* arena) const {
  DenseSupportVectors* n = new DenseSupportVectors;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void DenseSupportVectors::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.DenseSupportVectors)
  vectors_.Clear();
}

bool DenseSupportVectors::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CoreML.Specification.DenseSupportVectors)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .CoreML.Specification.DenseVector vectors = 1;
      case 1: {
        if (tag == 10) {
          DO_(input->IncrementRecursionDepth());
         parse_loop_vectors:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_vectors()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_loop_vectors;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CoreML.Specification.DenseSupportVectors)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CoreML.Specification.DenseSupportVectors)
  return false;
#undef DO_
}

void DenseSupportVectors::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CoreML.Specification.DenseSupportVectors)
  // repeated .CoreML.Specification.DenseVector vectors = 1;
  for (unsigned int i = 0, n = this->vectors_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->vectors(i), output);
  }

  // @@protoc_insertion_point(serialize_end:CoreML.Specification.DenseSupportVectors)
}

size_t DenseSupportVectors::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.DenseSupportVectors)
  size_t total_size = 0;

  // repeated .CoreML.Specification.DenseVector vectors = 1;
  {
    unsigned int count = this->vectors_size();
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->vectors(i));
    }
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DenseSupportVectors::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const DenseSupportVectors*>(&from));
}

void DenseSupportVectors::MergeFrom(const DenseSupportVectors& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.DenseSupportVectors)
  if (GOOGLE_PREDICT_TRUE(&from != this)) {
    UnsafeMergeFrom(from);
  } else {
    MergeFromFail(__LINE__);
  }
}

void DenseSupportVectors::UnsafeMergeFrom(const DenseSupportVectors& from) {
  GOOGLE_DCHECK(&from != this);
  vectors_.MergeFrom(from.vectors_);
}

void DenseSupportVectors::CopyFrom(const DenseSupportVectors& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.DenseSupportVectors)
  if (&from == this) return;
  Clear();
  UnsafeMergeFrom(from);
}

bool DenseSupportVectors::IsInitialized() const {

  return true;
}

void DenseSupportVectors::Swap(DenseSupportVectors* other) {
  if (other == this) return;
  InternalSwap(other);
}
void DenseSupportVectors::InternalSwap(DenseSupportVectors* other) {
  vectors_.UnsafeArenaSwap(&other->vectors_);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string DenseSupportVectors::GetTypeName() const {
  return "CoreML.Specification.DenseSupportVectors";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// DenseSupportVectors

// repeated .CoreML.Specification.DenseVector vectors = 1;
int DenseSupportVectors::vectors_size() const {
  return vectors_.size();
}
void DenseSupportVectors::clear_vectors() {
  vectors_.Clear();
}
const ::CoreML::Specification::DenseVector& DenseSupportVectors::vectors(int index) const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.DenseSupportVectors.vectors)
  return vectors_.Get(index);
}
::CoreML::Specification::DenseVector* DenseSupportVectors::mutable_vectors(int index) {
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.DenseSupportVectors.vectors)
  return vectors_.Mutable(index);
}
::CoreML::Specification::DenseVector* DenseSupportVectors::add_vectors() {
  // @@protoc_insertion_point(field_add:CoreML.Specification.DenseSupportVectors.vectors)
  return vectors_.Add();
}
::google::protobuf::RepeatedPtrField< ::CoreML::Specification::DenseVector >*
DenseSupportVectors::mutable_vectors() {
  // @@protoc_insertion_point(field_mutable_list:CoreML.Specification.DenseSupportVectors.vectors)
  return &vectors_;
}
const ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::DenseVector >&
DenseSupportVectors::vectors() const {
  // @@protoc_insertion_point(field_list:CoreML.Specification.DenseSupportVectors.vectors)
  return vectors_;
}

inline const DenseSupportVectors* DenseSupportVectors::internal_default_instance() {
  return &DenseSupportVectors_default_instance_.get();
}
#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Coefficients::kAlphaFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Coefficients::Coefficients()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  if (this != internal_default_instance()) protobuf_InitDefaults_SVM_2eproto();
  SharedCtor();
  // @@protoc_insertion_point(constructor:CoreML.Specification.Coefficients)
}

void Coefficients::InitAsDefaultInstance() {
}

Coefficients::Coefficients(const Coefficients& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  UnsafeMergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.Coefficients)
}

void Coefficients::SharedCtor() {
  _cached_size_ = 0;
}

Coefficients::~Coefficients() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.Coefficients)
  SharedDtor();
}

void Coefficients::SharedDtor() {
}

void Coefficients::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Coefficients& Coefficients::default_instance() {
  protobuf_InitDefaults_SVM_2eproto();
  return *internal_default_instance();
}

::google::protobuf::internal::ExplicitlyConstructed<Coefficients> Coefficients_default_instance_;

Coefficients* Coefficients::New(::google::protobuf::Arena* arena) const {
  Coefficients* n = new Coefficients;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Coefficients::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.Coefficients)
  alpha_.Clear();
}

bool Coefficients::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CoreML.Specification.Coefficients)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated double alpha = 1;
      case 1: {
        if (tag == 10) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, this->mutable_alpha())));
        } else if (tag == 9) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitiveNoInline<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 1, 10, input, this->mutable_alpha())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CoreML.Specification.Coefficients)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CoreML.Specification.Coefficients)
  return false;
#undef DO_
}

void Coefficients::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CoreML.Specification.Coefficients)
  // repeated double alpha = 1;
  if (this->alpha_size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteTag(1, ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED, output);
    output->WriteVarint32(_alpha_cached_byte_size_);
  }
  for (int i = 0; i < this->alpha_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteDoubleNoTag(
      this->alpha(i), output);
  }

  // @@protoc_insertion_point(serialize_end:CoreML.Specification.Coefficients)
}

size_t Coefficients::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.Coefficients)
  size_t total_size = 0;

  // repeated double alpha = 1;
  {
    size_t data_size = 0;
    unsigned int count = this->alpha_size();
    data_size = 8UL * count;
    if (data_size > 0) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(data_size);
    }
    int cached_size = ::google::protobuf::internal::ToCachedSize(data_size);
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _alpha_cached_byte_size_ = cached_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    total_size += data_size;
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Coefficients::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Coefficients*>(&from));
}

void Coefficients::MergeFrom(const Coefficients& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.Coefficients)
  if (GOOGLE_PREDICT_TRUE(&from != this)) {
    UnsafeMergeFrom(from);
  } else {
    MergeFromFail(__LINE__);
  }
}

void Coefficients::UnsafeMergeFrom(const Coefficients& from) {
  GOOGLE_DCHECK(&from != this);
  alpha_.UnsafeMergeFrom(from.alpha_);
}

void Coefficients::CopyFrom(const Coefficients& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.Coefficients)
  if (&from == this) return;
  Clear();
  UnsafeMergeFrom(from);
}

bool Coefficients::IsInitialized() const {

  return true;
}

void Coefficients::Swap(Coefficients* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Coefficients::InternalSwap(Coefficients* other) {
  alpha_.UnsafeArenaSwap(&other->alpha_);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string Coefficients::GetTypeName() const {
  return "CoreML.Specification.Coefficients";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Coefficients

// repeated double alpha = 1;
int Coefficients::alpha_size() const {
  return alpha_.size();
}
void Coefficients::clear_alpha() {
  alpha_.Clear();
}
double Coefficients::alpha(int index) const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.Coefficients.alpha)
  return alpha_.Get(index);
}
void Coefficients::set_alpha(int index, double value) {
  alpha_.Set(index, value);
  // @@protoc_insertion_point(field_set:CoreML.Specification.Coefficients.alpha)
}
void Coefficients::add_alpha(double value) {
  alpha_.Add(value);
  // @@protoc_insertion_point(field_add:CoreML.Specification.Coefficients.alpha)
}
const ::google::protobuf::RepeatedField< double >&
Coefficients::alpha() const {
  // @@protoc_insertion_point(field_list:CoreML.Specification.Coefficients.alpha)
  return alpha_;
}
::google::protobuf::RepeatedField< double >*
Coefficients::mutable_alpha() {
  // @@protoc_insertion_point(field_mutable_list:CoreML.Specification.Coefficients.alpha)
  return &alpha_;
}

inline const Coefficients* Coefficients::internal_default_instance() {
  return &Coefficients_default_instance_.get();
}
#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int SupportVectorRegressor::kKernelFieldNumber;
const int SupportVectorRegressor::kSparseSupportVectorsFieldNumber;
const int SupportVectorRegressor::kDenseSupportVectorsFieldNumber;
const int SupportVectorRegressor::kCoefficientsFieldNumber;
const int SupportVectorRegressor::kRhoFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

SupportVectorRegressor::SupportVectorRegressor()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  if (this != internal_default_instance()) protobuf_InitDefaults_SVM_2eproto();
  SharedCtor();
  // @@protoc_insertion_point(constructor:CoreML.Specification.SupportVectorRegressor)
}

void SupportVectorRegressor::InitAsDefaultInstance() {
  kernel_ = const_cast< ::CoreML::Specification::Kernel*>(
      ::CoreML::Specification::Kernel::internal_default_instance());
  coefficients_ = const_cast< ::CoreML::Specification::Coefficients*>(
      ::CoreML::Specification::Coefficients::internal_default_instance());
}

SupportVectorRegressor::SupportVectorRegressor(const SupportVectorRegressor& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  UnsafeMergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.SupportVectorRegressor)
}

void SupportVectorRegressor::SharedCtor() {
  kernel_ = NULL;
  coefficients_ = NULL;
  rho_ = 0;
  clear_has_supportVectors();
  _cached_size_ = 0;
}

SupportVectorRegressor::~SupportVectorRegressor() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.SupportVectorRegressor)
  SharedDtor();
}

void SupportVectorRegressor::SharedDtor() {
  if (has_supportVectors()) {
    clear_supportVectors();
  }
  if (this != &SupportVectorRegressor_default_instance_.get()) {
    delete kernel_;
    delete coefficients_;
  }
}

void SupportVectorRegressor::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const SupportVectorRegressor& SupportVectorRegressor::default_instance() {
  protobuf_InitDefaults_SVM_2eproto();
  return *internal_default_instance();
}

::google::protobuf::internal::ExplicitlyConstructed<SupportVectorRegressor> SupportVectorRegressor_default_instance_;

SupportVectorRegressor* SupportVectorRegressor::New(::google::protobuf::Arena* arena) const {
  SupportVectorRegressor* n = new SupportVectorRegressor;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void SupportVectorRegressor::clear_supportVectors() {
// @@protoc_insertion_point(one_of_clear_start:CoreML.Specification.SupportVectorRegressor)
  switch (supportVectors_case()) {
    case kSparseSupportVectors: {
      delete supportVectors_.sparsesupportvectors_;
      break;
    }
    case kDenseSupportVectors: {
      delete supportVectors_.densesupportvectors_;
      break;
    }
    case SUPPORTVECTORS_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = SUPPORTVECTORS_NOT_SET;
}


void SupportVectorRegressor::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.SupportVectorRegressor)
  if (GetArenaNoVirtual() == NULL && kernel_ != NULL) delete kernel_;
  kernel_ = NULL;
  if (GetArenaNoVirtual() == NULL && coefficients_ != NULL) delete coefficients_;
  coefficients_ = NULL;
  rho_ = 0;
  clear_supportVectors();
}

bool SupportVectorRegressor::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CoreML.Specification.SupportVectorRegressor)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .CoreML.Specification.Kernel kernel = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_kernel()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_sparseSupportVectors;
        break;
      }

      // optional .CoreML.Specification.SparseSupportVectors sparseSupportVectors = 2;
      case 2: {
        if (tag == 18) {
         parse_sparseSupportVectors:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_sparsesupportvectors()));
        } else {
          goto handle_unusual;
        }
        goto after_densesupportvectors;
        break;
      }

      // optional .CoreML.Specification.DenseSupportVectors denseSupportVectors = 3;
      case 3: {
        if (tag == 26) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_densesupportvectors()));
        } else {
          goto handle_unusual;
        }
       after_densesupportvectors:
        if (input->ExpectTag(34)) goto parse_coefficients;
        break;
      }

      // optional .CoreML.Specification.Coefficients coefficients = 4;
      case 4: {
        if (tag == 34) {
         parse_coefficients:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_coefficients()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(41)) goto parse_rho;
        break;
      }

      // optional double rho = 5;
      case 5: {
        if (tag == 41) {
         parse_rho:

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &rho_)));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CoreML.Specification.SupportVectorRegressor)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CoreML.Specification.SupportVectorRegressor)
  return false;
#undef DO_
}

void SupportVectorRegressor::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CoreML.Specification.SupportVectorRegressor)
  // optional .CoreML.Specification.Kernel kernel = 1;
  if (this->has_kernel()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, *this->kernel_, output);
  }

  // optional .CoreML.Specification.SparseSupportVectors sparseSupportVectors = 2;
  if (has_sparsesupportvectors()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, *supportVectors_.sparsesupportvectors_, output);
  }

  // optional .CoreML.Specification.DenseSupportVectors denseSupportVectors = 3;
  if (has_densesupportvectors()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, *supportVectors_.densesupportvectors_, output);
  }

  // optional .CoreML.Specification.Coefficients coefficients = 4;
  if (this->has_coefficients()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4, *this->coefficients_, output);
  }

  // optional double rho = 5;
  if (this->rho() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(5, this->rho(), output);
  }

  // @@protoc_insertion_point(serialize_end:CoreML.Specification.SupportVectorRegressor)
}

size_t SupportVectorRegressor::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.SupportVectorRegressor)
  size_t total_size = 0;

  // optional .CoreML.Specification.Kernel kernel = 1;
  if (this->has_kernel()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->kernel_);
  }

  // optional .CoreML.Specification.Coefficients coefficients = 4;
  if (this->has_coefficients()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->coefficients_);
  }

  // optional double rho = 5;
  if (this->rho() != 0) {
    total_size += 1 + 8;
  }

  switch (supportVectors_case()) {
    // optional .CoreML.Specification.SparseSupportVectors sparseSupportVectors = 2;
    case kSparseSupportVectors: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *supportVectors_.sparsesupportvectors_);
      break;
    }
    // optional .CoreML.Specification.DenseSupportVectors denseSupportVectors = 3;
    case kDenseSupportVectors: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *supportVectors_.densesupportvectors_);
      break;
    }
    case SUPPORTVECTORS_NOT_SET: {
      break;
    }
  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SupportVectorRegressor::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const SupportVectorRegressor*>(&from));
}

void SupportVectorRegressor::MergeFrom(const SupportVectorRegressor& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.SupportVectorRegressor)
  if (GOOGLE_PREDICT_TRUE(&from != this)) {
    UnsafeMergeFrom(from);
  } else {
    MergeFromFail(__LINE__);
  }
}

void SupportVectorRegressor::UnsafeMergeFrom(const SupportVectorRegressor& from) {
  GOOGLE_DCHECK(&from != this);
  switch (from.supportVectors_case()) {
    case kSparseSupportVectors: {
      mutable_sparsesupportvectors()->::CoreML::Specification::SparseSupportVectors::MergeFrom(from.sparsesupportvectors());
      break;
    }
    case kDenseSupportVectors: {
      mutable_densesupportvectors()->::CoreML::Specification::DenseSupportVectors::MergeFrom(from.densesupportvectors());
      break;
    }
    case SUPPORTVECTORS_NOT_SET: {
      break;
    }
  }
  if (from.has_kernel()) {
    mutable_kernel()->::CoreML::Specification::Kernel::MergeFrom(from.kernel());
  }
  if (from.has_coefficients()) {
    mutable_coefficients()->::CoreML::Specification::Coefficients::MergeFrom(from.coefficients());
  }
  if (from.rho() != 0) {
    set_rho(from.rho());
  }
}

void SupportVectorRegressor::CopyFrom(const SupportVectorRegressor& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.SupportVectorRegressor)
  if (&from == this) return;
  Clear();
  UnsafeMergeFrom(from);
}

bool SupportVectorRegressor::IsInitialized() const {

  return true;
}

void SupportVectorRegressor::Swap(SupportVectorRegressor* other) {
  if (other == this) return;
  InternalSwap(other);
}
void SupportVectorRegressor::InternalSwap(SupportVectorRegressor* other) {
  std::swap(kernel_, other->kernel_);
  std::swap(coefficients_, other->coefficients_);
  std::swap(rho_, other->rho_);
  std::swap(supportVectors_, other->supportVectors_);
  std::swap(_oneof_case_[0], other->_oneof_case_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string SupportVectorRegressor::GetTypeName() const {
  return "CoreML.Specification.SupportVectorRegressor";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// SupportVectorRegressor

// optional .CoreML.Specification.Kernel kernel = 1;
bool SupportVectorRegressor::has_kernel() const {
  return this != internal_default_instance() && kernel_ != NULL;
}
void SupportVectorRegressor::clear_kernel() {
  if (GetArenaNoVirtual() == NULL && kernel_ != NULL) delete kernel_;
  kernel_ = NULL;
}
const ::CoreML::Specification::Kernel& SupportVectorRegressor::kernel() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.SupportVectorRegressor.kernel)
  return kernel_ != NULL ? *kernel_
                         : *::CoreML::Specification::Kernel::internal_default_instance();
}
::CoreML::Specification::Kernel* SupportVectorRegressor::mutable_kernel() {
  
  if (kernel_ == NULL) {
    kernel_ = new ::CoreML::Specification::Kernel;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.SupportVectorRegressor.kernel)
  return kernel_;
}
::CoreML::Specification::Kernel* SupportVectorRegressor::release_kernel() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.SupportVectorRegressor.kernel)
  
  ::CoreML::Specification::Kernel* temp = kernel_;
  kernel_ = NULL;
  return temp;
}
void SupportVectorRegressor::set_allocated_kernel(::CoreML::Specification::Kernel* kernel) {
  delete kernel_;
  kernel_ = kernel;
  if (kernel) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.SupportVectorRegressor.kernel)
}

// optional .CoreML.Specification.SparseSupportVectors sparseSupportVectors = 2;
bool SupportVectorRegressor::has_sparsesupportvectors() const {
  return supportVectors_case() == kSparseSupportVectors;
}
void SupportVectorRegressor::set_has_sparsesupportvectors() {
  _oneof_case_[0] = kSparseSupportVectors;
}
void SupportVectorRegressor::clear_sparsesupportvectors() {
  if (has_sparsesupportvectors()) {
    delete supportVectors_.sparsesupportvectors_;
    clear_has_supportVectors();
  }
}
 const ::CoreML::Specification::SparseSupportVectors& SupportVectorRegressor::sparsesupportvectors() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.SupportVectorRegressor.sparseSupportVectors)
  return has_sparsesupportvectors()
      ? *supportVectors_.sparsesupportvectors_
      : ::CoreML::Specification::SparseSupportVectors::default_instance();
}
::CoreML::Specification::SparseSupportVectors* SupportVectorRegressor::mutable_sparsesupportvectors() {
  if (!has_sparsesupportvectors()) {
    clear_supportVectors();
    set_has_sparsesupportvectors();
    supportVectors_.sparsesupportvectors_ = new ::CoreML::Specification::SparseSupportVectors;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.SupportVectorRegressor.sparseSupportVectors)
  return supportVectors_.sparsesupportvectors_;
}
::CoreML::Specification::SparseSupportVectors* SupportVectorRegressor::release_sparsesupportvectors() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.SupportVectorRegressor.sparseSupportVectors)
  if (has_sparsesupportvectors()) {
    clear_has_supportVectors();
    ::CoreML::Specification::SparseSupportVectors* temp = supportVectors_.sparsesupportvectors_;
    supportVectors_.sparsesupportvectors_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void SupportVectorRegressor::set_allocated_sparsesupportvectors(::CoreML::Specification::SparseSupportVectors* sparsesupportvectors) {
  clear_supportVectors();
  if (sparsesupportvectors) {
    set_has_sparsesupportvectors();
    supportVectors_.sparsesupportvectors_ = sparsesupportvectors;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.SupportVectorRegressor.sparseSupportVectors)
}

// optional .CoreML.Specification.DenseSupportVectors denseSupportVectors = 3;
bool SupportVectorRegressor::has_densesupportvectors() const {
  return supportVectors_case() == kDenseSupportVectors;
}
void SupportVectorRegressor::set_has_densesupportvectors() {
  _oneof_case_[0] = kDenseSupportVectors;
}
void SupportVectorRegressor::clear_densesupportvectors() {
  if (has_densesupportvectors()) {
    delete supportVectors_.densesupportvectors_;
    clear_has_supportVectors();
  }
}
 const ::CoreML::Specification::DenseSupportVectors& SupportVectorRegressor::densesupportvectors() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.SupportVectorRegressor.denseSupportVectors)
  return has_densesupportvectors()
      ? *supportVectors_.densesupportvectors_
      : ::CoreML::Specification::DenseSupportVectors::default_instance();
}
::CoreML::Specification::DenseSupportVectors* SupportVectorRegressor::mutable_densesupportvectors() {
  if (!has_densesupportvectors()) {
    clear_supportVectors();
    set_has_densesupportvectors();
    supportVectors_.densesupportvectors_ = new ::CoreML::Specification::DenseSupportVectors;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.SupportVectorRegressor.denseSupportVectors)
  return supportVectors_.densesupportvectors_;
}
::CoreML::Specification::DenseSupportVectors* SupportVectorRegressor::release_densesupportvectors() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.SupportVectorRegressor.denseSupportVectors)
  if (has_densesupportvectors()) {
    clear_has_supportVectors();
    ::CoreML::Specification::DenseSupportVectors* temp = supportVectors_.densesupportvectors_;
    supportVectors_.densesupportvectors_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void SupportVectorRegressor::set_allocated_densesupportvectors(::CoreML::Specification::DenseSupportVectors* densesupportvectors) {
  clear_supportVectors();
  if (densesupportvectors) {
    set_has_densesupportvectors();
    supportVectors_.densesupportvectors_ = densesupportvectors;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.SupportVectorRegressor.denseSupportVectors)
}

// optional .CoreML.Specification.Coefficients coefficients = 4;
bool SupportVectorRegressor::has_coefficients() const {
  return this != internal_default_instance() && coefficients_ != NULL;
}
void SupportVectorRegressor::clear_coefficients() {
  if (GetArenaNoVirtual() == NULL && coefficients_ != NULL) delete coefficients_;
  coefficients_ = NULL;
}
const ::CoreML::Specification::Coefficients& SupportVectorRegressor::coefficients() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.SupportVectorRegressor.coefficients)
  return coefficients_ != NULL ? *coefficients_
                         : *::CoreML::Specification::Coefficients::internal_default_instance();
}
::CoreML::Specification::Coefficients* SupportVectorRegressor::mutable_coefficients() {
  
  if (coefficients_ == NULL) {
    coefficients_ = new ::CoreML::Specification::Coefficients;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.SupportVectorRegressor.coefficients)
  return coefficients_;
}
::CoreML::Specification::Coefficients* SupportVectorRegressor::release_coefficients() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.SupportVectorRegressor.coefficients)
  
  ::CoreML::Specification::Coefficients* temp = coefficients_;
  coefficients_ = NULL;
  return temp;
}
void SupportVectorRegressor::set_allocated_coefficients(::CoreML::Specification::Coefficients* coefficients) {
  delete coefficients_;
  coefficients_ = coefficients;
  if (coefficients) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.SupportVectorRegressor.coefficients)
}

// optional double rho = 5;
void SupportVectorRegressor::clear_rho() {
  rho_ = 0;
}
double SupportVectorRegressor::rho() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.SupportVectorRegressor.rho)
  return rho_;
}
void SupportVectorRegressor::set_rho(double value) {
  
  rho_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.SupportVectorRegressor.rho)
}

bool SupportVectorRegressor::has_supportVectors() const {
  return supportVectors_case() != SUPPORTVECTORS_NOT_SET;
}
void SupportVectorRegressor::clear_has_supportVectors() {
  _oneof_case_[0] = SUPPORTVECTORS_NOT_SET;
}
SupportVectorRegressor::SupportVectorsCase SupportVectorRegressor::supportVectors_case() const {
  return SupportVectorRegressor::SupportVectorsCase(_oneof_case_[0]);
}
inline const SupportVectorRegressor* SupportVectorRegressor::internal_default_instance() {
  return &SupportVectorRegressor_default_instance_.get();
}
#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int SupportVectorClassifier::kKernelFieldNumber;
const int SupportVectorClassifier::kNumberOfSupportVectorsPerClassFieldNumber;
const int SupportVectorClassifier::kSparseSupportVectorsFieldNumber;
const int SupportVectorClassifier::kDenseSupportVectorsFieldNumber;
const int SupportVectorClassifier::kCoefficientsFieldNumber;
const int SupportVectorClassifier::kRhoFieldNumber;
const int SupportVectorClassifier::kProbAFieldNumber;
const int SupportVectorClassifier::kProbBFieldNumber;
const int SupportVectorClassifier::kStringClassLabelsFieldNumber;
const int SupportVectorClassifier::kInt64ClassLabelsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

SupportVectorClassifier::SupportVectorClassifier()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  if (this != internal_default_instance()) protobuf_InitDefaults_SVM_2eproto();
  SharedCtor();
  // @@protoc_insertion_point(constructor:CoreML.Specification.SupportVectorClassifier)
}

void SupportVectorClassifier::InitAsDefaultInstance() {
  kernel_ = const_cast< ::CoreML::Specification::Kernel*>(
      ::CoreML::Specification::Kernel::internal_default_instance());
}

SupportVectorClassifier::SupportVectorClassifier(const SupportVectorClassifier& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  UnsafeMergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.SupportVectorClassifier)
}

void SupportVectorClassifier::SharedCtor() {
  kernel_ = NULL;
  clear_has_supportVectors();
  clear_has_ClassLabels();
  _cached_size_ = 0;
}

SupportVectorClassifier::~SupportVectorClassifier() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.SupportVectorClassifier)
  SharedDtor();
}

void SupportVectorClassifier::SharedDtor() {
  if (has_supportVectors()) {
    clear_supportVectors();
  }
  if (has_ClassLabels()) {
    clear_ClassLabels();
  }
  if (this != &SupportVectorClassifier_default_instance_.get()) {
    delete kernel_;
  }
}

void SupportVectorClassifier::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const SupportVectorClassifier& SupportVectorClassifier::default_instance() {
  protobuf_InitDefaults_SVM_2eproto();
  return *internal_default_instance();
}

::google::protobuf::internal::ExplicitlyConstructed<SupportVectorClassifier> SupportVectorClassifier_default_instance_;

SupportVectorClassifier* SupportVectorClassifier::New(::google::protobuf::Arena* arena) const {
  SupportVectorClassifier* n = new SupportVectorClassifier;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void SupportVectorClassifier::clear_supportVectors() {
// @@protoc_insertion_point(one_of_clear_start:CoreML.Specification.SupportVectorClassifier)
  switch (supportVectors_case()) {
    case kSparseSupportVectors: {
      delete supportVectors_.sparsesupportvectors_;
      break;
    }
    case kDenseSupportVectors: {
      delete supportVectors_.densesupportvectors_;
      break;
    }
    case SUPPORTVECTORS_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = SUPPORTVECTORS_NOT_SET;
}

void SupportVectorClassifier::clear_ClassLabels() {
// @@protoc_insertion_point(one_of_clear_start:CoreML.Specification.SupportVectorClassifier)
  switch (ClassLabels_case()) {
    case kStringClassLabels: {
      delete ClassLabels_.stringclasslabels_;
      break;
    }
    case kInt64ClassLabels: {
      delete ClassLabels_.int64classlabels_;
      break;
    }
    case CLASSLABELS_NOT_SET: {
      break;
    }
  }
  _oneof_case_[1] = CLASSLABELS_NOT_SET;
}


void SupportVectorClassifier::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.SupportVectorClassifier)
  if (GetArenaNoVirtual() == NULL && kernel_ != NULL) delete kernel_;
  kernel_ = NULL;
  numberofsupportvectorsperclass_.Clear();
  coefficients_.Clear();
  rho_.Clear();
  proba_.Clear();
  probb_.Clear();
  clear_supportVectors();
  clear_ClassLabels();
}

bool SupportVectorClassifier::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CoreML.Specification.SupportVectorClassifier)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(16383);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .CoreML.Specification.Kernel kernel = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_kernel()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_numberOfSupportVectorsPerClass;
        break;
      }

      // repeated int32 numberOfSupportVectorsPerClass = 2;
      case 2: {
        if (tag == 18) {
         parse_numberOfSupportVectorsPerClass:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, this->mutable_numberofsupportvectorsperclass())));
        } else if (tag == 16) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitiveNoInline<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 1, 18, input, this->mutable_numberofsupportvectorsperclass())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_sparseSupportVectors;
        break;
      }

      // optional .CoreML.Specification.SparseSupportVectors sparseSupportVectors = 3;
      case 3: {
        if (tag == 26) {
         parse_sparseSupportVectors:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_sparsesupportvectors()));
        } else {
          goto handle_unusual;
        }
        goto after_densesupportvectors;
        break;
      }

      // optional .CoreML.Specification.DenseSupportVectors denseSupportVectors = 4;
      case 4: {
        if (tag == 34) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_densesupportvectors()));
        } else {
          goto handle_unusual;
        }
       after_densesupportvectors:
        if (input->ExpectTag(42)) goto parse_coefficients;
        break;
      }

      // repeated .CoreML.Specification.Coefficients coefficients = 5;
      case 5: {
        if (tag == 42) {
         parse_coefficients:
          DO_(input->IncrementRecursionDepth());
         parse_loop_coefficients:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_coefficients()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_loop_coefficients;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectTag(50)) goto parse_rho;
        break;
      }

      // repeated double rho = 6;
      case 6: {
        if (tag == 50) {
         parse_rho:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, this->mutable_rho())));
        } else if (tag == 49) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitiveNoInline<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 1, 50, input, this->mutable_rho())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_probA;
        break;
      }

      // repeated double probA = 7;
      case 7: {
        if (tag == 58) {
         parse_probA:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, this->mutable_proba())));
        } else if (tag == 57) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitiveNoInline<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 1, 58, input, this->mutable_proba())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(66)) goto parse_probB;
        break;
      }

      // repeated double probB = 8;
      case 8: {
        if (tag == 66) {
         parse_probB:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, this->mutable_probb())));
        } else if (tag == 65) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitiveNoInline<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 1, 66, input, this->mutable_probb())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(802)) goto parse_stringClassLabels;
        break;
      }

      // optional .CoreML.Specification.StringVector stringClassLabels = 100;
      case 100: {
        if (tag == 802) {
         parse_stringClassLabels:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_stringclasslabels()));
        } else {
          goto handle_unusual;
        }
        goto after_int64classlabels;
        break;
      }

      // optional .CoreML.Specification.Int64Vector int64ClassLabels = 101;
      case 101: {
        if (tag == 810) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_int64classlabels()));
        } else {
          goto handle_unusual;
        }
       after_int64classlabels:
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CoreML.Specification.SupportVectorClassifier)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CoreML.Specification.SupportVectorClassifier)
  return false;
#undef DO_
}

void SupportVectorClassifier::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CoreML.Specification.SupportVectorClassifier)
  // optional .CoreML.Specification.Kernel kernel = 1;
  if (this->has_kernel()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, *this->kernel_, output);
  }

  // repeated int32 numberOfSupportVectorsPerClass = 2;
  if (this->numberofsupportvectorsperclass_size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteTag(2, ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED, output);
    output->WriteVarint32(_numberofsupportvectorsperclass_cached_byte_size_);
  }
  for (int i = 0; i < this->numberofsupportvectorsperclass_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32NoTag(
      this->numberofsupportvectorsperclass(i), output);
  }

  // optional .CoreML.Specification.SparseSupportVectors sparseSupportVectors = 3;
  if (has_sparsesupportvectors()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, *supportVectors_.sparsesupportvectors_, output);
  }

  // optional .CoreML.Specification.DenseSupportVectors denseSupportVectors = 4;
  if (has_densesupportvectors()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4, *supportVectors_.densesupportvectors_, output);
  }

  // repeated .CoreML.Specification.Coefficients coefficients = 5;
  for (unsigned int i = 0, n = this->coefficients_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      5, this->coefficients(i), output);
  }

  // repeated double rho = 6;
  if (this->rho_size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteTag(6, ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED, output);
    output->WriteVarint32(_rho_cached_byte_size_);
  }
  for (int i = 0; i < this->rho_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteDoubleNoTag(
      this->rho(i), output);
  }

  // repeated double probA = 7;
  if (this->proba_size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteTag(7, ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED, output);
    output->WriteVarint32(_proba_cached_byte_size_);
  }
  for (int i = 0; i < this->proba_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteDoubleNoTag(
      this->proba(i), output);
  }

  // repeated double probB = 8;
  if (this->probb_size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteTag(8, ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED, output);
    output->WriteVarint32(_probb_cached_byte_size_);
  }
  for (int i = 0; i < this->probb_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteDoubleNoTag(
      this->probb(i), output);
  }

  // optional .CoreML.Specification.StringVector stringClassLabels = 100;
  if (has_stringclasslabels()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      100, *ClassLabels_.stringclasslabels_, output);
  }

  // optional .CoreML.Specification.Int64Vector int64ClassLabels = 101;
  if (has_int64classlabels()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      101, *ClassLabels_.int64classlabels_, output);
  }

  // @@protoc_insertion_point(serialize_end:CoreML.Specification.SupportVectorClassifier)
}

size_t SupportVectorClassifier::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.SupportVectorClassifier)
  size_t total_size = 0;

  // optional .CoreML.Specification.Kernel kernel = 1;
  if (this->has_kernel()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->kernel_);
  }

  // repeated int32 numberOfSupportVectorsPerClass = 2;
  {
    size_t data_size = 0;
    unsigned int count = this->numberofsupportvectorsperclass_size();
    for (unsigned int i = 0; i < count; i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        Int32Size(this->numberofsupportvectorsperclass(i));
    }
    if (data_size > 0) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(data_size);
    }
    int cached_size = ::google::protobuf::internal::ToCachedSize(data_size);
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _numberofsupportvectorsperclass_cached_byte_size_ = cached_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    total_size += data_size;
  }

  // repeated .CoreML.Specification.Coefficients coefficients = 5;
  {
    unsigned int count = this->coefficients_size();
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->coefficients(i));
    }
  }

  // repeated double rho = 6;
  {
    size_t data_size = 0;
    unsigned int count = this->rho_size();
    data_size = 8UL * count;
    if (data_size > 0) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(data_size);
    }
    int cached_size = ::google::protobuf::internal::ToCachedSize(data_size);
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _rho_cached_byte_size_ = cached_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    total_size += data_size;
  }

  // repeated double probA = 7;
  {
    size_t data_size = 0;
    unsigned int count = this->proba_size();
    data_size = 8UL * count;
    if (data_size > 0) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(data_size);
    }
    int cached_size = ::google::protobuf::internal::ToCachedSize(data_size);
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _proba_cached_byte_size_ = cached_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    total_size += data_size;
  }

  // repeated double probB = 8;
  {
    size_t data_size = 0;
    unsigned int count = this->probb_size();
    data_size = 8UL * count;
    if (data_size > 0) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(data_size);
    }
    int cached_size = ::google::protobuf::internal::ToCachedSize(data_size);
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _probb_cached_byte_size_ = cached_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    total_size += data_size;
  }

  switch (supportVectors_case()) {
    // optional .CoreML.Specification.SparseSupportVectors sparseSupportVectors = 3;
    case kSparseSupportVectors: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *supportVectors_.sparsesupportvectors_);
      break;
    }
    // optional .CoreML.Specification.DenseSupportVectors denseSupportVectors = 4;
    case kDenseSupportVectors: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *supportVectors_.densesupportvectors_);
      break;
    }
    case SUPPORTVECTORS_NOT_SET: {
      break;
    }
  }
  switch (ClassLabels_case()) {
    // optional .CoreML.Specification.StringVector stringClassLabels = 100;
    case kStringClassLabels: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *ClassLabels_.stringclasslabels_);
      break;
    }
    // optional .CoreML.Specification.Int64Vector int64ClassLabels = 101;
    case kInt64ClassLabels: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *ClassLabels_.int64classlabels_);
      break;
    }
    case CLASSLABELS_NOT_SET: {
      break;
    }
  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SupportVectorClassifier::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const SupportVectorClassifier*>(&from));
}

void SupportVectorClassifier::MergeFrom(const SupportVectorClassifier& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.SupportVectorClassifier)
  if (GOOGLE_PREDICT_TRUE(&from != this)) {
    UnsafeMergeFrom(from);
  } else {
    MergeFromFail(__LINE__);
  }
}

void SupportVectorClassifier::UnsafeMergeFrom(const SupportVectorClassifier& from) {
  GOOGLE_DCHECK(&from != this);
  numberofsupportvectorsperclass_.UnsafeMergeFrom(from.numberofsupportvectorsperclass_);
  coefficients_.MergeFrom(from.coefficients_);
  rho_.UnsafeMergeFrom(from.rho_);
  proba_.UnsafeMergeFrom(from.proba_);
  probb_.UnsafeMergeFrom(from.probb_);
  switch (from.supportVectors_case()) {
    case kSparseSupportVectors: {
      mutable_sparsesupportvectors()->::CoreML::Specification::SparseSupportVectors::MergeFrom(from.sparsesupportvectors());
      break;
    }
    case kDenseSupportVectors: {
      mutable_densesupportvectors()->::CoreML::Specification::DenseSupportVectors::MergeFrom(from.densesupportvectors());
      break;
    }
    case SUPPORTVECTORS_NOT_SET: {
      break;
    }
  }
  switch (from.ClassLabels_case()) {
    case kStringClassLabels: {
      mutable_stringclasslabels()->::CoreML::Specification::StringVector::MergeFrom(from.stringclasslabels());
      break;
    }
    case kInt64ClassLabels: {
      mutable_int64classlabels()->::CoreML::Specification::Int64Vector::MergeFrom(from.int64classlabels());
      break;
    }
    case CLASSLABELS_NOT_SET: {
      break;
    }
  }
  if (from.has_kernel()) {
    mutable_kernel()->::CoreML::Specification::Kernel::MergeFrom(from.kernel());
  }
}

void SupportVectorClassifier::CopyFrom(const SupportVectorClassifier& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.SupportVectorClassifier)
  if (&from == this) return;
  Clear();
  UnsafeMergeFrom(from);
}

bool SupportVectorClassifier::IsInitialized() const {

  return true;
}

void SupportVectorClassifier::Swap(SupportVectorClassifier* other) {
  if (other == this) return;
  InternalSwap(other);
}
void SupportVectorClassifier::InternalSwap(SupportVectorClassifier* other) {
  std::swap(kernel_, other->kernel_);
  numberofsupportvectorsperclass_.UnsafeArenaSwap(&other->numberofsupportvectorsperclass_);
  coefficients_.UnsafeArenaSwap(&other->coefficients_);
  rho_.UnsafeArenaSwap(&other->rho_);
  proba_.UnsafeArenaSwap(&other->proba_);
  probb_.UnsafeArenaSwap(&other->probb_);
  std::swap(supportVectors_, other->supportVectors_);
  std::swap(_oneof_case_[0], other->_oneof_case_[0]);
  std::swap(ClassLabels_, other->ClassLabels_);
  std::swap(_oneof_case_[1], other->_oneof_case_[1]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string SupportVectorClassifier::GetTypeName() const {
  return "CoreML.Specification.SupportVectorClassifier";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// SupportVectorClassifier

// optional .CoreML.Specification.Kernel kernel = 1;
bool SupportVectorClassifier::has_kernel() const {
  return this != internal_default_instance() && kernel_ != NULL;
}
void SupportVectorClassifier::clear_kernel() {
  if (GetArenaNoVirtual() == NULL && kernel_ != NULL) delete kernel_;
  kernel_ = NULL;
}
const ::CoreML::Specification::Kernel& SupportVectorClassifier::kernel() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.SupportVectorClassifier.kernel)
  return kernel_ != NULL ? *kernel_
                         : *::CoreML::Specification::Kernel::internal_default_instance();
}
::CoreML::Specification::Kernel* SupportVectorClassifier::mutable_kernel() {
  
  if (kernel_ == NULL) {
    kernel_ = new ::CoreML::Specification::Kernel;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.SupportVectorClassifier.kernel)
  return kernel_;
}
::CoreML::Specification::Kernel* SupportVectorClassifier::release_kernel() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.SupportVectorClassifier.kernel)
  
  ::CoreML::Specification::Kernel* temp = kernel_;
  kernel_ = NULL;
  return temp;
}
void SupportVectorClassifier::set_allocated_kernel(::CoreML::Specification::Kernel* kernel) {
  delete kernel_;
  kernel_ = kernel;
  if (kernel) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.SupportVectorClassifier.kernel)
}

// repeated int32 numberOfSupportVectorsPerClass = 2;
int SupportVectorClassifier::numberofsupportvectorsperclass_size() const {
  return numberofsupportvectorsperclass_.size();
}
void SupportVectorClassifier::clear_numberofsupportvectorsperclass() {
  numberofsupportvectorsperclass_.Clear();
}
::google::protobuf::int32 SupportVectorClassifier::numberofsupportvectorsperclass(int index) const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.SupportVectorClassifier.numberOfSupportVectorsPerClass)
  return numberofsupportvectorsperclass_.Get(index);
}
void SupportVectorClassifier::set_numberofsupportvectorsperclass(int index, ::google::protobuf::int32 value) {
  numberofsupportvectorsperclass_.Set(index, value);
  // @@protoc_insertion_point(field_set:CoreML.Specification.SupportVectorClassifier.numberOfSupportVectorsPerClass)
}
void SupportVectorClassifier::add_numberofsupportvectorsperclass(::google::protobuf::int32 value) {
  numberofsupportvectorsperclass_.Add(value);
  // @@protoc_insertion_point(field_add:CoreML.Specification.SupportVectorClassifier.numberOfSupportVectorsPerClass)
}
const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
SupportVectorClassifier::numberofsupportvectorsperclass() const {
  // @@protoc_insertion_point(field_list:CoreML.Specification.SupportVectorClassifier.numberOfSupportVectorsPerClass)
  return numberofsupportvectorsperclass_;
}
::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
SupportVectorClassifier::mutable_numberofsupportvectorsperclass() {
  // @@protoc_insertion_point(field_mutable_list:CoreML.Specification.SupportVectorClassifier.numberOfSupportVectorsPerClass)
  return &numberofsupportvectorsperclass_;
}

// optional .CoreML.Specification.SparseSupportVectors sparseSupportVectors = 3;
bool SupportVectorClassifier::has_sparsesupportvectors() const {
  return supportVectors_case() == kSparseSupportVectors;
}
void SupportVectorClassifier::set_has_sparsesupportvectors() {
  _oneof_case_[0] = kSparseSupportVectors;
}
void SupportVectorClassifier::clear_sparsesupportvectors() {
  if (has_sparsesupportvectors()) {
    delete supportVectors_.sparsesupportvectors_;
    clear_has_supportVectors();
  }
}
 const ::CoreML::Specification::SparseSupportVectors& SupportVectorClassifier::sparsesupportvectors() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.SupportVectorClassifier.sparseSupportVectors)
  return has_sparsesupportvectors()
      ? *supportVectors_.sparsesupportvectors_
      : ::CoreML::Specification::SparseSupportVectors::default_instance();
}
::CoreML::Specification::SparseSupportVectors* SupportVectorClassifier::mutable_sparsesupportvectors() {
  if (!has_sparsesupportvectors()) {
    clear_supportVectors();
    set_has_sparsesupportvectors();
    supportVectors_.sparsesupportvectors_ = new ::CoreML::Specification::SparseSupportVectors;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.SupportVectorClassifier.sparseSupportVectors)
  return supportVectors_.sparsesupportvectors_;
}
::CoreML::Specification::SparseSupportVectors* SupportVectorClassifier::release_sparsesupportvectors() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.SupportVectorClassifier.sparseSupportVectors)
  if (has_sparsesupportvectors()) {
    clear_has_supportVectors();
    ::CoreML::Specification::SparseSupportVectors* temp = supportVectors_.sparsesupportvectors_;
    supportVectors_.sparsesupportvectors_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void SupportVectorClassifier::set_allocated_sparsesupportvectors(::CoreML::Specification::SparseSupportVectors* sparsesupportvectors) {
  clear_supportVectors();
  if (sparsesupportvectors) {
    set_has_sparsesupportvectors();
    supportVectors_.sparsesupportvectors_ = sparsesupportvectors;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.SupportVectorClassifier.sparseSupportVectors)
}

// optional .CoreML.Specification.DenseSupportVectors denseSupportVectors = 4;
bool SupportVectorClassifier::has_densesupportvectors() const {
  return supportVectors_case() == kDenseSupportVectors;
}
void SupportVectorClassifier::set_has_densesupportvectors() {
  _oneof_case_[0] = kDenseSupportVectors;
}
void SupportVectorClassifier::clear_densesupportvectors() {
  if (has_densesupportvectors()) {
    delete supportVectors_.densesupportvectors_;
    clear_has_supportVectors();
  }
}
 const ::CoreML::Specification::DenseSupportVectors& SupportVectorClassifier::densesupportvectors() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.SupportVectorClassifier.denseSupportVectors)
  return has_densesupportvectors()
      ? *supportVectors_.densesupportvectors_
      : ::CoreML::Specification::DenseSupportVectors::default_instance();
}
::CoreML::Specification::DenseSupportVectors* SupportVectorClassifier::mutable_densesupportvectors() {
  if (!has_densesupportvectors()) {
    clear_supportVectors();
    set_has_densesupportvectors();
    supportVectors_.densesupportvectors_ = new ::CoreML::Specification::DenseSupportVectors;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.SupportVectorClassifier.denseSupportVectors)
  return supportVectors_.densesupportvectors_;
}
::CoreML::Specification::DenseSupportVectors* SupportVectorClassifier::release_densesupportvectors() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.SupportVectorClassifier.denseSupportVectors)
  if (has_densesupportvectors()) {
    clear_has_supportVectors();
    ::CoreML::Specification::DenseSupportVectors* temp = supportVectors_.densesupportvectors_;
    supportVectors_.densesupportvectors_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void SupportVectorClassifier::set_allocated_densesupportvectors(::CoreML::Specification::DenseSupportVectors* densesupportvectors) {
  clear_supportVectors();
  if (densesupportvectors) {
    set_has_densesupportvectors();
    supportVectors_.densesupportvectors_ = densesupportvectors;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.SupportVectorClassifier.denseSupportVectors)
}

// repeated .CoreML.Specification.Coefficients coefficients = 5;
int SupportVectorClassifier::coefficients_size() const {
  return coefficients_.size();
}
void SupportVectorClassifier::clear_coefficients() {
  coefficients_.Clear();
}
const ::CoreML::Specification::Coefficients& SupportVectorClassifier::coefficients(int index) const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.SupportVectorClassifier.coefficients)
  return coefficients_.Get(index);
}
::CoreML::Specification::Coefficients* SupportVectorClassifier::mutable_coefficients(int index) {
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.SupportVectorClassifier.coefficients)
  return coefficients_.Mutable(index);
}
::CoreML::Specification::Coefficients* SupportVectorClassifier::add_coefficients() {
  // @@protoc_insertion_point(field_add:CoreML.Specification.SupportVectorClassifier.coefficients)
  return coefficients_.Add();
}
::google::protobuf::RepeatedPtrField< ::CoreML::Specification::Coefficients >*
SupportVectorClassifier::mutable_coefficients() {
  // @@protoc_insertion_point(field_mutable_list:CoreML.Specification.SupportVectorClassifier.coefficients)
  return &coefficients_;
}
const ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::Coefficients >&
SupportVectorClassifier::coefficients() const {
  // @@protoc_insertion_point(field_list:CoreML.Specification.SupportVectorClassifier.coefficients)
  return coefficients_;
}

// repeated double rho = 6;
int SupportVectorClassifier::rho_size() const {
  return rho_.size();
}
void SupportVectorClassifier::clear_rho() {
  rho_.Clear();
}
double SupportVectorClassifier::rho(int index) const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.SupportVectorClassifier.rho)
  return rho_.Get(index);
}
void SupportVectorClassifier::set_rho(int index, double value) {
  rho_.Set(index, value);
  // @@protoc_insertion_point(field_set:CoreML.Specification.SupportVectorClassifier.rho)
}
void SupportVectorClassifier::add_rho(double value) {
  rho_.Add(value);
  // @@protoc_insertion_point(field_add:CoreML.Specification.SupportVectorClassifier.rho)
}
const ::google::protobuf::RepeatedField< double >&
SupportVectorClassifier::rho() const {
  // @@protoc_insertion_point(field_list:CoreML.Specification.SupportVectorClassifier.rho)
  return rho_;
}
::google::protobuf::RepeatedField< double >*
SupportVectorClassifier::mutable_rho() {
  // @@protoc_insertion_point(field_mutable_list:CoreML.Specification.SupportVectorClassifier.rho)
  return &rho_;
}

// repeated double probA = 7;
int SupportVectorClassifier::proba_size() const {
  return proba_.size();
}
void SupportVectorClassifier::clear_proba() {
  proba_.Clear();
}
double SupportVectorClassifier::proba(int index) const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.SupportVectorClassifier.probA)
  return proba_.Get(index);
}
void SupportVectorClassifier::set_proba(int index, double value) {
  proba_.Set(index, value);
  // @@protoc_insertion_point(field_set:CoreML.Specification.SupportVectorClassifier.probA)
}
void SupportVectorClassifier::add_proba(double value) {
  proba_.Add(value);
  // @@protoc_insertion_point(field_add:CoreML.Specification.SupportVectorClassifier.probA)
}
const ::google::protobuf::RepeatedField< double >&
SupportVectorClassifier::proba() const {
  // @@protoc_insertion_point(field_list:CoreML.Specification.SupportVectorClassifier.probA)
  return proba_;
}
::google::protobuf::RepeatedField< double >*
SupportVectorClassifier::mutable_proba() {
  // @@protoc_insertion_point(field_mutable_list:CoreML.Specification.SupportVectorClassifier.probA)
  return &proba_;
}

// repeated double probB = 8;
int SupportVectorClassifier::probb_size() const {
  return probb_.size();
}
void SupportVectorClassifier::clear_probb() {
  probb_.Clear();
}
double SupportVectorClassifier::probb(int index) const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.SupportVectorClassifier.probB)
  return probb_.Get(index);
}
void SupportVectorClassifier::set_probb(int index, double value) {
  probb_.Set(index, value);
  // @@protoc_insertion_point(field_set:CoreML.Specification.SupportVectorClassifier.probB)
}
void SupportVectorClassifier::add_probb(double value) {
  probb_.Add(value);
  // @@protoc_insertion_point(field_add:CoreML.Specification.SupportVectorClassifier.probB)
}
const ::google::protobuf::RepeatedField< double >&
SupportVectorClassifier::probb() const {
  // @@protoc_insertion_point(field_list:CoreML.Specification.SupportVectorClassifier.probB)
  return probb_;
}
::google::protobuf::RepeatedField< double >*
SupportVectorClassifier::mutable_probb() {
  // @@protoc_insertion_point(field_mutable_list:CoreML.Specification.SupportVectorClassifier.probB)
  return &probb_;
}

// optional .CoreML.Specification.StringVector stringClassLabels = 100;
bool SupportVectorClassifier::has_stringclasslabels() const {
  return ClassLabels_case() == kStringClassLabels;
}
void SupportVectorClassifier::set_has_stringclasslabels() {
  _oneof_case_[1] = kStringClassLabels;
}
void SupportVectorClassifier::clear_stringclasslabels() {
  if (has_stringclasslabels()) {
    delete ClassLabels_.stringclasslabels_;
    clear_has_ClassLabels();
  }
}
 const ::CoreML::Specification::StringVector& SupportVectorClassifier::stringclasslabels() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.SupportVectorClassifier.stringClassLabels)
  return has_stringclasslabels()
      ? *ClassLabels_.stringclasslabels_
      : ::CoreML::Specification::StringVector::default_instance();
}
::CoreML::Specification::StringVector* SupportVectorClassifier::mutable_stringclasslabels() {
  if (!has_stringclasslabels()) {
    clear_ClassLabels();
    set_has_stringclasslabels();
    ClassLabels_.stringclasslabels_ = new ::CoreML::Specification::StringVector;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.SupportVectorClassifier.stringClassLabels)
  return ClassLabels_.stringclasslabels_;
}
::CoreML::Specification::StringVector* SupportVectorClassifier::release_stringclasslabels() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.SupportVectorClassifier.stringClassLabels)
  if (has_stringclasslabels()) {
    clear_has_ClassLabels();
    ::CoreML::Specification::StringVector* temp = ClassLabels_.stringclasslabels_;
    ClassLabels_.stringclasslabels_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void SupportVectorClassifier::set_allocated_stringclasslabels(::CoreML::Specification::StringVector* stringclasslabels) {
  clear_ClassLabels();
  if (stringclasslabels) {
    set_has_stringclasslabels();
    ClassLabels_.stringclasslabels_ = stringclasslabels;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.SupportVectorClassifier.stringClassLabels)
}

// optional .CoreML.Specification.Int64Vector int64ClassLabels = 101;
bool SupportVectorClassifier::has_int64classlabels() const {
  return ClassLabels_case() == kInt64ClassLabels;
}
void SupportVectorClassifier::set_has_int64classlabels() {
  _oneof_case_[1] = kInt64ClassLabels;
}
void SupportVectorClassifier::clear_int64classlabels() {
  if (has_int64classlabels()) {
    delete ClassLabels_.int64classlabels_;
    clear_has_ClassLabels();
  }
}
 const ::CoreML::Specification::Int64Vector& SupportVectorClassifier::int64classlabels() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.SupportVectorClassifier.int64ClassLabels)
  return has_int64classlabels()
      ? *ClassLabels_.int64classlabels_
      : ::CoreML::Specification::Int64Vector::default_instance();
}
::CoreML::Specification::Int64Vector* SupportVectorClassifier::mutable_int64classlabels() {
  if (!has_int64classlabels()) {
    clear_ClassLabels();
    set_has_int64classlabels();
    ClassLabels_.int64classlabels_ = new ::CoreML::Specification::Int64Vector;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.SupportVectorClassifier.int64ClassLabels)
  return ClassLabels_.int64classlabels_;
}
::CoreML::Specification::Int64Vector* SupportVectorClassifier::release_int64classlabels() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.SupportVectorClassifier.int64ClassLabels)
  if (has_int64classlabels()) {
    clear_has_ClassLabels();
    ::CoreML::Specification::Int64Vector* temp = ClassLabels_.int64classlabels_;
    ClassLabels_.int64classlabels_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void SupportVectorClassifier::set_allocated_int64classlabels(::CoreML::Specification::Int64Vector* int64classlabels) {
  clear_ClassLabels();
  if (int64classlabels) {
    set_has_int64classlabels();
    ClassLabels_.int64classlabels_ = int64classlabels;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.SupportVectorClassifier.int64ClassLabels)
}

bool SupportVectorClassifier::has_supportVectors() const {
  return supportVectors_case() != SUPPORTVECTORS_NOT_SET;
}
void SupportVectorClassifier::clear_has_supportVectors() {
  _oneof_case_[0] = SUPPORTVECTORS_NOT_SET;
}
bool SupportVectorClassifier::has_ClassLabels() const {
  return ClassLabels_case() != CLASSLABELS_NOT_SET;
}
void SupportVectorClassifier::clear_has_ClassLabels() {
  _oneof_case_[1] = CLASSLABELS_NOT_SET;
}
SupportVectorClassifier::SupportVectorsCase SupportVectorClassifier::supportVectors_case() const {
  return SupportVectorClassifier::SupportVectorsCase(_oneof_case_[0]);
}
SupportVectorClassifier::ClassLabelsCase SupportVectorClassifier::ClassLabels_case() const {
  return SupportVectorClassifier::ClassLabelsCase(_oneof_case_[1]);
}
inline const SupportVectorClassifier* SupportVectorClassifier::internal_default_instance() {
  return &SupportVectorClassifier_default_instance_.get();
}
#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace Specification
}  // namespace CoreML

// @@protoc_insertion_point(global_scope)
