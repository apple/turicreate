/* Copyright Â© 2017 Apple Inc. All rights reserved.
 *
 * Use of this source code is governed by a BSD-3-clause license that can
 * be found in the LICENSE.txt file or at https://opensource.org/licenses/BSD-3-Clause
 */
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: FeatureTypes.proto

#ifndef PROTOBUF_FeatureTypes_2eproto__INCLUDED
#define PROTOBUF_FeatureTypes_2eproto__INCLUDED

#include <string>

#include <protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3001000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3001000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <protobuf/arena.h>
#include <protobuf/arenastring.h>
#include <protobuf/generated_message_util.h>
#include <protobuf/message_lite.h>
#include <protobuf/repeated_field.h>
#include <protobuf/extension_set.h>
#include <protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)

namespace CoreML {
namespace Specification {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_FeatureTypes_2eproto();
void protobuf_InitDefaults_FeatureTypes_2eproto();
void protobuf_AssignDesc_FeatureTypes_2eproto();
void protobuf_ShutdownFile_FeatureTypes_2eproto();

class ArrayFeatureType;
class DictionaryFeatureType;
class DoubleFeatureType;
class FeatureType;
class ImageFeatureType;
class Int64FeatureType;
class StringFeatureType;

enum ImageFeatureType_ColorSpace {
  ImageFeatureType_ColorSpace_INVALID_COLOR_SPACE = 0,
  ImageFeatureType_ColorSpace_GRAYSCALE = 10,
  ImageFeatureType_ColorSpace_RGB = 20,
  ImageFeatureType_ColorSpace_BGR = 30,
  ImageFeatureType_ColorSpace_ImageFeatureType_ColorSpace_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ImageFeatureType_ColorSpace_ImageFeatureType_ColorSpace_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ImageFeatureType_ColorSpace_IsValid(int value);
const ImageFeatureType_ColorSpace ImageFeatureType_ColorSpace_ColorSpace_MIN = ImageFeatureType_ColorSpace_INVALID_COLOR_SPACE;
const ImageFeatureType_ColorSpace ImageFeatureType_ColorSpace_ColorSpace_MAX = ImageFeatureType_ColorSpace_BGR;
const int ImageFeatureType_ColorSpace_ColorSpace_ARRAYSIZE = ImageFeatureType_ColorSpace_ColorSpace_MAX + 1;

enum ArrayFeatureType_ArrayDataType {
  ArrayFeatureType_ArrayDataType_INVALID_ARRAY_DATA_TYPE = 0,
  ArrayFeatureType_ArrayDataType_FLOAT32 = 65568,
  ArrayFeatureType_ArrayDataType_DOUBLE = 65600,
  ArrayFeatureType_ArrayDataType_INT32 = 131104,
  ArrayFeatureType_ArrayDataType_ArrayFeatureType_ArrayDataType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ArrayFeatureType_ArrayDataType_ArrayFeatureType_ArrayDataType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ArrayFeatureType_ArrayDataType_IsValid(int value);
const ArrayFeatureType_ArrayDataType ArrayFeatureType_ArrayDataType_ArrayDataType_MIN = ArrayFeatureType_ArrayDataType_INVALID_ARRAY_DATA_TYPE;
const ArrayFeatureType_ArrayDataType ArrayFeatureType_ArrayDataType_ArrayDataType_MAX = ArrayFeatureType_ArrayDataType_INT32;
const int ArrayFeatureType_ArrayDataType_ArrayDataType_ARRAYSIZE = ArrayFeatureType_ArrayDataType_ArrayDataType_MAX + 1;

// ===================================================================

class Int64FeatureType : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.Int64FeatureType) */ {
 public:
  Int64FeatureType();
  virtual ~Int64FeatureType();

  Int64FeatureType(const Int64FeatureType& from);

  inline Int64FeatureType& operator=(const Int64FeatureType& from) {
    CopyFrom(from);
    return *this;
  }

  static const Int64FeatureType& default_instance();

  static const Int64FeatureType* internal_default_instance();

  void Swap(Int64FeatureType* other);

  // implements Message ----------------------------------------------

  inline Int64FeatureType* New() const { return New(NULL); }

  Int64FeatureType* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Int64FeatureType& from);
  void MergeFrom(const Int64FeatureType& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Int64FeatureType* other);
  void UnsafeMergeFrom(const Int64FeatureType& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:CoreML.Specification.Int64FeatureType)
 private:

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_FeatureTypes_2eproto_impl();
  friend void  protobuf_AddDesc_FeatureTypes_2eproto_impl();
  friend void protobuf_AssignDesc_FeatureTypes_2eproto();
  friend void protobuf_ShutdownFile_FeatureTypes_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<Int64FeatureType> Int64FeatureType_default_instance_;

// -------------------------------------------------------------------

class DoubleFeatureType : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.DoubleFeatureType) */ {
 public:
  DoubleFeatureType();
  virtual ~DoubleFeatureType();

  DoubleFeatureType(const DoubleFeatureType& from);

  inline DoubleFeatureType& operator=(const DoubleFeatureType& from) {
    CopyFrom(from);
    return *this;
  }

  static const DoubleFeatureType& default_instance();

  static const DoubleFeatureType* internal_default_instance();

  void Swap(DoubleFeatureType* other);

  // implements Message ----------------------------------------------

  inline DoubleFeatureType* New() const { return New(NULL); }

  DoubleFeatureType* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const DoubleFeatureType& from);
  void MergeFrom(const DoubleFeatureType& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DoubleFeatureType* other);
  void UnsafeMergeFrom(const DoubleFeatureType& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:CoreML.Specification.DoubleFeatureType)
 private:

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_FeatureTypes_2eproto_impl();
  friend void  protobuf_AddDesc_FeatureTypes_2eproto_impl();
  friend void protobuf_AssignDesc_FeatureTypes_2eproto();
  friend void protobuf_ShutdownFile_FeatureTypes_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<DoubleFeatureType> DoubleFeatureType_default_instance_;

// -------------------------------------------------------------------

class StringFeatureType : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.StringFeatureType) */ {
 public:
  StringFeatureType();
  virtual ~StringFeatureType();

  StringFeatureType(const StringFeatureType& from);

  inline StringFeatureType& operator=(const StringFeatureType& from) {
    CopyFrom(from);
    return *this;
  }

  static const StringFeatureType& default_instance();

  static const StringFeatureType* internal_default_instance();

  void Swap(StringFeatureType* other);

  // implements Message ----------------------------------------------

  inline StringFeatureType* New() const { return New(NULL); }

  StringFeatureType* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const StringFeatureType& from);
  void MergeFrom(const StringFeatureType& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(StringFeatureType* other);
  void UnsafeMergeFrom(const StringFeatureType& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:CoreML.Specification.StringFeatureType)
 private:

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_FeatureTypes_2eproto_impl();
  friend void  protobuf_AddDesc_FeatureTypes_2eproto_impl();
  friend void protobuf_AssignDesc_FeatureTypes_2eproto();
  friend void protobuf_ShutdownFile_FeatureTypes_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<StringFeatureType> StringFeatureType_default_instance_;

// -------------------------------------------------------------------

class ImageFeatureType : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.ImageFeatureType) */ {
 public:
  ImageFeatureType();
  virtual ~ImageFeatureType();

  ImageFeatureType(const ImageFeatureType& from);

  inline ImageFeatureType& operator=(const ImageFeatureType& from) {
    CopyFrom(from);
    return *this;
  }

  static const ImageFeatureType& default_instance();

  static const ImageFeatureType* internal_default_instance();

  void Swap(ImageFeatureType* other);

  // implements Message ----------------------------------------------

  inline ImageFeatureType* New() const { return New(NULL); }

  ImageFeatureType* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ImageFeatureType& from);
  void MergeFrom(const ImageFeatureType& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ImageFeatureType* other);
  void UnsafeMergeFrom(const ImageFeatureType& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef ImageFeatureType_ColorSpace ColorSpace;
  static const ColorSpace INVALID_COLOR_SPACE =
    ImageFeatureType_ColorSpace_INVALID_COLOR_SPACE;
  static const ColorSpace GRAYSCALE =
    ImageFeatureType_ColorSpace_GRAYSCALE;
  static const ColorSpace RGB =
    ImageFeatureType_ColorSpace_RGB;
  static const ColorSpace BGR =
    ImageFeatureType_ColorSpace_BGR;
  static inline bool ColorSpace_IsValid(int value) {
    return ImageFeatureType_ColorSpace_IsValid(value);
  }
  static const ColorSpace ColorSpace_MIN =
    ImageFeatureType_ColorSpace_ColorSpace_MIN;
  static const ColorSpace ColorSpace_MAX =
    ImageFeatureType_ColorSpace_ColorSpace_MAX;
  static const int ColorSpace_ARRAYSIZE =
    ImageFeatureType_ColorSpace_ColorSpace_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional uint64 width = 1;
  void clear_width();
  static const int kWidthFieldNumber = 1;
  ::google::protobuf::uint64 width() const;
  void set_width(::google::protobuf::uint64 value);

  // optional uint64 height = 2;
  void clear_height();
  static const int kHeightFieldNumber = 2;
  ::google::protobuf::uint64 height() const;
  void set_height(::google::protobuf::uint64 value);

  // optional .CoreML.Specification.ImageFeatureType.ColorSpace colorSpace = 3;
  void clear_colorspace();
  static const int kColorSpaceFieldNumber = 3;
  ::CoreML::Specification::ImageFeatureType_ColorSpace colorspace() const;
  void set_colorspace(::CoreML::Specification::ImageFeatureType_ColorSpace value);

  // @@protoc_insertion_point(class_scope:CoreML.Specification.ImageFeatureType)
 private:

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint64 width_;
  ::google::protobuf::uint64 height_;
  int colorspace_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_FeatureTypes_2eproto_impl();
  friend void  protobuf_AddDesc_FeatureTypes_2eproto_impl();
  friend void protobuf_AssignDesc_FeatureTypes_2eproto();
  friend void protobuf_ShutdownFile_FeatureTypes_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<ImageFeatureType> ImageFeatureType_default_instance_;

// -------------------------------------------------------------------

class ArrayFeatureType : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.ArrayFeatureType) */ {
 public:
  ArrayFeatureType();
  virtual ~ArrayFeatureType();

  ArrayFeatureType(const ArrayFeatureType& from);

  inline ArrayFeatureType& operator=(const ArrayFeatureType& from) {
    CopyFrom(from);
    return *this;
  }

  static const ArrayFeatureType& default_instance();

  static const ArrayFeatureType* internal_default_instance();

  void Swap(ArrayFeatureType* other);

  // implements Message ----------------------------------------------

  inline ArrayFeatureType* New() const { return New(NULL); }

  ArrayFeatureType* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ArrayFeatureType& from);
  void MergeFrom(const ArrayFeatureType& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ArrayFeatureType* other);
  void UnsafeMergeFrom(const ArrayFeatureType& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef ArrayFeatureType_ArrayDataType ArrayDataType;
  static const ArrayDataType INVALID_ARRAY_DATA_TYPE =
    ArrayFeatureType_ArrayDataType_INVALID_ARRAY_DATA_TYPE;
  static const ArrayDataType FLOAT32 =
    ArrayFeatureType_ArrayDataType_FLOAT32;
  static const ArrayDataType DOUBLE =
    ArrayFeatureType_ArrayDataType_DOUBLE;
  static const ArrayDataType INT32 =
    ArrayFeatureType_ArrayDataType_INT32;
  static inline bool ArrayDataType_IsValid(int value) {
    return ArrayFeatureType_ArrayDataType_IsValid(value);
  }
  static const ArrayDataType ArrayDataType_MIN =
    ArrayFeatureType_ArrayDataType_ArrayDataType_MIN;
  static const ArrayDataType ArrayDataType_MAX =
    ArrayFeatureType_ArrayDataType_ArrayDataType_MAX;
  static const int ArrayDataType_ARRAYSIZE =
    ArrayFeatureType_ArrayDataType_ArrayDataType_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // repeated uint64 shape = 1;
  int shape_size() const;
  void clear_shape();
  static const int kShapeFieldNumber = 1;
  ::google::protobuf::uint64 shape(int index) const;
  void set_shape(int index, ::google::protobuf::uint64 value);
  void add_shape(::google::protobuf::uint64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      shape() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_shape();

  // optional .CoreML.Specification.ArrayFeatureType.ArrayDataType dataType = 2;
  void clear_datatype();
  static const int kDataTypeFieldNumber = 2;
  ::CoreML::Specification::ArrayFeatureType_ArrayDataType datatype() const;
  void set_datatype(::CoreML::Specification::ArrayFeatureType_ArrayDataType value);

  // @@protoc_insertion_point(class_scope:CoreML.Specification.ArrayFeatureType)
 private:

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > shape_;
  mutable int _shape_cached_byte_size_;
  int datatype_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_FeatureTypes_2eproto_impl();
  friend void  protobuf_AddDesc_FeatureTypes_2eproto_impl();
  friend void protobuf_AssignDesc_FeatureTypes_2eproto();
  friend void protobuf_ShutdownFile_FeatureTypes_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<ArrayFeatureType> ArrayFeatureType_default_instance_;

// -------------------------------------------------------------------

class DictionaryFeatureType : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.DictionaryFeatureType) */ {
 public:
  DictionaryFeatureType();
  virtual ~DictionaryFeatureType();

  DictionaryFeatureType(const DictionaryFeatureType& from);

  inline DictionaryFeatureType& operator=(const DictionaryFeatureType& from) {
    CopyFrom(from);
    return *this;
  }

  static const DictionaryFeatureType& default_instance();

  enum KeyTypeCase {
    kInt64KeyType = 1,
    kStringKeyType = 2,
    KEYTYPE_NOT_SET = 0,
  };

  static const DictionaryFeatureType* internal_default_instance();

  void Swap(DictionaryFeatureType* other);

  // implements Message ----------------------------------------------

  inline DictionaryFeatureType* New() const { return New(NULL); }

  DictionaryFeatureType* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const DictionaryFeatureType& from);
  void MergeFrom(const DictionaryFeatureType& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DictionaryFeatureType* other);
  void UnsafeMergeFrom(const DictionaryFeatureType& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .CoreML.Specification.Int64FeatureType int64KeyType = 1;
  bool has_int64keytype() const;
  void clear_int64keytype();
  static const int kInt64KeyTypeFieldNumber = 1;
  const ::CoreML::Specification::Int64FeatureType& int64keytype() const;
  ::CoreML::Specification::Int64FeatureType* mutable_int64keytype();
  ::CoreML::Specification::Int64FeatureType* release_int64keytype();
  void set_allocated_int64keytype(::CoreML::Specification::Int64FeatureType* int64keytype);

  // optional .CoreML.Specification.StringFeatureType stringKeyType = 2;
  bool has_stringkeytype() const;
  void clear_stringkeytype();
  static const int kStringKeyTypeFieldNumber = 2;
  const ::CoreML::Specification::StringFeatureType& stringkeytype() const;
  ::CoreML::Specification::StringFeatureType* mutable_stringkeytype();
  ::CoreML::Specification::StringFeatureType* release_stringkeytype();
  void set_allocated_stringkeytype(::CoreML::Specification::StringFeatureType* stringkeytype);

  KeyTypeCase KeyType_case() const;
  // @@protoc_insertion_point(class_scope:CoreML.Specification.DictionaryFeatureType)
 private:
  inline void set_has_int64keytype();
  inline void set_has_stringkeytype();

  inline bool has_KeyType() const;
  void clear_KeyType();
  inline void clear_has_KeyType();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  union KeyTypeUnion {
    KeyTypeUnion() {}
    ::CoreML::Specification::Int64FeatureType* int64keytype_;
    ::CoreML::Specification::StringFeatureType* stringkeytype_;
  } KeyType_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_InitDefaults_FeatureTypes_2eproto_impl();
  friend void  protobuf_AddDesc_FeatureTypes_2eproto_impl();
  friend void protobuf_AssignDesc_FeatureTypes_2eproto();
  friend void protobuf_ShutdownFile_FeatureTypes_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<DictionaryFeatureType> DictionaryFeatureType_default_instance_;

// -------------------------------------------------------------------

class FeatureType : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.FeatureType) */ {
 public:
  FeatureType();
  virtual ~FeatureType();

  FeatureType(const FeatureType& from);

  inline FeatureType& operator=(const FeatureType& from) {
    CopyFrom(from);
    return *this;
  }

  static const FeatureType& default_instance();

  enum TypeCase {
    kInt64Type = 1,
    kDoubleType = 2,
    kStringType = 3,
    kImageType = 4,
    kMultiArrayType = 5,
    kDictionaryType = 6,
    TYPE_NOT_SET = 0,
  };

  static const FeatureType* internal_default_instance();

  void Swap(FeatureType* other);

  // implements Message ----------------------------------------------

  inline FeatureType* New() const { return New(NULL); }

  FeatureType* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const FeatureType& from);
  void MergeFrom(const FeatureType& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(FeatureType* other);
  void UnsafeMergeFrom(const FeatureType& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .CoreML.Specification.Int64FeatureType int64Type = 1;
  bool has_int64type() const;
  void clear_int64type();
  static const int kInt64TypeFieldNumber = 1;
  const ::CoreML::Specification::Int64FeatureType& int64type() const;
  ::CoreML::Specification::Int64FeatureType* mutable_int64type();
  ::CoreML::Specification::Int64FeatureType* release_int64type();
  void set_allocated_int64type(::CoreML::Specification::Int64FeatureType* int64type);

  // optional .CoreML.Specification.DoubleFeatureType doubleType = 2;
  bool has_doubletype() const;
  void clear_doubletype();
  static const int kDoubleTypeFieldNumber = 2;
  const ::CoreML::Specification::DoubleFeatureType& doubletype() const;
  ::CoreML::Specification::DoubleFeatureType* mutable_doubletype();
  ::CoreML::Specification::DoubleFeatureType* release_doubletype();
  void set_allocated_doubletype(::CoreML::Specification::DoubleFeatureType* doubletype);

  // optional .CoreML.Specification.StringFeatureType stringType = 3;
  bool has_stringtype() const;
  void clear_stringtype();
  static const int kStringTypeFieldNumber = 3;
  const ::CoreML::Specification::StringFeatureType& stringtype() const;
  ::CoreML::Specification::StringFeatureType* mutable_stringtype();
  ::CoreML::Specification::StringFeatureType* release_stringtype();
  void set_allocated_stringtype(::CoreML::Specification::StringFeatureType* stringtype);

  // optional .CoreML.Specification.ImageFeatureType imageType = 4;
  bool has_imagetype() const;
  void clear_imagetype();
  static const int kImageTypeFieldNumber = 4;
  const ::CoreML::Specification::ImageFeatureType& imagetype() const;
  ::CoreML::Specification::ImageFeatureType* mutable_imagetype();
  ::CoreML::Specification::ImageFeatureType* release_imagetype();
  void set_allocated_imagetype(::CoreML::Specification::ImageFeatureType* imagetype);

  // optional .CoreML.Specification.ArrayFeatureType multiArrayType = 5;
  bool has_multiarraytype() const;
  void clear_multiarraytype();
  static const int kMultiArrayTypeFieldNumber = 5;
  const ::CoreML::Specification::ArrayFeatureType& multiarraytype() const;
  ::CoreML::Specification::ArrayFeatureType* mutable_multiarraytype();
  ::CoreML::Specification::ArrayFeatureType* release_multiarraytype();
  void set_allocated_multiarraytype(::CoreML::Specification::ArrayFeatureType* multiarraytype);

  // optional .CoreML.Specification.DictionaryFeatureType dictionaryType = 6;
  bool has_dictionarytype() const;
  void clear_dictionarytype();
  static const int kDictionaryTypeFieldNumber = 6;
  const ::CoreML::Specification::DictionaryFeatureType& dictionarytype() const;
  ::CoreML::Specification::DictionaryFeatureType* mutable_dictionarytype();
  ::CoreML::Specification::DictionaryFeatureType* release_dictionarytype();
  void set_allocated_dictionarytype(::CoreML::Specification::DictionaryFeatureType* dictionarytype);

  // optional bool isOptional = 1000;
  void clear_isoptional();
  static const int kIsOptionalFieldNumber = 1000;
  bool isoptional() const;
  void set_isoptional(bool value);

  TypeCase Type_case() const;
  // @@protoc_insertion_point(class_scope:CoreML.Specification.FeatureType)
 private:
  inline void set_has_int64type();
  inline void set_has_doubletype();
  inline void set_has_stringtype();
  inline void set_has_imagetype();
  inline void set_has_multiarraytype();
  inline void set_has_dictionarytype();

  inline bool has_Type() const;
  void clear_Type();
  inline void clear_has_Type();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  bool isoptional_;
  union TypeUnion {
    TypeUnion() {}
    ::CoreML::Specification::Int64FeatureType* int64type_;
    ::CoreML::Specification::DoubleFeatureType* doubletype_;
    ::CoreML::Specification::StringFeatureType* stringtype_;
    ::CoreML::Specification::ImageFeatureType* imagetype_;
    ::CoreML::Specification::ArrayFeatureType* multiarraytype_;
    ::CoreML::Specification::DictionaryFeatureType* dictionarytype_;
  } Type_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_InitDefaults_FeatureTypes_2eproto_impl();
  friend void  protobuf_AddDesc_FeatureTypes_2eproto_impl();
  friend void protobuf_AssignDesc_FeatureTypes_2eproto();
  friend void protobuf_ShutdownFile_FeatureTypes_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<FeatureType> FeatureType_default_instance_;

// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// Int64FeatureType

inline const Int64FeatureType* Int64FeatureType::internal_default_instance() {
  return &Int64FeatureType_default_instance_.get();
}
// -------------------------------------------------------------------

// DoubleFeatureType

inline const DoubleFeatureType* DoubleFeatureType::internal_default_instance() {
  return &DoubleFeatureType_default_instance_.get();
}
// -------------------------------------------------------------------

// StringFeatureType

inline const StringFeatureType* StringFeatureType::internal_default_instance() {
  return &StringFeatureType_default_instance_.get();
}
// -------------------------------------------------------------------

// ImageFeatureType

// optional uint64 width = 1;
inline void ImageFeatureType::clear_width() {
  width_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 ImageFeatureType::width() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.ImageFeatureType.width)
  return width_;
}
inline void ImageFeatureType::set_width(::google::protobuf::uint64 value) {
  
  width_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.ImageFeatureType.width)
}

// optional uint64 height = 2;
inline void ImageFeatureType::clear_height() {
  height_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 ImageFeatureType::height() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.ImageFeatureType.height)
  return height_;
}
inline void ImageFeatureType::set_height(::google::protobuf::uint64 value) {
  
  height_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.ImageFeatureType.height)
}

// optional .CoreML.Specification.ImageFeatureType.ColorSpace colorSpace = 3;
inline void ImageFeatureType::clear_colorspace() {
  colorspace_ = 0;
}
inline ::CoreML::Specification::ImageFeatureType_ColorSpace ImageFeatureType::colorspace() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.ImageFeatureType.colorSpace)
  return static_cast< ::CoreML::Specification::ImageFeatureType_ColorSpace >(colorspace_);
}
inline void ImageFeatureType::set_colorspace(::CoreML::Specification::ImageFeatureType_ColorSpace value) {
  
  colorspace_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.ImageFeatureType.colorSpace)
}

inline const ImageFeatureType* ImageFeatureType::internal_default_instance() {
  return &ImageFeatureType_default_instance_.get();
}
// -------------------------------------------------------------------

// ArrayFeatureType

// repeated uint64 shape = 1;
inline int ArrayFeatureType::shape_size() const {
  return shape_.size();
}
inline void ArrayFeatureType::clear_shape() {
  shape_.Clear();
}
inline ::google::protobuf::uint64 ArrayFeatureType::shape(int index) const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.ArrayFeatureType.shape)
  return shape_.Get(index);
}
inline void ArrayFeatureType::set_shape(int index, ::google::protobuf::uint64 value) {
  shape_.Set(index, value);
  // @@protoc_insertion_point(field_set:CoreML.Specification.ArrayFeatureType.shape)
}
inline void ArrayFeatureType::add_shape(::google::protobuf::uint64 value) {
  shape_.Add(value);
  // @@protoc_insertion_point(field_add:CoreML.Specification.ArrayFeatureType.shape)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
ArrayFeatureType::shape() const {
  // @@protoc_insertion_point(field_list:CoreML.Specification.ArrayFeatureType.shape)
  return shape_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
ArrayFeatureType::mutable_shape() {
  // @@protoc_insertion_point(field_mutable_list:CoreML.Specification.ArrayFeatureType.shape)
  return &shape_;
}

// optional .CoreML.Specification.ArrayFeatureType.ArrayDataType dataType = 2;
inline void ArrayFeatureType::clear_datatype() {
  datatype_ = 0;
}
inline ::CoreML::Specification::ArrayFeatureType_ArrayDataType ArrayFeatureType::datatype() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.ArrayFeatureType.dataType)
  return static_cast< ::CoreML::Specification::ArrayFeatureType_ArrayDataType >(datatype_);
}
inline void ArrayFeatureType::set_datatype(::CoreML::Specification::ArrayFeatureType_ArrayDataType value) {
  
  datatype_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.ArrayFeatureType.dataType)
}

inline const ArrayFeatureType* ArrayFeatureType::internal_default_instance() {
  return &ArrayFeatureType_default_instance_.get();
}
// -------------------------------------------------------------------

// DictionaryFeatureType

// optional .CoreML.Specification.Int64FeatureType int64KeyType = 1;
inline bool DictionaryFeatureType::has_int64keytype() const {
  return KeyType_case() == kInt64KeyType;
}
inline void DictionaryFeatureType::set_has_int64keytype() {
  _oneof_case_[0] = kInt64KeyType;
}
inline void DictionaryFeatureType::clear_int64keytype() {
  if (has_int64keytype()) {
    delete KeyType_.int64keytype_;
    clear_has_KeyType();
  }
}
inline  const ::CoreML::Specification::Int64FeatureType& DictionaryFeatureType::int64keytype() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.DictionaryFeatureType.int64KeyType)
  return has_int64keytype()
      ? *KeyType_.int64keytype_
      : ::CoreML::Specification::Int64FeatureType::default_instance();
}
inline ::CoreML::Specification::Int64FeatureType* DictionaryFeatureType::mutable_int64keytype() {
  if (!has_int64keytype()) {
    clear_KeyType();
    set_has_int64keytype();
    KeyType_.int64keytype_ = new ::CoreML::Specification::Int64FeatureType;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.DictionaryFeatureType.int64KeyType)
  return KeyType_.int64keytype_;
}
inline ::CoreML::Specification::Int64FeatureType* DictionaryFeatureType::release_int64keytype() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.DictionaryFeatureType.int64KeyType)
  if (has_int64keytype()) {
    clear_has_KeyType();
    ::CoreML::Specification::Int64FeatureType* temp = KeyType_.int64keytype_;
    KeyType_.int64keytype_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void DictionaryFeatureType::set_allocated_int64keytype(::CoreML::Specification::Int64FeatureType* int64keytype) {
  clear_KeyType();
  if (int64keytype) {
    set_has_int64keytype();
    KeyType_.int64keytype_ = int64keytype;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.DictionaryFeatureType.int64KeyType)
}

// optional .CoreML.Specification.StringFeatureType stringKeyType = 2;
inline bool DictionaryFeatureType::has_stringkeytype() const {
  return KeyType_case() == kStringKeyType;
}
inline void DictionaryFeatureType::set_has_stringkeytype() {
  _oneof_case_[0] = kStringKeyType;
}
inline void DictionaryFeatureType::clear_stringkeytype() {
  if (has_stringkeytype()) {
    delete KeyType_.stringkeytype_;
    clear_has_KeyType();
  }
}
inline  const ::CoreML::Specification::StringFeatureType& DictionaryFeatureType::stringkeytype() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.DictionaryFeatureType.stringKeyType)
  return has_stringkeytype()
      ? *KeyType_.stringkeytype_
      : ::CoreML::Specification::StringFeatureType::default_instance();
}
inline ::CoreML::Specification::StringFeatureType* DictionaryFeatureType::mutable_stringkeytype() {
  if (!has_stringkeytype()) {
    clear_KeyType();
    set_has_stringkeytype();
    KeyType_.stringkeytype_ = new ::CoreML::Specification::StringFeatureType;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.DictionaryFeatureType.stringKeyType)
  return KeyType_.stringkeytype_;
}
inline ::CoreML::Specification::StringFeatureType* DictionaryFeatureType::release_stringkeytype() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.DictionaryFeatureType.stringKeyType)
  if (has_stringkeytype()) {
    clear_has_KeyType();
    ::CoreML::Specification::StringFeatureType* temp = KeyType_.stringkeytype_;
    KeyType_.stringkeytype_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void DictionaryFeatureType::set_allocated_stringkeytype(::CoreML::Specification::StringFeatureType* stringkeytype) {
  clear_KeyType();
  if (stringkeytype) {
    set_has_stringkeytype();
    KeyType_.stringkeytype_ = stringkeytype;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.DictionaryFeatureType.stringKeyType)
}

inline bool DictionaryFeatureType::has_KeyType() const {
  return KeyType_case() != KEYTYPE_NOT_SET;
}
inline void DictionaryFeatureType::clear_has_KeyType() {
  _oneof_case_[0] = KEYTYPE_NOT_SET;
}
inline DictionaryFeatureType::KeyTypeCase DictionaryFeatureType::KeyType_case() const {
  return DictionaryFeatureType::KeyTypeCase(_oneof_case_[0]);
}
inline const DictionaryFeatureType* DictionaryFeatureType::internal_default_instance() {
  return &DictionaryFeatureType_default_instance_.get();
}
// -------------------------------------------------------------------

// FeatureType

// optional .CoreML.Specification.Int64FeatureType int64Type = 1;
inline bool FeatureType::has_int64type() const {
  return Type_case() == kInt64Type;
}
inline void FeatureType::set_has_int64type() {
  _oneof_case_[0] = kInt64Type;
}
inline void FeatureType::clear_int64type() {
  if (has_int64type()) {
    delete Type_.int64type_;
    clear_has_Type();
  }
}
inline  const ::CoreML::Specification::Int64FeatureType& FeatureType::int64type() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.FeatureType.int64Type)
  return has_int64type()
      ? *Type_.int64type_
      : ::CoreML::Specification::Int64FeatureType::default_instance();
}
inline ::CoreML::Specification::Int64FeatureType* FeatureType::mutable_int64type() {
  if (!has_int64type()) {
    clear_Type();
    set_has_int64type();
    Type_.int64type_ = new ::CoreML::Specification::Int64FeatureType;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.FeatureType.int64Type)
  return Type_.int64type_;
}
inline ::CoreML::Specification::Int64FeatureType* FeatureType::release_int64type() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.FeatureType.int64Type)
  if (has_int64type()) {
    clear_has_Type();
    ::CoreML::Specification::Int64FeatureType* temp = Type_.int64type_;
    Type_.int64type_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void FeatureType::set_allocated_int64type(::CoreML::Specification::Int64FeatureType* int64type) {
  clear_Type();
  if (int64type) {
    set_has_int64type();
    Type_.int64type_ = int64type;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.FeatureType.int64Type)
}

// optional .CoreML.Specification.DoubleFeatureType doubleType = 2;
inline bool FeatureType::has_doubletype() const {
  return Type_case() == kDoubleType;
}
inline void FeatureType::set_has_doubletype() {
  _oneof_case_[0] = kDoubleType;
}
inline void FeatureType::clear_doubletype() {
  if (has_doubletype()) {
    delete Type_.doubletype_;
    clear_has_Type();
  }
}
inline  const ::CoreML::Specification::DoubleFeatureType& FeatureType::doubletype() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.FeatureType.doubleType)
  return has_doubletype()
      ? *Type_.doubletype_
      : ::CoreML::Specification::DoubleFeatureType::default_instance();
}
inline ::CoreML::Specification::DoubleFeatureType* FeatureType::mutable_doubletype() {
  if (!has_doubletype()) {
    clear_Type();
    set_has_doubletype();
    Type_.doubletype_ = new ::CoreML::Specification::DoubleFeatureType;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.FeatureType.doubleType)
  return Type_.doubletype_;
}
inline ::CoreML::Specification::DoubleFeatureType* FeatureType::release_doubletype() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.FeatureType.doubleType)
  if (has_doubletype()) {
    clear_has_Type();
    ::CoreML::Specification::DoubleFeatureType* temp = Type_.doubletype_;
    Type_.doubletype_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void FeatureType::set_allocated_doubletype(::CoreML::Specification::DoubleFeatureType* doubletype) {
  clear_Type();
  if (doubletype) {
    set_has_doubletype();
    Type_.doubletype_ = doubletype;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.FeatureType.doubleType)
}

// optional .CoreML.Specification.StringFeatureType stringType = 3;
inline bool FeatureType::has_stringtype() const {
  return Type_case() == kStringType;
}
inline void FeatureType::set_has_stringtype() {
  _oneof_case_[0] = kStringType;
}
inline void FeatureType::clear_stringtype() {
  if (has_stringtype()) {
    delete Type_.stringtype_;
    clear_has_Type();
  }
}
inline  const ::CoreML::Specification::StringFeatureType& FeatureType::stringtype() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.FeatureType.stringType)
  return has_stringtype()
      ? *Type_.stringtype_
      : ::CoreML::Specification::StringFeatureType::default_instance();
}
inline ::CoreML::Specification::StringFeatureType* FeatureType::mutable_stringtype() {
  if (!has_stringtype()) {
    clear_Type();
    set_has_stringtype();
    Type_.stringtype_ = new ::CoreML::Specification::StringFeatureType;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.FeatureType.stringType)
  return Type_.stringtype_;
}
inline ::CoreML::Specification::StringFeatureType* FeatureType::release_stringtype() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.FeatureType.stringType)
  if (has_stringtype()) {
    clear_has_Type();
    ::CoreML::Specification::StringFeatureType* temp = Type_.stringtype_;
    Type_.stringtype_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void FeatureType::set_allocated_stringtype(::CoreML::Specification::StringFeatureType* stringtype) {
  clear_Type();
  if (stringtype) {
    set_has_stringtype();
    Type_.stringtype_ = stringtype;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.FeatureType.stringType)
}

// optional .CoreML.Specification.ImageFeatureType imageType = 4;
inline bool FeatureType::has_imagetype() const {
  return Type_case() == kImageType;
}
inline void FeatureType::set_has_imagetype() {
  _oneof_case_[0] = kImageType;
}
inline void FeatureType::clear_imagetype() {
  if (has_imagetype()) {
    delete Type_.imagetype_;
    clear_has_Type();
  }
}
inline  const ::CoreML::Specification::ImageFeatureType& FeatureType::imagetype() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.FeatureType.imageType)
  return has_imagetype()
      ? *Type_.imagetype_
      : ::CoreML::Specification::ImageFeatureType::default_instance();
}
inline ::CoreML::Specification::ImageFeatureType* FeatureType::mutable_imagetype() {
  if (!has_imagetype()) {
    clear_Type();
    set_has_imagetype();
    Type_.imagetype_ = new ::CoreML::Specification::ImageFeatureType;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.FeatureType.imageType)
  return Type_.imagetype_;
}
inline ::CoreML::Specification::ImageFeatureType* FeatureType::release_imagetype() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.FeatureType.imageType)
  if (has_imagetype()) {
    clear_has_Type();
    ::CoreML::Specification::ImageFeatureType* temp = Type_.imagetype_;
    Type_.imagetype_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void FeatureType::set_allocated_imagetype(::CoreML::Specification::ImageFeatureType* imagetype) {
  clear_Type();
  if (imagetype) {
    set_has_imagetype();
    Type_.imagetype_ = imagetype;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.FeatureType.imageType)
}

// optional .CoreML.Specification.ArrayFeatureType multiArrayType = 5;
inline bool FeatureType::has_multiarraytype() const {
  return Type_case() == kMultiArrayType;
}
inline void FeatureType::set_has_multiarraytype() {
  _oneof_case_[0] = kMultiArrayType;
}
inline void FeatureType::clear_multiarraytype() {
  if (has_multiarraytype()) {
    delete Type_.multiarraytype_;
    clear_has_Type();
  }
}
inline  const ::CoreML::Specification::ArrayFeatureType& FeatureType::multiarraytype() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.FeatureType.multiArrayType)
  return has_multiarraytype()
      ? *Type_.multiarraytype_
      : ::CoreML::Specification::ArrayFeatureType::default_instance();
}
inline ::CoreML::Specification::ArrayFeatureType* FeatureType::mutable_multiarraytype() {
  if (!has_multiarraytype()) {
    clear_Type();
    set_has_multiarraytype();
    Type_.multiarraytype_ = new ::CoreML::Specification::ArrayFeatureType;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.FeatureType.multiArrayType)
  return Type_.multiarraytype_;
}
inline ::CoreML::Specification::ArrayFeatureType* FeatureType::release_multiarraytype() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.FeatureType.multiArrayType)
  if (has_multiarraytype()) {
    clear_has_Type();
    ::CoreML::Specification::ArrayFeatureType* temp = Type_.multiarraytype_;
    Type_.multiarraytype_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void FeatureType::set_allocated_multiarraytype(::CoreML::Specification::ArrayFeatureType* multiarraytype) {
  clear_Type();
  if (multiarraytype) {
    set_has_multiarraytype();
    Type_.multiarraytype_ = multiarraytype;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.FeatureType.multiArrayType)
}

// optional .CoreML.Specification.DictionaryFeatureType dictionaryType = 6;
inline bool FeatureType::has_dictionarytype() const {
  return Type_case() == kDictionaryType;
}
inline void FeatureType::set_has_dictionarytype() {
  _oneof_case_[0] = kDictionaryType;
}
inline void FeatureType::clear_dictionarytype() {
  if (has_dictionarytype()) {
    delete Type_.dictionarytype_;
    clear_has_Type();
  }
}
inline  const ::CoreML::Specification::DictionaryFeatureType& FeatureType::dictionarytype() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.FeatureType.dictionaryType)
  return has_dictionarytype()
      ? *Type_.dictionarytype_
      : ::CoreML::Specification::DictionaryFeatureType::default_instance();
}
inline ::CoreML::Specification::DictionaryFeatureType* FeatureType::mutable_dictionarytype() {
  if (!has_dictionarytype()) {
    clear_Type();
    set_has_dictionarytype();
    Type_.dictionarytype_ = new ::CoreML::Specification::DictionaryFeatureType;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.FeatureType.dictionaryType)
  return Type_.dictionarytype_;
}
inline ::CoreML::Specification::DictionaryFeatureType* FeatureType::release_dictionarytype() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.FeatureType.dictionaryType)
  if (has_dictionarytype()) {
    clear_has_Type();
    ::CoreML::Specification::DictionaryFeatureType* temp = Type_.dictionarytype_;
    Type_.dictionarytype_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void FeatureType::set_allocated_dictionarytype(::CoreML::Specification::DictionaryFeatureType* dictionarytype) {
  clear_Type();
  if (dictionarytype) {
    set_has_dictionarytype();
    Type_.dictionarytype_ = dictionarytype;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.FeatureType.dictionaryType)
}

// optional bool isOptional = 1000;
inline void FeatureType::clear_isoptional() {
  isoptional_ = false;
}
inline bool FeatureType::isoptional() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.FeatureType.isOptional)
  return isoptional_;
}
inline void FeatureType::set_isoptional(bool value) {
  
  isoptional_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.FeatureType.isOptional)
}

inline bool FeatureType::has_Type() const {
  return Type_case() != TYPE_NOT_SET;
}
inline void FeatureType::clear_has_Type() {
  _oneof_case_[0] = TYPE_NOT_SET;
}
inline FeatureType::TypeCase FeatureType::Type_case() const {
  return FeatureType::TypeCase(_oneof_case_[0]);
}
inline const FeatureType* FeatureType::internal_default_instance() {
  return &FeatureType_default_instance_.get();
}
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace Specification
}  // namespace CoreML

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::CoreML::Specification::ImageFeatureType_ColorSpace> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::CoreML::Specification::ArrayFeatureType_ArrayDataType> : ::google::protobuf::internal::true_type {};

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_FeatureTypes_2eproto__INCLUDED
