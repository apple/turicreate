// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: FeatureTypes.proto

#ifndef PROTOBUF_FeatureTypes_2eproto__INCLUDED
#define PROTOBUF_FeatureTypes_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3003000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3003000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)
namespace CoreML {
namespace Specification {
class ArrayFeatureType;
class ArrayFeatureTypeDefaultTypeInternal;
extern ArrayFeatureTypeDefaultTypeInternal _ArrayFeatureType_default_instance_;
class ArrayFeatureType_EnumeratedShapes;
class ArrayFeatureType_EnumeratedShapesDefaultTypeInternal;
extern ArrayFeatureType_EnumeratedShapesDefaultTypeInternal _ArrayFeatureType_EnumeratedShapes_default_instance_;
class ArrayFeatureType_Shape;
class ArrayFeatureType_ShapeDefaultTypeInternal;
extern ArrayFeatureType_ShapeDefaultTypeInternal _ArrayFeatureType_Shape_default_instance_;
class ArrayFeatureType_ShapeRange;
class ArrayFeatureType_ShapeRangeDefaultTypeInternal;
extern ArrayFeatureType_ShapeRangeDefaultTypeInternal _ArrayFeatureType_ShapeRange_default_instance_;
class DictionaryFeatureType;
class DictionaryFeatureTypeDefaultTypeInternal;
extern DictionaryFeatureTypeDefaultTypeInternal _DictionaryFeatureType_default_instance_;
class DoubleFeatureType;
class DoubleFeatureTypeDefaultTypeInternal;
extern DoubleFeatureTypeDefaultTypeInternal _DoubleFeatureType_default_instance_;
class FeatureType;
class FeatureTypeDefaultTypeInternal;
extern FeatureTypeDefaultTypeInternal _FeatureType_default_instance_;
class ImageFeatureType;
class ImageFeatureTypeDefaultTypeInternal;
extern ImageFeatureTypeDefaultTypeInternal _ImageFeatureType_default_instance_;
class ImageFeatureType_EnumeratedImageSizes;
class ImageFeatureType_EnumeratedImageSizesDefaultTypeInternal;
extern ImageFeatureType_EnumeratedImageSizesDefaultTypeInternal _ImageFeatureType_EnumeratedImageSizes_default_instance_;
class ImageFeatureType_ImageSize;
class ImageFeatureType_ImageSizeDefaultTypeInternal;
extern ImageFeatureType_ImageSizeDefaultTypeInternal _ImageFeatureType_ImageSize_default_instance_;
class ImageFeatureType_ImageSizeRange;
class ImageFeatureType_ImageSizeRangeDefaultTypeInternal;
extern ImageFeatureType_ImageSizeRangeDefaultTypeInternal _ImageFeatureType_ImageSizeRange_default_instance_;
class Int64FeatureType;
class Int64FeatureTypeDefaultTypeInternal;
extern Int64FeatureTypeDefaultTypeInternal _Int64FeatureType_default_instance_;
class SequenceFeatureType;
class SequenceFeatureTypeDefaultTypeInternal;
extern SequenceFeatureTypeDefaultTypeInternal _SequenceFeatureType_default_instance_;
class SizeRange;
class SizeRangeDefaultTypeInternal;
extern SizeRangeDefaultTypeInternal _SizeRange_default_instance_;
class StringFeatureType;
class StringFeatureTypeDefaultTypeInternal;
extern StringFeatureTypeDefaultTypeInternal _StringFeatureType_default_instance_;
}  // namespace Specification
}  // namespace CoreML

namespace CoreML {
namespace Specification {

namespace protobuf_FeatureTypes_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static void InitDefaultsImpl();
  static void Shutdown();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_FeatureTypes_2eproto

enum ImageFeatureType_ColorSpace {
  ImageFeatureType_ColorSpace_INVALID_COLOR_SPACE = 0,
  ImageFeatureType_ColorSpace_GRAYSCALE = 10,
  ImageFeatureType_ColorSpace_RGB = 20,
  ImageFeatureType_ColorSpace_BGR = 30,
  ImageFeatureType_ColorSpace_ImageFeatureType_ColorSpace_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ImageFeatureType_ColorSpace_ImageFeatureType_ColorSpace_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ImageFeatureType_ColorSpace_IsValid(int value);
const ImageFeatureType_ColorSpace ImageFeatureType_ColorSpace_ColorSpace_MIN = ImageFeatureType_ColorSpace_INVALID_COLOR_SPACE;
const ImageFeatureType_ColorSpace ImageFeatureType_ColorSpace_ColorSpace_MAX = ImageFeatureType_ColorSpace_BGR;
const int ImageFeatureType_ColorSpace_ColorSpace_ARRAYSIZE = ImageFeatureType_ColorSpace_ColorSpace_MAX + 1;

enum ArrayFeatureType_ArrayDataType {
  ArrayFeatureType_ArrayDataType_INVALID_ARRAY_DATA_TYPE = 0,
  ArrayFeatureType_ArrayDataType_FLOAT32 = 65568,
  ArrayFeatureType_ArrayDataType_DOUBLE = 65600,
  ArrayFeatureType_ArrayDataType_INT32 = 131104,
  ArrayFeatureType_ArrayDataType_ArrayFeatureType_ArrayDataType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ArrayFeatureType_ArrayDataType_ArrayFeatureType_ArrayDataType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ArrayFeatureType_ArrayDataType_IsValid(int value);
const ArrayFeatureType_ArrayDataType ArrayFeatureType_ArrayDataType_ArrayDataType_MIN = ArrayFeatureType_ArrayDataType_INVALID_ARRAY_DATA_TYPE;
const ArrayFeatureType_ArrayDataType ArrayFeatureType_ArrayDataType_ArrayDataType_MAX = ArrayFeatureType_ArrayDataType_INT32;
const int ArrayFeatureType_ArrayDataType_ArrayDataType_ARRAYSIZE = ArrayFeatureType_ArrayDataType_ArrayDataType_MAX + 1;

// ===================================================================

class Int64FeatureType : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.Int64FeatureType) */ {
 public:
  Int64FeatureType();
  virtual ~Int64FeatureType();

  Int64FeatureType(const Int64FeatureType& from);

  inline Int64FeatureType& operator=(const Int64FeatureType& from) {
    CopyFrom(from);
    return *this;
  }

  static const Int64FeatureType& default_instance();

  static inline const Int64FeatureType* internal_default_instance() {
    return reinterpret_cast<const Int64FeatureType*>(
               &_Int64FeatureType_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(Int64FeatureType* other);

  // implements Message ----------------------------------------------

  inline Int64FeatureType* New() const PROTOBUF_FINAL { return New(NULL); }

  Int64FeatureType* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const Int64FeatureType& from);
  void MergeFrom(const Int64FeatureType& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Int64FeatureType* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:CoreML.Specification.Int64FeatureType)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  mutable int _cached_size_;
  friend struct protobuf_FeatureTypes_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DoubleFeatureType : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.DoubleFeatureType) */ {
 public:
  DoubleFeatureType();
  virtual ~DoubleFeatureType();

  DoubleFeatureType(const DoubleFeatureType& from);

  inline DoubleFeatureType& operator=(const DoubleFeatureType& from) {
    CopyFrom(from);
    return *this;
  }

  static const DoubleFeatureType& default_instance();

  static inline const DoubleFeatureType* internal_default_instance() {
    return reinterpret_cast<const DoubleFeatureType*>(
               &_DoubleFeatureType_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(DoubleFeatureType* other);

  // implements Message ----------------------------------------------

  inline DoubleFeatureType* New() const PROTOBUF_FINAL { return New(NULL); }

  DoubleFeatureType* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const DoubleFeatureType& from);
  void MergeFrom(const DoubleFeatureType& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DoubleFeatureType* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:CoreML.Specification.DoubleFeatureType)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  mutable int _cached_size_;
  friend struct protobuf_FeatureTypes_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class StringFeatureType : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.StringFeatureType) */ {
 public:
  StringFeatureType();
  virtual ~StringFeatureType();

  StringFeatureType(const StringFeatureType& from);

  inline StringFeatureType& operator=(const StringFeatureType& from) {
    CopyFrom(from);
    return *this;
  }

  static const StringFeatureType& default_instance();

  static inline const StringFeatureType* internal_default_instance() {
    return reinterpret_cast<const StringFeatureType*>(
               &_StringFeatureType_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(StringFeatureType* other);

  // implements Message ----------------------------------------------

  inline StringFeatureType* New() const PROTOBUF_FINAL { return New(NULL); }

  StringFeatureType* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const StringFeatureType& from);
  void MergeFrom(const StringFeatureType& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(StringFeatureType* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:CoreML.Specification.StringFeatureType)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  mutable int _cached_size_;
  friend struct protobuf_FeatureTypes_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SizeRange : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.SizeRange) */ {
 public:
  SizeRange();
  virtual ~SizeRange();

  SizeRange(const SizeRange& from);

  inline SizeRange& operator=(const SizeRange& from) {
    CopyFrom(from);
    return *this;
  }

  static const SizeRange& default_instance();

  static inline const SizeRange* internal_default_instance() {
    return reinterpret_cast<const SizeRange*>(
               &_SizeRange_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(SizeRange* other);

  // implements Message ----------------------------------------------

  inline SizeRange* New() const PROTOBUF_FINAL { return New(NULL); }

  SizeRange* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const SizeRange& from);
  void MergeFrom(const SizeRange& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SizeRange* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint64 lowerBound = 1;
  void clear_lowerbound();
  static const int kLowerBoundFieldNumber = 1;
  ::google::protobuf::uint64 lowerbound() const;
  void set_lowerbound(::google::protobuf::uint64 value);

  // int64 upperBound = 2;
  void clear_upperbound();
  static const int kUpperBoundFieldNumber = 2;
  ::google::protobuf::int64 upperbound() const;
  void set_upperbound(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:CoreML.Specification.SizeRange)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::uint64 lowerbound_;
  ::google::protobuf::int64 upperbound_;
  mutable int _cached_size_;
  friend struct protobuf_FeatureTypes_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ImageFeatureType_ImageSize : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.ImageFeatureType.ImageSize) */ {
 public:
  ImageFeatureType_ImageSize();
  virtual ~ImageFeatureType_ImageSize();

  ImageFeatureType_ImageSize(const ImageFeatureType_ImageSize& from);

  inline ImageFeatureType_ImageSize& operator=(const ImageFeatureType_ImageSize& from) {
    CopyFrom(from);
    return *this;
  }

  static const ImageFeatureType_ImageSize& default_instance();

  static inline const ImageFeatureType_ImageSize* internal_default_instance() {
    return reinterpret_cast<const ImageFeatureType_ImageSize*>(
               &_ImageFeatureType_ImageSize_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(ImageFeatureType_ImageSize* other);

  // implements Message ----------------------------------------------

  inline ImageFeatureType_ImageSize* New() const PROTOBUF_FINAL { return New(NULL); }

  ImageFeatureType_ImageSize* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const ImageFeatureType_ImageSize& from);
  void MergeFrom(const ImageFeatureType_ImageSize& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ImageFeatureType_ImageSize* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint64 width = 1;
  void clear_width();
  static const int kWidthFieldNumber = 1;
  ::google::protobuf::uint64 width() const;
  void set_width(::google::protobuf::uint64 value);

  // uint64 height = 2;
  void clear_height();
  static const int kHeightFieldNumber = 2;
  ::google::protobuf::uint64 height() const;
  void set_height(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:CoreML.Specification.ImageFeatureType.ImageSize)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::uint64 width_;
  ::google::protobuf::uint64 height_;
  mutable int _cached_size_;
  friend struct protobuf_FeatureTypes_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ImageFeatureType_EnumeratedImageSizes : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.ImageFeatureType.EnumeratedImageSizes) */ {
 public:
  ImageFeatureType_EnumeratedImageSizes();
  virtual ~ImageFeatureType_EnumeratedImageSizes();

  ImageFeatureType_EnumeratedImageSizes(const ImageFeatureType_EnumeratedImageSizes& from);

  inline ImageFeatureType_EnumeratedImageSizes& operator=(const ImageFeatureType_EnumeratedImageSizes& from) {
    CopyFrom(from);
    return *this;
  }

  static const ImageFeatureType_EnumeratedImageSizes& default_instance();

  static inline const ImageFeatureType_EnumeratedImageSizes* internal_default_instance() {
    return reinterpret_cast<const ImageFeatureType_EnumeratedImageSizes*>(
               &_ImageFeatureType_EnumeratedImageSizes_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(ImageFeatureType_EnumeratedImageSizes* other);

  // implements Message ----------------------------------------------

  inline ImageFeatureType_EnumeratedImageSizes* New() const PROTOBUF_FINAL { return New(NULL); }

  ImageFeatureType_EnumeratedImageSizes* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const ImageFeatureType_EnumeratedImageSizes& from);
  void MergeFrom(const ImageFeatureType_EnumeratedImageSizes& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ImageFeatureType_EnumeratedImageSizes* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .CoreML.Specification.ImageFeatureType.ImageSize sizes = 1;
  int sizes_size() const;
  void clear_sizes();
  static const int kSizesFieldNumber = 1;
  const ::CoreML::Specification::ImageFeatureType_ImageSize& sizes(int index) const;
  ::CoreML::Specification::ImageFeatureType_ImageSize* mutable_sizes(int index);
  ::CoreML::Specification::ImageFeatureType_ImageSize* add_sizes();
  ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::ImageFeatureType_ImageSize >*
      mutable_sizes();
  const ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::ImageFeatureType_ImageSize >&
      sizes() const;

  // @@protoc_insertion_point(class_scope:CoreML.Specification.ImageFeatureType.EnumeratedImageSizes)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::ImageFeatureType_ImageSize > sizes_;
  mutable int _cached_size_;
  friend struct protobuf_FeatureTypes_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ImageFeatureType_ImageSizeRange : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.ImageFeatureType.ImageSizeRange) */ {
 public:
  ImageFeatureType_ImageSizeRange();
  virtual ~ImageFeatureType_ImageSizeRange();

  ImageFeatureType_ImageSizeRange(const ImageFeatureType_ImageSizeRange& from);

  inline ImageFeatureType_ImageSizeRange& operator=(const ImageFeatureType_ImageSizeRange& from) {
    CopyFrom(from);
    return *this;
  }

  static const ImageFeatureType_ImageSizeRange& default_instance();

  static inline const ImageFeatureType_ImageSizeRange* internal_default_instance() {
    return reinterpret_cast<const ImageFeatureType_ImageSizeRange*>(
               &_ImageFeatureType_ImageSizeRange_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(ImageFeatureType_ImageSizeRange* other);

  // implements Message ----------------------------------------------

  inline ImageFeatureType_ImageSizeRange* New() const PROTOBUF_FINAL { return New(NULL); }

  ImageFeatureType_ImageSizeRange* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const ImageFeatureType_ImageSizeRange& from);
  void MergeFrom(const ImageFeatureType_ImageSizeRange& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ImageFeatureType_ImageSizeRange* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .CoreML.Specification.SizeRange widthRange = 1;
  bool has_widthrange() const;
  void clear_widthrange();
  static const int kWidthRangeFieldNumber = 1;
  const ::CoreML::Specification::SizeRange& widthrange() const;
  ::CoreML::Specification::SizeRange* mutable_widthrange();
  ::CoreML::Specification::SizeRange* release_widthrange();
  void set_allocated_widthrange(::CoreML::Specification::SizeRange* widthrange);

  // .CoreML.Specification.SizeRange heightRange = 2;
  bool has_heightrange() const;
  void clear_heightrange();
  static const int kHeightRangeFieldNumber = 2;
  const ::CoreML::Specification::SizeRange& heightrange() const;
  ::CoreML::Specification::SizeRange* mutable_heightrange();
  ::CoreML::Specification::SizeRange* release_heightrange();
  void set_allocated_heightrange(::CoreML::Specification::SizeRange* heightrange);

  // @@protoc_insertion_point(class_scope:CoreML.Specification.ImageFeatureType.ImageSizeRange)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::CoreML::Specification::SizeRange* widthrange_;
  ::CoreML::Specification::SizeRange* heightrange_;
  mutable int _cached_size_;
  friend struct protobuf_FeatureTypes_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ImageFeatureType : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.ImageFeatureType) */ {
 public:
  ImageFeatureType();
  virtual ~ImageFeatureType();

  ImageFeatureType(const ImageFeatureType& from);

  inline ImageFeatureType& operator=(const ImageFeatureType& from) {
    CopyFrom(from);
    return *this;
  }

  static const ImageFeatureType& default_instance();

  enum SizeFlexibilityCase {
    kEnumeratedSizes = 21,
    kImageSizeRange = 31,
    SIZEFLEXIBILITY_NOT_SET = 0,
  };

  static inline const ImageFeatureType* internal_default_instance() {
    return reinterpret_cast<const ImageFeatureType*>(
               &_ImageFeatureType_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(ImageFeatureType* other);

  // implements Message ----------------------------------------------

  inline ImageFeatureType* New() const PROTOBUF_FINAL { return New(NULL); }

  ImageFeatureType* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const ImageFeatureType& from);
  void MergeFrom(const ImageFeatureType& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ImageFeatureType* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef ImageFeatureType_ImageSize ImageSize;
  typedef ImageFeatureType_EnumeratedImageSizes EnumeratedImageSizes;
  typedef ImageFeatureType_ImageSizeRange ImageSizeRange;

  typedef ImageFeatureType_ColorSpace ColorSpace;
  static const ColorSpace INVALID_COLOR_SPACE =
    ImageFeatureType_ColorSpace_INVALID_COLOR_SPACE;
  static const ColorSpace GRAYSCALE =
    ImageFeatureType_ColorSpace_GRAYSCALE;
  static const ColorSpace RGB =
    ImageFeatureType_ColorSpace_RGB;
  static const ColorSpace BGR =
    ImageFeatureType_ColorSpace_BGR;
  static inline bool ColorSpace_IsValid(int value) {
    return ImageFeatureType_ColorSpace_IsValid(value);
  }
  static const ColorSpace ColorSpace_MIN =
    ImageFeatureType_ColorSpace_ColorSpace_MIN;
  static const ColorSpace ColorSpace_MAX =
    ImageFeatureType_ColorSpace_ColorSpace_MAX;
  static const int ColorSpace_ARRAYSIZE =
    ImageFeatureType_ColorSpace_ColorSpace_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // int64 width = 1;
  void clear_width();
  static const int kWidthFieldNumber = 1;
  ::google::protobuf::int64 width() const;
  void set_width(::google::protobuf::int64 value);

  // int64 height = 2;
  void clear_height();
  static const int kHeightFieldNumber = 2;
  ::google::protobuf::int64 height() const;
  void set_height(::google::protobuf::int64 value);

  // .CoreML.Specification.ImageFeatureType.ColorSpace colorSpace = 3;
  void clear_colorspace();
  static const int kColorSpaceFieldNumber = 3;
  ::CoreML::Specification::ImageFeatureType_ColorSpace colorspace() const;
  void set_colorspace(::CoreML::Specification::ImageFeatureType_ColorSpace value);

  // .CoreML.Specification.ImageFeatureType.EnumeratedImageSizes enumeratedSizes = 21;
  bool has_enumeratedsizes() const;
  void clear_enumeratedsizes();
  static const int kEnumeratedSizesFieldNumber = 21;
  const ::CoreML::Specification::ImageFeatureType_EnumeratedImageSizes& enumeratedsizes() const;
  ::CoreML::Specification::ImageFeatureType_EnumeratedImageSizes* mutable_enumeratedsizes();
  ::CoreML::Specification::ImageFeatureType_EnumeratedImageSizes* release_enumeratedsizes();
  void set_allocated_enumeratedsizes(::CoreML::Specification::ImageFeatureType_EnumeratedImageSizes* enumeratedsizes);

  // .CoreML.Specification.ImageFeatureType.ImageSizeRange imageSizeRange = 31;
  bool has_imagesizerange() const;
  void clear_imagesizerange();
  static const int kImageSizeRangeFieldNumber = 31;
  const ::CoreML::Specification::ImageFeatureType_ImageSizeRange& imagesizerange() const;
  ::CoreML::Specification::ImageFeatureType_ImageSizeRange* mutable_imagesizerange();
  ::CoreML::Specification::ImageFeatureType_ImageSizeRange* release_imagesizerange();
  void set_allocated_imagesizerange(::CoreML::Specification::ImageFeatureType_ImageSizeRange* imagesizerange);

  SizeFlexibilityCase SizeFlexibility_case() const;
  // @@protoc_insertion_point(class_scope:CoreML.Specification.ImageFeatureType)
 private:
  void set_has_enumeratedsizes();
  void set_has_imagesizerange();

  inline bool has_SizeFlexibility() const;
  void clear_SizeFlexibility();
  inline void clear_has_SizeFlexibility();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::int64 width_;
  ::google::protobuf::int64 height_;
  int colorspace_;
  union SizeFlexibilityUnion {
    SizeFlexibilityUnion() {}
    ::CoreML::Specification::ImageFeatureType_EnumeratedImageSizes* enumeratedsizes_;
    ::CoreML::Specification::ImageFeatureType_ImageSizeRange* imagesizerange_;
  } SizeFlexibility_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct protobuf_FeatureTypes_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ArrayFeatureType_Shape : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.ArrayFeatureType.Shape) */ {
 public:
  ArrayFeatureType_Shape();
  virtual ~ArrayFeatureType_Shape();

  ArrayFeatureType_Shape(const ArrayFeatureType_Shape& from);

  inline ArrayFeatureType_Shape& operator=(const ArrayFeatureType_Shape& from) {
    CopyFrom(from);
    return *this;
  }

  static const ArrayFeatureType_Shape& default_instance();

  static inline const ArrayFeatureType_Shape* internal_default_instance() {
    return reinterpret_cast<const ArrayFeatureType_Shape*>(
               &_ArrayFeatureType_Shape_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(ArrayFeatureType_Shape* other);

  // implements Message ----------------------------------------------

  inline ArrayFeatureType_Shape* New() const PROTOBUF_FINAL { return New(NULL); }

  ArrayFeatureType_Shape* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const ArrayFeatureType_Shape& from);
  void MergeFrom(const ArrayFeatureType_Shape& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ArrayFeatureType_Shape* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int64 shape = 1;
  int shape_size() const;
  void clear_shape();
  static const int kShapeFieldNumber = 1;
  ::google::protobuf::int64 shape(int index) const;
  void set_shape(int index, ::google::protobuf::int64 value);
  void add_shape(::google::protobuf::int64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      shape() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_shape();

  // @@protoc_insertion_point(class_scope:CoreML.Specification.ArrayFeatureType.Shape)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > shape_;
  mutable int _shape_cached_byte_size_;
  mutable int _cached_size_;
  friend struct protobuf_FeatureTypes_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ArrayFeatureType_EnumeratedShapes : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.ArrayFeatureType.EnumeratedShapes) */ {
 public:
  ArrayFeatureType_EnumeratedShapes();
  virtual ~ArrayFeatureType_EnumeratedShapes();

  ArrayFeatureType_EnumeratedShapes(const ArrayFeatureType_EnumeratedShapes& from);

  inline ArrayFeatureType_EnumeratedShapes& operator=(const ArrayFeatureType_EnumeratedShapes& from) {
    CopyFrom(from);
    return *this;
  }

  static const ArrayFeatureType_EnumeratedShapes& default_instance();

  static inline const ArrayFeatureType_EnumeratedShapes* internal_default_instance() {
    return reinterpret_cast<const ArrayFeatureType_EnumeratedShapes*>(
               &_ArrayFeatureType_EnumeratedShapes_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(ArrayFeatureType_EnumeratedShapes* other);

  // implements Message ----------------------------------------------

  inline ArrayFeatureType_EnumeratedShapes* New() const PROTOBUF_FINAL { return New(NULL); }

  ArrayFeatureType_EnumeratedShapes* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const ArrayFeatureType_EnumeratedShapes& from);
  void MergeFrom(const ArrayFeatureType_EnumeratedShapes& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ArrayFeatureType_EnumeratedShapes* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .CoreML.Specification.ArrayFeatureType.Shape shapes = 1;
  int shapes_size() const;
  void clear_shapes();
  static const int kShapesFieldNumber = 1;
  const ::CoreML::Specification::ArrayFeatureType_Shape& shapes(int index) const;
  ::CoreML::Specification::ArrayFeatureType_Shape* mutable_shapes(int index);
  ::CoreML::Specification::ArrayFeatureType_Shape* add_shapes();
  ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::ArrayFeatureType_Shape >*
      mutable_shapes();
  const ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::ArrayFeatureType_Shape >&
      shapes() const;

  // @@protoc_insertion_point(class_scope:CoreML.Specification.ArrayFeatureType.EnumeratedShapes)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::ArrayFeatureType_Shape > shapes_;
  mutable int _cached_size_;
  friend struct protobuf_FeatureTypes_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ArrayFeatureType_ShapeRange : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.ArrayFeatureType.ShapeRange) */ {
 public:
  ArrayFeatureType_ShapeRange();
  virtual ~ArrayFeatureType_ShapeRange();

  ArrayFeatureType_ShapeRange(const ArrayFeatureType_ShapeRange& from);

  inline ArrayFeatureType_ShapeRange& operator=(const ArrayFeatureType_ShapeRange& from) {
    CopyFrom(from);
    return *this;
  }

  static const ArrayFeatureType_ShapeRange& default_instance();

  static inline const ArrayFeatureType_ShapeRange* internal_default_instance() {
    return reinterpret_cast<const ArrayFeatureType_ShapeRange*>(
               &_ArrayFeatureType_ShapeRange_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(ArrayFeatureType_ShapeRange* other);

  // implements Message ----------------------------------------------

  inline ArrayFeatureType_ShapeRange* New() const PROTOBUF_FINAL { return New(NULL); }

  ArrayFeatureType_ShapeRange* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const ArrayFeatureType_ShapeRange& from);
  void MergeFrom(const ArrayFeatureType_ShapeRange& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ArrayFeatureType_ShapeRange* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .CoreML.Specification.SizeRange sizeRanges = 1;
  int sizeranges_size() const;
  void clear_sizeranges();
  static const int kSizeRangesFieldNumber = 1;
  const ::CoreML::Specification::SizeRange& sizeranges(int index) const;
  ::CoreML::Specification::SizeRange* mutable_sizeranges(int index);
  ::CoreML::Specification::SizeRange* add_sizeranges();
  ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::SizeRange >*
      mutable_sizeranges();
  const ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::SizeRange >&
      sizeranges() const;

  // @@protoc_insertion_point(class_scope:CoreML.Specification.ArrayFeatureType.ShapeRange)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::SizeRange > sizeranges_;
  mutable int _cached_size_;
  friend struct protobuf_FeatureTypes_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ArrayFeatureType : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.ArrayFeatureType) */ {
 public:
  ArrayFeatureType();
  virtual ~ArrayFeatureType();

  ArrayFeatureType(const ArrayFeatureType& from);

  inline ArrayFeatureType& operator=(const ArrayFeatureType& from) {
    CopyFrom(from);
    return *this;
  }

  static const ArrayFeatureType& default_instance();

  enum ShapeFlexibilityCase {
    kEnumeratedShapes = 21,
    kShapeRange = 31,
    SHAPEFLEXIBILITY_NOT_SET = 0,
  };

  static inline const ArrayFeatureType* internal_default_instance() {
    return reinterpret_cast<const ArrayFeatureType*>(
               &_ArrayFeatureType_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    11;

  void Swap(ArrayFeatureType* other);

  // implements Message ----------------------------------------------

  inline ArrayFeatureType* New() const PROTOBUF_FINAL { return New(NULL); }

  ArrayFeatureType* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const ArrayFeatureType& from);
  void MergeFrom(const ArrayFeatureType& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ArrayFeatureType* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef ArrayFeatureType_Shape Shape;
  typedef ArrayFeatureType_EnumeratedShapes EnumeratedShapes;
  typedef ArrayFeatureType_ShapeRange ShapeRange;

  typedef ArrayFeatureType_ArrayDataType ArrayDataType;
  static const ArrayDataType INVALID_ARRAY_DATA_TYPE =
    ArrayFeatureType_ArrayDataType_INVALID_ARRAY_DATA_TYPE;
  static const ArrayDataType FLOAT32 =
    ArrayFeatureType_ArrayDataType_FLOAT32;
  static const ArrayDataType DOUBLE =
    ArrayFeatureType_ArrayDataType_DOUBLE;
  static const ArrayDataType INT32 =
    ArrayFeatureType_ArrayDataType_INT32;
  static inline bool ArrayDataType_IsValid(int value) {
    return ArrayFeatureType_ArrayDataType_IsValid(value);
  }
  static const ArrayDataType ArrayDataType_MIN =
    ArrayFeatureType_ArrayDataType_ArrayDataType_MIN;
  static const ArrayDataType ArrayDataType_MAX =
    ArrayFeatureType_ArrayDataType_ArrayDataType_MAX;
  static const int ArrayDataType_ARRAYSIZE =
    ArrayFeatureType_ArrayDataType_ArrayDataType_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // repeated int64 shape = 1;
  int shape_size() const;
  void clear_shape();
  static const int kShapeFieldNumber = 1;
  ::google::protobuf::int64 shape(int index) const;
  void set_shape(int index, ::google::protobuf::int64 value);
  void add_shape(::google::protobuf::int64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      shape() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_shape();

  // .CoreML.Specification.ArrayFeatureType.ArrayDataType dataType = 2;
  void clear_datatype();
  static const int kDataTypeFieldNumber = 2;
  ::CoreML::Specification::ArrayFeatureType_ArrayDataType datatype() const;
  void set_datatype(::CoreML::Specification::ArrayFeatureType_ArrayDataType value);

  // .CoreML.Specification.ArrayFeatureType.EnumeratedShapes enumeratedShapes = 21;
  bool has_enumeratedshapes() const;
  void clear_enumeratedshapes();
  static const int kEnumeratedShapesFieldNumber = 21;
  const ::CoreML::Specification::ArrayFeatureType_EnumeratedShapes& enumeratedshapes() const;
  ::CoreML::Specification::ArrayFeatureType_EnumeratedShapes* mutable_enumeratedshapes();
  ::CoreML::Specification::ArrayFeatureType_EnumeratedShapes* release_enumeratedshapes();
  void set_allocated_enumeratedshapes(::CoreML::Specification::ArrayFeatureType_EnumeratedShapes* enumeratedshapes);

  // .CoreML.Specification.ArrayFeatureType.ShapeRange shapeRange = 31;
  bool has_shaperange() const;
  void clear_shaperange();
  static const int kShapeRangeFieldNumber = 31;
  const ::CoreML::Specification::ArrayFeatureType_ShapeRange& shaperange() const;
  ::CoreML::Specification::ArrayFeatureType_ShapeRange* mutable_shaperange();
  ::CoreML::Specification::ArrayFeatureType_ShapeRange* release_shaperange();
  void set_allocated_shaperange(::CoreML::Specification::ArrayFeatureType_ShapeRange* shaperange);

  ShapeFlexibilityCase ShapeFlexibility_case() const;
  // @@protoc_insertion_point(class_scope:CoreML.Specification.ArrayFeatureType)
 private:
  void set_has_enumeratedshapes();
  void set_has_shaperange();

  inline bool has_ShapeFlexibility() const;
  void clear_ShapeFlexibility();
  inline void clear_has_ShapeFlexibility();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > shape_;
  mutable int _shape_cached_byte_size_;
  int datatype_;
  union ShapeFlexibilityUnion {
    ShapeFlexibilityUnion() {}
    ::CoreML::Specification::ArrayFeatureType_EnumeratedShapes* enumeratedshapes_;
    ::CoreML::Specification::ArrayFeatureType_ShapeRange* shaperange_;
  } ShapeFlexibility_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct protobuf_FeatureTypes_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DictionaryFeatureType : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.DictionaryFeatureType) */ {
 public:
  DictionaryFeatureType();
  virtual ~DictionaryFeatureType();

  DictionaryFeatureType(const DictionaryFeatureType& from);

  inline DictionaryFeatureType& operator=(const DictionaryFeatureType& from) {
    CopyFrom(from);
    return *this;
  }

  static const DictionaryFeatureType& default_instance();

  enum KeyTypeCase {
    kInt64KeyType = 1,
    kStringKeyType = 2,
    KEYTYPE_NOT_SET = 0,
  };

  static inline const DictionaryFeatureType* internal_default_instance() {
    return reinterpret_cast<const DictionaryFeatureType*>(
               &_DictionaryFeatureType_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    12;

  void Swap(DictionaryFeatureType* other);

  // implements Message ----------------------------------------------

  inline DictionaryFeatureType* New() const PROTOBUF_FINAL { return New(NULL); }

  DictionaryFeatureType* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const DictionaryFeatureType& from);
  void MergeFrom(const DictionaryFeatureType& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DictionaryFeatureType* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .CoreML.Specification.Int64FeatureType int64KeyType = 1;
  bool has_int64keytype() const;
  void clear_int64keytype();
  static const int kInt64KeyTypeFieldNumber = 1;
  const ::CoreML::Specification::Int64FeatureType& int64keytype() const;
  ::CoreML::Specification::Int64FeatureType* mutable_int64keytype();
  ::CoreML::Specification::Int64FeatureType* release_int64keytype();
  void set_allocated_int64keytype(::CoreML::Specification::Int64FeatureType* int64keytype);

  // .CoreML.Specification.StringFeatureType stringKeyType = 2;
  bool has_stringkeytype() const;
  void clear_stringkeytype();
  static const int kStringKeyTypeFieldNumber = 2;
  const ::CoreML::Specification::StringFeatureType& stringkeytype() const;
  ::CoreML::Specification::StringFeatureType* mutable_stringkeytype();
  ::CoreML::Specification::StringFeatureType* release_stringkeytype();
  void set_allocated_stringkeytype(::CoreML::Specification::StringFeatureType* stringkeytype);

  KeyTypeCase KeyType_case() const;
  // @@protoc_insertion_point(class_scope:CoreML.Specification.DictionaryFeatureType)
 private:
  void set_has_int64keytype();
  void set_has_stringkeytype();

  inline bool has_KeyType() const;
  void clear_KeyType();
  inline void clear_has_KeyType();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  union KeyTypeUnion {
    KeyTypeUnion() {}
    ::CoreML::Specification::Int64FeatureType* int64keytype_;
    ::CoreML::Specification::StringFeatureType* stringkeytype_;
  } KeyType_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct protobuf_FeatureTypes_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SequenceFeatureType : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.SequenceFeatureType) */ {
 public:
  SequenceFeatureType();
  virtual ~SequenceFeatureType();

  SequenceFeatureType(const SequenceFeatureType& from);

  inline SequenceFeatureType& operator=(const SequenceFeatureType& from) {
    CopyFrom(from);
    return *this;
  }

  static const SequenceFeatureType& default_instance();

  enum TypeCase {
    kInt64Type = 1,
    kStringType = 3,
    TYPE_NOT_SET = 0,
  };

  static inline const SequenceFeatureType* internal_default_instance() {
    return reinterpret_cast<const SequenceFeatureType*>(
               &_SequenceFeatureType_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    13;

  void Swap(SequenceFeatureType* other);

  // implements Message ----------------------------------------------

  inline SequenceFeatureType* New() const PROTOBUF_FINAL { return New(NULL); }

  SequenceFeatureType* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const SequenceFeatureType& from);
  void MergeFrom(const SequenceFeatureType& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SequenceFeatureType* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .CoreML.Specification.SizeRange sizeRange = 101;
  bool has_sizerange() const;
  void clear_sizerange();
  static const int kSizeRangeFieldNumber = 101;
  const ::CoreML::Specification::SizeRange& sizerange() const;
  ::CoreML::Specification::SizeRange* mutable_sizerange();
  ::CoreML::Specification::SizeRange* release_sizerange();
  void set_allocated_sizerange(::CoreML::Specification::SizeRange* sizerange);

  // .CoreML.Specification.Int64FeatureType int64Type = 1;
  bool has_int64type() const;
  void clear_int64type();
  static const int kInt64TypeFieldNumber = 1;
  const ::CoreML::Specification::Int64FeatureType& int64type() const;
  ::CoreML::Specification::Int64FeatureType* mutable_int64type();
  ::CoreML::Specification::Int64FeatureType* release_int64type();
  void set_allocated_int64type(::CoreML::Specification::Int64FeatureType* int64type);

  // .CoreML.Specification.StringFeatureType stringType = 3;
  bool has_stringtype() const;
  void clear_stringtype();
  static const int kStringTypeFieldNumber = 3;
  const ::CoreML::Specification::StringFeatureType& stringtype() const;
  ::CoreML::Specification::StringFeatureType* mutable_stringtype();
  ::CoreML::Specification::StringFeatureType* release_stringtype();
  void set_allocated_stringtype(::CoreML::Specification::StringFeatureType* stringtype);

  TypeCase Type_case() const;
  // @@protoc_insertion_point(class_scope:CoreML.Specification.SequenceFeatureType)
 private:
  void set_has_int64type();
  void set_has_stringtype();

  inline bool has_Type() const;
  void clear_Type();
  inline void clear_has_Type();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::CoreML::Specification::SizeRange* sizerange_;
  union TypeUnion {
    TypeUnion() {}
    ::CoreML::Specification::Int64FeatureType* int64type_;
    ::CoreML::Specification::StringFeatureType* stringtype_;
  } Type_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct protobuf_FeatureTypes_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FeatureType : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.FeatureType) */ {
 public:
  FeatureType();
  virtual ~FeatureType();

  FeatureType(const FeatureType& from);

  inline FeatureType& operator=(const FeatureType& from) {
    CopyFrom(from);
    return *this;
  }

  static const FeatureType& default_instance();

  enum TypeCase {
    kInt64Type = 1,
    kDoubleType = 2,
    kStringType = 3,
    kImageType = 4,
    kMultiArrayType = 5,
    kDictionaryType = 6,
    kSequenceType = 7,
    TYPE_NOT_SET = 0,
  };

  static inline const FeatureType* internal_default_instance() {
    return reinterpret_cast<const FeatureType*>(
               &_FeatureType_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    14;

  void Swap(FeatureType* other);

  // implements Message ----------------------------------------------

  inline FeatureType* New() const PROTOBUF_FINAL { return New(NULL); }

  FeatureType* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const FeatureType& from);
  void MergeFrom(const FeatureType& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(FeatureType* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bool isOptional = 1000;
  void clear_isoptional();
  static const int kIsOptionalFieldNumber = 1000;
  bool isoptional() const;
  void set_isoptional(bool value);

  // .CoreML.Specification.Int64FeatureType int64Type = 1;
  bool has_int64type() const;
  void clear_int64type();
  static const int kInt64TypeFieldNumber = 1;
  const ::CoreML::Specification::Int64FeatureType& int64type() const;
  ::CoreML::Specification::Int64FeatureType* mutable_int64type();
  ::CoreML::Specification::Int64FeatureType* release_int64type();
  void set_allocated_int64type(::CoreML::Specification::Int64FeatureType* int64type);

  // .CoreML.Specification.DoubleFeatureType doubleType = 2;
  bool has_doubletype() const;
  void clear_doubletype();
  static const int kDoubleTypeFieldNumber = 2;
  const ::CoreML::Specification::DoubleFeatureType& doubletype() const;
  ::CoreML::Specification::DoubleFeatureType* mutable_doubletype();
  ::CoreML::Specification::DoubleFeatureType* release_doubletype();
  void set_allocated_doubletype(::CoreML::Specification::DoubleFeatureType* doubletype);

  // .CoreML.Specification.StringFeatureType stringType = 3;
  bool has_stringtype() const;
  void clear_stringtype();
  static const int kStringTypeFieldNumber = 3;
  const ::CoreML::Specification::StringFeatureType& stringtype() const;
  ::CoreML::Specification::StringFeatureType* mutable_stringtype();
  ::CoreML::Specification::StringFeatureType* release_stringtype();
  void set_allocated_stringtype(::CoreML::Specification::StringFeatureType* stringtype);

  // .CoreML.Specification.ImageFeatureType imageType = 4;
  bool has_imagetype() const;
  void clear_imagetype();
  static const int kImageTypeFieldNumber = 4;
  const ::CoreML::Specification::ImageFeatureType& imagetype() const;
  ::CoreML::Specification::ImageFeatureType* mutable_imagetype();
  ::CoreML::Specification::ImageFeatureType* release_imagetype();
  void set_allocated_imagetype(::CoreML::Specification::ImageFeatureType* imagetype);

  // .CoreML.Specification.ArrayFeatureType multiArrayType = 5;
  bool has_multiarraytype() const;
  void clear_multiarraytype();
  static const int kMultiArrayTypeFieldNumber = 5;
  const ::CoreML::Specification::ArrayFeatureType& multiarraytype() const;
  ::CoreML::Specification::ArrayFeatureType* mutable_multiarraytype();
  ::CoreML::Specification::ArrayFeatureType* release_multiarraytype();
  void set_allocated_multiarraytype(::CoreML::Specification::ArrayFeatureType* multiarraytype);

  // .CoreML.Specification.DictionaryFeatureType dictionaryType = 6;
  bool has_dictionarytype() const;
  void clear_dictionarytype();
  static const int kDictionaryTypeFieldNumber = 6;
  const ::CoreML::Specification::DictionaryFeatureType& dictionarytype() const;
  ::CoreML::Specification::DictionaryFeatureType* mutable_dictionarytype();
  ::CoreML::Specification::DictionaryFeatureType* release_dictionarytype();
  void set_allocated_dictionarytype(::CoreML::Specification::DictionaryFeatureType* dictionarytype);

  // .CoreML.Specification.SequenceFeatureType sequenceType = 7;
  bool has_sequencetype() const;
  void clear_sequencetype();
  static const int kSequenceTypeFieldNumber = 7;
  const ::CoreML::Specification::SequenceFeatureType& sequencetype() const;
  ::CoreML::Specification::SequenceFeatureType* mutable_sequencetype();
  ::CoreML::Specification::SequenceFeatureType* release_sequencetype();
  void set_allocated_sequencetype(::CoreML::Specification::SequenceFeatureType* sequencetype);

  TypeCase Type_case() const;
  // @@protoc_insertion_point(class_scope:CoreML.Specification.FeatureType)
 private:
  void set_has_int64type();
  void set_has_doubletype();
  void set_has_stringtype();
  void set_has_imagetype();
  void set_has_multiarraytype();
  void set_has_dictionarytype();
  void set_has_sequencetype();

  inline bool has_Type() const;
  void clear_Type();
  inline void clear_has_Type();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  bool isoptional_;
  union TypeUnion {
    TypeUnion() {}
    ::CoreML::Specification::Int64FeatureType* int64type_;
    ::CoreML::Specification::DoubleFeatureType* doubletype_;
    ::CoreML::Specification::StringFeatureType* stringtype_;
    ::CoreML::Specification::ImageFeatureType* imagetype_;
    ::CoreML::Specification::ArrayFeatureType* multiarraytype_;
    ::CoreML::Specification::DictionaryFeatureType* dictionarytype_;
    ::CoreML::Specification::SequenceFeatureType* sequencetype_;
  } Type_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct protobuf_FeatureTypes_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// Int64FeatureType

// -------------------------------------------------------------------

// DoubleFeatureType

// -------------------------------------------------------------------

// StringFeatureType

// -------------------------------------------------------------------

// SizeRange

// uint64 lowerBound = 1;
inline void SizeRange::clear_lowerbound() {
  lowerbound_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 SizeRange::lowerbound() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.SizeRange.lowerBound)
  return lowerbound_;
}
inline void SizeRange::set_lowerbound(::google::protobuf::uint64 value) {

  lowerbound_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.SizeRange.lowerBound)
}

// int64 upperBound = 2;
inline void SizeRange::clear_upperbound() {
  upperbound_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 SizeRange::upperbound() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.SizeRange.upperBound)
  return upperbound_;
}
inline void SizeRange::set_upperbound(::google::protobuf::int64 value) {

  upperbound_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.SizeRange.upperBound)
}

// -------------------------------------------------------------------

// ImageFeatureType_ImageSize

// uint64 width = 1;
inline void ImageFeatureType_ImageSize::clear_width() {
  width_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 ImageFeatureType_ImageSize::width() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.ImageFeatureType.ImageSize.width)
  return width_;
}
inline void ImageFeatureType_ImageSize::set_width(::google::protobuf::uint64 value) {

  width_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.ImageFeatureType.ImageSize.width)
}

// uint64 height = 2;
inline void ImageFeatureType_ImageSize::clear_height() {
  height_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 ImageFeatureType_ImageSize::height() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.ImageFeatureType.ImageSize.height)
  return height_;
}
inline void ImageFeatureType_ImageSize::set_height(::google::protobuf::uint64 value) {

  height_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.ImageFeatureType.ImageSize.height)
}

// -------------------------------------------------------------------

// ImageFeatureType_EnumeratedImageSizes

// repeated .CoreML.Specification.ImageFeatureType.ImageSize sizes = 1;
inline int ImageFeatureType_EnumeratedImageSizes::sizes_size() const {
  return sizes_.size();
}
inline void ImageFeatureType_EnumeratedImageSizes::clear_sizes() {
  sizes_.Clear();
}
inline const ::CoreML::Specification::ImageFeatureType_ImageSize& ImageFeatureType_EnumeratedImageSizes::sizes(int index) const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.ImageFeatureType.EnumeratedImageSizes.sizes)
  return sizes_.Get(index);
}
inline ::CoreML::Specification::ImageFeatureType_ImageSize* ImageFeatureType_EnumeratedImageSizes::mutable_sizes(int index) {
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.ImageFeatureType.EnumeratedImageSizes.sizes)
  return sizes_.Mutable(index);
}
inline ::CoreML::Specification::ImageFeatureType_ImageSize* ImageFeatureType_EnumeratedImageSizes::add_sizes() {
  // @@protoc_insertion_point(field_add:CoreML.Specification.ImageFeatureType.EnumeratedImageSizes.sizes)
  return sizes_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::ImageFeatureType_ImageSize >*
ImageFeatureType_EnumeratedImageSizes::mutable_sizes() {
  // @@protoc_insertion_point(field_mutable_list:CoreML.Specification.ImageFeatureType.EnumeratedImageSizes.sizes)
  return &sizes_;
}
inline const ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::ImageFeatureType_ImageSize >&
ImageFeatureType_EnumeratedImageSizes::sizes() const {
  // @@protoc_insertion_point(field_list:CoreML.Specification.ImageFeatureType.EnumeratedImageSizes.sizes)
  return sizes_;
}

// -------------------------------------------------------------------

// ImageFeatureType_ImageSizeRange

// .CoreML.Specification.SizeRange widthRange = 1;
inline bool ImageFeatureType_ImageSizeRange::has_widthrange() const {
  return this != internal_default_instance() && widthrange_ != NULL;
}
inline void ImageFeatureType_ImageSizeRange::clear_widthrange() {
  if (GetArenaNoVirtual() == NULL && widthrange_ != NULL) delete widthrange_;
  widthrange_ = NULL;
}
inline const ::CoreML::Specification::SizeRange& ImageFeatureType_ImageSizeRange::widthrange() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.ImageFeatureType.ImageSizeRange.widthRange)
  return widthrange_ != NULL ? *widthrange_
                         : *::CoreML::Specification::SizeRange::internal_default_instance();
}
inline ::CoreML::Specification::SizeRange* ImageFeatureType_ImageSizeRange::mutable_widthrange() {

  if (widthrange_ == NULL) {
    widthrange_ = new ::CoreML::Specification::SizeRange;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.ImageFeatureType.ImageSizeRange.widthRange)
  return widthrange_;
}
inline ::CoreML::Specification::SizeRange* ImageFeatureType_ImageSizeRange::release_widthrange() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.ImageFeatureType.ImageSizeRange.widthRange)

  ::CoreML::Specification::SizeRange* temp = widthrange_;
  widthrange_ = NULL;
  return temp;
}
inline void ImageFeatureType_ImageSizeRange::set_allocated_widthrange(::CoreML::Specification::SizeRange* widthrange) {
  delete widthrange_;
  widthrange_ = widthrange;
  if (widthrange) {

  } else {

  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.ImageFeatureType.ImageSizeRange.widthRange)
}

// .CoreML.Specification.SizeRange heightRange = 2;
inline bool ImageFeatureType_ImageSizeRange::has_heightrange() const {
  return this != internal_default_instance() && heightrange_ != NULL;
}
inline void ImageFeatureType_ImageSizeRange::clear_heightrange() {
  if (GetArenaNoVirtual() == NULL && heightrange_ != NULL) delete heightrange_;
  heightrange_ = NULL;
}
inline const ::CoreML::Specification::SizeRange& ImageFeatureType_ImageSizeRange::heightrange() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.ImageFeatureType.ImageSizeRange.heightRange)
  return heightrange_ != NULL ? *heightrange_
                         : *::CoreML::Specification::SizeRange::internal_default_instance();
}
inline ::CoreML::Specification::SizeRange* ImageFeatureType_ImageSizeRange::mutable_heightrange() {

  if (heightrange_ == NULL) {
    heightrange_ = new ::CoreML::Specification::SizeRange;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.ImageFeatureType.ImageSizeRange.heightRange)
  return heightrange_;
}
inline ::CoreML::Specification::SizeRange* ImageFeatureType_ImageSizeRange::release_heightrange() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.ImageFeatureType.ImageSizeRange.heightRange)

  ::CoreML::Specification::SizeRange* temp = heightrange_;
  heightrange_ = NULL;
  return temp;
}
inline void ImageFeatureType_ImageSizeRange::set_allocated_heightrange(::CoreML::Specification::SizeRange* heightrange) {
  delete heightrange_;
  heightrange_ = heightrange;
  if (heightrange) {

  } else {

  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.ImageFeatureType.ImageSizeRange.heightRange)
}

// -------------------------------------------------------------------

// ImageFeatureType

// int64 width = 1;
inline void ImageFeatureType::clear_width() {
  width_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 ImageFeatureType::width() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.ImageFeatureType.width)
  return width_;
}
inline void ImageFeatureType::set_width(::google::protobuf::int64 value) {

  width_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.ImageFeatureType.width)
}

// int64 height = 2;
inline void ImageFeatureType::clear_height() {
  height_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 ImageFeatureType::height() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.ImageFeatureType.height)
  return height_;
}
inline void ImageFeatureType::set_height(::google::protobuf::int64 value) {

  height_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.ImageFeatureType.height)
}

// .CoreML.Specification.ImageFeatureType.EnumeratedImageSizes enumeratedSizes = 21;
inline bool ImageFeatureType::has_enumeratedsizes() const {
  return SizeFlexibility_case() == kEnumeratedSizes;
}
inline void ImageFeatureType::set_has_enumeratedsizes() {
  _oneof_case_[0] = kEnumeratedSizes;
}
inline void ImageFeatureType::clear_enumeratedsizes() {
  if (has_enumeratedsizes()) {
    delete SizeFlexibility_.enumeratedsizes_;
    clear_has_SizeFlexibility();
  }
}
inline  const ::CoreML::Specification::ImageFeatureType_EnumeratedImageSizes& ImageFeatureType::enumeratedsizes() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.ImageFeatureType.enumeratedSizes)
  return has_enumeratedsizes()
      ? *SizeFlexibility_.enumeratedsizes_
      : ::CoreML::Specification::ImageFeatureType_EnumeratedImageSizes::default_instance();
}
inline ::CoreML::Specification::ImageFeatureType_EnumeratedImageSizes* ImageFeatureType::mutable_enumeratedsizes() {
  if (!has_enumeratedsizes()) {
    clear_SizeFlexibility();
    set_has_enumeratedsizes();
    SizeFlexibility_.enumeratedsizes_ = new ::CoreML::Specification::ImageFeatureType_EnumeratedImageSizes;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.ImageFeatureType.enumeratedSizes)
  return SizeFlexibility_.enumeratedsizes_;
}
inline ::CoreML::Specification::ImageFeatureType_EnumeratedImageSizes* ImageFeatureType::release_enumeratedsizes() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.ImageFeatureType.enumeratedSizes)
  if (has_enumeratedsizes()) {
    clear_has_SizeFlexibility();
    ::CoreML::Specification::ImageFeatureType_EnumeratedImageSizes* temp = SizeFlexibility_.enumeratedsizes_;
    SizeFlexibility_.enumeratedsizes_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ImageFeatureType::set_allocated_enumeratedsizes(::CoreML::Specification::ImageFeatureType_EnumeratedImageSizes* enumeratedsizes) {
  clear_SizeFlexibility();
  if (enumeratedsizes) {
    set_has_enumeratedsizes();
    SizeFlexibility_.enumeratedsizes_ = enumeratedsizes;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.ImageFeatureType.enumeratedSizes)
}

// .CoreML.Specification.ImageFeatureType.ImageSizeRange imageSizeRange = 31;
inline bool ImageFeatureType::has_imagesizerange() const {
  return SizeFlexibility_case() == kImageSizeRange;
}
inline void ImageFeatureType::set_has_imagesizerange() {
  _oneof_case_[0] = kImageSizeRange;
}
inline void ImageFeatureType::clear_imagesizerange() {
  if (has_imagesizerange()) {
    delete SizeFlexibility_.imagesizerange_;
    clear_has_SizeFlexibility();
  }
}
inline  const ::CoreML::Specification::ImageFeatureType_ImageSizeRange& ImageFeatureType::imagesizerange() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.ImageFeatureType.imageSizeRange)
  return has_imagesizerange()
      ? *SizeFlexibility_.imagesizerange_
      : ::CoreML::Specification::ImageFeatureType_ImageSizeRange::default_instance();
}
inline ::CoreML::Specification::ImageFeatureType_ImageSizeRange* ImageFeatureType::mutable_imagesizerange() {
  if (!has_imagesizerange()) {
    clear_SizeFlexibility();
    set_has_imagesizerange();
    SizeFlexibility_.imagesizerange_ = new ::CoreML::Specification::ImageFeatureType_ImageSizeRange;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.ImageFeatureType.imageSizeRange)
  return SizeFlexibility_.imagesizerange_;
}
inline ::CoreML::Specification::ImageFeatureType_ImageSizeRange* ImageFeatureType::release_imagesizerange() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.ImageFeatureType.imageSizeRange)
  if (has_imagesizerange()) {
    clear_has_SizeFlexibility();
    ::CoreML::Specification::ImageFeatureType_ImageSizeRange* temp = SizeFlexibility_.imagesizerange_;
    SizeFlexibility_.imagesizerange_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ImageFeatureType::set_allocated_imagesizerange(::CoreML::Specification::ImageFeatureType_ImageSizeRange* imagesizerange) {
  clear_SizeFlexibility();
  if (imagesizerange) {
    set_has_imagesizerange();
    SizeFlexibility_.imagesizerange_ = imagesizerange;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.ImageFeatureType.imageSizeRange)
}

// .CoreML.Specification.ImageFeatureType.ColorSpace colorSpace = 3;
inline void ImageFeatureType::clear_colorspace() {
  colorspace_ = 0;
}
inline ::CoreML::Specification::ImageFeatureType_ColorSpace ImageFeatureType::colorspace() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.ImageFeatureType.colorSpace)
  return static_cast< ::CoreML::Specification::ImageFeatureType_ColorSpace >(colorspace_);
}
inline void ImageFeatureType::set_colorspace(::CoreML::Specification::ImageFeatureType_ColorSpace value) {

  colorspace_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.ImageFeatureType.colorSpace)
}

inline bool ImageFeatureType::has_SizeFlexibility() const {
  return SizeFlexibility_case() != SIZEFLEXIBILITY_NOT_SET;
}
inline void ImageFeatureType::clear_has_SizeFlexibility() {
  _oneof_case_[0] = SIZEFLEXIBILITY_NOT_SET;
}
inline ImageFeatureType::SizeFlexibilityCase ImageFeatureType::SizeFlexibility_case() const {
  return ImageFeatureType::SizeFlexibilityCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ArrayFeatureType_Shape

// repeated int64 shape = 1;
inline int ArrayFeatureType_Shape::shape_size() const {
  return shape_.size();
}
inline void ArrayFeatureType_Shape::clear_shape() {
  shape_.Clear();
}
inline ::google::protobuf::int64 ArrayFeatureType_Shape::shape(int index) const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.ArrayFeatureType.Shape.shape)
  return shape_.Get(index);
}
inline void ArrayFeatureType_Shape::set_shape(int index, ::google::protobuf::int64 value) {
  shape_.Set(index, value);
  // @@protoc_insertion_point(field_set:CoreML.Specification.ArrayFeatureType.Shape.shape)
}
inline void ArrayFeatureType_Shape::add_shape(::google::protobuf::int64 value) {
  shape_.Add(value);
  // @@protoc_insertion_point(field_add:CoreML.Specification.ArrayFeatureType.Shape.shape)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
ArrayFeatureType_Shape::shape() const {
  // @@protoc_insertion_point(field_list:CoreML.Specification.ArrayFeatureType.Shape.shape)
  return shape_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
ArrayFeatureType_Shape::mutable_shape() {
  // @@protoc_insertion_point(field_mutable_list:CoreML.Specification.ArrayFeatureType.Shape.shape)
  return &shape_;
}

// -------------------------------------------------------------------

// ArrayFeatureType_EnumeratedShapes

// repeated .CoreML.Specification.ArrayFeatureType.Shape shapes = 1;
inline int ArrayFeatureType_EnumeratedShapes::shapes_size() const {
  return shapes_.size();
}
inline void ArrayFeatureType_EnumeratedShapes::clear_shapes() {
  shapes_.Clear();
}
inline const ::CoreML::Specification::ArrayFeatureType_Shape& ArrayFeatureType_EnumeratedShapes::shapes(int index) const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.ArrayFeatureType.EnumeratedShapes.shapes)
  return shapes_.Get(index);
}
inline ::CoreML::Specification::ArrayFeatureType_Shape* ArrayFeatureType_EnumeratedShapes::mutable_shapes(int index) {
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.ArrayFeatureType.EnumeratedShapes.shapes)
  return shapes_.Mutable(index);
}
inline ::CoreML::Specification::ArrayFeatureType_Shape* ArrayFeatureType_EnumeratedShapes::add_shapes() {
  // @@protoc_insertion_point(field_add:CoreML.Specification.ArrayFeatureType.EnumeratedShapes.shapes)
  return shapes_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::ArrayFeatureType_Shape >*
ArrayFeatureType_EnumeratedShapes::mutable_shapes() {
  // @@protoc_insertion_point(field_mutable_list:CoreML.Specification.ArrayFeatureType.EnumeratedShapes.shapes)
  return &shapes_;
}
inline const ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::ArrayFeatureType_Shape >&
ArrayFeatureType_EnumeratedShapes::shapes() const {
  // @@protoc_insertion_point(field_list:CoreML.Specification.ArrayFeatureType.EnumeratedShapes.shapes)
  return shapes_;
}

// -------------------------------------------------------------------

// ArrayFeatureType_ShapeRange

// repeated .CoreML.Specification.SizeRange sizeRanges = 1;
inline int ArrayFeatureType_ShapeRange::sizeranges_size() const {
  return sizeranges_.size();
}
inline void ArrayFeatureType_ShapeRange::clear_sizeranges() {
  sizeranges_.Clear();
}
inline const ::CoreML::Specification::SizeRange& ArrayFeatureType_ShapeRange::sizeranges(int index) const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.ArrayFeatureType.ShapeRange.sizeRanges)
  return sizeranges_.Get(index);
}
inline ::CoreML::Specification::SizeRange* ArrayFeatureType_ShapeRange::mutable_sizeranges(int index) {
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.ArrayFeatureType.ShapeRange.sizeRanges)
  return sizeranges_.Mutable(index);
}
inline ::CoreML::Specification::SizeRange* ArrayFeatureType_ShapeRange::add_sizeranges() {
  // @@protoc_insertion_point(field_add:CoreML.Specification.ArrayFeatureType.ShapeRange.sizeRanges)
  return sizeranges_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::SizeRange >*
ArrayFeatureType_ShapeRange::mutable_sizeranges() {
  // @@protoc_insertion_point(field_mutable_list:CoreML.Specification.ArrayFeatureType.ShapeRange.sizeRanges)
  return &sizeranges_;
}
inline const ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::SizeRange >&
ArrayFeatureType_ShapeRange::sizeranges() const {
  // @@protoc_insertion_point(field_list:CoreML.Specification.ArrayFeatureType.ShapeRange.sizeRanges)
  return sizeranges_;
}

// -------------------------------------------------------------------

// ArrayFeatureType

// repeated int64 shape = 1;
inline int ArrayFeatureType::shape_size() const {
  return shape_.size();
}
inline void ArrayFeatureType::clear_shape() {
  shape_.Clear();
}
inline ::google::protobuf::int64 ArrayFeatureType::shape(int index) const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.ArrayFeatureType.shape)
  return shape_.Get(index);
}
inline void ArrayFeatureType::set_shape(int index, ::google::protobuf::int64 value) {
  shape_.Set(index, value);
  // @@protoc_insertion_point(field_set:CoreML.Specification.ArrayFeatureType.shape)
}
inline void ArrayFeatureType::add_shape(::google::protobuf::int64 value) {
  shape_.Add(value);
  // @@protoc_insertion_point(field_add:CoreML.Specification.ArrayFeatureType.shape)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
ArrayFeatureType::shape() const {
  // @@protoc_insertion_point(field_list:CoreML.Specification.ArrayFeatureType.shape)
  return shape_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
ArrayFeatureType::mutable_shape() {
  // @@protoc_insertion_point(field_mutable_list:CoreML.Specification.ArrayFeatureType.shape)
  return &shape_;
}

// .CoreML.Specification.ArrayFeatureType.ArrayDataType dataType = 2;
inline void ArrayFeatureType::clear_datatype() {
  datatype_ = 0;
}
inline ::CoreML::Specification::ArrayFeatureType_ArrayDataType ArrayFeatureType::datatype() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.ArrayFeatureType.dataType)
  return static_cast< ::CoreML::Specification::ArrayFeatureType_ArrayDataType >(datatype_);
}
inline void ArrayFeatureType::set_datatype(::CoreML::Specification::ArrayFeatureType_ArrayDataType value) {

  datatype_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.ArrayFeatureType.dataType)
}

// .CoreML.Specification.ArrayFeatureType.EnumeratedShapes enumeratedShapes = 21;
inline bool ArrayFeatureType::has_enumeratedshapes() const {
  return ShapeFlexibility_case() == kEnumeratedShapes;
}
inline void ArrayFeatureType::set_has_enumeratedshapes() {
  _oneof_case_[0] = kEnumeratedShapes;
}
inline void ArrayFeatureType::clear_enumeratedshapes() {
  if (has_enumeratedshapes()) {
    delete ShapeFlexibility_.enumeratedshapes_;
    clear_has_ShapeFlexibility();
  }
}
inline  const ::CoreML::Specification::ArrayFeatureType_EnumeratedShapes& ArrayFeatureType::enumeratedshapes() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.ArrayFeatureType.enumeratedShapes)
  return has_enumeratedshapes()
      ? *ShapeFlexibility_.enumeratedshapes_
      : ::CoreML::Specification::ArrayFeatureType_EnumeratedShapes::default_instance();
}
inline ::CoreML::Specification::ArrayFeatureType_EnumeratedShapes* ArrayFeatureType::mutable_enumeratedshapes() {
  if (!has_enumeratedshapes()) {
    clear_ShapeFlexibility();
    set_has_enumeratedshapes();
    ShapeFlexibility_.enumeratedshapes_ = new ::CoreML::Specification::ArrayFeatureType_EnumeratedShapes;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.ArrayFeatureType.enumeratedShapes)
  return ShapeFlexibility_.enumeratedshapes_;
}
inline ::CoreML::Specification::ArrayFeatureType_EnumeratedShapes* ArrayFeatureType::release_enumeratedshapes() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.ArrayFeatureType.enumeratedShapes)
  if (has_enumeratedshapes()) {
    clear_has_ShapeFlexibility();
    ::CoreML::Specification::ArrayFeatureType_EnumeratedShapes* temp = ShapeFlexibility_.enumeratedshapes_;
    ShapeFlexibility_.enumeratedshapes_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ArrayFeatureType::set_allocated_enumeratedshapes(::CoreML::Specification::ArrayFeatureType_EnumeratedShapes* enumeratedshapes) {
  clear_ShapeFlexibility();
  if (enumeratedshapes) {
    set_has_enumeratedshapes();
    ShapeFlexibility_.enumeratedshapes_ = enumeratedshapes;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.ArrayFeatureType.enumeratedShapes)
}

// .CoreML.Specification.ArrayFeatureType.ShapeRange shapeRange = 31;
inline bool ArrayFeatureType::has_shaperange() const {
  return ShapeFlexibility_case() == kShapeRange;
}
inline void ArrayFeatureType::set_has_shaperange() {
  _oneof_case_[0] = kShapeRange;
}
inline void ArrayFeatureType::clear_shaperange() {
  if (has_shaperange()) {
    delete ShapeFlexibility_.shaperange_;
    clear_has_ShapeFlexibility();
  }
}
inline  const ::CoreML::Specification::ArrayFeatureType_ShapeRange& ArrayFeatureType::shaperange() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.ArrayFeatureType.shapeRange)
  return has_shaperange()
      ? *ShapeFlexibility_.shaperange_
      : ::CoreML::Specification::ArrayFeatureType_ShapeRange::default_instance();
}
inline ::CoreML::Specification::ArrayFeatureType_ShapeRange* ArrayFeatureType::mutable_shaperange() {
  if (!has_shaperange()) {
    clear_ShapeFlexibility();
    set_has_shaperange();
    ShapeFlexibility_.shaperange_ = new ::CoreML::Specification::ArrayFeatureType_ShapeRange;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.ArrayFeatureType.shapeRange)
  return ShapeFlexibility_.shaperange_;
}
inline ::CoreML::Specification::ArrayFeatureType_ShapeRange* ArrayFeatureType::release_shaperange() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.ArrayFeatureType.shapeRange)
  if (has_shaperange()) {
    clear_has_ShapeFlexibility();
    ::CoreML::Specification::ArrayFeatureType_ShapeRange* temp = ShapeFlexibility_.shaperange_;
    ShapeFlexibility_.shaperange_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ArrayFeatureType::set_allocated_shaperange(::CoreML::Specification::ArrayFeatureType_ShapeRange* shaperange) {
  clear_ShapeFlexibility();
  if (shaperange) {
    set_has_shaperange();
    ShapeFlexibility_.shaperange_ = shaperange;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.ArrayFeatureType.shapeRange)
}

inline bool ArrayFeatureType::has_ShapeFlexibility() const {
  return ShapeFlexibility_case() != SHAPEFLEXIBILITY_NOT_SET;
}
inline void ArrayFeatureType::clear_has_ShapeFlexibility() {
  _oneof_case_[0] = SHAPEFLEXIBILITY_NOT_SET;
}
inline ArrayFeatureType::ShapeFlexibilityCase ArrayFeatureType::ShapeFlexibility_case() const {
  return ArrayFeatureType::ShapeFlexibilityCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// DictionaryFeatureType

// .CoreML.Specification.Int64FeatureType int64KeyType = 1;
inline bool DictionaryFeatureType::has_int64keytype() const {
  return KeyType_case() == kInt64KeyType;
}
inline void DictionaryFeatureType::set_has_int64keytype() {
  _oneof_case_[0] = kInt64KeyType;
}
inline void DictionaryFeatureType::clear_int64keytype() {
  if (has_int64keytype()) {
    delete KeyType_.int64keytype_;
    clear_has_KeyType();
  }
}
inline  const ::CoreML::Specification::Int64FeatureType& DictionaryFeatureType::int64keytype() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.DictionaryFeatureType.int64KeyType)
  return has_int64keytype()
      ? *KeyType_.int64keytype_
      : ::CoreML::Specification::Int64FeatureType::default_instance();
}
inline ::CoreML::Specification::Int64FeatureType* DictionaryFeatureType::mutable_int64keytype() {
  if (!has_int64keytype()) {
    clear_KeyType();
    set_has_int64keytype();
    KeyType_.int64keytype_ = new ::CoreML::Specification::Int64FeatureType;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.DictionaryFeatureType.int64KeyType)
  return KeyType_.int64keytype_;
}
inline ::CoreML::Specification::Int64FeatureType* DictionaryFeatureType::release_int64keytype() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.DictionaryFeatureType.int64KeyType)
  if (has_int64keytype()) {
    clear_has_KeyType();
    ::CoreML::Specification::Int64FeatureType* temp = KeyType_.int64keytype_;
    KeyType_.int64keytype_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void DictionaryFeatureType::set_allocated_int64keytype(::CoreML::Specification::Int64FeatureType* int64keytype) {
  clear_KeyType();
  if (int64keytype) {
    set_has_int64keytype();
    KeyType_.int64keytype_ = int64keytype;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.DictionaryFeatureType.int64KeyType)
}

// .CoreML.Specification.StringFeatureType stringKeyType = 2;
inline bool DictionaryFeatureType::has_stringkeytype() const {
  return KeyType_case() == kStringKeyType;
}
inline void DictionaryFeatureType::set_has_stringkeytype() {
  _oneof_case_[0] = kStringKeyType;
}
inline void DictionaryFeatureType::clear_stringkeytype() {
  if (has_stringkeytype()) {
    delete KeyType_.stringkeytype_;
    clear_has_KeyType();
  }
}
inline  const ::CoreML::Specification::StringFeatureType& DictionaryFeatureType::stringkeytype() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.DictionaryFeatureType.stringKeyType)
  return has_stringkeytype()
      ? *KeyType_.stringkeytype_
      : ::CoreML::Specification::StringFeatureType::default_instance();
}
inline ::CoreML::Specification::StringFeatureType* DictionaryFeatureType::mutable_stringkeytype() {
  if (!has_stringkeytype()) {
    clear_KeyType();
    set_has_stringkeytype();
    KeyType_.stringkeytype_ = new ::CoreML::Specification::StringFeatureType;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.DictionaryFeatureType.stringKeyType)
  return KeyType_.stringkeytype_;
}
inline ::CoreML::Specification::StringFeatureType* DictionaryFeatureType::release_stringkeytype() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.DictionaryFeatureType.stringKeyType)
  if (has_stringkeytype()) {
    clear_has_KeyType();
    ::CoreML::Specification::StringFeatureType* temp = KeyType_.stringkeytype_;
    KeyType_.stringkeytype_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void DictionaryFeatureType::set_allocated_stringkeytype(::CoreML::Specification::StringFeatureType* stringkeytype) {
  clear_KeyType();
  if (stringkeytype) {
    set_has_stringkeytype();
    KeyType_.stringkeytype_ = stringkeytype;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.DictionaryFeatureType.stringKeyType)
}

inline bool DictionaryFeatureType::has_KeyType() const {
  return KeyType_case() != KEYTYPE_NOT_SET;
}
inline void DictionaryFeatureType::clear_has_KeyType() {
  _oneof_case_[0] = KEYTYPE_NOT_SET;
}
inline DictionaryFeatureType::KeyTypeCase DictionaryFeatureType::KeyType_case() const {
  return DictionaryFeatureType::KeyTypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// SequenceFeatureType

// .CoreML.Specification.Int64FeatureType int64Type = 1;
inline bool SequenceFeatureType::has_int64type() const {
  return Type_case() == kInt64Type;
}
inline void SequenceFeatureType::set_has_int64type() {
  _oneof_case_[0] = kInt64Type;
}
inline void SequenceFeatureType::clear_int64type() {
  if (has_int64type()) {
    delete Type_.int64type_;
    clear_has_Type();
  }
}
inline  const ::CoreML::Specification::Int64FeatureType& SequenceFeatureType::int64type() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.SequenceFeatureType.int64Type)
  return has_int64type()
      ? *Type_.int64type_
      : ::CoreML::Specification::Int64FeatureType::default_instance();
}
inline ::CoreML::Specification::Int64FeatureType* SequenceFeatureType::mutable_int64type() {
  if (!has_int64type()) {
    clear_Type();
    set_has_int64type();
    Type_.int64type_ = new ::CoreML::Specification::Int64FeatureType;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.SequenceFeatureType.int64Type)
  return Type_.int64type_;
}
inline ::CoreML::Specification::Int64FeatureType* SequenceFeatureType::release_int64type() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.SequenceFeatureType.int64Type)
  if (has_int64type()) {
    clear_has_Type();
    ::CoreML::Specification::Int64FeatureType* temp = Type_.int64type_;
    Type_.int64type_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void SequenceFeatureType::set_allocated_int64type(::CoreML::Specification::Int64FeatureType* int64type) {
  clear_Type();
  if (int64type) {
    set_has_int64type();
    Type_.int64type_ = int64type;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.SequenceFeatureType.int64Type)
}

// .CoreML.Specification.StringFeatureType stringType = 3;
inline bool SequenceFeatureType::has_stringtype() const {
  return Type_case() == kStringType;
}
inline void SequenceFeatureType::set_has_stringtype() {
  _oneof_case_[0] = kStringType;
}
inline void SequenceFeatureType::clear_stringtype() {
  if (has_stringtype()) {
    delete Type_.stringtype_;
    clear_has_Type();
  }
}
inline  const ::CoreML::Specification::StringFeatureType& SequenceFeatureType::stringtype() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.SequenceFeatureType.stringType)
  return has_stringtype()
      ? *Type_.stringtype_
      : ::CoreML::Specification::StringFeatureType::default_instance();
}
inline ::CoreML::Specification::StringFeatureType* SequenceFeatureType::mutable_stringtype() {
  if (!has_stringtype()) {
    clear_Type();
    set_has_stringtype();
    Type_.stringtype_ = new ::CoreML::Specification::StringFeatureType;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.SequenceFeatureType.stringType)
  return Type_.stringtype_;
}
inline ::CoreML::Specification::StringFeatureType* SequenceFeatureType::release_stringtype() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.SequenceFeatureType.stringType)
  if (has_stringtype()) {
    clear_has_Type();
    ::CoreML::Specification::StringFeatureType* temp = Type_.stringtype_;
    Type_.stringtype_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void SequenceFeatureType::set_allocated_stringtype(::CoreML::Specification::StringFeatureType* stringtype) {
  clear_Type();
  if (stringtype) {
    set_has_stringtype();
    Type_.stringtype_ = stringtype;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.SequenceFeatureType.stringType)
}

// .CoreML.Specification.SizeRange sizeRange = 101;
inline bool SequenceFeatureType::has_sizerange() const {
  return this != internal_default_instance() && sizerange_ != NULL;
}
inline void SequenceFeatureType::clear_sizerange() {
  if (GetArenaNoVirtual() == NULL && sizerange_ != NULL) delete sizerange_;
  sizerange_ = NULL;
}
inline const ::CoreML::Specification::SizeRange& SequenceFeatureType::sizerange() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.SequenceFeatureType.sizeRange)
  return sizerange_ != NULL ? *sizerange_
                         : *::CoreML::Specification::SizeRange::internal_default_instance();
}
inline ::CoreML::Specification::SizeRange* SequenceFeatureType::mutable_sizerange() {

  if (sizerange_ == NULL) {
    sizerange_ = new ::CoreML::Specification::SizeRange;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.SequenceFeatureType.sizeRange)
  return sizerange_;
}
inline ::CoreML::Specification::SizeRange* SequenceFeatureType::release_sizerange() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.SequenceFeatureType.sizeRange)

  ::CoreML::Specification::SizeRange* temp = sizerange_;
  sizerange_ = NULL;
  return temp;
}
inline void SequenceFeatureType::set_allocated_sizerange(::CoreML::Specification::SizeRange* sizerange) {
  delete sizerange_;
  sizerange_ = sizerange;
  if (sizerange) {

  } else {

  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.SequenceFeatureType.sizeRange)
}

inline bool SequenceFeatureType::has_Type() const {
  return Type_case() != TYPE_NOT_SET;
}
inline void SequenceFeatureType::clear_has_Type() {
  _oneof_case_[0] = TYPE_NOT_SET;
}
inline SequenceFeatureType::TypeCase SequenceFeatureType::Type_case() const {
  return SequenceFeatureType::TypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// FeatureType

// .CoreML.Specification.Int64FeatureType int64Type = 1;
inline bool FeatureType::has_int64type() const {
  return Type_case() == kInt64Type;
}
inline void FeatureType::set_has_int64type() {
  _oneof_case_[0] = kInt64Type;
}
inline void FeatureType::clear_int64type() {
  if (has_int64type()) {
    delete Type_.int64type_;
    clear_has_Type();
  }
}
inline  const ::CoreML::Specification::Int64FeatureType& FeatureType::int64type() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.FeatureType.int64Type)
  return has_int64type()
      ? *Type_.int64type_
      : ::CoreML::Specification::Int64FeatureType::default_instance();
}
inline ::CoreML::Specification::Int64FeatureType* FeatureType::mutable_int64type() {
  if (!has_int64type()) {
    clear_Type();
    set_has_int64type();
    Type_.int64type_ = new ::CoreML::Specification::Int64FeatureType;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.FeatureType.int64Type)
  return Type_.int64type_;
}
inline ::CoreML::Specification::Int64FeatureType* FeatureType::release_int64type() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.FeatureType.int64Type)
  if (has_int64type()) {
    clear_has_Type();
    ::CoreML::Specification::Int64FeatureType* temp = Type_.int64type_;
    Type_.int64type_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void FeatureType::set_allocated_int64type(::CoreML::Specification::Int64FeatureType* int64type) {
  clear_Type();
  if (int64type) {
    set_has_int64type();
    Type_.int64type_ = int64type;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.FeatureType.int64Type)
}

// .CoreML.Specification.DoubleFeatureType doubleType = 2;
inline bool FeatureType::has_doubletype() const {
  return Type_case() == kDoubleType;
}
inline void FeatureType::set_has_doubletype() {
  _oneof_case_[0] = kDoubleType;
}
inline void FeatureType::clear_doubletype() {
  if (has_doubletype()) {
    delete Type_.doubletype_;
    clear_has_Type();
  }
}
inline  const ::CoreML::Specification::DoubleFeatureType& FeatureType::doubletype() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.FeatureType.doubleType)
  return has_doubletype()
      ? *Type_.doubletype_
      : ::CoreML::Specification::DoubleFeatureType::default_instance();
}
inline ::CoreML::Specification::DoubleFeatureType* FeatureType::mutable_doubletype() {
  if (!has_doubletype()) {
    clear_Type();
    set_has_doubletype();
    Type_.doubletype_ = new ::CoreML::Specification::DoubleFeatureType;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.FeatureType.doubleType)
  return Type_.doubletype_;
}
inline ::CoreML::Specification::DoubleFeatureType* FeatureType::release_doubletype() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.FeatureType.doubleType)
  if (has_doubletype()) {
    clear_has_Type();
    ::CoreML::Specification::DoubleFeatureType* temp = Type_.doubletype_;
    Type_.doubletype_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void FeatureType::set_allocated_doubletype(::CoreML::Specification::DoubleFeatureType* doubletype) {
  clear_Type();
  if (doubletype) {
    set_has_doubletype();
    Type_.doubletype_ = doubletype;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.FeatureType.doubleType)
}

// .CoreML.Specification.StringFeatureType stringType = 3;
inline bool FeatureType::has_stringtype() const {
  return Type_case() == kStringType;
}
inline void FeatureType::set_has_stringtype() {
  _oneof_case_[0] = kStringType;
}
inline void FeatureType::clear_stringtype() {
  if (has_stringtype()) {
    delete Type_.stringtype_;
    clear_has_Type();
  }
}
inline  const ::CoreML::Specification::StringFeatureType& FeatureType::stringtype() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.FeatureType.stringType)
  return has_stringtype()
      ? *Type_.stringtype_
      : ::CoreML::Specification::StringFeatureType::default_instance();
}
inline ::CoreML::Specification::StringFeatureType* FeatureType::mutable_stringtype() {
  if (!has_stringtype()) {
    clear_Type();
    set_has_stringtype();
    Type_.stringtype_ = new ::CoreML::Specification::StringFeatureType;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.FeatureType.stringType)
  return Type_.stringtype_;
}
inline ::CoreML::Specification::StringFeatureType* FeatureType::release_stringtype() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.FeatureType.stringType)
  if (has_stringtype()) {
    clear_has_Type();
    ::CoreML::Specification::StringFeatureType* temp = Type_.stringtype_;
    Type_.stringtype_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void FeatureType::set_allocated_stringtype(::CoreML::Specification::StringFeatureType* stringtype) {
  clear_Type();
  if (stringtype) {
    set_has_stringtype();
    Type_.stringtype_ = stringtype;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.FeatureType.stringType)
}

// .CoreML.Specification.ImageFeatureType imageType = 4;
inline bool FeatureType::has_imagetype() const {
  return Type_case() == kImageType;
}
inline void FeatureType::set_has_imagetype() {
  _oneof_case_[0] = kImageType;
}
inline void FeatureType::clear_imagetype() {
  if (has_imagetype()) {
    delete Type_.imagetype_;
    clear_has_Type();
  }
}
inline  const ::CoreML::Specification::ImageFeatureType& FeatureType::imagetype() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.FeatureType.imageType)
  return has_imagetype()
      ? *Type_.imagetype_
      : ::CoreML::Specification::ImageFeatureType::default_instance();
}
inline ::CoreML::Specification::ImageFeatureType* FeatureType::mutable_imagetype() {
  if (!has_imagetype()) {
    clear_Type();
    set_has_imagetype();
    Type_.imagetype_ = new ::CoreML::Specification::ImageFeatureType;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.FeatureType.imageType)
  return Type_.imagetype_;
}
inline ::CoreML::Specification::ImageFeatureType* FeatureType::release_imagetype() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.FeatureType.imageType)
  if (has_imagetype()) {
    clear_has_Type();
    ::CoreML::Specification::ImageFeatureType* temp = Type_.imagetype_;
    Type_.imagetype_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void FeatureType::set_allocated_imagetype(::CoreML::Specification::ImageFeatureType* imagetype) {
  clear_Type();
  if (imagetype) {
    set_has_imagetype();
    Type_.imagetype_ = imagetype;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.FeatureType.imageType)
}

// .CoreML.Specification.ArrayFeatureType multiArrayType = 5;
inline bool FeatureType::has_multiarraytype() const {
  return Type_case() == kMultiArrayType;
}
inline void FeatureType::set_has_multiarraytype() {
  _oneof_case_[0] = kMultiArrayType;
}
inline void FeatureType::clear_multiarraytype() {
  if (has_multiarraytype()) {
    delete Type_.multiarraytype_;
    clear_has_Type();
  }
}
inline  const ::CoreML::Specification::ArrayFeatureType& FeatureType::multiarraytype() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.FeatureType.multiArrayType)
  return has_multiarraytype()
      ? *Type_.multiarraytype_
      : ::CoreML::Specification::ArrayFeatureType::default_instance();
}
inline ::CoreML::Specification::ArrayFeatureType* FeatureType::mutable_multiarraytype() {
  if (!has_multiarraytype()) {
    clear_Type();
    set_has_multiarraytype();
    Type_.multiarraytype_ = new ::CoreML::Specification::ArrayFeatureType;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.FeatureType.multiArrayType)
  return Type_.multiarraytype_;
}
inline ::CoreML::Specification::ArrayFeatureType* FeatureType::release_multiarraytype() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.FeatureType.multiArrayType)
  if (has_multiarraytype()) {
    clear_has_Type();
    ::CoreML::Specification::ArrayFeatureType* temp = Type_.multiarraytype_;
    Type_.multiarraytype_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void FeatureType::set_allocated_multiarraytype(::CoreML::Specification::ArrayFeatureType* multiarraytype) {
  clear_Type();
  if (multiarraytype) {
    set_has_multiarraytype();
    Type_.multiarraytype_ = multiarraytype;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.FeatureType.multiArrayType)
}

// .CoreML.Specification.DictionaryFeatureType dictionaryType = 6;
inline bool FeatureType::has_dictionarytype() const {
  return Type_case() == kDictionaryType;
}
inline void FeatureType::set_has_dictionarytype() {
  _oneof_case_[0] = kDictionaryType;
}
inline void FeatureType::clear_dictionarytype() {
  if (has_dictionarytype()) {
    delete Type_.dictionarytype_;
    clear_has_Type();
  }
}
inline  const ::CoreML::Specification::DictionaryFeatureType& FeatureType::dictionarytype() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.FeatureType.dictionaryType)
  return has_dictionarytype()
      ? *Type_.dictionarytype_
      : ::CoreML::Specification::DictionaryFeatureType::default_instance();
}
inline ::CoreML::Specification::DictionaryFeatureType* FeatureType::mutable_dictionarytype() {
  if (!has_dictionarytype()) {
    clear_Type();
    set_has_dictionarytype();
    Type_.dictionarytype_ = new ::CoreML::Specification::DictionaryFeatureType;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.FeatureType.dictionaryType)
  return Type_.dictionarytype_;
}
inline ::CoreML::Specification::DictionaryFeatureType* FeatureType::release_dictionarytype() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.FeatureType.dictionaryType)
  if (has_dictionarytype()) {
    clear_has_Type();
    ::CoreML::Specification::DictionaryFeatureType* temp = Type_.dictionarytype_;
    Type_.dictionarytype_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void FeatureType::set_allocated_dictionarytype(::CoreML::Specification::DictionaryFeatureType* dictionarytype) {
  clear_Type();
  if (dictionarytype) {
    set_has_dictionarytype();
    Type_.dictionarytype_ = dictionarytype;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.FeatureType.dictionaryType)
}

// .CoreML.Specification.SequenceFeatureType sequenceType = 7;
inline bool FeatureType::has_sequencetype() const {
  return Type_case() == kSequenceType;
}
inline void FeatureType::set_has_sequencetype() {
  _oneof_case_[0] = kSequenceType;
}
inline void FeatureType::clear_sequencetype() {
  if (has_sequencetype()) {
    delete Type_.sequencetype_;
    clear_has_Type();
  }
}
inline  const ::CoreML::Specification::SequenceFeatureType& FeatureType::sequencetype() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.FeatureType.sequenceType)
  return has_sequencetype()
      ? *Type_.sequencetype_
      : ::CoreML::Specification::SequenceFeatureType::default_instance();
}
inline ::CoreML::Specification::SequenceFeatureType* FeatureType::mutable_sequencetype() {
  if (!has_sequencetype()) {
    clear_Type();
    set_has_sequencetype();
    Type_.sequencetype_ = new ::CoreML::Specification::SequenceFeatureType;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.FeatureType.sequenceType)
  return Type_.sequencetype_;
}
inline ::CoreML::Specification::SequenceFeatureType* FeatureType::release_sequencetype() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.FeatureType.sequenceType)
  if (has_sequencetype()) {
    clear_has_Type();
    ::CoreML::Specification::SequenceFeatureType* temp = Type_.sequencetype_;
    Type_.sequencetype_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void FeatureType::set_allocated_sequencetype(::CoreML::Specification::SequenceFeatureType* sequencetype) {
  clear_Type();
  if (sequencetype) {
    set_has_sequencetype();
    Type_.sequencetype_ = sequencetype;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.FeatureType.sequenceType)
}

// bool isOptional = 1000;
inline void FeatureType::clear_isoptional() {
  isoptional_ = false;
}
inline bool FeatureType::isoptional() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.FeatureType.isOptional)
  return isoptional_;
}
inline void FeatureType::set_isoptional(bool value) {

  isoptional_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.FeatureType.isOptional)
}

inline bool FeatureType::has_Type() const {
  return Type_case() != TYPE_NOT_SET;
}
inline void FeatureType::clear_has_Type() {
  _oneof_case_[0] = TYPE_NOT_SET;
}
inline FeatureType::TypeCase FeatureType::Type_case() const {
  return FeatureType::TypeCase(_oneof_case_[0]);
}
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace Specification
}  // namespace CoreML

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::CoreML::Specification::ImageFeatureType_ColorSpace> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::CoreML::Specification::ArrayFeatureType_ArrayDataType> : ::google::protobuf::internal::true_type {};

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_FeatureTypes_2eproto__INCLUDED
