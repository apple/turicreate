// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Model.proto

#ifndef PROTOBUF_Model_2eproto__INCLUDED
#define PROTOBUF_Model_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3003000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3003000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_field_lite.h>
#include "VisionFeaturePrint.pb.h"  // IWYU pragma: export
#include "TextClassifier.pb.h"  // IWYU pragma: export
#include "WordTagger.pb.h"  // IWYU pragma: export
#include "ArrayFeatureExtractor.pb.h"  // IWYU pragma: export
#include "BayesianProbitRegressor.pb.h"  // IWYU pragma: export
#include "CategoricalMapping.pb.h"  // IWYU pragma: export
#include "CustomModel.pb.h"  // IWYU pragma: export
#include "DictVectorizer.pb.h"  // IWYU pragma: export
#include "FeatureTypes.pb.h"  // IWYU pragma: export
#include "FeatureVectorizer.pb.h"  // IWYU pragma: export
#include "GLMRegressor.pb.h"  // IWYU pragma: export
#include "GLMClassifier.pb.h"  // IWYU pragma: export
#include "Identity.pb.h"  // IWYU pragma: export
#include "Imputer.pb.h"  // IWYU pragma: export
#include "NeuralNetwork.pb.h"  // IWYU pragma: export
#include "Normalizer.pb.h"  // IWYU pragma: export
#include "OneHotEncoder.pb.h"  // IWYU pragma: export
#include "Scaler.pb.h"  // IWYU pragma: export
#include "NonMaximumSuppression.pb.h"  // IWYU pragma: export
#include "SVM.pb.h"  // IWYU pragma: export
#include "TreeEnsemble.pb.h"  // IWYU pragma: export
// @@protoc_insertion_point(includes)
namespace CoreML {
namespace Specification {
class ActivationELU;
class ActivationELUDefaultTypeInternal;
extern ActivationELUDefaultTypeInternal _ActivationELU_default_instance_;
class ActivationLeakyReLU;
class ActivationLeakyReLUDefaultTypeInternal;
extern ActivationLeakyReLUDefaultTypeInternal _ActivationLeakyReLU_default_instance_;
class ActivationLinear;
class ActivationLinearDefaultTypeInternal;
extern ActivationLinearDefaultTypeInternal _ActivationLinear_default_instance_;
class ActivationPReLU;
class ActivationPReLUDefaultTypeInternal;
extern ActivationPReLUDefaultTypeInternal _ActivationPReLU_default_instance_;
class ActivationParametricSoftplus;
class ActivationParametricSoftplusDefaultTypeInternal;
extern ActivationParametricSoftplusDefaultTypeInternal _ActivationParametricSoftplus_default_instance_;
class ActivationParams;
class ActivationParamsDefaultTypeInternal;
extern ActivationParamsDefaultTypeInternal _ActivationParams_default_instance_;
class ActivationReLU;
class ActivationReLUDefaultTypeInternal;
extern ActivationReLUDefaultTypeInternal _ActivationReLU_default_instance_;
class ActivationScaledTanh;
class ActivationScaledTanhDefaultTypeInternal;
extern ActivationScaledTanhDefaultTypeInternal _ActivationScaledTanh_default_instance_;
class ActivationSigmoid;
class ActivationSigmoidDefaultTypeInternal;
extern ActivationSigmoidDefaultTypeInternal _ActivationSigmoid_default_instance_;
class ActivationSigmoidHard;
class ActivationSigmoidHardDefaultTypeInternal;
extern ActivationSigmoidHardDefaultTypeInternal _ActivationSigmoidHard_default_instance_;
class ActivationSoftplus;
class ActivationSoftplusDefaultTypeInternal;
extern ActivationSoftplusDefaultTypeInternal _ActivationSoftplus_default_instance_;
class ActivationSoftsign;
class ActivationSoftsignDefaultTypeInternal;
extern ActivationSoftsignDefaultTypeInternal _ActivationSoftsign_default_instance_;
class ActivationTanh;
class ActivationTanhDefaultTypeInternal;
extern ActivationTanhDefaultTypeInternal _ActivationTanh_default_instance_;
class ActivationThresholdedReLU;
class ActivationThresholdedReLUDefaultTypeInternal;
extern ActivationThresholdedReLUDefaultTypeInternal _ActivationThresholdedReLU_default_instance_;
class AddLayerParams;
class AddLayerParamsDefaultTypeInternal;
extern AddLayerParamsDefaultTypeInternal _AddLayerParams_default_instance_;
class ArrayFeatureExtractor;
class ArrayFeatureExtractorDefaultTypeInternal;
extern ArrayFeatureExtractorDefaultTypeInternal _ArrayFeatureExtractor_default_instance_;
class ArrayFeatureType;
class ArrayFeatureTypeDefaultTypeInternal;
extern ArrayFeatureTypeDefaultTypeInternal _ArrayFeatureType_default_instance_;
class ArrayFeatureType_EnumeratedShapes;
class ArrayFeatureType_EnumeratedShapesDefaultTypeInternal;
extern ArrayFeatureType_EnumeratedShapesDefaultTypeInternal _ArrayFeatureType_EnumeratedShapes_default_instance_;
class ArrayFeatureType_Shape;
class ArrayFeatureType_ShapeDefaultTypeInternal;
extern ArrayFeatureType_ShapeDefaultTypeInternal _ArrayFeatureType_Shape_default_instance_;
class ArrayFeatureType_ShapeRange;
class ArrayFeatureType_ShapeRangeDefaultTypeInternal;
extern ArrayFeatureType_ShapeRangeDefaultTypeInternal _ArrayFeatureType_ShapeRange_default_instance_;
class AverageLayerParams;
class AverageLayerParamsDefaultTypeInternal;
extern AverageLayerParamsDefaultTypeInternal _AverageLayerParams_default_instance_;
class BatchnormLayerParams;
class BatchnormLayerParamsDefaultTypeInternal;
extern BatchnormLayerParamsDefaultTypeInternal _BatchnormLayerParams_default_instance_;
class BayesianProbitRegressor;
class BayesianProbitRegressorDefaultTypeInternal;
extern BayesianProbitRegressorDefaultTypeInternal _BayesianProbitRegressor_default_instance_;
class BayesianProbitRegressor_FeatureValueWeight;
class BayesianProbitRegressor_FeatureValueWeightDefaultTypeInternal;
extern BayesianProbitRegressor_FeatureValueWeightDefaultTypeInternal _BayesianProbitRegressor_FeatureValueWeight_default_instance_;
class BayesianProbitRegressor_FeatureWeight;
class BayesianProbitRegressor_FeatureWeightDefaultTypeInternal;
extern BayesianProbitRegressor_FeatureWeightDefaultTypeInternal _BayesianProbitRegressor_FeatureWeight_default_instance_;
class BayesianProbitRegressor_Gaussian;
class BayesianProbitRegressor_GaussianDefaultTypeInternal;
extern BayesianProbitRegressor_GaussianDefaultTypeInternal _BayesianProbitRegressor_Gaussian_default_instance_;
class BiDirectionalLSTMLayerParams;
class BiDirectionalLSTMLayerParamsDefaultTypeInternal;
extern BiDirectionalLSTMLayerParamsDefaultTypeInternal _BiDirectionalLSTMLayerParams_default_instance_;
class BiasLayerParams;
class BiasLayerParamsDefaultTypeInternal;
extern BiasLayerParamsDefaultTypeInternal _BiasLayerParams_default_instance_;
class BorderAmounts;
class BorderAmountsDefaultTypeInternal;
extern BorderAmountsDefaultTypeInternal _BorderAmounts_default_instance_;
class BorderAmounts_EdgeSizes;
class BorderAmounts_EdgeSizesDefaultTypeInternal;
extern BorderAmounts_EdgeSizesDefaultTypeInternal _BorderAmounts_EdgeSizes_default_instance_;
class BoxCoordinatesMode;
class BoxCoordinatesModeDefaultTypeInternal;
extern BoxCoordinatesModeDefaultTypeInternal _BoxCoordinatesMode_default_instance_;
class CategoricalMapping;
class CategoricalMappingDefaultTypeInternal;
extern CategoricalMappingDefaultTypeInternal _CategoricalMapping_default_instance_;
class Coefficients;
class CoefficientsDefaultTypeInternal;
extern CoefficientsDefaultTypeInternal _Coefficients_default_instance_;
class ConcatLayerParams;
class ConcatLayerParamsDefaultTypeInternal;
extern ConcatLayerParamsDefaultTypeInternal _ConcatLayerParams_default_instance_;
class ConvolutionLayerParams;
class ConvolutionLayerParamsDefaultTypeInternal;
extern ConvolutionLayerParamsDefaultTypeInternal _ConvolutionLayerParams_default_instance_;
class CropLayerParams;
class CropLayerParamsDefaultTypeInternal;
extern CropLayerParamsDefaultTypeInternal _CropLayerParams_default_instance_;
class CropResizeLayerParams;
class CropResizeLayerParamsDefaultTypeInternal;
extern CropResizeLayerParamsDefaultTypeInternal _CropResizeLayerParams_default_instance_;
class CustomLayerParams;
class CustomLayerParamsDefaultTypeInternal;
extern CustomLayerParamsDefaultTypeInternal _CustomLayerParams_default_instance_;
class CustomLayerParams_CustomLayerParamValue;
class CustomLayerParams_CustomLayerParamValueDefaultTypeInternal;
extern CustomLayerParams_CustomLayerParamValueDefaultTypeInternal _CustomLayerParams_CustomLayerParamValue_default_instance_;
class CustomLayerParams_ParametersEntry;
class CustomLayerParams_ParametersEntryDefaultTypeInternal;
extern CustomLayerParams_ParametersEntryDefaultTypeInternal _CustomLayerParams_ParametersEntry_default_instance_;
class CustomModel;
class CustomModelDefaultTypeInternal;
extern CustomModelDefaultTypeInternal _CustomModel_default_instance_;
class CustomModel_CustomModelParamValue;
class CustomModel_CustomModelParamValueDefaultTypeInternal;
extern CustomModel_CustomModelParamValueDefaultTypeInternal _CustomModel_CustomModelParamValue_default_instance_;
class CustomModel_ParametersEntry;
class CustomModel_ParametersEntryDefaultTypeInternal;
extern CustomModel_ParametersEntryDefaultTypeInternal _CustomModel_ParametersEntry_default_instance_;
class DenseSupportVectors;
class DenseSupportVectorsDefaultTypeInternal;
extern DenseSupportVectorsDefaultTypeInternal _DenseSupportVectors_default_instance_;
class DenseVector;
class DenseVectorDefaultTypeInternal;
extern DenseVectorDefaultTypeInternal _DenseVector_default_instance_;
class DictVectorizer;
class DictVectorizerDefaultTypeInternal;
extern DictVectorizerDefaultTypeInternal _DictVectorizer_default_instance_;
class DictionaryFeatureType;
class DictionaryFeatureTypeDefaultTypeInternal;
extern DictionaryFeatureTypeDefaultTypeInternal _DictionaryFeatureType_default_instance_;
class DotProductLayerParams;
class DotProductLayerParamsDefaultTypeInternal;
extern DotProductLayerParamsDefaultTypeInternal _DotProductLayerParams_default_instance_;
class DoubleFeatureType;
class DoubleFeatureTypeDefaultTypeInternal;
extern DoubleFeatureTypeDefaultTypeInternal _DoubleFeatureType_default_instance_;
class DoubleVector;
class DoubleVectorDefaultTypeInternal;
extern DoubleVectorDefaultTypeInternal _DoubleVector_default_instance_;
class EmbeddingLayerParams;
class EmbeddingLayerParamsDefaultTypeInternal;
extern EmbeddingLayerParamsDefaultTypeInternal _EmbeddingLayerParams_default_instance_;
class FeatureDescription;
class FeatureDescriptionDefaultTypeInternal;
extern FeatureDescriptionDefaultTypeInternal _FeatureDescription_default_instance_;
class FeatureType;
class FeatureTypeDefaultTypeInternal;
extern FeatureTypeDefaultTypeInternal _FeatureType_default_instance_;
class FeatureVectorizer;
class FeatureVectorizerDefaultTypeInternal;
extern FeatureVectorizerDefaultTypeInternal _FeatureVectorizer_default_instance_;
class FeatureVectorizer_InputColumn;
class FeatureVectorizer_InputColumnDefaultTypeInternal;
extern FeatureVectorizer_InputColumnDefaultTypeInternal _FeatureVectorizer_InputColumn_default_instance_;
class FlattenLayerParams;
class FlattenLayerParamsDefaultTypeInternal;
extern FlattenLayerParamsDefaultTypeInternal _FlattenLayerParams_default_instance_;
class GLMClassifier;
class GLMClassifierDefaultTypeInternal;
extern GLMClassifierDefaultTypeInternal _GLMClassifier_default_instance_;
class GLMClassifier_DoubleArray;
class GLMClassifier_DoubleArrayDefaultTypeInternal;
extern GLMClassifier_DoubleArrayDefaultTypeInternal _GLMClassifier_DoubleArray_default_instance_;
class GLMRegressor;
class GLMRegressorDefaultTypeInternal;
extern GLMRegressorDefaultTypeInternal _GLMRegressor_default_instance_;
class GLMRegressor_DoubleArray;
class GLMRegressor_DoubleArrayDefaultTypeInternal;
extern GLMRegressor_DoubleArrayDefaultTypeInternal _GLMRegressor_DoubleArray_default_instance_;
class GRULayerParams;
class GRULayerParamsDefaultTypeInternal;
extern GRULayerParamsDefaultTypeInternal _GRULayerParams_default_instance_;
class Identity;
class IdentityDefaultTypeInternal;
extern IdentityDefaultTypeInternal _Identity_default_instance_;
class ImageFeatureType;
class ImageFeatureTypeDefaultTypeInternal;
extern ImageFeatureTypeDefaultTypeInternal _ImageFeatureType_default_instance_;
class ImageFeatureType_EnumeratedImageSizes;
class ImageFeatureType_EnumeratedImageSizesDefaultTypeInternal;
extern ImageFeatureType_EnumeratedImageSizesDefaultTypeInternal _ImageFeatureType_EnumeratedImageSizes_default_instance_;
class ImageFeatureType_ImageSize;
class ImageFeatureType_ImageSizeDefaultTypeInternal;
extern ImageFeatureType_ImageSizeDefaultTypeInternal _ImageFeatureType_ImageSize_default_instance_;
class ImageFeatureType_ImageSizeRange;
class ImageFeatureType_ImageSizeRangeDefaultTypeInternal;
extern ImageFeatureType_ImageSizeRangeDefaultTypeInternal _ImageFeatureType_ImageSizeRange_default_instance_;
class Imputer;
class ImputerDefaultTypeInternal;
extern ImputerDefaultTypeInternal _Imputer_default_instance_;
class InnerProductLayerParams;
class InnerProductLayerParamsDefaultTypeInternal;
extern InnerProductLayerParamsDefaultTypeInternal _InnerProductLayerParams_default_instance_;
class Int64FeatureType;
class Int64FeatureTypeDefaultTypeInternal;
extern Int64FeatureTypeDefaultTypeInternal _Int64FeatureType_default_instance_;
class Int64ToDoubleMap;
class Int64ToDoubleMapDefaultTypeInternal;
extern Int64ToDoubleMapDefaultTypeInternal _Int64ToDoubleMap_default_instance_;
class Int64ToDoubleMap_MapEntry;
class Int64ToDoubleMap_MapEntryDefaultTypeInternal;
extern Int64ToDoubleMap_MapEntryDefaultTypeInternal _Int64ToDoubleMap_MapEntry_default_instance_;
class Int64ToStringMap;
class Int64ToStringMapDefaultTypeInternal;
extern Int64ToStringMapDefaultTypeInternal _Int64ToStringMap_default_instance_;
class Int64ToStringMap_MapEntry;
class Int64ToStringMap_MapEntryDefaultTypeInternal;
extern Int64ToStringMap_MapEntryDefaultTypeInternal _Int64ToStringMap_MapEntry_default_instance_;
class Int64Vector;
class Int64VectorDefaultTypeInternal;
extern Int64VectorDefaultTypeInternal _Int64Vector_default_instance_;
class Kernel;
class KernelDefaultTypeInternal;
extern KernelDefaultTypeInternal _Kernel_default_instance_;
class L2NormalizeLayerParams;
class L2NormalizeLayerParamsDefaultTypeInternal;
extern L2NormalizeLayerParamsDefaultTypeInternal _L2NormalizeLayerParams_default_instance_;
class LRNLayerParams;
class LRNLayerParamsDefaultTypeInternal;
extern LRNLayerParamsDefaultTypeInternal _LRNLayerParams_default_instance_;
class LSTMParams;
class LSTMParamsDefaultTypeInternal;
extern LSTMParamsDefaultTypeInternal _LSTMParams_default_instance_;
class LSTMWeightParams;
class LSTMWeightParamsDefaultTypeInternal;
extern LSTMWeightParamsDefaultTypeInternal _LSTMWeightParams_default_instance_;
class LinearKernel;
class LinearKernelDefaultTypeInternal;
extern LinearKernelDefaultTypeInternal _LinearKernel_default_instance_;
class LinearQuantizationParams;
class LinearQuantizationParamsDefaultTypeInternal;
extern LinearQuantizationParamsDefaultTypeInternal _LinearQuantizationParams_default_instance_;
class LoadConstantLayerParams;
class LoadConstantLayerParamsDefaultTypeInternal;
extern LoadConstantLayerParamsDefaultTypeInternal _LoadConstantLayerParams_default_instance_;
class LookUpTableQuantizationParams;
class LookUpTableQuantizationParamsDefaultTypeInternal;
extern LookUpTableQuantizationParamsDefaultTypeInternal _LookUpTableQuantizationParams_default_instance_;
class MaxLayerParams;
class MaxLayerParamsDefaultTypeInternal;
extern MaxLayerParamsDefaultTypeInternal _MaxLayerParams_default_instance_;
class MeanVarianceNormalizeLayerParams;
class MeanVarianceNormalizeLayerParamsDefaultTypeInternal;
extern MeanVarianceNormalizeLayerParamsDefaultTypeInternal _MeanVarianceNormalizeLayerParams_default_instance_;
class Metadata;
class MetadataDefaultTypeInternal;
extern MetadataDefaultTypeInternal _Metadata_default_instance_;
class Metadata_UserDefinedEntry;
class Metadata_UserDefinedEntryDefaultTypeInternal;
extern Metadata_UserDefinedEntryDefaultTypeInternal _Metadata_UserDefinedEntry_default_instance_;
class MinLayerParams;
class MinLayerParamsDefaultTypeInternal;
extern MinLayerParamsDefaultTypeInternal _MinLayerParams_default_instance_;
class Model;
class ModelDefaultTypeInternal;
extern ModelDefaultTypeInternal _Model_default_instance_;
class ModelDescription;
class ModelDescriptionDefaultTypeInternal;
extern ModelDescriptionDefaultTypeInternal _ModelDescription_default_instance_;
class MultiplyLayerParams;
class MultiplyLayerParamsDefaultTypeInternal;
extern MultiplyLayerParamsDefaultTypeInternal _MultiplyLayerParams_default_instance_;
class NeuralNetwork;
class NeuralNetworkDefaultTypeInternal;
extern NeuralNetworkDefaultTypeInternal _NeuralNetwork_default_instance_;
class NeuralNetworkClassifier;
class NeuralNetworkClassifierDefaultTypeInternal;
extern NeuralNetworkClassifierDefaultTypeInternal _NeuralNetworkClassifier_default_instance_;
class NeuralNetworkImageScaler;
class NeuralNetworkImageScalerDefaultTypeInternal;
extern NeuralNetworkImageScalerDefaultTypeInternal _NeuralNetworkImageScaler_default_instance_;
class NeuralNetworkLayer;
class NeuralNetworkLayerDefaultTypeInternal;
extern NeuralNetworkLayerDefaultTypeInternal _NeuralNetworkLayer_default_instance_;
class NeuralNetworkMeanImage;
class NeuralNetworkMeanImageDefaultTypeInternal;
extern NeuralNetworkMeanImageDefaultTypeInternal _NeuralNetworkMeanImage_default_instance_;
class NeuralNetworkPreprocessing;
class NeuralNetworkPreprocessingDefaultTypeInternal;
extern NeuralNetworkPreprocessingDefaultTypeInternal _NeuralNetworkPreprocessing_default_instance_;
class NeuralNetworkRegressor;
class NeuralNetworkRegressorDefaultTypeInternal;
extern NeuralNetworkRegressorDefaultTypeInternal _NeuralNetworkRegressor_default_instance_;
class NonMaximumSuppression;
class NonMaximumSuppressionDefaultTypeInternal;
extern NonMaximumSuppressionDefaultTypeInternal _NonMaximumSuppression_default_instance_;
class NonMaximumSuppression_PickTop;
class NonMaximumSuppression_PickTopDefaultTypeInternal;
extern NonMaximumSuppression_PickTopDefaultTypeInternal _NonMaximumSuppression_PickTop_default_instance_;
class Normalizer;
class NormalizerDefaultTypeInternal;
extern NormalizerDefaultTypeInternal _Normalizer_default_instance_;
class OneHotEncoder;
class OneHotEncoderDefaultTypeInternal;
extern OneHotEncoderDefaultTypeInternal _OneHotEncoder_default_instance_;
class PaddingLayerParams;
class PaddingLayerParamsDefaultTypeInternal;
extern PaddingLayerParamsDefaultTypeInternal _PaddingLayerParams_default_instance_;
class PaddingLayerParams_PaddingConstant;
class PaddingLayerParams_PaddingConstantDefaultTypeInternal;
extern PaddingLayerParams_PaddingConstantDefaultTypeInternal _PaddingLayerParams_PaddingConstant_default_instance_;
class PaddingLayerParams_PaddingReflection;
class PaddingLayerParams_PaddingReflectionDefaultTypeInternal;
extern PaddingLayerParams_PaddingReflectionDefaultTypeInternal _PaddingLayerParams_PaddingReflection_default_instance_;
class PaddingLayerParams_PaddingReplication;
class PaddingLayerParams_PaddingReplicationDefaultTypeInternal;
extern PaddingLayerParams_PaddingReplicationDefaultTypeInternal _PaddingLayerParams_PaddingReplication_default_instance_;
class PermuteLayerParams;
class PermuteLayerParamsDefaultTypeInternal;
extern PermuteLayerParamsDefaultTypeInternal _PermuteLayerParams_default_instance_;
class Pipeline;
class PipelineDefaultTypeInternal;
extern PipelineDefaultTypeInternal _Pipeline_default_instance_;
class PipelineClassifier;
class PipelineClassifierDefaultTypeInternal;
extern PipelineClassifierDefaultTypeInternal _PipelineClassifier_default_instance_;
class PipelineRegressor;
class PipelineRegressorDefaultTypeInternal;
extern PipelineRegressorDefaultTypeInternal _PipelineRegressor_default_instance_;
class PolyKernel;
class PolyKernelDefaultTypeInternal;
extern PolyKernelDefaultTypeInternal _PolyKernel_default_instance_;
class PoolingLayerParams;
class PoolingLayerParamsDefaultTypeInternal;
extern PoolingLayerParamsDefaultTypeInternal _PoolingLayerParams_default_instance_;
class PoolingLayerParams_ValidCompletePadding;
class PoolingLayerParams_ValidCompletePaddingDefaultTypeInternal;
extern PoolingLayerParams_ValidCompletePaddingDefaultTypeInternal _PoolingLayerParams_ValidCompletePadding_default_instance_;
class QuantizationParams;
class QuantizationParamsDefaultTypeInternal;
extern QuantizationParamsDefaultTypeInternal _QuantizationParams_default_instance_;
class RBFKernel;
class RBFKernelDefaultTypeInternal;
extern RBFKernelDefaultTypeInternal _RBFKernel_default_instance_;
class ReduceLayerParams;
class ReduceLayerParamsDefaultTypeInternal;
extern ReduceLayerParamsDefaultTypeInternal _ReduceLayerParams_default_instance_;
class ReorganizeDataLayerParams;
class ReorganizeDataLayerParamsDefaultTypeInternal;
extern ReorganizeDataLayerParamsDefaultTypeInternal _ReorganizeDataLayerParams_default_instance_;
class ReshapeLayerParams;
class ReshapeLayerParamsDefaultTypeInternal;
extern ReshapeLayerParamsDefaultTypeInternal _ReshapeLayerParams_default_instance_;
class ResizeBilinearLayerParams;
class ResizeBilinearLayerParamsDefaultTypeInternal;
extern ResizeBilinearLayerParamsDefaultTypeInternal _ResizeBilinearLayerParams_default_instance_;
class SamePadding;
class SamePaddingDefaultTypeInternal;
extern SamePaddingDefaultTypeInternal _SamePadding_default_instance_;
class SamplingMode;
class SamplingModeDefaultTypeInternal;
extern SamplingModeDefaultTypeInternal _SamplingMode_default_instance_;
class ScaleLayerParams;
class ScaleLayerParamsDefaultTypeInternal;
extern ScaleLayerParamsDefaultTypeInternal _ScaleLayerParams_default_instance_;
class Scaler;
class ScalerDefaultTypeInternal;
extern ScalerDefaultTypeInternal _Scaler_default_instance_;
class SequenceFeatureType;
class SequenceFeatureTypeDefaultTypeInternal;
extern SequenceFeatureTypeDefaultTypeInternal _SequenceFeatureType_default_instance_;
class SequenceRepeatLayerParams;
class SequenceRepeatLayerParamsDefaultTypeInternal;
extern SequenceRepeatLayerParamsDefaultTypeInternal _SequenceRepeatLayerParams_default_instance_;
class SigmoidKernel;
class SigmoidKernelDefaultTypeInternal;
extern SigmoidKernelDefaultTypeInternal _SigmoidKernel_default_instance_;
class SimpleRecurrentLayerParams;
class SimpleRecurrentLayerParamsDefaultTypeInternal;
extern SimpleRecurrentLayerParamsDefaultTypeInternal _SimpleRecurrentLayerParams_default_instance_;
class SizeRange;
class SizeRangeDefaultTypeInternal;
extern SizeRangeDefaultTypeInternal _SizeRange_default_instance_;
class SliceLayerParams;
class SliceLayerParamsDefaultTypeInternal;
extern SliceLayerParamsDefaultTypeInternal _SliceLayerParams_default_instance_;
class SoftmaxLayerParams;
class SoftmaxLayerParamsDefaultTypeInternal;
extern SoftmaxLayerParamsDefaultTypeInternal _SoftmaxLayerParams_default_instance_;
class SparseNode;
class SparseNodeDefaultTypeInternal;
extern SparseNodeDefaultTypeInternal _SparseNode_default_instance_;
class SparseSupportVectors;
class SparseSupportVectorsDefaultTypeInternal;
extern SparseSupportVectorsDefaultTypeInternal _SparseSupportVectors_default_instance_;
class SparseVector;
class SparseVectorDefaultTypeInternal;
extern SparseVectorDefaultTypeInternal _SparseVector_default_instance_;
class SplitLayerParams;
class SplitLayerParamsDefaultTypeInternal;
extern SplitLayerParamsDefaultTypeInternal _SplitLayerParams_default_instance_;
class StringFeatureType;
class StringFeatureTypeDefaultTypeInternal;
extern StringFeatureTypeDefaultTypeInternal _StringFeatureType_default_instance_;
class StringToDoubleMap;
class StringToDoubleMapDefaultTypeInternal;
extern StringToDoubleMapDefaultTypeInternal _StringToDoubleMap_default_instance_;
class StringToDoubleMap_MapEntry;
class StringToDoubleMap_MapEntryDefaultTypeInternal;
extern StringToDoubleMap_MapEntryDefaultTypeInternal _StringToDoubleMap_MapEntry_default_instance_;
class StringToInt64Map;
class StringToInt64MapDefaultTypeInternal;
extern StringToInt64MapDefaultTypeInternal _StringToInt64Map_default_instance_;
class StringToInt64Map_MapEntry;
class StringToInt64Map_MapEntryDefaultTypeInternal;
extern StringToInt64Map_MapEntryDefaultTypeInternal _StringToInt64Map_MapEntry_default_instance_;
class StringVector;
class StringVectorDefaultTypeInternal;
extern StringVectorDefaultTypeInternal _StringVector_default_instance_;
class SupportVectorClassifier;
class SupportVectorClassifierDefaultTypeInternal;
extern SupportVectorClassifierDefaultTypeInternal _SupportVectorClassifier_default_instance_;
class SupportVectorRegressor;
class SupportVectorRegressorDefaultTypeInternal;
extern SupportVectorRegressorDefaultTypeInternal _SupportVectorRegressor_default_instance_;
class TreeEnsembleClassifier;
class TreeEnsembleClassifierDefaultTypeInternal;
extern TreeEnsembleClassifierDefaultTypeInternal _TreeEnsembleClassifier_default_instance_;
class TreeEnsembleParameters;
class TreeEnsembleParametersDefaultTypeInternal;
extern TreeEnsembleParametersDefaultTypeInternal _TreeEnsembleParameters_default_instance_;
class TreeEnsembleParameters_TreeNode;
class TreeEnsembleParameters_TreeNodeDefaultTypeInternal;
extern TreeEnsembleParameters_TreeNodeDefaultTypeInternal _TreeEnsembleParameters_TreeNode_default_instance_;
class TreeEnsembleParameters_TreeNode_EvaluationInfo;
class TreeEnsembleParameters_TreeNode_EvaluationInfoDefaultTypeInternal;
extern TreeEnsembleParameters_TreeNode_EvaluationInfoDefaultTypeInternal _TreeEnsembleParameters_TreeNode_EvaluationInfo_default_instance_;
class TreeEnsembleRegressor;
class TreeEnsembleRegressorDefaultTypeInternal;
extern TreeEnsembleRegressorDefaultTypeInternal _TreeEnsembleRegressor_default_instance_;
class UnaryFunctionLayerParams;
class UnaryFunctionLayerParamsDefaultTypeInternal;
extern UnaryFunctionLayerParamsDefaultTypeInternal _UnaryFunctionLayerParams_default_instance_;
class UniDirectionalLSTMLayerParams;
class UniDirectionalLSTMLayerParamsDefaultTypeInternal;
extern UniDirectionalLSTMLayerParamsDefaultTypeInternal _UniDirectionalLSTMLayerParams_default_instance_;
class UpsampleLayerParams;
class UpsampleLayerParamsDefaultTypeInternal;
extern UpsampleLayerParamsDefaultTypeInternal _UpsampleLayerParams_default_instance_;
class ValidPadding;
class ValidPaddingDefaultTypeInternal;
extern ValidPaddingDefaultTypeInternal _ValidPadding_default_instance_;
class WeightParams;
class WeightParamsDefaultTypeInternal;
extern WeightParamsDefaultTypeInternal _WeightParams_default_instance_;
namespace CoreMLModels {
class TextClassifier;
class TextClassifierDefaultTypeInternal;
extern TextClassifierDefaultTypeInternal _TextClassifier_default_instance_;
class VisionFeaturePrint;
class VisionFeaturePrintDefaultTypeInternal;
extern VisionFeaturePrintDefaultTypeInternal _VisionFeaturePrint_default_instance_;
class VisionFeaturePrint_Scene;
class VisionFeaturePrint_SceneDefaultTypeInternal;
extern VisionFeaturePrint_SceneDefaultTypeInternal _VisionFeaturePrint_Scene_default_instance_;
class WordTagger;
class WordTaggerDefaultTypeInternal;
extern WordTaggerDefaultTypeInternal _WordTagger_default_instance_;
}  // namespace CoreMLModels
}  // namespace Specification
}  // namespace CoreML

namespace CoreML {
namespace Specification {

namespace protobuf_Model_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static void InitDefaultsImpl();
  static void Shutdown();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_Model_2eproto

// ===================================================================

class Pipeline : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.Pipeline) */ {
 public:
  Pipeline();
  virtual ~Pipeline();

  Pipeline(const Pipeline& from);

  inline Pipeline& operator=(const Pipeline& from) {
    CopyFrom(from);
    return *this;
  }

  static const Pipeline& default_instance();

  static inline const Pipeline* internal_default_instance() {
    return reinterpret_cast<const Pipeline*>(
               &_Pipeline_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(Pipeline* other);

  // implements Message ----------------------------------------------

  inline Pipeline* New() const PROTOBUF_FINAL { return New(NULL); }

  Pipeline* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const Pipeline& from);
  void MergeFrom(const Pipeline& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Pipeline* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .CoreML.Specification.Model models = 1;
  int models_size() const;
  void clear_models();
  static const int kModelsFieldNumber = 1;
  const ::CoreML::Specification::Model& models(int index) const;
  ::CoreML::Specification::Model* mutable_models(int index);
  ::CoreML::Specification::Model* add_models();
  ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::Model >*
      mutable_models();
  const ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::Model >&
      models() const;

  // @@protoc_insertion_point(class_scope:CoreML.Specification.Pipeline)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::Model > models_;
  mutable int _cached_size_;
  friend struct protobuf_Model_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PipelineClassifier : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.PipelineClassifier) */ {
 public:
  PipelineClassifier();
  virtual ~PipelineClassifier();

  PipelineClassifier(const PipelineClassifier& from);

  inline PipelineClassifier& operator=(const PipelineClassifier& from) {
    CopyFrom(from);
    return *this;
  }

  static const PipelineClassifier& default_instance();

  static inline const PipelineClassifier* internal_default_instance() {
    return reinterpret_cast<const PipelineClassifier*>(
               &_PipelineClassifier_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(PipelineClassifier* other);

  // implements Message ----------------------------------------------

  inline PipelineClassifier* New() const PROTOBUF_FINAL { return New(NULL); }

  PipelineClassifier* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const PipelineClassifier& from);
  void MergeFrom(const PipelineClassifier& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PipelineClassifier* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .CoreML.Specification.Pipeline pipeline = 1;
  bool has_pipeline() const;
  void clear_pipeline();
  static const int kPipelineFieldNumber = 1;
  const ::CoreML::Specification::Pipeline& pipeline() const;
  ::CoreML::Specification::Pipeline* mutable_pipeline();
  ::CoreML::Specification::Pipeline* release_pipeline();
  void set_allocated_pipeline(::CoreML::Specification::Pipeline* pipeline);

  // @@protoc_insertion_point(class_scope:CoreML.Specification.PipelineClassifier)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::CoreML::Specification::Pipeline* pipeline_;
  mutable int _cached_size_;
  friend struct protobuf_Model_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PipelineRegressor : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.PipelineRegressor) */ {
 public:
  PipelineRegressor();
  virtual ~PipelineRegressor();

  PipelineRegressor(const PipelineRegressor& from);

  inline PipelineRegressor& operator=(const PipelineRegressor& from) {
    CopyFrom(from);
    return *this;
  }

  static const PipelineRegressor& default_instance();

  static inline const PipelineRegressor* internal_default_instance() {
    return reinterpret_cast<const PipelineRegressor*>(
               &_PipelineRegressor_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(PipelineRegressor* other);

  // implements Message ----------------------------------------------

  inline PipelineRegressor* New() const PROTOBUF_FINAL { return New(NULL); }

  PipelineRegressor* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const PipelineRegressor& from);
  void MergeFrom(const PipelineRegressor& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PipelineRegressor* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .CoreML.Specification.Pipeline pipeline = 1;
  bool has_pipeline() const;
  void clear_pipeline();
  static const int kPipelineFieldNumber = 1;
  const ::CoreML::Specification::Pipeline& pipeline() const;
  ::CoreML::Specification::Pipeline* mutable_pipeline();
  ::CoreML::Specification::Pipeline* release_pipeline();
  void set_allocated_pipeline(::CoreML::Specification::Pipeline* pipeline);

  // @@protoc_insertion_point(class_scope:CoreML.Specification.PipelineRegressor)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::CoreML::Specification::Pipeline* pipeline_;
  mutable int _cached_size_;
  friend struct protobuf_Model_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FeatureDescription : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.FeatureDescription) */ {
 public:
  FeatureDescription();
  virtual ~FeatureDescription();

  FeatureDescription(const FeatureDescription& from);

  inline FeatureDescription& operator=(const FeatureDescription& from) {
    CopyFrom(from);
    return *this;
  }

  static const FeatureDescription& default_instance();

  static inline const FeatureDescription* internal_default_instance() {
    return reinterpret_cast<const FeatureDescription*>(
               &_FeatureDescription_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(FeatureDescription* other);

  // implements Message ----------------------------------------------

  inline FeatureDescription* New() const PROTOBUF_FINAL { return New(NULL); }

  FeatureDescription* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const FeatureDescription& from);
  void MergeFrom(const FeatureDescription& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(FeatureDescription* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // string shortDescription = 2;
  void clear_shortdescription();
  static const int kShortDescriptionFieldNumber = 2;
  const ::std::string& shortdescription() const;
  void set_shortdescription(const ::std::string& value);
  #if LANG_CXX11
  void set_shortdescription(::std::string&& value);
  #endif
  void set_shortdescription(const char* value);
  void set_shortdescription(const char* value, size_t size);
  ::std::string* mutable_shortdescription();
  ::std::string* release_shortdescription();
  void set_allocated_shortdescription(::std::string* shortdescription);

  // .CoreML.Specification.FeatureType type = 3;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 3;
  const ::CoreML::Specification::FeatureType& type() const;
  ::CoreML::Specification::FeatureType* mutable_type();
  ::CoreML::Specification::FeatureType* release_type();
  void set_allocated_type(::CoreML::Specification::FeatureType* type);

  // @@protoc_insertion_point(class_scope:CoreML.Specification.FeatureDescription)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr shortdescription_;
  ::CoreML::Specification::FeatureType* type_;
  mutable int _cached_size_;
  friend struct protobuf_Model_2eproto::TableStruct;
};
// -------------------------------------------------------------------


// -------------------------------------------------------------------

class Metadata : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.Metadata) */ {
 public:
  Metadata();
  virtual ~Metadata();

  Metadata(const Metadata& from);

  inline Metadata& operator=(const Metadata& from) {
    CopyFrom(from);
    return *this;
  }

  static const Metadata& default_instance();

  static inline const Metadata* internal_default_instance() {
    return reinterpret_cast<const Metadata*>(
               &_Metadata_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(Metadata* other);

  // implements Message ----------------------------------------------

  inline Metadata* New() const PROTOBUF_FINAL { return New(NULL); }

  Metadata* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const Metadata& from);
  void MergeFrom(const Metadata& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Metadata* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<string, string> userDefined = 100;
  int userdefined_size() const;
  void clear_userdefined();
  static const int kUserDefinedFieldNumber = 100;
  const ::google::protobuf::Map< ::std::string, ::std::string >&
      userdefined() const;
  ::google::protobuf::Map< ::std::string, ::std::string >*
      mutable_userdefined();

  // string shortDescription = 1;
  void clear_shortdescription();
  static const int kShortDescriptionFieldNumber = 1;
  const ::std::string& shortdescription() const;
  void set_shortdescription(const ::std::string& value);
  #if LANG_CXX11
  void set_shortdescription(::std::string&& value);
  #endif
  void set_shortdescription(const char* value);
  void set_shortdescription(const char* value, size_t size);
  ::std::string* mutable_shortdescription();
  ::std::string* release_shortdescription();
  void set_allocated_shortdescription(::std::string* shortdescription);

  // string versionString = 2;
  void clear_versionstring();
  static const int kVersionStringFieldNumber = 2;
  const ::std::string& versionstring() const;
  void set_versionstring(const ::std::string& value);
  #if LANG_CXX11
  void set_versionstring(::std::string&& value);
  #endif
  void set_versionstring(const char* value);
  void set_versionstring(const char* value, size_t size);
  ::std::string* mutable_versionstring();
  ::std::string* release_versionstring();
  void set_allocated_versionstring(::std::string* versionstring);

  // string author = 3;
  void clear_author();
  static const int kAuthorFieldNumber = 3;
  const ::std::string& author() const;
  void set_author(const ::std::string& value);
  #if LANG_CXX11
  void set_author(::std::string&& value);
  #endif
  void set_author(const char* value);
  void set_author(const char* value, size_t size);
  ::std::string* mutable_author();
  ::std::string* release_author();
  void set_allocated_author(::std::string* author);

  // string license = 4;
  void clear_license();
  static const int kLicenseFieldNumber = 4;
  const ::std::string& license() const;
  void set_license(const ::std::string& value);
  #if LANG_CXX11
  void set_license(::std::string&& value);
  #endif
  void set_license(const char* value);
  void set_license(const char* value, size_t size);
  ::std::string* mutable_license();
  ::std::string* release_license();
  void set_allocated_license(::std::string* license);

  // @@protoc_insertion_point(class_scope:CoreML.Specification.Metadata)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  public:
  typedef ::google::protobuf::internal::MapEntryLite<
      ::std::string, ::std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      0 >
      Metadata_UserDefinedEntry;
  ::google::protobuf::internal::MapFieldLite<
      Metadata_UserDefinedEntry,
      ::std::string, ::std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      0 > userdefined_;
  private:
  ::google::protobuf::internal::ArenaStringPtr shortdescription_;
  ::google::protobuf::internal::ArenaStringPtr versionstring_;
  ::google::protobuf::internal::ArenaStringPtr author_;
  ::google::protobuf::internal::ArenaStringPtr license_;
  mutable int _cached_size_;
  friend struct protobuf_Model_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ModelDescription : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.ModelDescription) */ {
 public:
  ModelDescription();
  virtual ~ModelDescription();

  ModelDescription(const ModelDescription& from);

  inline ModelDescription& operator=(const ModelDescription& from) {
    CopyFrom(from);
    return *this;
  }

  static const ModelDescription& default_instance();

  static inline const ModelDescription* internal_default_instance() {
    return reinterpret_cast<const ModelDescription*>(
               &_ModelDescription_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(ModelDescription* other);

  // implements Message ----------------------------------------------

  inline ModelDescription* New() const PROTOBUF_FINAL { return New(NULL); }

  ModelDescription* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const ModelDescription& from);
  void MergeFrom(const ModelDescription& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ModelDescription* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .CoreML.Specification.FeatureDescription input = 1;
  int input_size() const;
  void clear_input();
  static const int kInputFieldNumber = 1;
  const ::CoreML::Specification::FeatureDescription& input(int index) const;
  ::CoreML::Specification::FeatureDescription* mutable_input(int index);
  ::CoreML::Specification::FeatureDescription* add_input();
  ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::FeatureDescription >*
      mutable_input();
  const ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::FeatureDescription >&
      input() const;

  // repeated .CoreML.Specification.FeatureDescription output = 10;
  int output_size() const;
  void clear_output();
  static const int kOutputFieldNumber = 10;
  const ::CoreML::Specification::FeatureDescription& output(int index) const;
  ::CoreML::Specification::FeatureDescription* mutable_output(int index);
  ::CoreML::Specification::FeatureDescription* add_output();
  ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::FeatureDescription >*
      mutable_output();
  const ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::FeatureDescription >&
      output() const;

  // string predictedFeatureName = 11;
  void clear_predictedfeaturename();
  static const int kPredictedFeatureNameFieldNumber = 11;
  const ::std::string& predictedfeaturename() const;
  void set_predictedfeaturename(const ::std::string& value);
  #if LANG_CXX11
  void set_predictedfeaturename(::std::string&& value);
  #endif
  void set_predictedfeaturename(const char* value);
  void set_predictedfeaturename(const char* value, size_t size);
  ::std::string* mutable_predictedfeaturename();
  ::std::string* release_predictedfeaturename();
  void set_allocated_predictedfeaturename(::std::string* predictedfeaturename);

  // string predictedProbabilitiesName = 12;
  void clear_predictedprobabilitiesname();
  static const int kPredictedProbabilitiesNameFieldNumber = 12;
  const ::std::string& predictedprobabilitiesname() const;
  void set_predictedprobabilitiesname(const ::std::string& value);
  #if LANG_CXX11
  void set_predictedprobabilitiesname(::std::string&& value);
  #endif
  void set_predictedprobabilitiesname(const char* value);
  void set_predictedprobabilitiesname(const char* value, size_t size);
  ::std::string* mutable_predictedprobabilitiesname();
  ::std::string* release_predictedprobabilitiesname();
  void set_allocated_predictedprobabilitiesname(::std::string* predictedprobabilitiesname);

  // .CoreML.Specification.Metadata metadata = 100;
  bool has_metadata() const;
  void clear_metadata();
  static const int kMetadataFieldNumber = 100;
  const ::CoreML::Specification::Metadata& metadata() const;
  ::CoreML::Specification::Metadata* mutable_metadata();
  ::CoreML::Specification::Metadata* release_metadata();
  void set_allocated_metadata(::CoreML::Specification::Metadata* metadata);

  // @@protoc_insertion_point(class_scope:CoreML.Specification.ModelDescription)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::FeatureDescription > input_;
  ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::FeatureDescription > output_;
  ::google::protobuf::internal::ArenaStringPtr predictedfeaturename_;
  ::google::protobuf::internal::ArenaStringPtr predictedprobabilitiesname_;
  ::CoreML::Specification::Metadata* metadata_;
  mutable int _cached_size_;
  friend struct protobuf_Model_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Model : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.Model) */ {
 public:
  Model();
  virtual ~Model();

  Model(const Model& from);

  inline Model& operator=(const Model& from) {
    CopyFrom(from);
    return *this;
  }

  static const Model& default_instance();

  enum TypeCase {
    kPipelineClassifier = 200,
    kPipelineRegressor = 201,
    kPipeline = 202,
    kGlmRegressor = 300,
    kSupportVectorRegressor = 301,
    kTreeEnsembleRegressor = 302,
    kNeuralNetworkRegressor = 303,
    kBayesianProbitRegressor = 304,
    kGlmClassifier = 400,
    kSupportVectorClassifier = 401,
    kTreeEnsembleClassifier = 402,
    kNeuralNetworkClassifier = 403,
    kNeuralNetwork = 500,
    kCustomModel = 555,
    kOneHotEncoder = 600,
    kImputer = 601,
    kFeatureVectorizer = 602,
    kDictVectorizer = 603,
    kScaler = 604,
    kCategoricalMapping = 606,
    kNormalizer = 607,
    kArrayFeatureExtractor = 609,
    kNonMaximumSuppression = 610,
    kIdentity = 900,
    kTextClassifier = 2000,
    kWordTagger = 2001,
    kVisionFeaturePrint = 2002,
    TYPE_NOT_SET = 0,
  };

  static inline const Model* internal_default_instance() {
    return reinterpret_cast<const Model*>(
               &_Model_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(Model* other);

  // implements Message ----------------------------------------------

  inline Model* New() const PROTOBUF_FINAL { return New(NULL); }

  Model* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const Model& from);
  void MergeFrom(const Model& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Model* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .CoreML.Specification.ModelDescription description = 2;
  bool has_description() const;
  void clear_description();
  static const int kDescriptionFieldNumber = 2;
  const ::CoreML::Specification::ModelDescription& description() const;
  ::CoreML::Specification::ModelDescription* mutable_description();
  ::CoreML::Specification::ModelDescription* release_description();
  void set_allocated_description(::CoreML::Specification::ModelDescription* description);

  // int32 specificationVersion = 1;
  void clear_specificationversion();
  static const int kSpecificationVersionFieldNumber = 1;
  ::google::protobuf::int32 specificationversion() const;
  void set_specificationversion(::google::protobuf::int32 value);

  // .CoreML.Specification.PipelineClassifier pipelineClassifier = 200;
  bool has_pipelineclassifier() const;
  void clear_pipelineclassifier();
  static const int kPipelineClassifierFieldNumber = 200;
  const ::CoreML::Specification::PipelineClassifier& pipelineclassifier() const;
  ::CoreML::Specification::PipelineClassifier* mutable_pipelineclassifier();
  ::CoreML::Specification::PipelineClassifier* release_pipelineclassifier();
  void set_allocated_pipelineclassifier(::CoreML::Specification::PipelineClassifier* pipelineclassifier);

  // .CoreML.Specification.PipelineRegressor pipelineRegressor = 201;
  bool has_pipelineregressor() const;
  void clear_pipelineregressor();
  static const int kPipelineRegressorFieldNumber = 201;
  const ::CoreML::Specification::PipelineRegressor& pipelineregressor() const;
  ::CoreML::Specification::PipelineRegressor* mutable_pipelineregressor();
  ::CoreML::Specification::PipelineRegressor* release_pipelineregressor();
  void set_allocated_pipelineregressor(::CoreML::Specification::PipelineRegressor* pipelineregressor);

  // .CoreML.Specification.Pipeline pipeline = 202;
  bool has_pipeline() const;
  void clear_pipeline();
  static const int kPipelineFieldNumber = 202;
  const ::CoreML::Specification::Pipeline& pipeline() const;
  ::CoreML::Specification::Pipeline* mutable_pipeline();
  ::CoreML::Specification::Pipeline* release_pipeline();
  void set_allocated_pipeline(::CoreML::Specification::Pipeline* pipeline);

  // .CoreML.Specification.GLMRegressor glmRegressor = 300;
  bool has_glmregressor() const;
  void clear_glmregressor();
  static const int kGlmRegressorFieldNumber = 300;
  const ::CoreML::Specification::GLMRegressor& glmregressor() const;
  ::CoreML::Specification::GLMRegressor* mutable_glmregressor();
  ::CoreML::Specification::GLMRegressor* release_glmregressor();
  void set_allocated_glmregressor(::CoreML::Specification::GLMRegressor* glmregressor);

  // .CoreML.Specification.SupportVectorRegressor supportVectorRegressor = 301;
  bool has_supportvectorregressor() const;
  void clear_supportvectorregressor();
  static const int kSupportVectorRegressorFieldNumber = 301;
  const ::CoreML::Specification::SupportVectorRegressor& supportvectorregressor() const;
  ::CoreML::Specification::SupportVectorRegressor* mutable_supportvectorregressor();
  ::CoreML::Specification::SupportVectorRegressor* release_supportvectorregressor();
  void set_allocated_supportvectorregressor(::CoreML::Specification::SupportVectorRegressor* supportvectorregressor);

  // .CoreML.Specification.TreeEnsembleRegressor treeEnsembleRegressor = 302;
  bool has_treeensembleregressor() const;
  void clear_treeensembleregressor();
  static const int kTreeEnsembleRegressorFieldNumber = 302;
  const ::CoreML::Specification::TreeEnsembleRegressor& treeensembleregressor() const;
  ::CoreML::Specification::TreeEnsembleRegressor* mutable_treeensembleregressor();
  ::CoreML::Specification::TreeEnsembleRegressor* release_treeensembleregressor();
  void set_allocated_treeensembleregressor(::CoreML::Specification::TreeEnsembleRegressor* treeensembleregressor);

  // .CoreML.Specification.NeuralNetworkRegressor neuralNetworkRegressor = 303;
  bool has_neuralnetworkregressor() const;
  void clear_neuralnetworkregressor();
  static const int kNeuralNetworkRegressorFieldNumber = 303;
  const ::CoreML::Specification::NeuralNetworkRegressor& neuralnetworkregressor() const;
  ::CoreML::Specification::NeuralNetworkRegressor* mutable_neuralnetworkregressor();
  ::CoreML::Specification::NeuralNetworkRegressor* release_neuralnetworkregressor();
  void set_allocated_neuralnetworkregressor(::CoreML::Specification::NeuralNetworkRegressor* neuralnetworkregressor);

  // .CoreML.Specification.BayesianProbitRegressor bayesianProbitRegressor = 304;
  bool has_bayesianprobitregressor() const;
  void clear_bayesianprobitregressor();
  static const int kBayesianProbitRegressorFieldNumber = 304;
  const ::CoreML::Specification::BayesianProbitRegressor& bayesianprobitregressor() const;
  ::CoreML::Specification::BayesianProbitRegressor* mutable_bayesianprobitregressor();
  ::CoreML::Specification::BayesianProbitRegressor* release_bayesianprobitregressor();
  void set_allocated_bayesianprobitregressor(::CoreML::Specification::BayesianProbitRegressor* bayesianprobitregressor);

  // .CoreML.Specification.GLMClassifier glmClassifier = 400;
  bool has_glmclassifier() const;
  void clear_glmclassifier();
  static const int kGlmClassifierFieldNumber = 400;
  const ::CoreML::Specification::GLMClassifier& glmclassifier() const;
  ::CoreML::Specification::GLMClassifier* mutable_glmclassifier();
  ::CoreML::Specification::GLMClassifier* release_glmclassifier();
  void set_allocated_glmclassifier(::CoreML::Specification::GLMClassifier* glmclassifier);

  // .CoreML.Specification.SupportVectorClassifier supportVectorClassifier = 401;
  bool has_supportvectorclassifier() const;
  void clear_supportvectorclassifier();
  static const int kSupportVectorClassifierFieldNumber = 401;
  const ::CoreML::Specification::SupportVectorClassifier& supportvectorclassifier() const;
  ::CoreML::Specification::SupportVectorClassifier* mutable_supportvectorclassifier();
  ::CoreML::Specification::SupportVectorClassifier* release_supportvectorclassifier();
  void set_allocated_supportvectorclassifier(::CoreML::Specification::SupportVectorClassifier* supportvectorclassifier);

  // .CoreML.Specification.TreeEnsembleClassifier treeEnsembleClassifier = 402;
  bool has_treeensembleclassifier() const;
  void clear_treeensembleclassifier();
  static const int kTreeEnsembleClassifierFieldNumber = 402;
  const ::CoreML::Specification::TreeEnsembleClassifier& treeensembleclassifier() const;
  ::CoreML::Specification::TreeEnsembleClassifier* mutable_treeensembleclassifier();
  ::CoreML::Specification::TreeEnsembleClassifier* release_treeensembleclassifier();
  void set_allocated_treeensembleclassifier(::CoreML::Specification::TreeEnsembleClassifier* treeensembleclassifier);

  // .CoreML.Specification.NeuralNetworkClassifier neuralNetworkClassifier = 403;
  bool has_neuralnetworkclassifier() const;
  void clear_neuralnetworkclassifier();
  static const int kNeuralNetworkClassifierFieldNumber = 403;
  const ::CoreML::Specification::NeuralNetworkClassifier& neuralnetworkclassifier() const;
  ::CoreML::Specification::NeuralNetworkClassifier* mutable_neuralnetworkclassifier();
  ::CoreML::Specification::NeuralNetworkClassifier* release_neuralnetworkclassifier();
  void set_allocated_neuralnetworkclassifier(::CoreML::Specification::NeuralNetworkClassifier* neuralnetworkclassifier);

  // .CoreML.Specification.NeuralNetwork neuralNetwork = 500;
  bool has_neuralnetwork() const;
  void clear_neuralnetwork();
  static const int kNeuralNetworkFieldNumber = 500;
  const ::CoreML::Specification::NeuralNetwork& neuralnetwork() const;
  ::CoreML::Specification::NeuralNetwork* mutable_neuralnetwork();
  ::CoreML::Specification::NeuralNetwork* release_neuralnetwork();
  void set_allocated_neuralnetwork(::CoreML::Specification::NeuralNetwork* neuralnetwork);

  // .CoreML.Specification.CustomModel customModel = 555;
  bool has_custommodel() const;
  void clear_custommodel();
  static const int kCustomModelFieldNumber = 555;
  const ::CoreML::Specification::CustomModel& custommodel() const;
  ::CoreML::Specification::CustomModel* mutable_custommodel();
  ::CoreML::Specification::CustomModel* release_custommodel();
  void set_allocated_custommodel(::CoreML::Specification::CustomModel* custommodel);

  // .CoreML.Specification.OneHotEncoder oneHotEncoder = 600;
  bool has_onehotencoder() const;
  void clear_onehotencoder();
  static const int kOneHotEncoderFieldNumber = 600;
  const ::CoreML::Specification::OneHotEncoder& onehotencoder() const;
  ::CoreML::Specification::OneHotEncoder* mutable_onehotencoder();
  ::CoreML::Specification::OneHotEncoder* release_onehotencoder();
  void set_allocated_onehotencoder(::CoreML::Specification::OneHotEncoder* onehotencoder);

  // .CoreML.Specification.Imputer imputer = 601;
  bool has_imputer() const;
  void clear_imputer();
  static const int kImputerFieldNumber = 601;
  const ::CoreML::Specification::Imputer& imputer() const;
  ::CoreML::Specification::Imputer* mutable_imputer();
  ::CoreML::Specification::Imputer* release_imputer();
  void set_allocated_imputer(::CoreML::Specification::Imputer* imputer);

  // .CoreML.Specification.FeatureVectorizer featureVectorizer = 602;
  bool has_featurevectorizer() const;
  void clear_featurevectorizer();
  static const int kFeatureVectorizerFieldNumber = 602;
  const ::CoreML::Specification::FeatureVectorizer& featurevectorizer() const;
  ::CoreML::Specification::FeatureVectorizer* mutable_featurevectorizer();
  ::CoreML::Specification::FeatureVectorizer* release_featurevectorizer();
  void set_allocated_featurevectorizer(::CoreML::Specification::FeatureVectorizer* featurevectorizer);

  // .CoreML.Specification.DictVectorizer dictVectorizer = 603;
  bool has_dictvectorizer() const;
  void clear_dictvectorizer();
  static const int kDictVectorizerFieldNumber = 603;
  const ::CoreML::Specification::DictVectorizer& dictvectorizer() const;
  ::CoreML::Specification::DictVectorizer* mutable_dictvectorizer();
  ::CoreML::Specification::DictVectorizer* release_dictvectorizer();
  void set_allocated_dictvectorizer(::CoreML::Specification::DictVectorizer* dictvectorizer);

  // .CoreML.Specification.Scaler scaler = 604;
  bool has_scaler() const;
  void clear_scaler();
  static const int kScalerFieldNumber = 604;
  const ::CoreML::Specification::Scaler& scaler() const;
  ::CoreML::Specification::Scaler* mutable_scaler();
  ::CoreML::Specification::Scaler* release_scaler();
  void set_allocated_scaler(::CoreML::Specification::Scaler* scaler);

  // .CoreML.Specification.CategoricalMapping categoricalMapping = 606;
  bool has_categoricalmapping() const;
  void clear_categoricalmapping();
  static const int kCategoricalMappingFieldNumber = 606;
  const ::CoreML::Specification::CategoricalMapping& categoricalmapping() const;
  ::CoreML::Specification::CategoricalMapping* mutable_categoricalmapping();
  ::CoreML::Specification::CategoricalMapping* release_categoricalmapping();
  void set_allocated_categoricalmapping(::CoreML::Specification::CategoricalMapping* categoricalmapping);

  // .CoreML.Specification.Normalizer normalizer = 607;
  bool has_normalizer() const;
  void clear_normalizer();
  static const int kNormalizerFieldNumber = 607;
  const ::CoreML::Specification::Normalizer& normalizer() const;
  ::CoreML::Specification::Normalizer* mutable_normalizer();
  ::CoreML::Specification::Normalizer* release_normalizer();
  void set_allocated_normalizer(::CoreML::Specification::Normalizer* normalizer);

  // .CoreML.Specification.ArrayFeatureExtractor arrayFeatureExtractor = 609;
  bool has_arrayfeatureextractor() const;
  void clear_arrayfeatureextractor();
  static const int kArrayFeatureExtractorFieldNumber = 609;
  const ::CoreML::Specification::ArrayFeatureExtractor& arrayfeatureextractor() const;
  ::CoreML::Specification::ArrayFeatureExtractor* mutable_arrayfeatureextractor();
  ::CoreML::Specification::ArrayFeatureExtractor* release_arrayfeatureextractor();
  void set_allocated_arrayfeatureextractor(::CoreML::Specification::ArrayFeatureExtractor* arrayfeatureextractor);

  // .CoreML.Specification.NonMaximumSuppression nonMaximumSuppression = 610;
  bool has_nonmaximumsuppression() const;
  void clear_nonmaximumsuppression();
  static const int kNonMaximumSuppressionFieldNumber = 610;
  const ::CoreML::Specification::NonMaximumSuppression& nonmaximumsuppression() const;
  ::CoreML::Specification::NonMaximumSuppression* mutable_nonmaximumsuppression();
  ::CoreML::Specification::NonMaximumSuppression* release_nonmaximumsuppression();
  void set_allocated_nonmaximumsuppression(::CoreML::Specification::NonMaximumSuppression* nonmaximumsuppression);

  // .CoreML.Specification.Identity identity = 900;
  bool has_identity() const;
  void clear_identity();
  static const int kIdentityFieldNumber = 900;
  const ::CoreML::Specification::Identity& identity() const;
  ::CoreML::Specification::Identity* mutable_identity();
  ::CoreML::Specification::Identity* release_identity();
  void set_allocated_identity(::CoreML::Specification::Identity* identity);

  // .CoreML.Specification.CoreMLModels.TextClassifier textClassifier = 2000;
  bool has_textclassifier() const;
  void clear_textclassifier();
  static const int kTextClassifierFieldNumber = 2000;
  const ::CoreML::Specification::CoreMLModels::TextClassifier& textclassifier() const;
  ::CoreML::Specification::CoreMLModels::TextClassifier* mutable_textclassifier();
  ::CoreML::Specification::CoreMLModels::TextClassifier* release_textclassifier();
  void set_allocated_textclassifier(::CoreML::Specification::CoreMLModels::TextClassifier* textclassifier);

  // .CoreML.Specification.CoreMLModels.WordTagger wordTagger = 2001;
  bool has_wordtagger() const;
  void clear_wordtagger();
  static const int kWordTaggerFieldNumber = 2001;
  const ::CoreML::Specification::CoreMLModels::WordTagger& wordtagger() const;
  ::CoreML::Specification::CoreMLModels::WordTagger* mutable_wordtagger();
  ::CoreML::Specification::CoreMLModels::WordTagger* release_wordtagger();
  void set_allocated_wordtagger(::CoreML::Specification::CoreMLModels::WordTagger* wordtagger);

  // .CoreML.Specification.CoreMLModels.VisionFeaturePrint visionFeaturePrint = 2002;
  bool has_visionfeatureprint() const;
  void clear_visionfeatureprint();
  static const int kVisionFeaturePrintFieldNumber = 2002;
  const ::CoreML::Specification::CoreMLModels::VisionFeaturePrint& visionfeatureprint() const;
  ::CoreML::Specification::CoreMLModels::VisionFeaturePrint* mutable_visionfeatureprint();
  ::CoreML::Specification::CoreMLModels::VisionFeaturePrint* release_visionfeatureprint();
  void set_allocated_visionfeatureprint(::CoreML::Specification::CoreMLModels::VisionFeaturePrint* visionfeatureprint);

  TypeCase Type_case() const;
  // @@protoc_insertion_point(class_scope:CoreML.Specification.Model)
 private:
  void set_has_pipelineclassifier();
  void set_has_pipelineregressor();
  void set_has_pipeline();
  void set_has_glmregressor();
  void set_has_supportvectorregressor();
  void set_has_treeensembleregressor();
  void set_has_neuralnetworkregressor();
  void set_has_bayesianprobitregressor();
  void set_has_glmclassifier();
  void set_has_supportvectorclassifier();
  void set_has_treeensembleclassifier();
  void set_has_neuralnetworkclassifier();
  void set_has_neuralnetwork();
  void set_has_custommodel();
  void set_has_onehotencoder();
  void set_has_imputer();
  void set_has_featurevectorizer();
  void set_has_dictvectorizer();
  void set_has_scaler();
  void set_has_categoricalmapping();
  void set_has_normalizer();
  void set_has_arrayfeatureextractor();
  void set_has_nonmaximumsuppression();
  void set_has_identity();
  void set_has_textclassifier();
  void set_has_wordtagger();
  void set_has_visionfeatureprint();

  inline bool has_Type() const;
  void clear_Type();
  inline void clear_has_Type();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::CoreML::Specification::ModelDescription* description_;
  ::google::protobuf::int32 specificationversion_;
  union TypeUnion {
    TypeUnion() {}
    ::CoreML::Specification::PipelineClassifier* pipelineclassifier_;
    ::CoreML::Specification::PipelineRegressor* pipelineregressor_;
    ::CoreML::Specification::Pipeline* pipeline_;
    ::CoreML::Specification::GLMRegressor* glmregressor_;
    ::CoreML::Specification::SupportVectorRegressor* supportvectorregressor_;
    ::CoreML::Specification::TreeEnsembleRegressor* treeensembleregressor_;
    ::CoreML::Specification::NeuralNetworkRegressor* neuralnetworkregressor_;
    ::CoreML::Specification::BayesianProbitRegressor* bayesianprobitregressor_;
    ::CoreML::Specification::GLMClassifier* glmclassifier_;
    ::CoreML::Specification::SupportVectorClassifier* supportvectorclassifier_;
    ::CoreML::Specification::TreeEnsembleClassifier* treeensembleclassifier_;
    ::CoreML::Specification::NeuralNetworkClassifier* neuralnetworkclassifier_;
    ::CoreML::Specification::NeuralNetwork* neuralnetwork_;
    ::CoreML::Specification::CustomModel* custommodel_;
    ::CoreML::Specification::OneHotEncoder* onehotencoder_;
    ::CoreML::Specification::Imputer* imputer_;
    ::CoreML::Specification::FeatureVectorizer* featurevectorizer_;
    ::CoreML::Specification::DictVectorizer* dictvectorizer_;
    ::CoreML::Specification::Scaler* scaler_;
    ::CoreML::Specification::CategoricalMapping* categoricalmapping_;
    ::CoreML::Specification::Normalizer* normalizer_;
    ::CoreML::Specification::ArrayFeatureExtractor* arrayfeatureextractor_;
    ::CoreML::Specification::NonMaximumSuppression* nonmaximumsuppression_;
    ::CoreML::Specification::Identity* identity_;
    ::CoreML::Specification::CoreMLModels::TextClassifier* textclassifier_;
    ::CoreML::Specification::CoreMLModels::WordTagger* wordtagger_;
    ::CoreML::Specification::CoreMLModels::VisionFeaturePrint* visionfeatureprint_;
  } Type_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct protobuf_Model_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// Pipeline

// repeated .CoreML.Specification.Model models = 1;
inline int Pipeline::models_size() const {
  return models_.size();
}
inline void Pipeline::clear_models() {
  models_.Clear();
}
inline const ::CoreML::Specification::Model& Pipeline::models(int index) const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.Pipeline.models)
  return models_.Get(index);
}
inline ::CoreML::Specification::Model* Pipeline::mutable_models(int index) {
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.Pipeline.models)
  return models_.Mutable(index);
}
inline ::CoreML::Specification::Model* Pipeline::add_models() {
  // @@protoc_insertion_point(field_add:CoreML.Specification.Pipeline.models)
  return models_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::Model >*
Pipeline::mutable_models() {
  // @@protoc_insertion_point(field_mutable_list:CoreML.Specification.Pipeline.models)
  return &models_;
}
inline const ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::Model >&
Pipeline::models() const {
  // @@protoc_insertion_point(field_list:CoreML.Specification.Pipeline.models)
  return models_;
}

// -------------------------------------------------------------------

// PipelineClassifier

// .CoreML.Specification.Pipeline pipeline = 1;
inline bool PipelineClassifier::has_pipeline() const {
  return this != internal_default_instance() && pipeline_ != NULL;
}
inline void PipelineClassifier::clear_pipeline() {
  if (GetArenaNoVirtual() == NULL && pipeline_ != NULL) delete pipeline_;
  pipeline_ = NULL;
}
inline const ::CoreML::Specification::Pipeline& PipelineClassifier::pipeline() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.PipelineClassifier.pipeline)
  return pipeline_ != NULL ? *pipeline_
                         : *::CoreML::Specification::Pipeline::internal_default_instance();
}
inline ::CoreML::Specification::Pipeline* PipelineClassifier::mutable_pipeline() {

  if (pipeline_ == NULL) {
    pipeline_ = new ::CoreML::Specification::Pipeline;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.PipelineClassifier.pipeline)
  return pipeline_;
}
inline ::CoreML::Specification::Pipeline* PipelineClassifier::release_pipeline() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.PipelineClassifier.pipeline)

  ::CoreML::Specification::Pipeline* temp = pipeline_;
  pipeline_ = NULL;
  return temp;
}
inline void PipelineClassifier::set_allocated_pipeline(::CoreML::Specification::Pipeline* pipeline) {
  delete pipeline_;
  pipeline_ = pipeline;
  if (pipeline) {

  } else {

  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.PipelineClassifier.pipeline)
}

// -------------------------------------------------------------------

// PipelineRegressor

// .CoreML.Specification.Pipeline pipeline = 1;
inline bool PipelineRegressor::has_pipeline() const {
  return this != internal_default_instance() && pipeline_ != NULL;
}
inline void PipelineRegressor::clear_pipeline() {
  if (GetArenaNoVirtual() == NULL && pipeline_ != NULL) delete pipeline_;
  pipeline_ = NULL;
}
inline const ::CoreML::Specification::Pipeline& PipelineRegressor::pipeline() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.PipelineRegressor.pipeline)
  return pipeline_ != NULL ? *pipeline_
                         : *::CoreML::Specification::Pipeline::internal_default_instance();
}
inline ::CoreML::Specification::Pipeline* PipelineRegressor::mutable_pipeline() {

  if (pipeline_ == NULL) {
    pipeline_ = new ::CoreML::Specification::Pipeline;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.PipelineRegressor.pipeline)
  return pipeline_;
}
inline ::CoreML::Specification::Pipeline* PipelineRegressor::release_pipeline() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.PipelineRegressor.pipeline)

  ::CoreML::Specification::Pipeline* temp = pipeline_;
  pipeline_ = NULL;
  return temp;
}
inline void PipelineRegressor::set_allocated_pipeline(::CoreML::Specification::Pipeline* pipeline) {
  delete pipeline_;
  pipeline_ = pipeline;
  if (pipeline) {

  } else {

  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.PipelineRegressor.pipeline)
}

// -------------------------------------------------------------------

// FeatureDescription

// string name = 1;
inline void FeatureDescription::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& FeatureDescription::name() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.FeatureDescription.name)
  return name_.GetNoArena();
}
inline void FeatureDescription::set_name(const ::std::string& value) {

  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:CoreML.Specification.FeatureDescription.name)
}
#if LANG_CXX11
inline void FeatureDescription::set_name(::std::string&& value) {

  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:CoreML.Specification.FeatureDescription.name)
}
#endif
inline void FeatureDescription::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);

  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:CoreML.Specification.FeatureDescription.name)
}
inline void FeatureDescription::set_name(const char* value, size_t size) {

  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:CoreML.Specification.FeatureDescription.name)
}
inline ::std::string* FeatureDescription::mutable_name() {

  // @@protoc_insertion_point(field_mutable:CoreML.Specification.FeatureDescription.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FeatureDescription::release_name() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.FeatureDescription.name)

  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FeatureDescription::set_allocated_name(::std::string* name) {
  if (name != NULL) {

  } else {

  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.FeatureDescription.name)
}

// string shortDescription = 2;
inline void FeatureDescription::clear_shortdescription() {
  shortdescription_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& FeatureDescription::shortdescription() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.FeatureDescription.shortDescription)
  return shortdescription_.GetNoArena();
}
inline void FeatureDescription::set_shortdescription(const ::std::string& value) {

  shortdescription_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:CoreML.Specification.FeatureDescription.shortDescription)
}
#if LANG_CXX11
inline void FeatureDescription::set_shortdescription(::std::string&& value) {

  shortdescription_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:CoreML.Specification.FeatureDescription.shortDescription)
}
#endif
inline void FeatureDescription::set_shortdescription(const char* value) {
  GOOGLE_DCHECK(value != NULL);

  shortdescription_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:CoreML.Specification.FeatureDescription.shortDescription)
}
inline void FeatureDescription::set_shortdescription(const char* value, size_t size) {

  shortdescription_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:CoreML.Specification.FeatureDescription.shortDescription)
}
inline ::std::string* FeatureDescription::mutable_shortdescription() {

  // @@protoc_insertion_point(field_mutable:CoreML.Specification.FeatureDescription.shortDescription)
  return shortdescription_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FeatureDescription::release_shortdescription() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.FeatureDescription.shortDescription)

  return shortdescription_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FeatureDescription::set_allocated_shortdescription(::std::string* shortdescription) {
  if (shortdescription != NULL) {

  } else {

  }
  shortdescription_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), shortdescription);
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.FeatureDescription.shortDescription)
}

// .CoreML.Specification.FeatureType type = 3;
inline bool FeatureDescription::has_type() const {
  return this != internal_default_instance() && type_ != NULL;
}
inline void FeatureDescription::clear_type() {
  if (GetArenaNoVirtual() == NULL && type_ != NULL) delete type_;
  type_ = NULL;
}
inline const ::CoreML::Specification::FeatureType& FeatureDescription::type() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.FeatureDescription.type)
  return type_ != NULL ? *type_
                         : *::CoreML::Specification::FeatureType::internal_default_instance();
}
inline ::CoreML::Specification::FeatureType* FeatureDescription::mutable_type() {

  if (type_ == NULL) {
    type_ = new ::CoreML::Specification::FeatureType;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.FeatureDescription.type)
  return type_;
}
inline ::CoreML::Specification::FeatureType* FeatureDescription::release_type() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.FeatureDescription.type)

  ::CoreML::Specification::FeatureType* temp = type_;
  type_ = NULL;
  return temp;
}
inline void FeatureDescription::set_allocated_type(::CoreML::Specification::FeatureType* type) {
  delete type_;
  type_ = type;
  if (type) {

  } else {

  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.FeatureDescription.type)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Metadata

// string shortDescription = 1;
inline void Metadata::clear_shortdescription() {
  shortdescription_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Metadata::shortdescription() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.Metadata.shortDescription)
  return shortdescription_.GetNoArena();
}
inline void Metadata::set_shortdescription(const ::std::string& value) {

  shortdescription_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:CoreML.Specification.Metadata.shortDescription)
}
#if LANG_CXX11
inline void Metadata::set_shortdescription(::std::string&& value) {

  shortdescription_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:CoreML.Specification.Metadata.shortDescription)
}
#endif
inline void Metadata::set_shortdescription(const char* value) {
  GOOGLE_DCHECK(value != NULL);

  shortdescription_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:CoreML.Specification.Metadata.shortDescription)
}
inline void Metadata::set_shortdescription(const char* value, size_t size) {

  shortdescription_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:CoreML.Specification.Metadata.shortDescription)
}
inline ::std::string* Metadata::mutable_shortdescription() {

  // @@protoc_insertion_point(field_mutable:CoreML.Specification.Metadata.shortDescription)
  return shortdescription_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Metadata::release_shortdescription() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.Metadata.shortDescription)

  return shortdescription_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Metadata::set_allocated_shortdescription(::std::string* shortdescription) {
  if (shortdescription != NULL) {

  } else {

  }
  shortdescription_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), shortdescription);
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.Metadata.shortDescription)
}

// string versionString = 2;
inline void Metadata::clear_versionstring() {
  versionstring_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Metadata::versionstring() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.Metadata.versionString)
  return versionstring_.GetNoArena();
}
inline void Metadata::set_versionstring(const ::std::string& value) {

  versionstring_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:CoreML.Specification.Metadata.versionString)
}
#if LANG_CXX11
inline void Metadata::set_versionstring(::std::string&& value) {

  versionstring_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:CoreML.Specification.Metadata.versionString)
}
#endif
inline void Metadata::set_versionstring(const char* value) {
  GOOGLE_DCHECK(value != NULL);

  versionstring_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:CoreML.Specification.Metadata.versionString)
}
inline void Metadata::set_versionstring(const char* value, size_t size) {

  versionstring_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:CoreML.Specification.Metadata.versionString)
}
inline ::std::string* Metadata::mutable_versionstring() {

  // @@protoc_insertion_point(field_mutable:CoreML.Specification.Metadata.versionString)
  return versionstring_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Metadata::release_versionstring() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.Metadata.versionString)

  return versionstring_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Metadata::set_allocated_versionstring(::std::string* versionstring) {
  if (versionstring != NULL) {

  } else {

  }
  versionstring_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), versionstring);
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.Metadata.versionString)
}

// string author = 3;
inline void Metadata::clear_author() {
  author_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Metadata::author() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.Metadata.author)
  return author_.GetNoArena();
}
inline void Metadata::set_author(const ::std::string& value) {

  author_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:CoreML.Specification.Metadata.author)
}
#if LANG_CXX11
inline void Metadata::set_author(::std::string&& value) {

  author_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:CoreML.Specification.Metadata.author)
}
#endif
inline void Metadata::set_author(const char* value) {
  GOOGLE_DCHECK(value != NULL);

  author_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:CoreML.Specification.Metadata.author)
}
inline void Metadata::set_author(const char* value, size_t size) {

  author_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:CoreML.Specification.Metadata.author)
}
inline ::std::string* Metadata::mutable_author() {

  // @@protoc_insertion_point(field_mutable:CoreML.Specification.Metadata.author)
  return author_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Metadata::release_author() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.Metadata.author)

  return author_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Metadata::set_allocated_author(::std::string* author) {
  if (author != NULL) {

  } else {

  }
  author_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), author);
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.Metadata.author)
}

// string license = 4;
inline void Metadata::clear_license() {
  license_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Metadata::license() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.Metadata.license)
  return license_.GetNoArena();
}
inline void Metadata::set_license(const ::std::string& value) {

  license_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:CoreML.Specification.Metadata.license)
}
#if LANG_CXX11
inline void Metadata::set_license(::std::string&& value) {

  license_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:CoreML.Specification.Metadata.license)
}
#endif
inline void Metadata::set_license(const char* value) {
  GOOGLE_DCHECK(value != NULL);

  license_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:CoreML.Specification.Metadata.license)
}
inline void Metadata::set_license(const char* value, size_t size) {

  license_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:CoreML.Specification.Metadata.license)
}
inline ::std::string* Metadata::mutable_license() {

  // @@protoc_insertion_point(field_mutable:CoreML.Specification.Metadata.license)
  return license_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Metadata::release_license() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.Metadata.license)

  return license_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Metadata::set_allocated_license(::std::string* license) {
  if (license != NULL) {

  } else {

  }
  license_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), license);
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.Metadata.license)
}

// map<string, string> userDefined = 100;
inline int Metadata::userdefined_size() const {
  return userdefined_.size();
}
inline void Metadata::clear_userdefined() {
  userdefined_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::std::string >&
Metadata::userdefined() const {
  // @@protoc_insertion_point(field_map:CoreML.Specification.Metadata.userDefined)
  return userdefined_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::std::string >*
Metadata::mutable_userdefined() {
  // @@protoc_insertion_point(field_mutable_map:CoreML.Specification.Metadata.userDefined)
  return userdefined_.MutableMap();
}

// -------------------------------------------------------------------

// ModelDescription

// repeated .CoreML.Specification.FeatureDescription input = 1;
inline int ModelDescription::input_size() const {
  return input_.size();
}
inline void ModelDescription::clear_input() {
  input_.Clear();
}
inline const ::CoreML::Specification::FeatureDescription& ModelDescription::input(int index) const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.ModelDescription.input)
  return input_.Get(index);
}
inline ::CoreML::Specification::FeatureDescription* ModelDescription::mutable_input(int index) {
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.ModelDescription.input)
  return input_.Mutable(index);
}
inline ::CoreML::Specification::FeatureDescription* ModelDescription::add_input() {
  // @@protoc_insertion_point(field_add:CoreML.Specification.ModelDescription.input)
  return input_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::FeatureDescription >*
ModelDescription::mutable_input() {
  // @@protoc_insertion_point(field_mutable_list:CoreML.Specification.ModelDescription.input)
  return &input_;
}
inline const ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::FeatureDescription >&
ModelDescription::input() const {
  // @@protoc_insertion_point(field_list:CoreML.Specification.ModelDescription.input)
  return input_;
}

// repeated .CoreML.Specification.FeatureDescription output = 10;
inline int ModelDescription::output_size() const {
  return output_.size();
}
inline void ModelDescription::clear_output() {
  output_.Clear();
}
inline const ::CoreML::Specification::FeatureDescription& ModelDescription::output(int index) const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.ModelDescription.output)
  return output_.Get(index);
}
inline ::CoreML::Specification::FeatureDescription* ModelDescription::mutable_output(int index) {
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.ModelDescription.output)
  return output_.Mutable(index);
}
inline ::CoreML::Specification::FeatureDescription* ModelDescription::add_output() {
  // @@protoc_insertion_point(field_add:CoreML.Specification.ModelDescription.output)
  return output_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::FeatureDescription >*
ModelDescription::mutable_output() {
  // @@protoc_insertion_point(field_mutable_list:CoreML.Specification.ModelDescription.output)
  return &output_;
}
inline const ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::FeatureDescription >&
ModelDescription::output() const {
  // @@protoc_insertion_point(field_list:CoreML.Specification.ModelDescription.output)
  return output_;
}

// string predictedFeatureName = 11;
inline void ModelDescription::clear_predictedfeaturename() {
  predictedfeaturename_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ModelDescription::predictedfeaturename() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.ModelDescription.predictedFeatureName)
  return predictedfeaturename_.GetNoArena();
}
inline void ModelDescription::set_predictedfeaturename(const ::std::string& value) {

  predictedfeaturename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:CoreML.Specification.ModelDescription.predictedFeatureName)
}
#if LANG_CXX11
inline void ModelDescription::set_predictedfeaturename(::std::string&& value) {

  predictedfeaturename_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:CoreML.Specification.ModelDescription.predictedFeatureName)
}
#endif
inline void ModelDescription::set_predictedfeaturename(const char* value) {
  GOOGLE_DCHECK(value != NULL);

  predictedfeaturename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:CoreML.Specification.ModelDescription.predictedFeatureName)
}
inline void ModelDescription::set_predictedfeaturename(const char* value, size_t size) {

  predictedfeaturename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:CoreML.Specification.ModelDescription.predictedFeatureName)
}
inline ::std::string* ModelDescription::mutable_predictedfeaturename() {

  // @@protoc_insertion_point(field_mutable:CoreML.Specification.ModelDescription.predictedFeatureName)
  return predictedfeaturename_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ModelDescription::release_predictedfeaturename() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.ModelDescription.predictedFeatureName)

  return predictedfeaturename_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ModelDescription::set_allocated_predictedfeaturename(::std::string* predictedfeaturename) {
  if (predictedfeaturename != NULL) {

  } else {

  }
  predictedfeaturename_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), predictedfeaturename);
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.ModelDescription.predictedFeatureName)
}

// string predictedProbabilitiesName = 12;
inline void ModelDescription::clear_predictedprobabilitiesname() {
  predictedprobabilitiesname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ModelDescription::predictedprobabilitiesname() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.ModelDescription.predictedProbabilitiesName)
  return predictedprobabilitiesname_.GetNoArena();
}
inline void ModelDescription::set_predictedprobabilitiesname(const ::std::string& value) {

  predictedprobabilitiesname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:CoreML.Specification.ModelDescription.predictedProbabilitiesName)
}
#if LANG_CXX11
inline void ModelDescription::set_predictedprobabilitiesname(::std::string&& value) {

  predictedprobabilitiesname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:CoreML.Specification.ModelDescription.predictedProbabilitiesName)
}
#endif
inline void ModelDescription::set_predictedprobabilitiesname(const char* value) {
  GOOGLE_DCHECK(value != NULL);

  predictedprobabilitiesname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:CoreML.Specification.ModelDescription.predictedProbabilitiesName)
}
inline void ModelDescription::set_predictedprobabilitiesname(const char* value, size_t size) {

  predictedprobabilitiesname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:CoreML.Specification.ModelDescription.predictedProbabilitiesName)
}
inline ::std::string* ModelDescription::mutable_predictedprobabilitiesname() {

  // @@protoc_insertion_point(field_mutable:CoreML.Specification.ModelDescription.predictedProbabilitiesName)
  return predictedprobabilitiesname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ModelDescription::release_predictedprobabilitiesname() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.ModelDescription.predictedProbabilitiesName)

  return predictedprobabilitiesname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ModelDescription::set_allocated_predictedprobabilitiesname(::std::string* predictedprobabilitiesname) {
  if (predictedprobabilitiesname != NULL) {

  } else {

  }
  predictedprobabilitiesname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), predictedprobabilitiesname);
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.ModelDescription.predictedProbabilitiesName)
}

// .CoreML.Specification.Metadata metadata = 100;
inline bool ModelDescription::has_metadata() const {
  return this != internal_default_instance() && metadata_ != NULL;
}
inline void ModelDescription::clear_metadata() {
  if (GetArenaNoVirtual() == NULL && metadata_ != NULL) delete metadata_;
  metadata_ = NULL;
}
inline const ::CoreML::Specification::Metadata& ModelDescription::metadata() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.ModelDescription.metadata)
  return metadata_ != NULL ? *metadata_
                         : *::CoreML::Specification::Metadata::internal_default_instance();
}
inline ::CoreML::Specification::Metadata* ModelDescription::mutable_metadata() {

  if (metadata_ == NULL) {
    metadata_ = new ::CoreML::Specification::Metadata;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.ModelDescription.metadata)
  return metadata_;
}
inline ::CoreML::Specification::Metadata* ModelDescription::release_metadata() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.ModelDescription.metadata)

  ::CoreML::Specification::Metadata* temp = metadata_;
  metadata_ = NULL;
  return temp;
}
inline void ModelDescription::set_allocated_metadata(::CoreML::Specification::Metadata* metadata) {
  delete metadata_;
  metadata_ = metadata;
  if (metadata) {

  } else {

  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.ModelDescription.metadata)
}

// -------------------------------------------------------------------

// Model

// int32 specificationVersion = 1;
inline void Model::clear_specificationversion() {
  specificationversion_ = 0;
}
inline ::google::protobuf::int32 Model::specificationversion() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.Model.specificationVersion)
  return specificationversion_;
}
inline void Model::set_specificationversion(::google::protobuf::int32 value) {

  specificationversion_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.Model.specificationVersion)
}

// .CoreML.Specification.ModelDescription description = 2;
inline bool Model::has_description() const {
  return this != internal_default_instance() && description_ != NULL;
}
inline void Model::clear_description() {
  if (GetArenaNoVirtual() == NULL && description_ != NULL) delete description_;
  description_ = NULL;
}
inline const ::CoreML::Specification::ModelDescription& Model::description() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.Model.description)
  return description_ != NULL ? *description_
                         : *::CoreML::Specification::ModelDescription::internal_default_instance();
}
inline ::CoreML::Specification::ModelDescription* Model::mutable_description() {

  if (description_ == NULL) {
    description_ = new ::CoreML::Specification::ModelDescription;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.Model.description)
  return description_;
}
inline ::CoreML::Specification::ModelDescription* Model::release_description() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.Model.description)

  ::CoreML::Specification::ModelDescription* temp = description_;
  description_ = NULL;
  return temp;
}
inline void Model::set_allocated_description(::CoreML::Specification::ModelDescription* description) {
  delete description_;
  description_ = description;
  if (description) {

  } else {

  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.Model.description)
}

// .CoreML.Specification.PipelineClassifier pipelineClassifier = 200;
inline bool Model::has_pipelineclassifier() const {
  return Type_case() == kPipelineClassifier;
}
inline void Model::set_has_pipelineclassifier() {
  _oneof_case_[0] = kPipelineClassifier;
}
inline void Model::clear_pipelineclassifier() {
  if (has_pipelineclassifier()) {
    delete Type_.pipelineclassifier_;
    clear_has_Type();
  }
}
inline  const ::CoreML::Specification::PipelineClassifier& Model::pipelineclassifier() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.Model.pipelineClassifier)
  return has_pipelineclassifier()
      ? *Type_.pipelineclassifier_
      : ::CoreML::Specification::PipelineClassifier::default_instance();
}
inline ::CoreML::Specification::PipelineClassifier* Model::mutable_pipelineclassifier() {
  if (!has_pipelineclassifier()) {
    clear_Type();
    set_has_pipelineclassifier();
    Type_.pipelineclassifier_ = new ::CoreML::Specification::PipelineClassifier;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.Model.pipelineClassifier)
  return Type_.pipelineclassifier_;
}
inline ::CoreML::Specification::PipelineClassifier* Model::release_pipelineclassifier() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.Model.pipelineClassifier)
  if (has_pipelineclassifier()) {
    clear_has_Type();
    ::CoreML::Specification::PipelineClassifier* temp = Type_.pipelineclassifier_;
    Type_.pipelineclassifier_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Model::set_allocated_pipelineclassifier(::CoreML::Specification::PipelineClassifier* pipelineclassifier) {
  clear_Type();
  if (pipelineclassifier) {
    set_has_pipelineclassifier();
    Type_.pipelineclassifier_ = pipelineclassifier;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.Model.pipelineClassifier)
}

// .CoreML.Specification.PipelineRegressor pipelineRegressor = 201;
inline bool Model::has_pipelineregressor() const {
  return Type_case() == kPipelineRegressor;
}
inline void Model::set_has_pipelineregressor() {
  _oneof_case_[0] = kPipelineRegressor;
}
inline void Model::clear_pipelineregressor() {
  if (has_pipelineregressor()) {
    delete Type_.pipelineregressor_;
    clear_has_Type();
  }
}
inline  const ::CoreML::Specification::PipelineRegressor& Model::pipelineregressor() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.Model.pipelineRegressor)
  return has_pipelineregressor()
      ? *Type_.pipelineregressor_
      : ::CoreML::Specification::PipelineRegressor::default_instance();
}
inline ::CoreML::Specification::PipelineRegressor* Model::mutable_pipelineregressor() {
  if (!has_pipelineregressor()) {
    clear_Type();
    set_has_pipelineregressor();
    Type_.pipelineregressor_ = new ::CoreML::Specification::PipelineRegressor;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.Model.pipelineRegressor)
  return Type_.pipelineregressor_;
}
inline ::CoreML::Specification::PipelineRegressor* Model::release_pipelineregressor() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.Model.pipelineRegressor)
  if (has_pipelineregressor()) {
    clear_has_Type();
    ::CoreML::Specification::PipelineRegressor* temp = Type_.pipelineregressor_;
    Type_.pipelineregressor_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Model::set_allocated_pipelineregressor(::CoreML::Specification::PipelineRegressor* pipelineregressor) {
  clear_Type();
  if (pipelineregressor) {
    set_has_pipelineregressor();
    Type_.pipelineregressor_ = pipelineregressor;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.Model.pipelineRegressor)
}

// .CoreML.Specification.Pipeline pipeline = 202;
inline bool Model::has_pipeline() const {
  return Type_case() == kPipeline;
}
inline void Model::set_has_pipeline() {
  _oneof_case_[0] = kPipeline;
}
inline void Model::clear_pipeline() {
  if (has_pipeline()) {
    delete Type_.pipeline_;
    clear_has_Type();
  }
}
inline  const ::CoreML::Specification::Pipeline& Model::pipeline() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.Model.pipeline)
  return has_pipeline()
      ? *Type_.pipeline_
      : ::CoreML::Specification::Pipeline::default_instance();
}
inline ::CoreML::Specification::Pipeline* Model::mutable_pipeline() {
  if (!has_pipeline()) {
    clear_Type();
    set_has_pipeline();
    Type_.pipeline_ = new ::CoreML::Specification::Pipeline;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.Model.pipeline)
  return Type_.pipeline_;
}
inline ::CoreML::Specification::Pipeline* Model::release_pipeline() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.Model.pipeline)
  if (has_pipeline()) {
    clear_has_Type();
    ::CoreML::Specification::Pipeline* temp = Type_.pipeline_;
    Type_.pipeline_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Model::set_allocated_pipeline(::CoreML::Specification::Pipeline* pipeline) {
  clear_Type();
  if (pipeline) {
    set_has_pipeline();
    Type_.pipeline_ = pipeline;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.Model.pipeline)
}

// .CoreML.Specification.GLMRegressor glmRegressor = 300;
inline bool Model::has_glmregressor() const {
  return Type_case() == kGlmRegressor;
}
inline void Model::set_has_glmregressor() {
  _oneof_case_[0] = kGlmRegressor;
}
inline void Model::clear_glmregressor() {
  if (has_glmregressor()) {
    delete Type_.glmregressor_;
    clear_has_Type();
  }
}
inline  const ::CoreML::Specification::GLMRegressor& Model::glmregressor() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.Model.glmRegressor)
  return has_glmregressor()
      ? *Type_.glmregressor_
      : ::CoreML::Specification::GLMRegressor::default_instance();
}
inline ::CoreML::Specification::GLMRegressor* Model::mutable_glmregressor() {
  if (!has_glmregressor()) {
    clear_Type();
    set_has_glmregressor();
    Type_.glmregressor_ = new ::CoreML::Specification::GLMRegressor;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.Model.glmRegressor)
  return Type_.glmregressor_;
}
inline ::CoreML::Specification::GLMRegressor* Model::release_glmregressor() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.Model.glmRegressor)
  if (has_glmregressor()) {
    clear_has_Type();
    ::CoreML::Specification::GLMRegressor* temp = Type_.glmregressor_;
    Type_.glmregressor_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Model::set_allocated_glmregressor(::CoreML::Specification::GLMRegressor* glmregressor) {
  clear_Type();
  if (glmregressor) {
    set_has_glmregressor();
    Type_.glmregressor_ = glmregressor;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.Model.glmRegressor)
}

// .CoreML.Specification.SupportVectorRegressor supportVectorRegressor = 301;
inline bool Model::has_supportvectorregressor() const {
  return Type_case() == kSupportVectorRegressor;
}
inline void Model::set_has_supportvectorregressor() {
  _oneof_case_[0] = kSupportVectorRegressor;
}
inline void Model::clear_supportvectorregressor() {
  if (has_supportvectorregressor()) {
    delete Type_.supportvectorregressor_;
    clear_has_Type();
  }
}
inline  const ::CoreML::Specification::SupportVectorRegressor& Model::supportvectorregressor() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.Model.supportVectorRegressor)
  return has_supportvectorregressor()
      ? *Type_.supportvectorregressor_
      : ::CoreML::Specification::SupportVectorRegressor::default_instance();
}
inline ::CoreML::Specification::SupportVectorRegressor* Model::mutable_supportvectorregressor() {
  if (!has_supportvectorregressor()) {
    clear_Type();
    set_has_supportvectorregressor();
    Type_.supportvectorregressor_ = new ::CoreML::Specification::SupportVectorRegressor;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.Model.supportVectorRegressor)
  return Type_.supportvectorregressor_;
}
inline ::CoreML::Specification::SupportVectorRegressor* Model::release_supportvectorregressor() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.Model.supportVectorRegressor)
  if (has_supportvectorregressor()) {
    clear_has_Type();
    ::CoreML::Specification::SupportVectorRegressor* temp = Type_.supportvectorregressor_;
    Type_.supportvectorregressor_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Model::set_allocated_supportvectorregressor(::CoreML::Specification::SupportVectorRegressor* supportvectorregressor) {
  clear_Type();
  if (supportvectorregressor) {
    set_has_supportvectorregressor();
    Type_.supportvectorregressor_ = supportvectorregressor;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.Model.supportVectorRegressor)
}

// .CoreML.Specification.TreeEnsembleRegressor treeEnsembleRegressor = 302;
inline bool Model::has_treeensembleregressor() const {
  return Type_case() == kTreeEnsembleRegressor;
}
inline void Model::set_has_treeensembleregressor() {
  _oneof_case_[0] = kTreeEnsembleRegressor;
}
inline void Model::clear_treeensembleregressor() {
  if (has_treeensembleregressor()) {
    delete Type_.treeensembleregressor_;
    clear_has_Type();
  }
}
inline  const ::CoreML::Specification::TreeEnsembleRegressor& Model::treeensembleregressor() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.Model.treeEnsembleRegressor)
  return has_treeensembleregressor()
      ? *Type_.treeensembleregressor_
      : ::CoreML::Specification::TreeEnsembleRegressor::default_instance();
}
inline ::CoreML::Specification::TreeEnsembleRegressor* Model::mutable_treeensembleregressor() {
  if (!has_treeensembleregressor()) {
    clear_Type();
    set_has_treeensembleregressor();
    Type_.treeensembleregressor_ = new ::CoreML::Specification::TreeEnsembleRegressor;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.Model.treeEnsembleRegressor)
  return Type_.treeensembleregressor_;
}
inline ::CoreML::Specification::TreeEnsembleRegressor* Model::release_treeensembleregressor() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.Model.treeEnsembleRegressor)
  if (has_treeensembleregressor()) {
    clear_has_Type();
    ::CoreML::Specification::TreeEnsembleRegressor* temp = Type_.treeensembleregressor_;
    Type_.treeensembleregressor_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Model::set_allocated_treeensembleregressor(::CoreML::Specification::TreeEnsembleRegressor* treeensembleregressor) {
  clear_Type();
  if (treeensembleregressor) {
    set_has_treeensembleregressor();
    Type_.treeensembleregressor_ = treeensembleregressor;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.Model.treeEnsembleRegressor)
}

// .CoreML.Specification.NeuralNetworkRegressor neuralNetworkRegressor = 303;
inline bool Model::has_neuralnetworkregressor() const {
  return Type_case() == kNeuralNetworkRegressor;
}
inline void Model::set_has_neuralnetworkregressor() {
  _oneof_case_[0] = kNeuralNetworkRegressor;
}
inline void Model::clear_neuralnetworkregressor() {
  if (has_neuralnetworkregressor()) {
    delete Type_.neuralnetworkregressor_;
    clear_has_Type();
  }
}
inline  const ::CoreML::Specification::NeuralNetworkRegressor& Model::neuralnetworkregressor() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.Model.neuralNetworkRegressor)
  return has_neuralnetworkregressor()
      ? *Type_.neuralnetworkregressor_
      : ::CoreML::Specification::NeuralNetworkRegressor::default_instance();
}
inline ::CoreML::Specification::NeuralNetworkRegressor* Model::mutable_neuralnetworkregressor() {
  if (!has_neuralnetworkregressor()) {
    clear_Type();
    set_has_neuralnetworkregressor();
    Type_.neuralnetworkregressor_ = new ::CoreML::Specification::NeuralNetworkRegressor;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.Model.neuralNetworkRegressor)
  return Type_.neuralnetworkregressor_;
}
inline ::CoreML::Specification::NeuralNetworkRegressor* Model::release_neuralnetworkregressor() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.Model.neuralNetworkRegressor)
  if (has_neuralnetworkregressor()) {
    clear_has_Type();
    ::CoreML::Specification::NeuralNetworkRegressor* temp = Type_.neuralnetworkregressor_;
    Type_.neuralnetworkregressor_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Model::set_allocated_neuralnetworkregressor(::CoreML::Specification::NeuralNetworkRegressor* neuralnetworkregressor) {
  clear_Type();
  if (neuralnetworkregressor) {
    set_has_neuralnetworkregressor();
    Type_.neuralnetworkregressor_ = neuralnetworkregressor;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.Model.neuralNetworkRegressor)
}

// .CoreML.Specification.BayesianProbitRegressor bayesianProbitRegressor = 304;
inline bool Model::has_bayesianprobitregressor() const {
  return Type_case() == kBayesianProbitRegressor;
}
inline void Model::set_has_bayesianprobitregressor() {
  _oneof_case_[0] = kBayesianProbitRegressor;
}
inline void Model::clear_bayesianprobitregressor() {
  if (has_bayesianprobitregressor()) {
    delete Type_.bayesianprobitregressor_;
    clear_has_Type();
  }
}
inline  const ::CoreML::Specification::BayesianProbitRegressor& Model::bayesianprobitregressor() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.Model.bayesianProbitRegressor)
  return has_bayesianprobitregressor()
      ? *Type_.bayesianprobitregressor_
      : ::CoreML::Specification::BayesianProbitRegressor::default_instance();
}
inline ::CoreML::Specification::BayesianProbitRegressor* Model::mutable_bayesianprobitregressor() {
  if (!has_bayesianprobitregressor()) {
    clear_Type();
    set_has_bayesianprobitregressor();
    Type_.bayesianprobitregressor_ = new ::CoreML::Specification::BayesianProbitRegressor;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.Model.bayesianProbitRegressor)
  return Type_.bayesianprobitregressor_;
}
inline ::CoreML::Specification::BayesianProbitRegressor* Model::release_bayesianprobitregressor() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.Model.bayesianProbitRegressor)
  if (has_bayesianprobitregressor()) {
    clear_has_Type();
    ::CoreML::Specification::BayesianProbitRegressor* temp = Type_.bayesianprobitregressor_;
    Type_.bayesianprobitregressor_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Model::set_allocated_bayesianprobitregressor(::CoreML::Specification::BayesianProbitRegressor* bayesianprobitregressor) {
  clear_Type();
  if (bayesianprobitregressor) {
    set_has_bayesianprobitregressor();
    Type_.bayesianprobitregressor_ = bayesianprobitregressor;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.Model.bayesianProbitRegressor)
}

// .CoreML.Specification.GLMClassifier glmClassifier = 400;
inline bool Model::has_glmclassifier() const {
  return Type_case() == kGlmClassifier;
}
inline void Model::set_has_glmclassifier() {
  _oneof_case_[0] = kGlmClassifier;
}
inline void Model::clear_glmclassifier() {
  if (has_glmclassifier()) {
    delete Type_.glmclassifier_;
    clear_has_Type();
  }
}
inline  const ::CoreML::Specification::GLMClassifier& Model::glmclassifier() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.Model.glmClassifier)
  return has_glmclassifier()
      ? *Type_.glmclassifier_
      : ::CoreML::Specification::GLMClassifier::default_instance();
}
inline ::CoreML::Specification::GLMClassifier* Model::mutable_glmclassifier() {
  if (!has_glmclassifier()) {
    clear_Type();
    set_has_glmclassifier();
    Type_.glmclassifier_ = new ::CoreML::Specification::GLMClassifier;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.Model.glmClassifier)
  return Type_.glmclassifier_;
}
inline ::CoreML::Specification::GLMClassifier* Model::release_glmclassifier() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.Model.glmClassifier)
  if (has_glmclassifier()) {
    clear_has_Type();
    ::CoreML::Specification::GLMClassifier* temp = Type_.glmclassifier_;
    Type_.glmclassifier_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Model::set_allocated_glmclassifier(::CoreML::Specification::GLMClassifier* glmclassifier) {
  clear_Type();
  if (glmclassifier) {
    set_has_glmclassifier();
    Type_.glmclassifier_ = glmclassifier;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.Model.glmClassifier)
}

// .CoreML.Specification.SupportVectorClassifier supportVectorClassifier = 401;
inline bool Model::has_supportvectorclassifier() const {
  return Type_case() == kSupportVectorClassifier;
}
inline void Model::set_has_supportvectorclassifier() {
  _oneof_case_[0] = kSupportVectorClassifier;
}
inline void Model::clear_supportvectorclassifier() {
  if (has_supportvectorclassifier()) {
    delete Type_.supportvectorclassifier_;
    clear_has_Type();
  }
}
inline  const ::CoreML::Specification::SupportVectorClassifier& Model::supportvectorclassifier() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.Model.supportVectorClassifier)
  return has_supportvectorclassifier()
      ? *Type_.supportvectorclassifier_
      : ::CoreML::Specification::SupportVectorClassifier::default_instance();
}
inline ::CoreML::Specification::SupportVectorClassifier* Model::mutable_supportvectorclassifier() {
  if (!has_supportvectorclassifier()) {
    clear_Type();
    set_has_supportvectorclassifier();
    Type_.supportvectorclassifier_ = new ::CoreML::Specification::SupportVectorClassifier;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.Model.supportVectorClassifier)
  return Type_.supportvectorclassifier_;
}
inline ::CoreML::Specification::SupportVectorClassifier* Model::release_supportvectorclassifier() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.Model.supportVectorClassifier)
  if (has_supportvectorclassifier()) {
    clear_has_Type();
    ::CoreML::Specification::SupportVectorClassifier* temp = Type_.supportvectorclassifier_;
    Type_.supportvectorclassifier_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Model::set_allocated_supportvectorclassifier(::CoreML::Specification::SupportVectorClassifier* supportvectorclassifier) {
  clear_Type();
  if (supportvectorclassifier) {
    set_has_supportvectorclassifier();
    Type_.supportvectorclassifier_ = supportvectorclassifier;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.Model.supportVectorClassifier)
}

// .CoreML.Specification.TreeEnsembleClassifier treeEnsembleClassifier = 402;
inline bool Model::has_treeensembleclassifier() const {
  return Type_case() == kTreeEnsembleClassifier;
}
inline void Model::set_has_treeensembleclassifier() {
  _oneof_case_[0] = kTreeEnsembleClassifier;
}
inline void Model::clear_treeensembleclassifier() {
  if (has_treeensembleclassifier()) {
    delete Type_.treeensembleclassifier_;
    clear_has_Type();
  }
}
inline  const ::CoreML::Specification::TreeEnsembleClassifier& Model::treeensembleclassifier() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.Model.treeEnsembleClassifier)
  return has_treeensembleclassifier()
      ? *Type_.treeensembleclassifier_
      : ::CoreML::Specification::TreeEnsembleClassifier::default_instance();
}
inline ::CoreML::Specification::TreeEnsembleClassifier* Model::mutable_treeensembleclassifier() {
  if (!has_treeensembleclassifier()) {
    clear_Type();
    set_has_treeensembleclassifier();
    Type_.treeensembleclassifier_ = new ::CoreML::Specification::TreeEnsembleClassifier;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.Model.treeEnsembleClassifier)
  return Type_.treeensembleclassifier_;
}
inline ::CoreML::Specification::TreeEnsembleClassifier* Model::release_treeensembleclassifier() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.Model.treeEnsembleClassifier)
  if (has_treeensembleclassifier()) {
    clear_has_Type();
    ::CoreML::Specification::TreeEnsembleClassifier* temp = Type_.treeensembleclassifier_;
    Type_.treeensembleclassifier_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Model::set_allocated_treeensembleclassifier(::CoreML::Specification::TreeEnsembleClassifier* treeensembleclassifier) {
  clear_Type();
  if (treeensembleclassifier) {
    set_has_treeensembleclassifier();
    Type_.treeensembleclassifier_ = treeensembleclassifier;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.Model.treeEnsembleClassifier)
}

// .CoreML.Specification.NeuralNetworkClassifier neuralNetworkClassifier = 403;
inline bool Model::has_neuralnetworkclassifier() const {
  return Type_case() == kNeuralNetworkClassifier;
}
inline void Model::set_has_neuralnetworkclassifier() {
  _oneof_case_[0] = kNeuralNetworkClassifier;
}
inline void Model::clear_neuralnetworkclassifier() {
  if (has_neuralnetworkclassifier()) {
    delete Type_.neuralnetworkclassifier_;
    clear_has_Type();
  }
}
inline  const ::CoreML::Specification::NeuralNetworkClassifier& Model::neuralnetworkclassifier() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.Model.neuralNetworkClassifier)
  return has_neuralnetworkclassifier()
      ? *Type_.neuralnetworkclassifier_
      : ::CoreML::Specification::NeuralNetworkClassifier::default_instance();
}
inline ::CoreML::Specification::NeuralNetworkClassifier* Model::mutable_neuralnetworkclassifier() {
  if (!has_neuralnetworkclassifier()) {
    clear_Type();
    set_has_neuralnetworkclassifier();
    Type_.neuralnetworkclassifier_ = new ::CoreML::Specification::NeuralNetworkClassifier;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.Model.neuralNetworkClassifier)
  return Type_.neuralnetworkclassifier_;
}
inline ::CoreML::Specification::NeuralNetworkClassifier* Model::release_neuralnetworkclassifier() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.Model.neuralNetworkClassifier)
  if (has_neuralnetworkclassifier()) {
    clear_has_Type();
    ::CoreML::Specification::NeuralNetworkClassifier* temp = Type_.neuralnetworkclassifier_;
    Type_.neuralnetworkclassifier_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Model::set_allocated_neuralnetworkclassifier(::CoreML::Specification::NeuralNetworkClassifier* neuralnetworkclassifier) {
  clear_Type();
  if (neuralnetworkclassifier) {
    set_has_neuralnetworkclassifier();
    Type_.neuralnetworkclassifier_ = neuralnetworkclassifier;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.Model.neuralNetworkClassifier)
}

// .CoreML.Specification.NeuralNetwork neuralNetwork = 500;
inline bool Model::has_neuralnetwork() const {
  return Type_case() == kNeuralNetwork;
}
inline void Model::set_has_neuralnetwork() {
  _oneof_case_[0] = kNeuralNetwork;
}
inline void Model::clear_neuralnetwork() {
  if (has_neuralnetwork()) {
    delete Type_.neuralnetwork_;
    clear_has_Type();
  }
}
inline  const ::CoreML::Specification::NeuralNetwork& Model::neuralnetwork() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.Model.neuralNetwork)
  return has_neuralnetwork()
      ? *Type_.neuralnetwork_
      : ::CoreML::Specification::NeuralNetwork::default_instance();
}
inline ::CoreML::Specification::NeuralNetwork* Model::mutable_neuralnetwork() {
  if (!has_neuralnetwork()) {
    clear_Type();
    set_has_neuralnetwork();
    Type_.neuralnetwork_ = new ::CoreML::Specification::NeuralNetwork;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.Model.neuralNetwork)
  return Type_.neuralnetwork_;
}
inline ::CoreML::Specification::NeuralNetwork* Model::release_neuralnetwork() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.Model.neuralNetwork)
  if (has_neuralnetwork()) {
    clear_has_Type();
    ::CoreML::Specification::NeuralNetwork* temp = Type_.neuralnetwork_;
    Type_.neuralnetwork_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Model::set_allocated_neuralnetwork(::CoreML::Specification::NeuralNetwork* neuralnetwork) {
  clear_Type();
  if (neuralnetwork) {
    set_has_neuralnetwork();
    Type_.neuralnetwork_ = neuralnetwork;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.Model.neuralNetwork)
}

// .CoreML.Specification.CustomModel customModel = 555;
inline bool Model::has_custommodel() const {
  return Type_case() == kCustomModel;
}
inline void Model::set_has_custommodel() {
  _oneof_case_[0] = kCustomModel;
}
inline void Model::clear_custommodel() {
  if (has_custommodel()) {
    delete Type_.custommodel_;
    clear_has_Type();
  }
}
inline  const ::CoreML::Specification::CustomModel& Model::custommodel() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.Model.customModel)
  return has_custommodel()
      ? *Type_.custommodel_
      : ::CoreML::Specification::CustomModel::default_instance();
}
inline ::CoreML::Specification::CustomModel* Model::mutable_custommodel() {
  if (!has_custommodel()) {
    clear_Type();
    set_has_custommodel();
    Type_.custommodel_ = new ::CoreML::Specification::CustomModel;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.Model.customModel)
  return Type_.custommodel_;
}
inline ::CoreML::Specification::CustomModel* Model::release_custommodel() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.Model.customModel)
  if (has_custommodel()) {
    clear_has_Type();
    ::CoreML::Specification::CustomModel* temp = Type_.custommodel_;
    Type_.custommodel_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Model::set_allocated_custommodel(::CoreML::Specification::CustomModel* custommodel) {
  clear_Type();
  if (custommodel) {
    set_has_custommodel();
    Type_.custommodel_ = custommodel;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.Model.customModel)
}

// .CoreML.Specification.OneHotEncoder oneHotEncoder = 600;
inline bool Model::has_onehotencoder() const {
  return Type_case() == kOneHotEncoder;
}
inline void Model::set_has_onehotencoder() {
  _oneof_case_[0] = kOneHotEncoder;
}
inline void Model::clear_onehotencoder() {
  if (has_onehotencoder()) {
    delete Type_.onehotencoder_;
    clear_has_Type();
  }
}
inline  const ::CoreML::Specification::OneHotEncoder& Model::onehotencoder() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.Model.oneHotEncoder)
  return has_onehotencoder()
      ? *Type_.onehotencoder_
      : ::CoreML::Specification::OneHotEncoder::default_instance();
}
inline ::CoreML::Specification::OneHotEncoder* Model::mutable_onehotencoder() {
  if (!has_onehotencoder()) {
    clear_Type();
    set_has_onehotencoder();
    Type_.onehotencoder_ = new ::CoreML::Specification::OneHotEncoder;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.Model.oneHotEncoder)
  return Type_.onehotencoder_;
}
inline ::CoreML::Specification::OneHotEncoder* Model::release_onehotencoder() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.Model.oneHotEncoder)
  if (has_onehotencoder()) {
    clear_has_Type();
    ::CoreML::Specification::OneHotEncoder* temp = Type_.onehotencoder_;
    Type_.onehotencoder_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Model::set_allocated_onehotencoder(::CoreML::Specification::OneHotEncoder* onehotencoder) {
  clear_Type();
  if (onehotencoder) {
    set_has_onehotencoder();
    Type_.onehotencoder_ = onehotencoder;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.Model.oneHotEncoder)
}

// .CoreML.Specification.Imputer imputer = 601;
inline bool Model::has_imputer() const {
  return Type_case() == kImputer;
}
inline void Model::set_has_imputer() {
  _oneof_case_[0] = kImputer;
}
inline void Model::clear_imputer() {
  if (has_imputer()) {
    delete Type_.imputer_;
    clear_has_Type();
  }
}
inline  const ::CoreML::Specification::Imputer& Model::imputer() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.Model.imputer)
  return has_imputer()
      ? *Type_.imputer_
      : ::CoreML::Specification::Imputer::default_instance();
}
inline ::CoreML::Specification::Imputer* Model::mutable_imputer() {
  if (!has_imputer()) {
    clear_Type();
    set_has_imputer();
    Type_.imputer_ = new ::CoreML::Specification::Imputer;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.Model.imputer)
  return Type_.imputer_;
}
inline ::CoreML::Specification::Imputer* Model::release_imputer() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.Model.imputer)
  if (has_imputer()) {
    clear_has_Type();
    ::CoreML::Specification::Imputer* temp = Type_.imputer_;
    Type_.imputer_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Model::set_allocated_imputer(::CoreML::Specification::Imputer* imputer) {
  clear_Type();
  if (imputer) {
    set_has_imputer();
    Type_.imputer_ = imputer;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.Model.imputer)
}

// .CoreML.Specification.FeatureVectorizer featureVectorizer = 602;
inline bool Model::has_featurevectorizer() const {
  return Type_case() == kFeatureVectorizer;
}
inline void Model::set_has_featurevectorizer() {
  _oneof_case_[0] = kFeatureVectorizer;
}
inline void Model::clear_featurevectorizer() {
  if (has_featurevectorizer()) {
    delete Type_.featurevectorizer_;
    clear_has_Type();
  }
}
inline  const ::CoreML::Specification::FeatureVectorizer& Model::featurevectorizer() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.Model.featureVectorizer)
  return has_featurevectorizer()
      ? *Type_.featurevectorizer_
      : ::CoreML::Specification::FeatureVectorizer::default_instance();
}
inline ::CoreML::Specification::FeatureVectorizer* Model::mutable_featurevectorizer() {
  if (!has_featurevectorizer()) {
    clear_Type();
    set_has_featurevectorizer();
    Type_.featurevectorizer_ = new ::CoreML::Specification::FeatureVectorizer;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.Model.featureVectorizer)
  return Type_.featurevectorizer_;
}
inline ::CoreML::Specification::FeatureVectorizer* Model::release_featurevectorizer() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.Model.featureVectorizer)
  if (has_featurevectorizer()) {
    clear_has_Type();
    ::CoreML::Specification::FeatureVectorizer* temp = Type_.featurevectorizer_;
    Type_.featurevectorizer_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Model::set_allocated_featurevectorizer(::CoreML::Specification::FeatureVectorizer* featurevectorizer) {
  clear_Type();
  if (featurevectorizer) {
    set_has_featurevectorizer();
    Type_.featurevectorizer_ = featurevectorizer;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.Model.featureVectorizer)
}

// .CoreML.Specification.DictVectorizer dictVectorizer = 603;
inline bool Model::has_dictvectorizer() const {
  return Type_case() == kDictVectorizer;
}
inline void Model::set_has_dictvectorizer() {
  _oneof_case_[0] = kDictVectorizer;
}
inline void Model::clear_dictvectorizer() {
  if (has_dictvectorizer()) {
    delete Type_.dictvectorizer_;
    clear_has_Type();
  }
}
inline  const ::CoreML::Specification::DictVectorizer& Model::dictvectorizer() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.Model.dictVectorizer)
  return has_dictvectorizer()
      ? *Type_.dictvectorizer_
      : ::CoreML::Specification::DictVectorizer::default_instance();
}
inline ::CoreML::Specification::DictVectorizer* Model::mutable_dictvectorizer() {
  if (!has_dictvectorizer()) {
    clear_Type();
    set_has_dictvectorizer();
    Type_.dictvectorizer_ = new ::CoreML::Specification::DictVectorizer;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.Model.dictVectorizer)
  return Type_.dictvectorizer_;
}
inline ::CoreML::Specification::DictVectorizer* Model::release_dictvectorizer() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.Model.dictVectorizer)
  if (has_dictvectorizer()) {
    clear_has_Type();
    ::CoreML::Specification::DictVectorizer* temp = Type_.dictvectorizer_;
    Type_.dictvectorizer_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Model::set_allocated_dictvectorizer(::CoreML::Specification::DictVectorizer* dictvectorizer) {
  clear_Type();
  if (dictvectorizer) {
    set_has_dictvectorizer();
    Type_.dictvectorizer_ = dictvectorizer;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.Model.dictVectorizer)
}

// .CoreML.Specification.Scaler scaler = 604;
inline bool Model::has_scaler() const {
  return Type_case() == kScaler;
}
inline void Model::set_has_scaler() {
  _oneof_case_[0] = kScaler;
}
inline void Model::clear_scaler() {
  if (has_scaler()) {
    delete Type_.scaler_;
    clear_has_Type();
  }
}
inline  const ::CoreML::Specification::Scaler& Model::scaler() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.Model.scaler)
  return has_scaler()
      ? *Type_.scaler_
      : ::CoreML::Specification::Scaler::default_instance();
}
inline ::CoreML::Specification::Scaler* Model::mutable_scaler() {
  if (!has_scaler()) {
    clear_Type();
    set_has_scaler();
    Type_.scaler_ = new ::CoreML::Specification::Scaler;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.Model.scaler)
  return Type_.scaler_;
}
inline ::CoreML::Specification::Scaler* Model::release_scaler() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.Model.scaler)
  if (has_scaler()) {
    clear_has_Type();
    ::CoreML::Specification::Scaler* temp = Type_.scaler_;
    Type_.scaler_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Model::set_allocated_scaler(::CoreML::Specification::Scaler* scaler) {
  clear_Type();
  if (scaler) {
    set_has_scaler();
    Type_.scaler_ = scaler;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.Model.scaler)
}

// .CoreML.Specification.CategoricalMapping categoricalMapping = 606;
inline bool Model::has_categoricalmapping() const {
  return Type_case() == kCategoricalMapping;
}
inline void Model::set_has_categoricalmapping() {
  _oneof_case_[0] = kCategoricalMapping;
}
inline void Model::clear_categoricalmapping() {
  if (has_categoricalmapping()) {
    delete Type_.categoricalmapping_;
    clear_has_Type();
  }
}
inline  const ::CoreML::Specification::CategoricalMapping& Model::categoricalmapping() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.Model.categoricalMapping)
  return has_categoricalmapping()
      ? *Type_.categoricalmapping_
      : ::CoreML::Specification::CategoricalMapping::default_instance();
}
inline ::CoreML::Specification::CategoricalMapping* Model::mutable_categoricalmapping() {
  if (!has_categoricalmapping()) {
    clear_Type();
    set_has_categoricalmapping();
    Type_.categoricalmapping_ = new ::CoreML::Specification::CategoricalMapping;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.Model.categoricalMapping)
  return Type_.categoricalmapping_;
}
inline ::CoreML::Specification::CategoricalMapping* Model::release_categoricalmapping() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.Model.categoricalMapping)
  if (has_categoricalmapping()) {
    clear_has_Type();
    ::CoreML::Specification::CategoricalMapping* temp = Type_.categoricalmapping_;
    Type_.categoricalmapping_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Model::set_allocated_categoricalmapping(::CoreML::Specification::CategoricalMapping* categoricalmapping) {
  clear_Type();
  if (categoricalmapping) {
    set_has_categoricalmapping();
    Type_.categoricalmapping_ = categoricalmapping;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.Model.categoricalMapping)
}

// .CoreML.Specification.Normalizer normalizer = 607;
inline bool Model::has_normalizer() const {
  return Type_case() == kNormalizer;
}
inline void Model::set_has_normalizer() {
  _oneof_case_[0] = kNormalizer;
}
inline void Model::clear_normalizer() {
  if (has_normalizer()) {
    delete Type_.normalizer_;
    clear_has_Type();
  }
}
inline  const ::CoreML::Specification::Normalizer& Model::normalizer() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.Model.normalizer)
  return has_normalizer()
      ? *Type_.normalizer_
      : ::CoreML::Specification::Normalizer::default_instance();
}
inline ::CoreML::Specification::Normalizer* Model::mutable_normalizer() {
  if (!has_normalizer()) {
    clear_Type();
    set_has_normalizer();
    Type_.normalizer_ = new ::CoreML::Specification::Normalizer;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.Model.normalizer)
  return Type_.normalizer_;
}
inline ::CoreML::Specification::Normalizer* Model::release_normalizer() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.Model.normalizer)
  if (has_normalizer()) {
    clear_has_Type();
    ::CoreML::Specification::Normalizer* temp = Type_.normalizer_;
    Type_.normalizer_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Model::set_allocated_normalizer(::CoreML::Specification::Normalizer* normalizer) {
  clear_Type();
  if (normalizer) {
    set_has_normalizer();
    Type_.normalizer_ = normalizer;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.Model.normalizer)
}

// .CoreML.Specification.ArrayFeatureExtractor arrayFeatureExtractor = 609;
inline bool Model::has_arrayfeatureextractor() const {
  return Type_case() == kArrayFeatureExtractor;
}
inline void Model::set_has_arrayfeatureextractor() {
  _oneof_case_[0] = kArrayFeatureExtractor;
}
inline void Model::clear_arrayfeatureextractor() {
  if (has_arrayfeatureextractor()) {
    delete Type_.arrayfeatureextractor_;
    clear_has_Type();
  }
}
inline  const ::CoreML::Specification::ArrayFeatureExtractor& Model::arrayfeatureextractor() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.Model.arrayFeatureExtractor)
  return has_arrayfeatureextractor()
      ? *Type_.arrayfeatureextractor_
      : ::CoreML::Specification::ArrayFeatureExtractor::default_instance();
}
inline ::CoreML::Specification::ArrayFeatureExtractor* Model::mutable_arrayfeatureextractor() {
  if (!has_arrayfeatureextractor()) {
    clear_Type();
    set_has_arrayfeatureextractor();
    Type_.arrayfeatureextractor_ = new ::CoreML::Specification::ArrayFeatureExtractor;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.Model.arrayFeatureExtractor)
  return Type_.arrayfeatureextractor_;
}
inline ::CoreML::Specification::ArrayFeatureExtractor* Model::release_arrayfeatureextractor() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.Model.arrayFeatureExtractor)
  if (has_arrayfeatureextractor()) {
    clear_has_Type();
    ::CoreML::Specification::ArrayFeatureExtractor* temp = Type_.arrayfeatureextractor_;
    Type_.arrayfeatureextractor_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Model::set_allocated_arrayfeatureextractor(::CoreML::Specification::ArrayFeatureExtractor* arrayfeatureextractor) {
  clear_Type();
  if (arrayfeatureextractor) {
    set_has_arrayfeatureextractor();
    Type_.arrayfeatureextractor_ = arrayfeatureextractor;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.Model.arrayFeatureExtractor)
}

// .CoreML.Specification.NonMaximumSuppression nonMaximumSuppression = 610;
inline bool Model::has_nonmaximumsuppression() const {
  return Type_case() == kNonMaximumSuppression;
}
inline void Model::set_has_nonmaximumsuppression() {
  _oneof_case_[0] = kNonMaximumSuppression;
}
inline void Model::clear_nonmaximumsuppression() {
  if (has_nonmaximumsuppression()) {
    delete Type_.nonmaximumsuppression_;
    clear_has_Type();
  }
}
inline  const ::CoreML::Specification::NonMaximumSuppression& Model::nonmaximumsuppression() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.Model.nonMaximumSuppression)
  return has_nonmaximumsuppression()
      ? *Type_.nonmaximumsuppression_
      : ::CoreML::Specification::NonMaximumSuppression::default_instance();
}
inline ::CoreML::Specification::NonMaximumSuppression* Model::mutable_nonmaximumsuppression() {
  if (!has_nonmaximumsuppression()) {
    clear_Type();
    set_has_nonmaximumsuppression();
    Type_.nonmaximumsuppression_ = new ::CoreML::Specification::NonMaximumSuppression;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.Model.nonMaximumSuppression)
  return Type_.nonmaximumsuppression_;
}
inline ::CoreML::Specification::NonMaximumSuppression* Model::release_nonmaximumsuppression() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.Model.nonMaximumSuppression)
  if (has_nonmaximumsuppression()) {
    clear_has_Type();
    ::CoreML::Specification::NonMaximumSuppression* temp = Type_.nonmaximumsuppression_;
    Type_.nonmaximumsuppression_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Model::set_allocated_nonmaximumsuppression(::CoreML::Specification::NonMaximumSuppression* nonmaximumsuppression) {
  clear_Type();
  if (nonmaximumsuppression) {
    set_has_nonmaximumsuppression();
    Type_.nonmaximumsuppression_ = nonmaximumsuppression;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.Model.nonMaximumSuppression)
}

// .CoreML.Specification.Identity identity = 900;
inline bool Model::has_identity() const {
  return Type_case() == kIdentity;
}
inline void Model::set_has_identity() {
  _oneof_case_[0] = kIdentity;
}
inline void Model::clear_identity() {
  if (has_identity()) {
    delete Type_.identity_;
    clear_has_Type();
  }
}
inline  const ::CoreML::Specification::Identity& Model::identity() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.Model.identity)
  return has_identity()
      ? *Type_.identity_
      : ::CoreML::Specification::Identity::default_instance();
}
inline ::CoreML::Specification::Identity* Model::mutable_identity() {
  if (!has_identity()) {
    clear_Type();
    set_has_identity();
    Type_.identity_ = new ::CoreML::Specification::Identity;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.Model.identity)
  return Type_.identity_;
}
inline ::CoreML::Specification::Identity* Model::release_identity() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.Model.identity)
  if (has_identity()) {
    clear_has_Type();
    ::CoreML::Specification::Identity* temp = Type_.identity_;
    Type_.identity_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Model::set_allocated_identity(::CoreML::Specification::Identity* identity) {
  clear_Type();
  if (identity) {
    set_has_identity();
    Type_.identity_ = identity;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.Model.identity)
}

// .CoreML.Specification.CoreMLModels.TextClassifier textClassifier = 2000;
inline bool Model::has_textclassifier() const {
  return Type_case() == kTextClassifier;
}
inline void Model::set_has_textclassifier() {
  _oneof_case_[0] = kTextClassifier;
}
inline void Model::clear_textclassifier() {
  if (has_textclassifier()) {
    delete Type_.textclassifier_;
    clear_has_Type();
  }
}
inline  const ::CoreML::Specification::CoreMLModels::TextClassifier& Model::textclassifier() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.Model.textClassifier)
  return has_textclassifier()
      ? *Type_.textclassifier_
      : ::CoreML::Specification::CoreMLModels::TextClassifier::default_instance();
}
inline ::CoreML::Specification::CoreMLModels::TextClassifier* Model::mutable_textclassifier() {
  if (!has_textclassifier()) {
    clear_Type();
    set_has_textclassifier();
    Type_.textclassifier_ = new ::CoreML::Specification::CoreMLModels::TextClassifier;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.Model.textClassifier)
  return Type_.textclassifier_;
}
inline ::CoreML::Specification::CoreMLModels::TextClassifier* Model::release_textclassifier() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.Model.textClassifier)
  if (has_textclassifier()) {
    clear_has_Type();
    ::CoreML::Specification::CoreMLModels::TextClassifier* temp = Type_.textclassifier_;
    Type_.textclassifier_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Model::set_allocated_textclassifier(::CoreML::Specification::CoreMLModels::TextClassifier* textclassifier) {
  clear_Type();
  if (textclassifier) {
    set_has_textclassifier();
    Type_.textclassifier_ = textclassifier;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.Model.textClassifier)
}

// .CoreML.Specification.CoreMLModels.WordTagger wordTagger = 2001;
inline bool Model::has_wordtagger() const {
  return Type_case() == kWordTagger;
}
inline void Model::set_has_wordtagger() {
  _oneof_case_[0] = kWordTagger;
}
inline void Model::clear_wordtagger() {
  if (has_wordtagger()) {
    delete Type_.wordtagger_;
    clear_has_Type();
  }
}
inline  const ::CoreML::Specification::CoreMLModels::WordTagger& Model::wordtagger() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.Model.wordTagger)
  return has_wordtagger()
      ? *Type_.wordtagger_
      : ::CoreML::Specification::CoreMLModels::WordTagger::default_instance();
}
inline ::CoreML::Specification::CoreMLModels::WordTagger* Model::mutable_wordtagger() {
  if (!has_wordtagger()) {
    clear_Type();
    set_has_wordtagger();
    Type_.wordtagger_ = new ::CoreML::Specification::CoreMLModels::WordTagger;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.Model.wordTagger)
  return Type_.wordtagger_;
}
inline ::CoreML::Specification::CoreMLModels::WordTagger* Model::release_wordtagger() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.Model.wordTagger)
  if (has_wordtagger()) {
    clear_has_Type();
    ::CoreML::Specification::CoreMLModels::WordTagger* temp = Type_.wordtagger_;
    Type_.wordtagger_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Model::set_allocated_wordtagger(::CoreML::Specification::CoreMLModels::WordTagger* wordtagger) {
  clear_Type();
  if (wordtagger) {
    set_has_wordtagger();
    Type_.wordtagger_ = wordtagger;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.Model.wordTagger)
}

// .CoreML.Specification.CoreMLModels.VisionFeaturePrint visionFeaturePrint = 2002;
inline bool Model::has_visionfeatureprint() const {
  return Type_case() == kVisionFeaturePrint;
}
inline void Model::set_has_visionfeatureprint() {
  _oneof_case_[0] = kVisionFeaturePrint;
}
inline void Model::clear_visionfeatureprint() {
  if (has_visionfeatureprint()) {
    delete Type_.visionfeatureprint_;
    clear_has_Type();
  }
}
inline  const ::CoreML::Specification::CoreMLModels::VisionFeaturePrint& Model::visionfeatureprint() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.Model.visionFeaturePrint)
  return has_visionfeatureprint()
      ? *Type_.visionfeatureprint_
      : ::CoreML::Specification::CoreMLModels::VisionFeaturePrint::default_instance();
}
inline ::CoreML::Specification::CoreMLModels::VisionFeaturePrint* Model::mutable_visionfeatureprint() {
  if (!has_visionfeatureprint()) {
    clear_Type();
    set_has_visionfeatureprint();
    Type_.visionfeatureprint_ = new ::CoreML::Specification::CoreMLModels::VisionFeaturePrint;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.Model.visionFeaturePrint)
  return Type_.visionfeatureprint_;
}
inline ::CoreML::Specification::CoreMLModels::VisionFeaturePrint* Model::release_visionfeatureprint() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.Model.visionFeaturePrint)
  if (has_visionfeatureprint()) {
    clear_has_Type();
    ::CoreML::Specification::CoreMLModels::VisionFeaturePrint* temp = Type_.visionfeatureprint_;
    Type_.visionfeatureprint_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Model::set_allocated_visionfeatureprint(::CoreML::Specification::CoreMLModels::VisionFeaturePrint* visionfeatureprint) {
  clear_Type();
  if (visionfeatureprint) {
    set_has_visionfeatureprint();
    Type_.visionfeatureprint_ = visionfeatureprint;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.Model.visionFeaturePrint)
}

inline bool Model::has_Type() const {
  return Type_case() != TYPE_NOT_SET;
}
inline void Model::clear_has_Type() {
  _oneof_case_[0] = TYPE_NOT_SET;
}
inline Model::TypeCase Model::Type_case() const {
  return Model::TypeCase(_oneof_case_[0]);
}
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace Specification
}  // namespace CoreML

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_Model_2eproto__INCLUDED
