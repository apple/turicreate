// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: NeuralNetwork.proto

#ifndef PROTOBUF_NeuralNetwork_2eproto__INCLUDED
#define PROTOBUF_NeuralNetwork_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3003000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3003000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_field_lite.h>
#include <google/protobuf/generated_enum_util.h>
#include "DataStructures.pb.h"  // IWYU pragma: export
// @@protoc_insertion_point(includes)
namespace CoreML {
namespace Specification {
class ActivationELU;
class ActivationELUDefaultTypeInternal;
extern ActivationELUDefaultTypeInternal _ActivationELU_default_instance_;
class ActivationLeakyReLU;
class ActivationLeakyReLUDefaultTypeInternal;
extern ActivationLeakyReLUDefaultTypeInternal _ActivationLeakyReLU_default_instance_;
class ActivationLinear;
class ActivationLinearDefaultTypeInternal;
extern ActivationLinearDefaultTypeInternal _ActivationLinear_default_instance_;
class ActivationPReLU;
class ActivationPReLUDefaultTypeInternal;
extern ActivationPReLUDefaultTypeInternal _ActivationPReLU_default_instance_;
class ActivationParametricSoftplus;
class ActivationParametricSoftplusDefaultTypeInternal;
extern ActivationParametricSoftplusDefaultTypeInternal _ActivationParametricSoftplus_default_instance_;
class ActivationParams;
class ActivationParamsDefaultTypeInternal;
extern ActivationParamsDefaultTypeInternal _ActivationParams_default_instance_;
class ActivationReLU;
class ActivationReLUDefaultTypeInternal;
extern ActivationReLUDefaultTypeInternal _ActivationReLU_default_instance_;
class ActivationScaledTanh;
class ActivationScaledTanhDefaultTypeInternal;
extern ActivationScaledTanhDefaultTypeInternal _ActivationScaledTanh_default_instance_;
class ActivationSigmoid;
class ActivationSigmoidDefaultTypeInternal;
extern ActivationSigmoidDefaultTypeInternal _ActivationSigmoid_default_instance_;
class ActivationSigmoidHard;
class ActivationSigmoidHardDefaultTypeInternal;
extern ActivationSigmoidHardDefaultTypeInternal _ActivationSigmoidHard_default_instance_;
class ActivationSoftplus;
class ActivationSoftplusDefaultTypeInternal;
extern ActivationSoftplusDefaultTypeInternal _ActivationSoftplus_default_instance_;
class ActivationSoftsign;
class ActivationSoftsignDefaultTypeInternal;
extern ActivationSoftsignDefaultTypeInternal _ActivationSoftsign_default_instance_;
class ActivationTanh;
class ActivationTanhDefaultTypeInternal;
extern ActivationTanhDefaultTypeInternal _ActivationTanh_default_instance_;
class ActivationThresholdedReLU;
class ActivationThresholdedReLUDefaultTypeInternal;
extern ActivationThresholdedReLUDefaultTypeInternal _ActivationThresholdedReLU_default_instance_;
class AddLayerParams;
class AddLayerParamsDefaultTypeInternal;
extern AddLayerParamsDefaultTypeInternal _AddLayerParams_default_instance_;
class ArrayFeatureType;
class ArrayFeatureTypeDefaultTypeInternal;
extern ArrayFeatureTypeDefaultTypeInternal _ArrayFeatureType_default_instance_;
class ArrayFeatureType_EnumeratedShapes;
class ArrayFeatureType_EnumeratedShapesDefaultTypeInternal;
extern ArrayFeatureType_EnumeratedShapesDefaultTypeInternal _ArrayFeatureType_EnumeratedShapes_default_instance_;
class ArrayFeatureType_Shape;
class ArrayFeatureType_ShapeDefaultTypeInternal;
extern ArrayFeatureType_ShapeDefaultTypeInternal _ArrayFeatureType_Shape_default_instance_;
class ArrayFeatureType_ShapeRange;
class ArrayFeatureType_ShapeRangeDefaultTypeInternal;
extern ArrayFeatureType_ShapeRangeDefaultTypeInternal _ArrayFeatureType_ShapeRange_default_instance_;
class AverageLayerParams;
class AverageLayerParamsDefaultTypeInternal;
extern AverageLayerParamsDefaultTypeInternal _AverageLayerParams_default_instance_;
class BatchnormLayerParams;
class BatchnormLayerParamsDefaultTypeInternal;
extern BatchnormLayerParamsDefaultTypeInternal _BatchnormLayerParams_default_instance_;
class BiDirectionalLSTMLayerParams;
class BiDirectionalLSTMLayerParamsDefaultTypeInternal;
extern BiDirectionalLSTMLayerParamsDefaultTypeInternal _BiDirectionalLSTMLayerParams_default_instance_;
class BiasLayerParams;
class BiasLayerParamsDefaultTypeInternal;
extern BiasLayerParamsDefaultTypeInternal _BiasLayerParams_default_instance_;
class BorderAmounts;
class BorderAmountsDefaultTypeInternal;
extern BorderAmountsDefaultTypeInternal _BorderAmounts_default_instance_;
class BorderAmounts_EdgeSizes;
class BorderAmounts_EdgeSizesDefaultTypeInternal;
extern BorderAmounts_EdgeSizesDefaultTypeInternal _BorderAmounts_EdgeSizes_default_instance_;
class BoxCoordinatesMode;
class BoxCoordinatesModeDefaultTypeInternal;
extern BoxCoordinatesModeDefaultTypeInternal _BoxCoordinatesMode_default_instance_;
class ConcatLayerParams;
class ConcatLayerParamsDefaultTypeInternal;
extern ConcatLayerParamsDefaultTypeInternal _ConcatLayerParams_default_instance_;
class ConvolutionLayerParams;
class ConvolutionLayerParamsDefaultTypeInternal;
extern ConvolutionLayerParamsDefaultTypeInternal _ConvolutionLayerParams_default_instance_;
class CropLayerParams;
class CropLayerParamsDefaultTypeInternal;
extern CropLayerParamsDefaultTypeInternal _CropLayerParams_default_instance_;
class CropResizeLayerParams;
class CropResizeLayerParamsDefaultTypeInternal;
extern CropResizeLayerParamsDefaultTypeInternal _CropResizeLayerParams_default_instance_;
class CustomLayerParams;
class CustomLayerParamsDefaultTypeInternal;
extern CustomLayerParamsDefaultTypeInternal _CustomLayerParams_default_instance_;
class CustomLayerParams_CustomLayerParamValue;
class CustomLayerParams_CustomLayerParamValueDefaultTypeInternal;
extern CustomLayerParams_CustomLayerParamValueDefaultTypeInternal _CustomLayerParams_CustomLayerParamValue_default_instance_;
class CustomLayerParams_ParametersEntry;
class CustomLayerParams_ParametersEntryDefaultTypeInternal;
extern CustomLayerParams_ParametersEntryDefaultTypeInternal _CustomLayerParams_ParametersEntry_default_instance_;
class DictionaryFeatureType;
class DictionaryFeatureTypeDefaultTypeInternal;
extern DictionaryFeatureTypeDefaultTypeInternal _DictionaryFeatureType_default_instance_;
class DotProductLayerParams;
class DotProductLayerParamsDefaultTypeInternal;
extern DotProductLayerParamsDefaultTypeInternal _DotProductLayerParams_default_instance_;
class DoubleFeatureType;
class DoubleFeatureTypeDefaultTypeInternal;
extern DoubleFeatureTypeDefaultTypeInternal _DoubleFeatureType_default_instance_;
class DoubleVector;
class DoubleVectorDefaultTypeInternal;
extern DoubleVectorDefaultTypeInternal _DoubleVector_default_instance_;
class EmbeddingLayerParams;
class EmbeddingLayerParamsDefaultTypeInternal;
extern EmbeddingLayerParamsDefaultTypeInternal _EmbeddingLayerParams_default_instance_;
class FeatureType;
class FeatureTypeDefaultTypeInternal;
extern FeatureTypeDefaultTypeInternal _FeatureType_default_instance_;
class FlattenLayerParams;
class FlattenLayerParamsDefaultTypeInternal;
extern FlattenLayerParamsDefaultTypeInternal _FlattenLayerParams_default_instance_;
class GRULayerParams;
class GRULayerParamsDefaultTypeInternal;
extern GRULayerParamsDefaultTypeInternal _GRULayerParams_default_instance_;
class ImageFeatureType;
class ImageFeatureTypeDefaultTypeInternal;
extern ImageFeatureTypeDefaultTypeInternal _ImageFeatureType_default_instance_;
class ImageFeatureType_EnumeratedImageSizes;
class ImageFeatureType_EnumeratedImageSizesDefaultTypeInternal;
extern ImageFeatureType_EnumeratedImageSizesDefaultTypeInternal _ImageFeatureType_EnumeratedImageSizes_default_instance_;
class ImageFeatureType_ImageSize;
class ImageFeatureType_ImageSizeDefaultTypeInternal;
extern ImageFeatureType_ImageSizeDefaultTypeInternal _ImageFeatureType_ImageSize_default_instance_;
class ImageFeatureType_ImageSizeRange;
class ImageFeatureType_ImageSizeRangeDefaultTypeInternal;
extern ImageFeatureType_ImageSizeRangeDefaultTypeInternal _ImageFeatureType_ImageSizeRange_default_instance_;
class InnerProductLayerParams;
class InnerProductLayerParamsDefaultTypeInternal;
extern InnerProductLayerParamsDefaultTypeInternal _InnerProductLayerParams_default_instance_;
class Int64FeatureType;
class Int64FeatureTypeDefaultTypeInternal;
extern Int64FeatureTypeDefaultTypeInternal _Int64FeatureType_default_instance_;
class Int64ToDoubleMap;
class Int64ToDoubleMapDefaultTypeInternal;
extern Int64ToDoubleMapDefaultTypeInternal _Int64ToDoubleMap_default_instance_;
class Int64ToDoubleMap_MapEntry;
class Int64ToDoubleMap_MapEntryDefaultTypeInternal;
extern Int64ToDoubleMap_MapEntryDefaultTypeInternal _Int64ToDoubleMap_MapEntry_default_instance_;
class Int64ToStringMap;
class Int64ToStringMapDefaultTypeInternal;
extern Int64ToStringMapDefaultTypeInternal _Int64ToStringMap_default_instance_;
class Int64ToStringMap_MapEntry;
class Int64ToStringMap_MapEntryDefaultTypeInternal;
extern Int64ToStringMap_MapEntryDefaultTypeInternal _Int64ToStringMap_MapEntry_default_instance_;
class Int64Vector;
class Int64VectorDefaultTypeInternal;
extern Int64VectorDefaultTypeInternal _Int64Vector_default_instance_;
class L2NormalizeLayerParams;
class L2NormalizeLayerParamsDefaultTypeInternal;
extern L2NormalizeLayerParamsDefaultTypeInternal _L2NormalizeLayerParams_default_instance_;
class LRNLayerParams;
class LRNLayerParamsDefaultTypeInternal;
extern LRNLayerParamsDefaultTypeInternal _LRNLayerParams_default_instance_;
class LSTMParams;
class LSTMParamsDefaultTypeInternal;
extern LSTMParamsDefaultTypeInternal _LSTMParams_default_instance_;
class LSTMWeightParams;
class LSTMWeightParamsDefaultTypeInternal;
extern LSTMWeightParamsDefaultTypeInternal _LSTMWeightParams_default_instance_;
class LinearQuantizationParams;
class LinearQuantizationParamsDefaultTypeInternal;
extern LinearQuantizationParamsDefaultTypeInternal _LinearQuantizationParams_default_instance_;
class LoadConstantLayerParams;
class LoadConstantLayerParamsDefaultTypeInternal;
extern LoadConstantLayerParamsDefaultTypeInternal _LoadConstantLayerParams_default_instance_;
class LookUpTableQuantizationParams;
class LookUpTableQuantizationParamsDefaultTypeInternal;
extern LookUpTableQuantizationParamsDefaultTypeInternal _LookUpTableQuantizationParams_default_instance_;
class MaxLayerParams;
class MaxLayerParamsDefaultTypeInternal;
extern MaxLayerParamsDefaultTypeInternal _MaxLayerParams_default_instance_;
class MeanVarianceNormalizeLayerParams;
class MeanVarianceNormalizeLayerParamsDefaultTypeInternal;
extern MeanVarianceNormalizeLayerParamsDefaultTypeInternal _MeanVarianceNormalizeLayerParams_default_instance_;
class MinLayerParams;
class MinLayerParamsDefaultTypeInternal;
extern MinLayerParamsDefaultTypeInternal _MinLayerParams_default_instance_;
class MultiplyLayerParams;
class MultiplyLayerParamsDefaultTypeInternal;
extern MultiplyLayerParamsDefaultTypeInternal _MultiplyLayerParams_default_instance_;
class NeuralNetwork;
class NeuralNetworkDefaultTypeInternal;
extern NeuralNetworkDefaultTypeInternal _NeuralNetwork_default_instance_;
class NeuralNetworkClassifier;
class NeuralNetworkClassifierDefaultTypeInternal;
extern NeuralNetworkClassifierDefaultTypeInternal _NeuralNetworkClassifier_default_instance_;
class NeuralNetworkImageScaler;
class NeuralNetworkImageScalerDefaultTypeInternal;
extern NeuralNetworkImageScalerDefaultTypeInternal _NeuralNetworkImageScaler_default_instance_;
class NeuralNetworkLayer;
class NeuralNetworkLayerDefaultTypeInternal;
extern NeuralNetworkLayerDefaultTypeInternal _NeuralNetworkLayer_default_instance_;
class NeuralNetworkMeanImage;
class NeuralNetworkMeanImageDefaultTypeInternal;
extern NeuralNetworkMeanImageDefaultTypeInternal _NeuralNetworkMeanImage_default_instance_;
class NeuralNetworkPreprocessing;
class NeuralNetworkPreprocessingDefaultTypeInternal;
extern NeuralNetworkPreprocessingDefaultTypeInternal _NeuralNetworkPreprocessing_default_instance_;
class NeuralNetworkRegressor;
class NeuralNetworkRegressorDefaultTypeInternal;
extern NeuralNetworkRegressorDefaultTypeInternal _NeuralNetworkRegressor_default_instance_;
class PaddingLayerParams;
class PaddingLayerParamsDefaultTypeInternal;
extern PaddingLayerParamsDefaultTypeInternal _PaddingLayerParams_default_instance_;
class PaddingLayerParams_PaddingConstant;
class PaddingLayerParams_PaddingConstantDefaultTypeInternal;
extern PaddingLayerParams_PaddingConstantDefaultTypeInternal _PaddingLayerParams_PaddingConstant_default_instance_;
class PaddingLayerParams_PaddingReflection;
class PaddingLayerParams_PaddingReflectionDefaultTypeInternal;
extern PaddingLayerParams_PaddingReflectionDefaultTypeInternal _PaddingLayerParams_PaddingReflection_default_instance_;
class PaddingLayerParams_PaddingReplication;
class PaddingLayerParams_PaddingReplicationDefaultTypeInternal;
extern PaddingLayerParams_PaddingReplicationDefaultTypeInternal _PaddingLayerParams_PaddingReplication_default_instance_;
class PermuteLayerParams;
class PermuteLayerParamsDefaultTypeInternal;
extern PermuteLayerParamsDefaultTypeInternal _PermuteLayerParams_default_instance_;
class PoolingLayerParams;
class PoolingLayerParamsDefaultTypeInternal;
extern PoolingLayerParamsDefaultTypeInternal _PoolingLayerParams_default_instance_;
class PoolingLayerParams_ValidCompletePadding;
class PoolingLayerParams_ValidCompletePaddingDefaultTypeInternal;
extern PoolingLayerParams_ValidCompletePaddingDefaultTypeInternal _PoolingLayerParams_ValidCompletePadding_default_instance_;
class QuantizationParams;
class QuantizationParamsDefaultTypeInternal;
extern QuantizationParamsDefaultTypeInternal _QuantizationParams_default_instance_;
class ReduceLayerParams;
class ReduceLayerParamsDefaultTypeInternal;
extern ReduceLayerParamsDefaultTypeInternal _ReduceLayerParams_default_instance_;
class ReorganizeDataLayerParams;
class ReorganizeDataLayerParamsDefaultTypeInternal;
extern ReorganizeDataLayerParamsDefaultTypeInternal _ReorganizeDataLayerParams_default_instance_;
class ReshapeLayerParams;
class ReshapeLayerParamsDefaultTypeInternal;
extern ReshapeLayerParamsDefaultTypeInternal _ReshapeLayerParams_default_instance_;
class ResizeBilinearLayerParams;
class ResizeBilinearLayerParamsDefaultTypeInternal;
extern ResizeBilinearLayerParamsDefaultTypeInternal _ResizeBilinearLayerParams_default_instance_;
class SamePadding;
class SamePaddingDefaultTypeInternal;
extern SamePaddingDefaultTypeInternal _SamePadding_default_instance_;
class SamplingMode;
class SamplingModeDefaultTypeInternal;
extern SamplingModeDefaultTypeInternal _SamplingMode_default_instance_;
class ScaleLayerParams;
class ScaleLayerParamsDefaultTypeInternal;
extern ScaleLayerParamsDefaultTypeInternal _ScaleLayerParams_default_instance_;
class SequenceFeatureType;
class SequenceFeatureTypeDefaultTypeInternal;
extern SequenceFeatureTypeDefaultTypeInternal _SequenceFeatureType_default_instance_;
class SequenceRepeatLayerParams;
class SequenceRepeatLayerParamsDefaultTypeInternal;
extern SequenceRepeatLayerParamsDefaultTypeInternal _SequenceRepeatLayerParams_default_instance_;
class SimpleRecurrentLayerParams;
class SimpleRecurrentLayerParamsDefaultTypeInternal;
extern SimpleRecurrentLayerParamsDefaultTypeInternal _SimpleRecurrentLayerParams_default_instance_;
class SizeRange;
class SizeRangeDefaultTypeInternal;
extern SizeRangeDefaultTypeInternal _SizeRange_default_instance_;
class SliceLayerParams;
class SliceLayerParamsDefaultTypeInternal;
extern SliceLayerParamsDefaultTypeInternal _SliceLayerParams_default_instance_;
class SoftmaxLayerParams;
class SoftmaxLayerParamsDefaultTypeInternal;
extern SoftmaxLayerParamsDefaultTypeInternal _SoftmaxLayerParams_default_instance_;
class SplitLayerParams;
class SplitLayerParamsDefaultTypeInternal;
extern SplitLayerParamsDefaultTypeInternal _SplitLayerParams_default_instance_;
class StringFeatureType;
class StringFeatureTypeDefaultTypeInternal;
extern StringFeatureTypeDefaultTypeInternal _StringFeatureType_default_instance_;
class StringToDoubleMap;
class StringToDoubleMapDefaultTypeInternal;
extern StringToDoubleMapDefaultTypeInternal _StringToDoubleMap_default_instance_;
class StringToDoubleMap_MapEntry;
class StringToDoubleMap_MapEntryDefaultTypeInternal;
extern StringToDoubleMap_MapEntryDefaultTypeInternal _StringToDoubleMap_MapEntry_default_instance_;
class StringToInt64Map;
class StringToInt64MapDefaultTypeInternal;
extern StringToInt64MapDefaultTypeInternal _StringToInt64Map_default_instance_;
class StringToInt64Map_MapEntry;
class StringToInt64Map_MapEntryDefaultTypeInternal;
extern StringToInt64Map_MapEntryDefaultTypeInternal _StringToInt64Map_MapEntry_default_instance_;
class StringVector;
class StringVectorDefaultTypeInternal;
extern StringVectorDefaultTypeInternal _StringVector_default_instance_;
class UnaryFunctionLayerParams;
class UnaryFunctionLayerParamsDefaultTypeInternal;
extern UnaryFunctionLayerParamsDefaultTypeInternal _UnaryFunctionLayerParams_default_instance_;
class UniDirectionalLSTMLayerParams;
class UniDirectionalLSTMLayerParamsDefaultTypeInternal;
extern UniDirectionalLSTMLayerParamsDefaultTypeInternal _UniDirectionalLSTMLayerParams_default_instance_;
class UpsampleLayerParams;
class UpsampleLayerParamsDefaultTypeInternal;
extern UpsampleLayerParamsDefaultTypeInternal _UpsampleLayerParams_default_instance_;
class ValidPadding;
class ValidPaddingDefaultTypeInternal;
extern ValidPaddingDefaultTypeInternal _ValidPadding_default_instance_;
class WeightParams;
class WeightParamsDefaultTypeInternal;
extern WeightParamsDefaultTypeInternal _WeightParams_default_instance_;
}  // namespace Specification
}  // namespace CoreML

namespace CoreML {
namespace Specification {

namespace protobuf_NeuralNetwork_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static void InitDefaultsImpl();
  static void Shutdown();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_NeuralNetwork_2eproto

enum SamePadding_SamePaddingMode {
  SamePadding_SamePaddingMode_BOTTOM_RIGHT_HEAVY = 0,
  SamePadding_SamePaddingMode_TOP_LEFT_HEAVY = 1,
  SamePadding_SamePaddingMode_SamePadding_SamePaddingMode_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  SamePadding_SamePaddingMode_SamePadding_SamePaddingMode_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool SamePadding_SamePaddingMode_IsValid(int value);
const SamePadding_SamePaddingMode SamePadding_SamePaddingMode_SamePaddingMode_MIN = SamePadding_SamePaddingMode_BOTTOM_RIGHT_HEAVY;
const SamePadding_SamePaddingMode SamePadding_SamePaddingMode_SamePaddingMode_MAX = SamePadding_SamePaddingMode_TOP_LEFT_HEAVY;
const int SamePadding_SamePaddingMode_SamePaddingMode_ARRAYSIZE = SamePadding_SamePaddingMode_SamePaddingMode_MAX + 1;

enum SamplingMode_Method {
  SamplingMode_Method_STRICT_ALIGN_ENDPOINTS_MODE = 0,
  SamplingMode_Method_ALIGN_ENDPOINTS_MODE = 1,
  SamplingMode_Method_UPSAMPLE_MODE = 2,
  SamplingMode_Method_ROI_ALIGN_MODE = 3,
  SamplingMode_Method_SamplingMode_Method_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  SamplingMode_Method_SamplingMode_Method_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool SamplingMode_Method_IsValid(int value);
const SamplingMode_Method SamplingMode_Method_Method_MIN = SamplingMode_Method_STRICT_ALIGN_ENDPOINTS_MODE;
const SamplingMode_Method SamplingMode_Method_Method_MAX = SamplingMode_Method_ROI_ALIGN_MODE;
const int SamplingMode_Method_Method_ARRAYSIZE = SamplingMode_Method_Method_MAX + 1;

enum BoxCoordinatesMode_Coordinates {
  BoxCoordinatesMode_Coordinates_CORNERS_HEIGHT_FIRST = 0,
  BoxCoordinatesMode_Coordinates_CORNERS_WIDTH_FIRST = 1,
  BoxCoordinatesMode_Coordinates_CENTER_SIZE_HEIGHT_FIRST = 2,
  BoxCoordinatesMode_Coordinates_CENTER_SIZE_WIDTH_FIRST = 3,
  BoxCoordinatesMode_Coordinates_BoxCoordinatesMode_Coordinates_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  BoxCoordinatesMode_Coordinates_BoxCoordinatesMode_Coordinates_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool BoxCoordinatesMode_Coordinates_IsValid(int value);
const BoxCoordinatesMode_Coordinates BoxCoordinatesMode_Coordinates_Coordinates_MIN = BoxCoordinatesMode_Coordinates_CORNERS_HEIGHT_FIRST;
const BoxCoordinatesMode_Coordinates BoxCoordinatesMode_Coordinates_Coordinates_MAX = BoxCoordinatesMode_Coordinates_CENTER_SIZE_WIDTH_FIRST;
const int BoxCoordinatesMode_Coordinates_Coordinates_ARRAYSIZE = BoxCoordinatesMode_Coordinates_Coordinates_MAX + 1;

enum PoolingLayerParams_PoolingType {
  PoolingLayerParams_PoolingType_MAX = 0,
  PoolingLayerParams_PoolingType_AVERAGE = 1,
  PoolingLayerParams_PoolingType_L2 = 2,
  PoolingLayerParams_PoolingType_PoolingLayerParams_PoolingType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  PoolingLayerParams_PoolingType_PoolingLayerParams_PoolingType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool PoolingLayerParams_PoolingType_IsValid(int value);
const PoolingLayerParams_PoolingType PoolingLayerParams_PoolingType_PoolingType_MIN = PoolingLayerParams_PoolingType_MAX;
const PoolingLayerParams_PoolingType PoolingLayerParams_PoolingType_PoolingType_MAX = PoolingLayerParams_PoolingType_L2;
const int PoolingLayerParams_PoolingType_PoolingType_ARRAYSIZE = PoolingLayerParams_PoolingType_PoolingType_MAX + 1;

enum UnaryFunctionLayerParams_Operation {
  UnaryFunctionLayerParams_Operation_SQRT = 0,
  UnaryFunctionLayerParams_Operation_RSQRT = 1,
  UnaryFunctionLayerParams_Operation_INVERSE = 2,
  UnaryFunctionLayerParams_Operation_POWER = 3,
  UnaryFunctionLayerParams_Operation_EXP = 4,
  UnaryFunctionLayerParams_Operation_LOG = 5,
  UnaryFunctionLayerParams_Operation_ABS = 6,
  UnaryFunctionLayerParams_Operation_THRESHOLD = 7,
  UnaryFunctionLayerParams_Operation_UnaryFunctionLayerParams_Operation_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  UnaryFunctionLayerParams_Operation_UnaryFunctionLayerParams_Operation_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool UnaryFunctionLayerParams_Operation_IsValid(int value);
const UnaryFunctionLayerParams_Operation UnaryFunctionLayerParams_Operation_Operation_MIN = UnaryFunctionLayerParams_Operation_SQRT;
const UnaryFunctionLayerParams_Operation UnaryFunctionLayerParams_Operation_Operation_MAX = UnaryFunctionLayerParams_Operation_THRESHOLD;
const int UnaryFunctionLayerParams_Operation_Operation_ARRAYSIZE = UnaryFunctionLayerParams_Operation_Operation_MAX + 1;

enum UpsampleLayerParams_InterpolationMode {
  UpsampleLayerParams_InterpolationMode_NN = 0,
  UpsampleLayerParams_InterpolationMode_BILINEAR = 1,
  UpsampleLayerParams_InterpolationMode_UpsampleLayerParams_InterpolationMode_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  UpsampleLayerParams_InterpolationMode_UpsampleLayerParams_InterpolationMode_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool UpsampleLayerParams_InterpolationMode_IsValid(int value);
const UpsampleLayerParams_InterpolationMode UpsampleLayerParams_InterpolationMode_InterpolationMode_MIN = UpsampleLayerParams_InterpolationMode_NN;
const UpsampleLayerParams_InterpolationMode UpsampleLayerParams_InterpolationMode_InterpolationMode_MAX = UpsampleLayerParams_InterpolationMode_BILINEAR;
const int UpsampleLayerParams_InterpolationMode_InterpolationMode_ARRAYSIZE = UpsampleLayerParams_InterpolationMode_InterpolationMode_MAX + 1;

enum FlattenLayerParams_FlattenOrder {
  FlattenLayerParams_FlattenOrder_CHANNEL_FIRST = 0,
  FlattenLayerParams_FlattenOrder_CHANNEL_LAST = 1,
  FlattenLayerParams_FlattenOrder_FlattenLayerParams_FlattenOrder_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  FlattenLayerParams_FlattenOrder_FlattenLayerParams_FlattenOrder_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool FlattenLayerParams_FlattenOrder_IsValid(int value);
const FlattenLayerParams_FlattenOrder FlattenLayerParams_FlattenOrder_FlattenOrder_MIN = FlattenLayerParams_FlattenOrder_CHANNEL_FIRST;
const FlattenLayerParams_FlattenOrder FlattenLayerParams_FlattenOrder_FlattenOrder_MAX = FlattenLayerParams_FlattenOrder_CHANNEL_LAST;
const int FlattenLayerParams_FlattenOrder_FlattenOrder_ARRAYSIZE = FlattenLayerParams_FlattenOrder_FlattenOrder_MAX + 1;

enum ReshapeLayerParams_ReshapeOrder {
  ReshapeLayerParams_ReshapeOrder_CHANNEL_FIRST = 0,
  ReshapeLayerParams_ReshapeOrder_CHANNEL_LAST = 1,
  ReshapeLayerParams_ReshapeOrder_ReshapeLayerParams_ReshapeOrder_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ReshapeLayerParams_ReshapeOrder_ReshapeLayerParams_ReshapeOrder_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ReshapeLayerParams_ReshapeOrder_IsValid(int value);
const ReshapeLayerParams_ReshapeOrder ReshapeLayerParams_ReshapeOrder_ReshapeOrder_MIN = ReshapeLayerParams_ReshapeOrder_CHANNEL_FIRST;
const ReshapeLayerParams_ReshapeOrder ReshapeLayerParams_ReshapeOrder_ReshapeOrder_MAX = ReshapeLayerParams_ReshapeOrder_CHANNEL_LAST;
const int ReshapeLayerParams_ReshapeOrder_ReshapeOrder_ARRAYSIZE = ReshapeLayerParams_ReshapeOrder_ReshapeOrder_MAX + 1;

enum ReorganizeDataLayerParams_ReorganizationType {
  ReorganizeDataLayerParams_ReorganizationType_SPACE_TO_DEPTH = 0,
  ReorganizeDataLayerParams_ReorganizationType_DEPTH_TO_SPACE = 1,
  ReorganizeDataLayerParams_ReorganizationType_ReorganizeDataLayerParams_ReorganizationType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ReorganizeDataLayerParams_ReorganizationType_ReorganizeDataLayerParams_ReorganizationType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ReorganizeDataLayerParams_ReorganizationType_IsValid(int value);
const ReorganizeDataLayerParams_ReorganizationType ReorganizeDataLayerParams_ReorganizationType_ReorganizationType_MIN = ReorganizeDataLayerParams_ReorganizationType_SPACE_TO_DEPTH;
const ReorganizeDataLayerParams_ReorganizationType ReorganizeDataLayerParams_ReorganizationType_ReorganizationType_MAX = ReorganizeDataLayerParams_ReorganizationType_DEPTH_TO_SPACE;
const int ReorganizeDataLayerParams_ReorganizationType_ReorganizationType_ARRAYSIZE = ReorganizeDataLayerParams_ReorganizationType_ReorganizationType_MAX + 1;

enum SliceLayerParams_SliceAxis {
  SliceLayerParams_SliceAxis_CHANNEL_AXIS = 0,
  SliceLayerParams_SliceAxis_HEIGHT_AXIS = 1,
  SliceLayerParams_SliceAxis_WIDTH_AXIS = 2,
  SliceLayerParams_SliceAxis_SliceLayerParams_SliceAxis_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  SliceLayerParams_SliceAxis_SliceLayerParams_SliceAxis_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool SliceLayerParams_SliceAxis_IsValid(int value);
const SliceLayerParams_SliceAxis SliceLayerParams_SliceAxis_SliceAxis_MIN = SliceLayerParams_SliceAxis_CHANNEL_AXIS;
const SliceLayerParams_SliceAxis SliceLayerParams_SliceAxis_SliceAxis_MAX = SliceLayerParams_SliceAxis_WIDTH_AXIS;
const int SliceLayerParams_SliceAxis_SliceAxis_ARRAYSIZE = SliceLayerParams_SliceAxis_SliceAxis_MAX + 1;

enum ReduceLayerParams_ReduceOperation {
  ReduceLayerParams_ReduceOperation_SUM = 0,
  ReduceLayerParams_ReduceOperation_AVG = 1,
  ReduceLayerParams_ReduceOperation_PROD = 2,
  ReduceLayerParams_ReduceOperation_LOGSUM = 3,
  ReduceLayerParams_ReduceOperation_SUMSQUARE = 4,
  ReduceLayerParams_ReduceOperation_L1 = 5,
  ReduceLayerParams_ReduceOperation_L2 = 6,
  ReduceLayerParams_ReduceOperation_MAX = 7,
  ReduceLayerParams_ReduceOperation_MIN = 8,
  ReduceLayerParams_ReduceOperation_ARGMAX = 9,
  ReduceLayerParams_ReduceOperation_ReduceLayerParams_ReduceOperation_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ReduceLayerParams_ReduceOperation_ReduceLayerParams_ReduceOperation_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ReduceLayerParams_ReduceOperation_IsValid(int value);
const ReduceLayerParams_ReduceOperation ReduceLayerParams_ReduceOperation_ReduceOperation_MIN = ReduceLayerParams_ReduceOperation_SUM;
const ReduceLayerParams_ReduceOperation ReduceLayerParams_ReduceOperation_ReduceOperation_MAX = ReduceLayerParams_ReduceOperation_ARGMAX;
const int ReduceLayerParams_ReduceOperation_ReduceOperation_ARRAYSIZE = ReduceLayerParams_ReduceOperation_ReduceOperation_MAX + 1;

enum ReduceLayerParams_ReduceAxis {
  ReduceLayerParams_ReduceAxis_CHW = 0,
  ReduceLayerParams_ReduceAxis_HW = 1,
  ReduceLayerParams_ReduceAxis_C = 2,
  ReduceLayerParams_ReduceAxis_H = 3,
  ReduceLayerParams_ReduceAxis_W = 4,
  ReduceLayerParams_ReduceAxis_ReduceLayerParams_ReduceAxis_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ReduceLayerParams_ReduceAxis_ReduceLayerParams_ReduceAxis_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ReduceLayerParams_ReduceAxis_IsValid(int value);
const ReduceLayerParams_ReduceAxis ReduceLayerParams_ReduceAxis_ReduceAxis_MIN = ReduceLayerParams_ReduceAxis_CHW;
const ReduceLayerParams_ReduceAxis ReduceLayerParams_ReduceAxis_ReduceAxis_MAX = ReduceLayerParams_ReduceAxis_W;
const int ReduceLayerParams_ReduceAxis_ReduceAxis_ARRAYSIZE = ReduceLayerParams_ReduceAxis_ReduceAxis_MAX + 1;

// ===================================================================

class NeuralNetwork : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.NeuralNetwork) */ {
 public:
  NeuralNetwork();
  virtual ~NeuralNetwork();

  NeuralNetwork(const NeuralNetwork& from);

  inline NeuralNetwork& operator=(const NeuralNetwork& from) {
    CopyFrom(from);
    return *this;
  }

  static const NeuralNetwork& default_instance();

  static inline const NeuralNetwork* internal_default_instance() {
    return reinterpret_cast<const NeuralNetwork*>(
               &_NeuralNetwork_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(NeuralNetwork* other);

  // implements Message ----------------------------------------------

  inline NeuralNetwork* New() const PROTOBUF_FINAL { return New(NULL); }

  NeuralNetwork* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const NeuralNetwork& from);
  void MergeFrom(const NeuralNetwork& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(NeuralNetwork* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .CoreML.Specification.NeuralNetworkLayer layers = 1;
  int layers_size() const;
  void clear_layers();
  static const int kLayersFieldNumber = 1;
  const ::CoreML::Specification::NeuralNetworkLayer& layers(int index) const;
  ::CoreML::Specification::NeuralNetworkLayer* mutable_layers(int index);
  ::CoreML::Specification::NeuralNetworkLayer* add_layers();
  ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::NeuralNetworkLayer >*
      mutable_layers();
  const ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::NeuralNetworkLayer >&
      layers() const;

  // repeated .CoreML.Specification.NeuralNetworkPreprocessing preprocessing = 2;
  int preprocessing_size() const;
  void clear_preprocessing();
  static const int kPreprocessingFieldNumber = 2;
  const ::CoreML::Specification::NeuralNetworkPreprocessing& preprocessing(int index) const;
  ::CoreML::Specification::NeuralNetworkPreprocessing* mutable_preprocessing(int index);
  ::CoreML::Specification::NeuralNetworkPreprocessing* add_preprocessing();
  ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::NeuralNetworkPreprocessing >*
      mutable_preprocessing();
  const ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::NeuralNetworkPreprocessing >&
      preprocessing() const;

  // @@protoc_insertion_point(class_scope:CoreML.Specification.NeuralNetwork)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::NeuralNetworkLayer > layers_;
  ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::NeuralNetworkPreprocessing > preprocessing_;
  mutable int _cached_size_;
  friend struct protobuf_NeuralNetwork_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class NeuralNetworkImageScaler : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.NeuralNetworkImageScaler) */ {
 public:
  NeuralNetworkImageScaler();
  virtual ~NeuralNetworkImageScaler();

  NeuralNetworkImageScaler(const NeuralNetworkImageScaler& from);

  inline NeuralNetworkImageScaler& operator=(const NeuralNetworkImageScaler& from) {
    CopyFrom(from);
    return *this;
  }

  static const NeuralNetworkImageScaler& default_instance();

  static inline const NeuralNetworkImageScaler* internal_default_instance() {
    return reinterpret_cast<const NeuralNetworkImageScaler*>(
               &_NeuralNetworkImageScaler_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(NeuralNetworkImageScaler* other);

  // implements Message ----------------------------------------------

  inline NeuralNetworkImageScaler* New() const PROTOBUF_FINAL { return New(NULL); }

  NeuralNetworkImageScaler* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const NeuralNetworkImageScaler& from);
  void MergeFrom(const NeuralNetworkImageScaler& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(NeuralNetworkImageScaler* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float grayBias = 30;
  void clear_graybias();
  static const int kGrayBiasFieldNumber = 30;
  float graybias() const;
  void set_graybias(float value);

  // float channelScale = 10;
  void clear_channelscale();
  static const int kChannelScaleFieldNumber = 10;
  float channelscale() const;
  void set_channelscale(float value);

  // float blueBias = 20;
  void clear_bluebias();
  static const int kBlueBiasFieldNumber = 20;
  float bluebias() const;
  void set_bluebias(float value);

  // float greenBias = 21;
  void clear_greenbias();
  static const int kGreenBiasFieldNumber = 21;
  float greenbias() const;
  void set_greenbias(float value);

  // float redBias = 22;
  void clear_redbias();
  static const int kRedBiasFieldNumber = 22;
  float redbias() const;
  void set_redbias(float value);

  // @@protoc_insertion_point(class_scope:CoreML.Specification.NeuralNetworkImageScaler)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  float graybias_;
  float channelscale_;
  float bluebias_;
  float greenbias_;
  float redbias_;
  mutable int _cached_size_;
  friend struct protobuf_NeuralNetwork_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class NeuralNetworkMeanImage : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.NeuralNetworkMeanImage) */ {
 public:
  NeuralNetworkMeanImage();
  virtual ~NeuralNetworkMeanImage();

  NeuralNetworkMeanImage(const NeuralNetworkMeanImage& from);

  inline NeuralNetworkMeanImage& operator=(const NeuralNetworkMeanImage& from) {
    CopyFrom(from);
    return *this;
  }

  static const NeuralNetworkMeanImage& default_instance();

  static inline const NeuralNetworkMeanImage* internal_default_instance() {
    return reinterpret_cast<const NeuralNetworkMeanImage*>(
               &_NeuralNetworkMeanImage_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(NeuralNetworkMeanImage* other);

  // implements Message ----------------------------------------------

  inline NeuralNetworkMeanImage* New() const PROTOBUF_FINAL { return New(NULL); }

  NeuralNetworkMeanImage* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const NeuralNetworkMeanImage& from);
  void MergeFrom(const NeuralNetworkMeanImage& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(NeuralNetworkMeanImage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated float meanImage = 1;
  int meanimage_size() const;
  void clear_meanimage();
  static const int kMeanImageFieldNumber = 1;
  float meanimage(int index) const;
  void set_meanimage(int index, float value);
  void add_meanimage(float value);
  const ::google::protobuf::RepeatedField< float >&
      meanimage() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_meanimage();

  // @@protoc_insertion_point(class_scope:CoreML.Specification.NeuralNetworkMeanImage)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedField< float > meanimage_;
  mutable int _meanimage_cached_byte_size_;
  mutable int _cached_size_;
  friend struct protobuf_NeuralNetwork_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class NeuralNetworkPreprocessing : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.NeuralNetworkPreprocessing) */ {
 public:
  NeuralNetworkPreprocessing();
  virtual ~NeuralNetworkPreprocessing();

  NeuralNetworkPreprocessing(const NeuralNetworkPreprocessing& from);

  inline NeuralNetworkPreprocessing& operator=(const NeuralNetworkPreprocessing& from) {
    CopyFrom(from);
    return *this;
  }

  static const NeuralNetworkPreprocessing& default_instance();

  enum PreprocessorCase {
    kScaler = 10,
    kMeanImage = 11,
    PREPROCESSOR_NOT_SET = 0,
  };

  static inline const NeuralNetworkPreprocessing* internal_default_instance() {
    return reinterpret_cast<const NeuralNetworkPreprocessing*>(
               &_NeuralNetworkPreprocessing_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(NeuralNetworkPreprocessing* other);

  // implements Message ----------------------------------------------

  inline NeuralNetworkPreprocessing* New() const PROTOBUF_FINAL { return New(NULL); }

  NeuralNetworkPreprocessing* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const NeuralNetworkPreprocessing& from);
  void MergeFrom(const NeuralNetworkPreprocessing& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(NeuralNetworkPreprocessing* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string featureName = 1;
  void clear_featurename();
  static const int kFeatureNameFieldNumber = 1;
  const ::std::string& featurename() const;
  void set_featurename(const ::std::string& value);
  #if LANG_CXX11
  void set_featurename(::std::string&& value);
  #endif
  void set_featurename(const char* value);
  void set_featurename(const char* value, size_t size);
  ::std::string* mutable_featurename();
  ::std::string* release_featurename();
  void set_allocated_featurename(::std::string* featurename);

  // .CoreML.Specification.NeuralNetworkImageScaler scaler = 10;
  bool has_scaler() const;
  void clear_scaler();
  static const int kScalerFieldNumber = 10;
  const ::CoreML::Specification::NeuralNetworkImageScaler& scaler() const;
  ::CoreML::Specification::NeuralNetworkImageScaler* mutable_scaler();
  ::CoreML::Specification::NeuralNetworkImageScaler* release_scaler();
  void set_allocated_scaler(::CoreML::Specification::NeuralNetworkImageScaler* scaler);

  // .CoreML.Specification.NeuralNetworkMeanImage meanImage = 11;
  bool has_meanimage() const;
  void clear_meanimage();
  static const int kMeanImageFieldNumber = 11;
  const ::CoreML::Specification::NeuralNetworkMeanImage& meanimage() const;
  ::CoreML::Specification::NeuralNetworkMeanImage* mutable_meanimage();
  ::CoreML::Specification::NeuralNetworkMeanImage* release_meanimage();
  void set_allocated_meanimage(::CoreML::Specification::NeuralNetworkMeanImage* meanimage);

  PreprocessorCase preprocessor_case() const;
  // @@protoc_insertion_point(class_scope:CoreML.Specification.NeuralNetworkPreprocessing)
 private:
  void set_has_scaler();
  void set_has_meanimage();

  inline bool has_preprocessor() const;
  void clear_preprocessor();
  inline void clear_has_preprocessor();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr featurename_;
  union PreprocessorUnion {
    PreprocessorUnion() {}
    ::CoreML::Specification::NeuralNetworkImageScaler* scaler_;
    ::CoreML::Specification::NeuralNetworkMeanImage* meanimage_;
  } preprocessor_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct protobuf_NeuralNetwork_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ActivationReLU : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.ActivationReLU) */ {
 public:
  ActivationReLU();
  virtual ~ActivationReLU();

  ActivationReLU(const ActivationReLU& from);

  inline ActivationReLU& operator=(const ActivationReLU& from) {
    CopyFrom(from);
    return *this;
  }

  static const ActivationReLU& default_instance();

  static inline const ActivationReLU* internal_default_instance() {
    return reinterpret_cast<const ActivationReLU*>(
               &_ActivationReLU_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(ActivationReLU* other);

  // implements Message ----------------------------------------------

  inline ActivationReLU* New() const PROTOBUF_FINAL { return New(NULL); }

  ActivationReLU* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const ActivationReLU& from);
  void MergeFrom(const ActivationReLU& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ActivationReLU* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:CoreML.Specification.ActivationReLU)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  mutable int _cached_size_;
  friend struct protobuf_NeuralNetwork_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ActivationLeakyReLU : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.ActivationLeakyReLU) */ {
 public:
  ActivationLeakyReLU();
  virtual ~ActivationLeakyReLU();

  ActivationLeakyReLU(const ActivationLeakyReLU& from);

  inline ActivationLeakyReLU& operator=(const ActivationLeakyReLU& from) {
    CopyFrom(from);
    return *this;
  }

  static const ActivationLeakyReLU& default_instance();

  static inline const ActivationLeakyReLU* internal_default_instance() {
    return reinterpret_cast<const ActivationLeakyReLU*>(
               &_ActivationLeakyReLU_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(ActivationLeakyReLU* other);

  // implements Message ----------------------------------------------

  inline ActivationLeakyReLU* New() const PROTOBUF_FINAL { return New(NULL); }

  ActivationLeakyReLU* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const ActivationLeakyReLU& from);
  void MergeFrom(const ActivationLeakyReLU& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ActivationLeakyReLU* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float alpha = 1;
  void clear_alpha();
  static const int kAlphaFieldNumber = 1;
  float alpha() const;
  void set_alpha(float value);

  // @@protoc_insertion_point(class_scope:CoreML.Specification.ActivationLeakyReLU)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  float alpha_;
  mutable int _cached_size_;
  friend struct protobuf_NeuralNetwork_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ActivationTanh : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.ActivationTanh) */ {
 public:
  ActivationTanh();
  virtual ~ActivationTanh();

  ActivationTanh(const ActivationTanh& from);

  inline ActivationTanh& operator=(const ActivationTanh& from) {
    CopyFrom(from);
    return *this;
  }

  static const ActivationTanh& default_instance();

  static inline const ActivationTanh* internal_default_instance() {
    return reinterpret_cast<const ActivationTanh*>(
               &_ActivationTanh_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(ActivationTanh* other);

  // implements Message ----------------------------------------------

  inline ActivationTanh* New() const PROTOBUF_FINAL { return New(NULL); }

  ActivationTanh* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const ActivationTanh& from);
  void MergeFrom(const ActivationTanh& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ActivationTanh* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:CoreML.Specification.ActivationTanh)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  mutable int _cached_size_;
  friend struct protobuf_NeuralNetwork_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ActivationScaledTanh : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.ActivationScaledTanh) */ {
 public:
  ActivationScaledTanh();
  virtual ~ActivationScaledTanh();

  ActivationScaledTanh(const ActivationScaledTanh& from);

  inline ActivationScaledTanh& operator=(const ActivationScaledTanh& from) {
    CopyFrom(from);
    return *this;
  }

  static const ActivationScaledTanh& default_instance();

  static inline const ActivationScaledTanh* internal_default_instance() {
    return reinterpret_cast<const ActivationScaledTanh*>(
               &_ActivationScaledTanh_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(ActivationScaledTanh* other);

  // implements Message ----------------------------------------------

  inline ActivationScaledTanh* New() const PROTOBUF_FINAL { return New(NULL); }

  ActivationScaledTanh* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const ActivationScaledTanh& from);
  void MergeFrom(const ActivationScaledTanh& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ActivationScaledTanh* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float alpha = 1;
  void clear_alpha();
  static const int kAlphaFieldNumber = 1;
  float alpha() const;
  void set_alpha(float value);

  // float beta = 2;
  void clear_beta();
  static const int kBetaFieldNumber = 2;
  float beta() const;
  void set_beta(float value);

  // @@protoc_insertion_point(class_scope:CoreML.Specification.ActivationScaledTanh)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  float alpha_;
  float beta_;
  mutable int _cached_size_;
  friend struct protobuf_NeuralNetwork_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ActivationSigmoid : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.ActivationSigmoid) */ {
 public:
  ActivationSigmoid();
  virtual ~ActivationSigmoid();

  ActivationSigmoid(const ActivationSigmoid& from);

  inline ActivationSigmoid& operator=(const ActivationSigmoid& from) {
    CopyFrom(from);
    return *this;
  }

  static const ActivationSigmoid& default_instance();

  static inline const ActivationSigmoid* internal_default_instance() {
    return reinterpret_cast<const ActivationSigmoid*>(
               &_ActivationSigmoid_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(ActivationSigmoid* other);

  // implements Message ----------------------------------------------

  inline ActivationSigmoid* New() const PROTOBUF_FINAL { return New(NULL); }

  ActivationSigmoid* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const ActivationSigmoid& from);
  void MergeFrom(const ActivationSigmoid& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ActivationSigmoid* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:CoreML.Specification.ActivationSigmoid)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  mutable int _cached_size_;
  friend struct protobuf_NeuralNetwork_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ActivationLinear : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.ActivationLinear) */ {
 public:
  ActivationLinear();
  virtual ~ActivationLinear();

  ActivationLinear(const ActivationLinear& from);

  inline ActivationLinear& operator=(const ActivationLinear& from) {
    CopyFrom(from);
    return *this;
  }

  static const ActivationLinear& default_instance();

  static inline const ActivationLinear* internal_default_instance() {
    return reinterpret_cast<const ActivationLinear*>(
               &_ActivationLinear_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(ActivationLinear* other);

  // implements Message ----------------------------------------------

  inline ActivationLinear* New() const PROTOBUF_FINAL { return New(NULL); }

  ActivationLinear* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const ActivationLinear& from);
  void MergeFrom(const ActivationLinear& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ActivationLinear* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float alpha = 1;
  void clear_alpha();
  static const int kAlphaFieldNumber = 1;
  float alpha() const;
  void set_alpha(float value);

  // float beta = 2;
  void clear_beta();
  static const int kBetaFieldNumber = 2;
  float beta() const;
  void set_beta(float value);

  // @@protoc_insertion_point(class_scope:CoreML.Specification.ActivationLinear)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  float alpha_;
  float beta_;
  mutable int _cached_size_;
  friend struct protobuf_NeuralNetwork_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ActivationSigmoidHard : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.ActivationSigmoidHard) */ {
 public:
  ActivationSigmoidHard();
  virtual ~ActivationSigmoidHard();

  ActivationSigmoidHard(const ActivationSigmoidHard& from);

  inline ActivationSigmoidHard& operator=(const ActivationSigmoidHard& from) {
    CopyFrom(from);
    return *this;
  }

  static const ActivationSigmoidHard& default_instance();

  static inline const ActivationSigmoidHard* internal_default_instance() {
    return reinterpret_cast<const ActivationSigmoidHard*>(
               &_ActivationSigmoidHard_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(ActivationSigmoidHard* other);

  // implements Message ----------------------------------------------

  inline ActivationSigmoidHard* New() const PROTOBUF_FINAL { return New(NULL); }

  ActivationSigmoidHard* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const ActivationSigmoidHard& from);
  void MergeFrom(const ActivationSigmoidHard& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ActivationSigmoidHard* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float alpha = 1;
  void clear_alpha();
  static const int kAlphaFieldNumber = 1;
  float alpha() const;
  void set_alpha(float value);

  // float beta = 2;
  void clear_beta();
  static const int kBetaFieldNumber = 2;
  float beta() const;
  void set_beta(float value);

  // @@protoc_insertion_point(class_scope:CoreML.Specification.ActivationSigmoidHard)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  float alpha_;
  float beta_;
  mutable int _cached_size_;
  friend struct protobuf_NeuralNetwork_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ActivationPReLU : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.ActivationPReLU) */ {
 public:
  ActivationPReLU();
  virtual ~ActivationPReLU();

  ActivationPReLU(const ActivationPReLU& from);

  inline ActivationPReLU& operator=(const ActivationPReLU& from) {
    CopyFrom(from);
    return *this;
  }

  static const ActivationPReLU& default_instance();

  static inline const ActivationPReLU* internal_default_instance() {
    return reinterpret_cast<const ActivationPReLU*>(
               &_ActivationPReLU_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    11;

  void Swap(ActivationPReLU* other);

  // implements Message ----------------------------------------------

  inline ActivationPReLU* New() const PROTOBUF_FINAL { return New(NULL); }

  ActivationPReLU* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const ActivationPReLU& from);
  void MergeFrom(const ActivationPReLU& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ActivationPReLU* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .CoreML.Specification.WeightParams alpha = 1;
  bool has_alpha() const;
  void clear_alpha();
  static const int kAlphaFieldNumber = 1;
  const ::CoreML::Specification::WeightParams& alpha() const;
  ::CoreML::Specification::WeightParams* mutable_alpha();
  ::CoreML::Specification::WeightParams* release_alpha();
  void set_allocated_alpha(::CoreML::Specification::WeightParams* alpha);

  // @@protoc_insertion_point(class_scope:CoreML.Specification.ActivationPReLU)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::CoreML::Specification::WeightParams* alpha_;
  mutable int _cached_size_;
  friend struct protobuf_NeuralNetwork_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ActivationELU : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.ActivationELU) */ {
 public:
  ActivationELU();
  virtual ~ActivationELU();

  ActivationELU(const ActivationELU& from);

  inline ActivationELU& operator=(const ActivationELU& from) {
    CopyFrom(from);
    return *this;
  }

  static const ActivationELU& default_instance();

  static inline const ActivationELU* internal_default_instance() {
    return reinterpret_cast<const ActivationELU*>(
               &_ActivationELU_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    12;

  void Swap(ActivationELU* other);

  // implements Message ----------------------------------------------

  inline ActivationELU* New() const PROTOBUF_FINAL { return New(NULL); }

  ActivationELU* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const ActivationELU& from);
  void MergeFrom(const ActivationELU& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ActivationELU* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float alpha = 1;
  void clear_alpha();
  static const int kAlphaFieldNumber = 1;
  float alpha() const;
  void set_alpha(float value);

  // @@protoc_insertion_point(class_scope:CoreML.Specification.ActivationELU)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  float alpha_;
  mutable int _cached_size_;
  friend struct protobuf_NeuralNetwork_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ActivationThresholdedReLU : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.ActivationThresholdedReLU) */ {
 public:
  ActivationThresholdedReLU();
  virtual ~ActivationThresholdedReLU();

  ActivationThresholdedReLU(const ActivationThresholdedReLU& from);

  inline ActivationThresholdedReLU& operator=(const ActivationThresholdedReLU& from) {
    CopyFrom(from);
    return *this;
  }

  static const ActivationThresholdedReLU& default_instance();

  static inline const ActivationThresholdedReLU* internal_default_instance() {
    return reinterpret_cast<const ActivationThresholdedReLU*>(
               &_ActivationThresholdedReLU_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    13;

  void Swap(ActivationThresholdedReLU* other);

  // implements Message ----------------------------------------------

  inline ActivationThresholdedReLU* New() const PROTOBUF_FINAL { return New(NULL); }

  ActivationThresholdedReLU* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const ActivationThresholdedReLU& from);
  void MergeFrom(const ActivationThresholdedReLU& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ActivationThresholdedReLU* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float alpha = 1;
  void clear_alpha();
  static const int kAlphaFieldNumber = 1;
  float alpha() const;
  void set_alpha(float value);

  // @@protoc_insertion_point(class_scope:CoreML.Specification.ActivationThresholdedReLU)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  float alpha_;
  mutable int _cached_size_;
  friend struct protobuf_NeuralNetwork_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ActivationSoftsign : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.ActivationSoftsign) */ {
 public:
  ActivationSoftsign();
  virtual ~ActivationSoftsign();

  ActivationSoftsign(const ActivationSoftsign& from);

  inline ActivationSoftsign& operator=(const ActivationSoftsign& from) {
    CopyFrom(from);
    return *this;
  }

  static const ActivationSoftsign& default_instance();

  static inline const ActivationSoftsign* internal_default_instance() {
    return reinterpret_cast<const ActivationSoftsign*>(
               &_ActivationSoftsign_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    14;

  void Swap(ActivationSoftsign* other);

  // implements Message ----------------------------------------------

  inline ActivationSoftsign* New() const PROTOBUF_FINAL { return New(NULL); }

  ActivationSoftsign* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const ActivationSoftsign& from);
  void MergeFrom(const ActivationSoftsign& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ActivationSoftsign* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:CoreML.Specification.ActivationSoftsign)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  mutable int _cached_size_;
  friend struct protobuf_NeuralNetwork_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ActivationSoftplus : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.ActivationSoftplus) */ {
 public:
  ActivationSoftplus();
  virtual ~ActivationSoftplus();

  ActivationSoftplus(const ActivationSoftplus& from);

  inline ActivationSoftplus& operator=(const ActivationSoftplus& from) {
    CopyFrom(from);
    return *this;
  }

  static const ActivationSoftplus& default_instance();

  static inline const ActivationSoftplus* internal_default_instance() {
    return reinterpret_cast<const ActivationSoftplus*>(
               &_ActivationSoftplus_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    15;

  void Swap(ActivationSoftplus* other);

  // implements Message ----------------------------------------------

  inline ActivationSoftplus* New() const PROTOBUF_FINAL { return New(NULL); }

  ActivationSoftplus* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const ActivationSoftplus& from);
  void MergeFrom(const ActivationSoftplus& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ActivationSoftplus* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:CoreML.Specification.ActivationSoftplus)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  mutable int _cached_size_;
  friend struct protobuf_NeuralNetwork_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ActivationParametricSoftplus : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.ActivationParametricSoftplus) */ {
 public:
  ActivationParametricSoftplus();
  virtual ~ActivationParametricSoftplus();

  ActivationParametricSoftplus(const ActivationParametricSoftplus& from);

  inline ActivationParametricSoftplus& operator=(const ActivationParametricSoftplus& from) {
    CopyFrom(from);
    return *this;
  }

  static const ActivationParametricSoftplus& default_instance();

  static inline const ActivationParametricSoftplus* internal_default_instance() {
    return reinterpret_cast<const ActivationParametricSoftplus*>(
               &_ActivationParametricSoftplus_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    16;

  void Swap(ActivationParametricSoftplus* other);

  // implements Message ----------------------------------------------

  inline ActivationParametricSoftplus* New() const PROTOBUF_FINAL { return New(NULL); }

  ActivationParametricSoftplus* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const ActivationParametricSoftplus& from);
  void MergeFrom(const ActivationParametricSoftplus& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ActivationParametricSoftplus* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .CoreML.Specification.WeightParams alpha = 1;
  bool has_alpha() const;
  void clear_alpha();
  static const int kAlphaFieldNumber = 1;
  const ::CoreML::Specification::WeightParams& alpha() const;
  ::CoreML::Specification::WeightParams* mutable_alpha();
  ::CoreML::Specification::WeightParams* release_alpha();
  void set_allocated_alpha(::CoreML::Specification::WeightParams* alpha);

  // .CoreML.Specification.WeightParams beta = 2;
  bool has_beta() const;
  void clear_beta();
  static const int kBetaFieldNumber = 2;
  const ::CoreML::Specification::WeightParams& beta() const;
  ::CoreML::Specification::WeightParams* mutable_beta();
  ::CoreML::Specification::WeightParams* release_beta();
  void set_allocated_beta(::CoreML::Specification::WeightParams* beta);

  // @@protoc_insertion_point(class_scope:CoreML.Specification.ActivationParametricSoftplus)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::CoreML::Specification::WeightParams* alpha_;
  ::CoreML::Specification::WeightParams* beta_;
  mutable int _cached_size_;
  friend struct protobuf_NeuralNetwork_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ActivationParams : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.ActivationParams) */ {
 public:
  ActivationParams();
  virtual ~ActivationParams();

  ActivationParams(const ActivationParams& from);

  inline ActivationParams& operator=(const ActivationParams& from) {
    CopyFrom(from);
    return *this;
  }

  static const ActivationParams& default_instance();

  enum NonlinearityTypeCase {
    kLinear = 5,
    kReLU = 10,
    kLeakyReLU = 15,
    kThresholdedReLU = 20,
    kPReLU = 25,
    kTanh = 30,
    kScaledTanh = 31,
    kSigmoid = 40,
    kSigmoidHard = 41,
    kELU = 50,
    kSoftsign = 60,
    kSoftplus = 70,
    kParametricSoftplus = 71,
    NONLINEARITYTYPE_NOT_SET = 0,
  };

  static inline const ActivationParams* internal_default_instance() {
    return reinterpret_cast<const ActivationParams*>(
               &_ActivationParams_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    17;

  void Swap(ActivationParams* other);

  // implements Message ----------------------------------------------

  inline ActivationParams* New() const PROTOBUF_FINAL { return New(NULL); }

  ActivationParams* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const ActivationParams& from);
  void MergeFrom(const ActivationParams& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ActivationParams* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .CoreML.Specification.ActivationLinear linear = 5;
  bool has_linear() const;
  void clear_linear();
  static const int kLinearFieldNumber = 5;
  const ::CoreML::Specification::ActivationLinear& linear() const;
  ::CoreML::Specification::ActivationLinear* mutable_linear();
  ::CoreML::Specification::ActivationLinear* release_linear();
  void set_allocated_linear(::CoreML::Specification::ActivationLinear* linear);

  // .CoreML.Specification.ActivationReLU ReLU = 10;
  bool has_relu() const;
  void clear_relu();
  static const int kReLUFieldNumber = 10;
  const ::CoreML::Specification::ActivationReLU& relu() const;
  ::CoreML::Specification::ActivationReLU* mutable_relu();
  ::CoreML::Specification::ActivationReLU* release_relu();
  void set_allocated_relu(::CoreML::Specification::ActivationReLU* relu);

  // .CoreML.Specification.ActivationLeakyReLU leakyReLU = 15;
  bool has_leakyrelu() const;
  void clear_leakyrelu();
  static const int kLeakyReLUFieldNumber = 15;
  const ::CoreML::Specification::ActivationLeakyReLU& leakyrelu() const;
  ::CoreML::Specification::ActivationLeakyReLU* mutable_leakyrelu();
  ::CoreML::Specification::ActivationLeakyReLU* release_leakyrelu();
  void set_allocated_leakyrelu(::CoreML::Specification::ActivationLeakyReLU* leakyrelu);

  // .CoreML.Specification.ActivationThresholdedReLU thresholdedReLU = 20;
  bool has_thresholdedrelu() const;
  void clear_thresholdedrelu();
  static const int kThresholdedReLUFieldNumber = 20;
  const ::CoreML::Specification::ActivationThresholdedReLU& thresholdedrelu() const;
  ::CoreML::Specification::ActivationThresholdedReLU* mutable_thresholdedrelu();
  ::CoreML::Specification::ActivationThresholdedReLU* release_thresholdedrelu();
  void set_allocated_thresholdedrelu(::CoreML::Specification::ActivationThresholdedReLU* thresholdedrelu);

  // .CoreML.Specification.ActivationPReLU PReLU = 25;
  bool has_prelu() const;
  void clear_prelu();
  static const int kPReLUFieldNumber = 25;
  const ::CoreML::Specification::ActivationPReLU& prelu() const;
  ::CoreML::Specification::ActivationPReLU* mutable_prelu();
  ::CoreML::Specification::ActivationPReLU* release_prelu();
  void set_allocated_prelu(::CoreML::Specification::ActivationPReLU* prelu);

  // .CoreML.Specification.ActivationTanh tanh = 30;
  bool has_tanh() const;
  void clear_tanh();
  static const int kTanhFieldNumber = 30;
  const ::CoreML::Specification::ActivationTanh& tanh() const;
  ::CoreML::Specification::ActivationTanh* mutable_tanh();
  ::CoreML::Specification::ActivationTanh* release_tanh();
  void set_allocated_tanh(::CoreML::Specification::ActivationTanh* tanh);

  // .CoreML.Specification.ActivationScaledTanh scaledTanh = 31;
  bool has_scaledtanh() const;
  void clear_scaledtanh();
  static const int kScaledTanhFieldNumber = 31;
  const ::CoreML::Specification::ActivationScaledTanh& scaledtanh() const;
  ::CoreML::Specification::ActivationScaledTanh* mutable_scaledtanh();
  ::CoreML::Specification::ActivationScaledTanh* release_scaledtanh();
  void set_allocated_scaledtanh(::CoreML::Specification::ActivationScaledTanh* scaledtanh);

  // .CoreML.Specification.ActivationSigmoid sigmoid = 40;
  bool has_sigmoid() const;
  void clear_sigmoid();
  static const int kSigmoidFieldNumber = 40;
  const ::CoreML::Specification::ActivationSigmoid& sigmoid() const;
  ::CoreML::Specification::ActivationSigmoid* mutable_sigmoid();
  ::CoreML::Specification::ActivationSigmoid* release_sigmoid();
  void set_allocated_sigmoid(::CoreML::Specification::ActivationSigmoid* sigmoid);

  // .CoreML.Specification.ActivationSigmoidHard sigmoidHard = 41;
  bool has_sigmoidhard() const;
  void clear_sigmoidhard();
  static const int kSigmoidHardFieldNumber = 41;
  const ::CoreML::Specification::ActivationSigmoidHard& sigmoidhard() const;
  ::CoreML::Specification::ActivationSigmoidHard* mutable_sigmoidhard();
  ::CoreML::Specification::ActivationSigmoidHard* release_sigmoidhard();
  void set_allocated_sigmoidhard(::CoreML::Specification::ActivationSigmoidHard* sigmoidhard);

  // .CoreML.Specification.ActivationELU ELU = 50;
  bool has_elu() const;
  void clear_elu();
  static const int kELUFieldNumber = 50;
  const ::CoreML::Specification::ActivationELU& elu() const;
  ::CoreML::Specification::ActivationELU* mutable_elu();
  ::CoreML::Specification::ActivationELU* release_elu();
  void set_allocated_elu(::CoreML::Specification::ActivationELU* elu);

  // .CoreML.Specification.ActivationSoftsign softsign = 60;
  bool has_softsign() const;
  void clear_softsign();
  static const int kSoftsignFieldNumber = 60;
  const ::CoreML::Specification::ActivationSoftsign& softsign() const;
  ::CoreML::Specification::ActivationSoftsign* mutable_softsign();
  ::CoreML::Specification::ActivationSoftsign* release_softsign();
  void set_allocated_softsign(::CoreML::Specification::ActivationSoftsign* softsign);

  // .CoreML.Specification.ActivationSoftplus softplus = 70;
  bool has_softplus() const;
  void clear_softplus();
  static const int kSoftplusFieldNumber = 70;
  const ::CoreML::Specification::ActivationSoftplus& softplus() const;
  ::CoreML::Specification::ActivationSoftplus* mutable_softplus();
  ::CoreML::Specification::ActivationSoftplus* release_softplus();
  void set_allocated_softplus(::CoreML::Specification::ActivationSoftplus* softplus);

  // .CoreML.Specification.ActivationParametricSoftplus parametricSoftplus = 71;
  bool has_parametricsoftplus() const;
  void clear_parametricsoftplus();
  static const int kParametricSoftplusFieldNumber = 71;
  const ::CoreML::Specification::ActivationParametricSoftplus& parametricsoftplus() const;
  ::CoreML::Specification::ActivationParametricSoftplus* mutable_parametricsoftplus();
  ::CoreML::Specification::ActivationParametricSoftplus* release_parametricsoftplus();
  void set_allocated_parametricsoftplus(::CoreML::Specification::ActivationParametricSoftplus* parametricsoftplus);

  NonlinearityTypeCase NonlinearityType_case() const;
  // @@protoc_insertion_point(class_scope:CoreML.Specification.ActivationParams)
 private:
  void set_has_linear();
  void set_has_relu();
  void set_has_leakyrelu();
  void set_has_thresholdedrelu();
  void set_has_prelu();
  void set_has_tanh();
  void set_has_scaledtanh();
  void set_has_sigmoid();
  void set_has_sigmoidhard();
  void set_has_elu();
  void set_has_softsign();
  void set_has_softplus();
  void set_has_parametricsoftplus();

  inline bool has_NonlinearityType() const;
  void clear_NonlinearityType();
  inline void clear_has_NonlinearityType();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  union NonlinearityTypeUnion {
    NonlinearityTypeUnion() {}
    ::CoreML::Specification::ActivationLinear* linear_;
    ::CoreML::Specification::ActivationReLU* relu_;
    ::CoreML::Specification::ActivationLeakyReLU* leakyrelu_;
    ::CoreML::Specification::ActivationThresholdedReLU* thresholdedrelu_;
    ::CoreML::Specification::ActivationPReLU* prelu_;
    ::CoreML::Specification::ActivationTanh* tanh_;
    ::CoreML::Specification::ActivationScaledTanh* scaledtanh_;
    ::CoreML::Specification::ActivationSigmoid* sigmoid_;
    ::CoreML::Specification::ActivationSigmoidHard* sigmoidhard_;
    ::CoreML::Specification::ActivationELU* elu_;
    ::CoreML::Specification::ActivationSoftsign* softsign_;
    ::CoreML::Specification::ActivationSoftplus* softplus_;
    ::CoreML::Specification::ActivationParametricSoftplus* parametricsoftplus_;
  } NonlinearityType_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct protobuf_NeuralNetwork_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class NeuralNetworkLayer : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.NeuralNetworkLayer) */ {
 public:
  NeuralNetworkLayer();
  virtual ~NeuralNetworkLayer();

  NeuralNetworkLayer(const NeuralNetworkLayer& from);

  inline NeuralNetworkLayer& operator=(const NeuralNetworkLayer& from) {
    CopyFrom(from);
    return *this;
  }

  static const NeuralNetworkLayer& default_instance();

  enum LayerCase {
    kConvolution = 100,
    kPooling = 120,
    kActivation = 130,
    kInnerProduct = 140,
    kEmbedding = 150,
    kBatchnorm = 160,
    kMvn = 165,
    kL2Normalize = 170,
    kSoftmax = 175,
    kLrn = 180,
    kCrop = 190,
    kPadding = 200,
    kUpsample = 210,
    kResizeBilinear = 211,
    kCropResize = 212,
    kUnary = 220,
    kAdd = 230,
    kMultiply = 231,
    kAverage = 240,
    kScale = 245,
    kBias = 250,
    kMax = 260,
    kMin = 261,
    kDot = 270,
    kReduce = 280,
    kLoadConstant = 290,
    kReshape = 300,
    kFlatten = 301,
    kPermute = 310,
    kConcat = 320,
    kSplit = 330,
    kSequenceRepeat = 340,
    kReorganizeData = 345,
    kSlice = 350,
    kSimpleRecurrent = 400,
    kGru = 410,
    kUniDirectionalLSTM = 420,
    kBiDirectionalLSTM = 430,
    kCustom = 500,
    LAYER_NOT_SET = 0,
  };

  static inline const NeuralNetworkLayer* internal_default_instance() {
    return reinterpret_cast<const NeuralNetworkLayer*>(
               &_NeuralNetworkLayer_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    18;

  void Swap(NeuralNetworkLayer* other);

  // implements Message ----------------------------------------------

  inline NeuralNetworkLayer* New() const PROTOBUF_FINAL { return New(NULL); }

  NeuralNetworkLayer* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const NeuralNetworkLayer& from);
  void MergeFrom(const NeuralNetworkLayer& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(NeuralNetworkLayer* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string input = 2;
  int input_size() const;
  void clear_input();
  static const int kInputFieldNumber = 2;
  const ::std::string& input(int index) const;
  ::std::string* mutable_input(int index);
  void set_input(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_input(int index, ::std::string&& value);
  #endif
  void set_input(int index, const char* value);
  void set_input(int index, const char* value, size_t size);
  ::std::string* add_input();
  void add_input(const ::std::string& value);
  #if LANG_CXX11
  void add_input(::std::string&& value);
  #endif
  void add_input(const char* value);
  void add_input(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& input() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_input();

  // repeated string output = 3;
  int output_size() const;
  void clear_output();
  static const int kOutputFieldNumber = 3;
  const ::std::string& output(int index) const;
  ::std::string* mutable_output(int index);
  void set_output(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_output(int index, ::std::string&& value);
  #endif
  void set_output(int index, const char* value);
  void set_output(int index, const char* value, size_t size);
  ::std::string* add_output();
  void add_output(const ::std::string& value);
  #if LANG_CXX11
  void add_output(::std::string&& value);
  #endif
  void add_output(const char* value);
  void add_output(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& output() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_output();

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // .CoreML.Specification.ConvolutionLayerParams convolution = 100;
  bool has_convolution() const;
  void clear_convolution();
  static const int kConvolutionFieldNumber = 100;
  const ::CoreML::Specification::ConvolutionLayerParams& convolution() const;
  ::CoreML::Specification::ConvolutionLayerParams* mutable_convolution();
  ::CoreML::Specification::ConvolutionLayerParams* release_convolution();
  void set_allocated_convolution(::CoreML::Specification::ConvolutionLayerParams* convolution);

  // .CoreML.Specification.PoolingLayerParams pooling = 120;
  bool has_pooling() const;
  void clear_pooling();
  static const int kPoolingFieldNumber = 120;
  const ::CoreML::Specification::PoolingLayerParams& pooling() const;
  ::CoreML::Specification::PoolingLayerParams* mutable_pooling();
  ::CoreML::Specification::PoolingLayerParams* release_pooling();
  void set_allocated_pooling(::CoreML::Specification::PoolingLayerParams* pooling);

  // .CoreML.Specification.ActivationParams activation = 130;
  bool has_activation() const;
  void clear_activation();
  static const int kActivationFieldNumber = 130;
  const ::CoreML::Specification::ActivationParams& activation() const;
  ::CoreML::Specification::ActivationParams* mutable_activation();
  ::CoreML::Specification::ActivationParams* release_activation();
  void set_allocated_activation(::CoreML::Specification::ActivationParams* activation);

  // .CoreML.Specification.InnerProductLayerParams innerProduct = 140;
  bool has_innerproduct() const;
  void clear_innerproduct();
  static const int kInnerProductFieldNumber = 140;
  const ::CoreML::Specification::InnerProductLayerParams& innerproduct() const;
  ::CoreML::Specification::InnerProductLayerParams* mutable_innerproduct();
  ::CoreML::Specification::InnerProductLayerParams* release_innerproduct();
  void set_allocated_innerproduct(::CoreML::Specification::InnerProductLayerParams* innerproduct);

  // .CoreML.Specification.EmbeddingLayerParams embedding = 150;
  bool has_embedding() const;
  void clear_embedding();
  static const int kEmbeddingFieldNumber = 150;
  const ::CoreML::Specification::EmbeddingLayerParams& embedding() const;
  ::CoreML::Specification::EmbeddingLayerParams* mutable_embedding();
  ::CoreML::Specification::EmbeddingLayerParams* release_embedding();
  void set_allocated_embedding(::CoreML::Specification::EmbeddingLayerParams* embedding);

  // .CoreML.Specification.BatchnormLayerParams batchnorm = 160;
  bool has_batchnorm() const;
  void clear_batchnorm();
  static const int kBatchnormFieldNumber = 160;
  const ::CoreML::Specification::BatchnormLayerParams& batchnorm() const;
  ::CoreML::Specification::BatchnormLayerParams* mutable_batchnorm();
  ::CoreML::Specification::BatchnormLayerParams* release_batchnorm();
  void set_allocated_batchnorm(::CoreML::Specification::BatchnormLayerParams* batchnorm);

  // .CoreML.Specification.MeanVarianceNormalizeLayerParams mvn = 165;
  bool has_mvn() const;
  void clear_mvn();
  static const int kMvnFieldNumber = 165;
  const ::CoreML::Specification::MeanVarianceNormalizeLayerParams& mvn() const;
  ::CoreML::Specification::MeanVarianceNormalizeLayerParams* mutable_mvn();
  ::CoreML::Specification::MeanVarianceNormalizeLayerParams* release_mvn();
  void set_allocated_mvn(::CoreML::Specification::MeanVarianceNormalizeLayerParams* mvn);

  // .CoreML.Specification.L2NormalizeLayerParams l2normalize = 170;
  bool has_l2normalize() const;
  void clear_l2normalize();
  static const int kL2NormalizeFieldNumber = 170;
  const ::CoreML::Specification::L2NormalizeLayerParams& l2normalize() const;
  ::CoreML::Specification::L2NormalizeLayerParams* mutable_l2normalize();
  ::CoreML::Specification::L2NormalizeLayerParams* release_l2normalize();
  void set_allocated_l2normalize(::CoreML::Specification::L2NormalizeLayerParams* l2normalize);

  // .CoreML.Specification.SoftmaxLayerParams softmax = 175;
  bool has_softmax() const;
  void clear_softmax();
  static const int kSoftmaxFieldNumber = 175;
  const ::CoreML::Specification::SoftmaxLayerParams& softmax() const;
  ::CoreML::Specification::SoftmaxLayerParams* mutable_softmax();
  ::CoreML::Specification::SoftmaxLayerParams* release_softmax();
  void set_allocated_softmax(::CoreML::Specification::SoftmaxLayerParams* softmax);

  // .CoreML.Specification.LRNLayerParams lrn = 180;
  bool has_lrn() const;
  void clear_lrn();
  static const int kLrnFieldNumber = 180;
  const ::CoreML::Specification::LRNLayerParams& lrn() const;
  ::CoreML::Specification::LRNLayerParams* mutable_lrn();
  ::CoreML::Specification::LRNLayerParams* release_lrn();
  void set_allocated_lrn(::CoreML::Specification::LRNLayerParams* lrn);

  // .CoreML.Specification.CropLayerParams crop = 190;
  bool has_crop() const;
  void clear_crop();
  static const int kCropFieldNumber = 190;
  const ::CoreML::Specification::CropLayerParams& crop() const;
  ::CoreML::Specification::CropLayerParams* mutable_crop();
  ::CoreML::Specification::CropLayerParams* release_crop();
  void set_allocated_crop(::CoreML::Specification::CropLayerParams* crop);

  // .CoreML.Specification.PaddingLayerParams padding = 200;
  bool has_padding() const;
  void clear_padding();
  static const int kPaddingFieldNumber = 200;
  const ::CoreML::Specification::PaddingLayerParams& padding() const;
  ::CoreML::Specification::PaddingLayerParams* mutable_padding();
  ::CoreML::Specification::PaddingLayerParams* release_padding();
  void set_allocated_padding(::CoreML::Specification::PaddingLayerParams* padding);

  // .CoreML.Specification.UpsampleLayerParams upsample = 210;
  bool has_upsample() const;
  void clear_upsample();
  static const int kUpsampleFieldNumber = 210;
  const ::CoreML::Specification::UpsampleLayerParams& upsample() const;
  ::CoreML::Specification::UpsampleLayerParams* mutable_upsample();
  ::CoreML::Specification::UpsampleLayerParams* release_upsample();
  void set_allocated_upsample(::CoreML::Specification::UpsampleLayerParams* upsample);

  // .CoreML.Specification.ResizeBilinearLayerParams resizeBilinear = 211;
  bool has_resizebilinear() const;
  void clear_resizebilinear();
  static const int kResizeBilinearFieldNumber = 211;
  const ::CoreML::Specification::ResizeBilinearLayerParams& resizebilinear() const;
  ::CoreML::Specification::ResizeBilinearLayerParams* mutable_resizebilinear();
  ::CoreML::Specification::ResizeBilinearLayerParams* release_resizebilinear();
  void set_allocated_resizebilinear(::CoreML::Specification::ResizeBilinearLayerParams* resizebilinear);

  // .CoreML.Specification.CropResizeLayerParams cropResize = 212;
  bool has_cropresize() const;
  void clear_cropresize();
  static const int kCropResizeFieldNumber = 212;
  const ::CoreML::Specification::CropResizeLayerParams& cropresize() const;
  ::CoreML::Specification::CropResizeLayerParams* mutable_cropresize();
  ::CoreML::Specification::CropResizeLayerParams* release_cropresize();
  void set_allocated_cropresize(::CoreML::Specification::CropResizeLayerParams* cropresize);

  // .CoreML.Specification.UnaryFunctionLayerParams unary = 220;
  bool has_unary() const;
  void clear_unary();
  static const int kUnaryFieldNumber = 220;
  const ::CoreML::Specification::UnaryFunctionLayerParams& unary() const;
  ::CoreML::Specification::UnaryFunctionLayerParams* mutable_unary();
  ::CoreML::Specification::UnaryFunctionLayerParams* release_unary();
  void set_allocated_unary(::CoreML::Specification::UnaryFunctionLayerParams* unary);

  // .CoreML.Specification.AddLayerParams add = 230;
  bool has_add() const;
  void clear_add();
  static const int kAddFieldNumber = 230;
  const ::CoreML::Specification::AddLayerParams& add() const;
  ::CoreML::Specification::AddLayerParams* mutable_add();
  ::CoreML::Specification::AddLayerParams* release_add();
  void set_allocated_add(::CoreML::Specification::AddLayerParams* add);

  // .CoreML.Specification.MultiplyLayerParams multiply = 231;
  bool has_multiply() const;
  void clear_multiply();
  static const int kMultiplyFieldNumber = 231;
  const ::CoreML::Specification::MultiplyLayerParams& multiply() const;
  ::CoreML::Specification::MultiplyLayerParams* mutable_multiply();
  ::CoreML::Specification::MultiplyLayerParams* release_multiply();
  void set_allocated_multiply(::CoreML::Specification::MultiplyLayerParams* multiply);

  // .CoreML.Specification.AverageLayerParams average = 240;
  bool has_average() const;
  void clear_average();
  static const int kAverageFieldNumber = 240;
  const ::CoreML::Specification::AverageLayerParams& average() const;
  ::CoreML::Specification::AverageLayerParams* mutable_average();
  ::CoreML::Specification::AverageLayerParams* release_average();
  void set_allocated_average(::CoreML::Specification::AverageLayerParams* average);

  // .CoreML.Specification.ScaleLayerParams scale = 245;
  bool has_scale() const;
  void clear_scale();
  static const int kScaleFieldNumber = 245;
  const ::CoreML::Specification::ScaleLayerParams& scale() const;
  ::CoreML::Specification::ScaleLayerParams* mutable_scale();
  ::CoreML::Specification::ScaleLayerParams* release_scale();
  void set_allocated_scale(::CoreML::Specification::ScaleLayerParams* scale);

  // .CoreML.Specification.BiasLayerParams bias = 250;
  bool has_bias() const;
  void clear_bias();
  static const int kBiasFieldNumber = 250;
  const ::CoreML::Specification::BiasLayerParams& bias() const;
  ::CoreML::Specification::BiasLayerParams* mutable_bias();
  ::CoreML::Specification::BiasLayerParams* release_bias();
  void set_allocated_bias(::CoreML::Specification::BiasLayerParams* bias);

  // .CoreML.Specification.MaxLayerParams max = 260;
  bool has_max() const;
  void clear_max();
  static const int kMaxFieldNumber = 260;
  const ::CoreML::Specification::MaxLayerParams& max() const;
  ::CoreML::Specification::MaxLayerParams* mutable_max();
  ::CoreML::Specification::MaxLayerParams* release_max();
  void set_allocated_max(::CoreML::Specification::MaxLayerParams* max);

  // .CoreML.Specification.MinLayerParams min = 261;
  bool has_min() const;
  void clear_min();
  static const int kMinFieldNumber = 261;
  const ::CoreML::Specification::MinLayerParams& min() const;
  ::CoreML::Specification::MinLayerParams* mutable_min();
  ::CoreML::Specification::MinLayerParams* release_min();
  void set_allocated_min(::CoreML::Specification::MinLayerParams* min);

  // .CoreML.Specification.DotProductLayerParams dot = 270;
  bool has_dot() const;
  void clear_dot();
  static const int kDotFieldNumber = 270;
  const ::CoreML::Specification::DotProductLayerParams& dot() const;
  ::CoreML::Specification::DotProductLayerParams* mutable_dot();
  ::CoreML::Specification::DotProductLayerParams* release_dot();
  void set_allocated_dot(::CoreML::Specification::DotProductLayerParams* dot);

  // .CoreML.Specification.ReduceLayerParams reduce = 280;
  bool has_reduce() const;
  void clear_reduce();
  static const int kReduceFieldNumber = 280;
  const ::CoreML::Specification::ReduceLayerParams& reduce() const;
  ::CoreML::Specification::ReduceLayerParams* mutable_reduce();
  ::CoreML::Specification::ReduceLayerParams* release_reduce();
  void set_allocated_reduce(::CoreML::Specification::ReduceLayerParams* reduce);

  // .CoreML.Specification.LoadConstantLayerParams loadConstant = 290;
  bool has_loadconstant() const;
  void clear_loadconstant();
  static const int kLoadConstantFieldNumber = 290;
  const ::CoreML::Specification::LoadConstantLayerParams& loadconstant() const;
  ::CoreML::Specification::LoadConstantLayerParams* mutable_loadconstant();
  ::CoreML::Specification::LoadConstantLayerParams* release_loadconstant();
  void set_allocated_loadconstant(::CoreML::Specification::LoadConstantLayerParams* loadconstant);

  // .CoreML.Specification.ReshapeLayerParams reshape = 300;
  bool has_reshape() const;
  void clear_reshape();
  static const int kReshapeFieldNumber = 300;
  const ::CoreML::Specification::ReshapeLayerParams& reshape() const;
  ::CoreML::Specification::ReshapeLayerParams* mutable_reshape();
  ::CoreML::Specification::ReshapeLayerParams* release_reshape();
  void set_allocated_reshape(::CoreML::Specification::ReshapeLayerParams* reshape);

  // .CoreML.Specification.FlattenLayerParams flatten = 301;
  bool has_flatten() const;
  void clear_flatten();
  static const int kFlattenFieldNumber = 301;
  const ::CoreML::Specification::FlattenLayerParams& flatten() const;
  ::CoreML::Specification::FlattenLayerParams* mutable_flatten();
  ::CoreML::Specification::FlattenLayerParams* release_flatten();
  void set_allocated_flatten(::CoreML::Specification::FlattenLayerParams* flatten);

  // .CoreML.Specification.PermuteLayerParams permute = 310;
  bool has_permute() const;
  void clear_permute();
  static const int kPermuteFieldNumber = 310;
  const ::CoreML::Specification::PermuteLayerParams& permute() const;
  ::CoreML::Specification::PermuteLayerParams* mutable_permute();
  ::CoreML::Specification::PermuteLayerParams* release_permute();
  void set_allocated_permute(::CoreML::Specification::PermuteLayerParams* permute);

  // .CoreML.Specification.ConcatLayerParams concat = 320;
  bool has_concat() const;
  void clear_concat();
  static const int kConcatFieldNumber = 320;
  const ::CoreML::Specification::ConcatLayerParams& concat() const;
  ::CoreML::Specification::ConcatLayerParams* mutable_concat();
  ::CoreML::Specification::ConcatLayerParams* release_concat();
  void set_allocated_concat(::CoreML::Specification::ConcatLayerParams* concat);

  // .CoreML.Specification.SplitLayerParams split = 330;
  bool has_split() const;
  void clear_split();
  static const int kSplitFieldNumber = 330;
  const ::CoreML::Specification::SplitLayerParams& split() const;
  ::CoreML::Specification::SplitLayerParams* mutable_split();
  ::CoreML::Specification::SplitLayerParams* release_split();
  void set_allocated_split(::CoreML::Specification::SplitLayerParams* split);

  // .CoreML.Specification.SequenceRepeatLayerParams sequenceRepeat = 340;
  bool has_sequencerepeat() const;
  void clear_sequencerepeat();
  static const int kSequenceRepeatFieldNumber = 340;
  const ::CoreML::Specification::SequenceRepeatLayerParams& sequencerepeat() const;
  ::CoreML::Specification::SequenceRepeatLayerParams* mutable_sequencerepeat();
  ::CoreML::Specification::SequenceRepeatLayerParams* release_sequencerepeat();
  void set_allocated_sequencerepeat(::CoreML::Specification::SequenceRepeatLayerParams* sequencerepeat);

  // .CoreML.Specification.ReorganizeDataLayerParams reorganizeData = 345;
  bool has_reorganizedata() const;
  void clear_reorganizedata();
  static const int kReorganizeDataFieldNumber = 345;
  const ::CoreML::Specification::ReorganizeDataLayerParams& reorganizedata() const;
  ::CoreML::Specification::ReorganizeDataLayerParams* mutable_reorganizedata();
  ::CoreML::Specification::ReorganizeDataLayerParams* release_reorganizedata();
  void set_allocated_reorganizedata(::CoreML::Specification::ReorganizeDataLayerParams* reorganizedata);

  // .CoreML.Specification.SliceLayerParams slice = 350;
  bool has_slice() const;
  void clear_slice();
  static const int kSliceFieldNumber = 350;
  const ::CoreML::Specification::SliceLayerParams& slice() const;
  ::CoreML::Specification::SliceLayerParams* mutable_slice();
  ::CoreML::Specification::SliceLayerParams* release_slice();
  void set_allocated_slice(::CoreML::Specification::SliceLayerParams* slice);

  // .CoreML.Specification.SimpleRecurrentLayerParams simpleRecurrent = 400;
  bool has_simplerecurrent() const;
  void clear_simplerecurrent();
  static const int kSimpleRecurrentFieldNumber = 400;
  const ::CoreML::Specification::SimpleRecurrentLayerParams& simplerecurrent() const;
  ::CoreML::Specification::SimpleRecurrentLayerParams* mutable_simplerecurrent();
  ::CoreML::Specification::SimpleRecurrentLayerParams* release_simplerecurrent();
  void set_allocated_simplerecurrent(::CoreML::Specification::SimpleRecurrentLayerParams* simplerecurrent);

  // .CoreML.Specification.GRULayerParams gru = 410;
  bool has_gru() const;
  void clear_gru();
  static const int kGruFieldNumber = 410;
  const ::CoreML::Specification::GRULayerParams& gru() const;
  ::CoreML::Specification::GRULayerParams* mutable_gru();
  ::CoreML::Specification::GRULayerParams* release_gru();
  void set_allocated_gru(::CoreML::Specification::GRULayerParams* gru);

  // .CoreML.Specification.UniDirectionalLSTMLayerParams uniDirectionalLSTM = 420;
  bool has_unidirectionallstm() const;
  void clear_unidirectionallstm();
  static const int kUniDirectionalLSTMFieldNumber = 420;
  const ::CoreML::Specification::UniDirectionalLSTMLayerParams& unidirectionallstm() const;
  ::CoreML::Specification::UniDirectionalLSTMLayerParams* mutable_unidirectionallstm();
  ::CoreML::Specification::UniDirectionalLSTMLayerParams* release_unidirectionallstm();
  void set_allocated_unidirectionallstm(::CoreML::Specification::UniDirectionalLSTMLayerParams* unidirectionallstm);

  // .CoreML.Specification.BiDirectionalLSTMLayerParams biDirectionalLSTM = 430;
  bool has_bidirectionallstm() const;
  void clear_bidirectionallstm();
  static const int kBiDirectionalLSTMFieldNumber = 430;
  const ::CoreML::Specification::BiDirectionalLSTMLayerParams& bidirectionallstm() const;
  ::CoreML::Specification::BiDirectionalLSTMLayerParams* mutable_bidirectionallstm();
  ::CoreML::Specification::BiDirectionalLSTMLayerParams* release_bidirectionallstm();
  void set_allocated_bidirectionallstm(::CoreML::Specification::BiDirectionalLSTMLayerParams* bidirectionallstm);

  // .CoreML.Specification.CustomLayerParams custom = 500;
  bool has_custom() const;
  void clear_custom();
  static const int kCustomFieldNumber = 500;
  const ::CoreML::Specification::CustomLayerParams& custom() const;
  ::CoreML::Specification::CustomLayerParams* mutable_custom();
  ::CoreML::Specification::CustomLayerParams* release_custom();
  void set_allocated_custom(::CoreML::Specification::CustomLayerParams* custom);

  LayerCase layer_case() const;
  // @@protoc_insertion_point(class_scope:CoreML.Specification.NeuralNetworkLayer)
 private:
  void set_has_convolution();
  void set_has_pooling();
  void set_has_activation();
  void set_has_innerproduct();
  void set_has_embedding();
  void set_has_batchnorm();
  void set_has_mvn();
  void set_has_l2normalize();
  void set_has_softmax();
  void set_has_lrn();
  void set_has_crop();
  void set_has_padding();
  void set_has_upsample();
  void set_has_resizebilinear();
  void set_has_cropresize();
  void set_has_unary();
  void set_has_add();
  void set_has_multiply();
  void set_has_average();
  void set_has_scale();
  void set_has_bias();
  void set_has_max();
  void set_has_min();
  void set_has_dot();
  void set_has_reduce();
  void set_has_loadconstant();
  void set_has_reshape();
  void set_has_flatten();
  void set_has_permute();
  void set_has_concat();
  void set_has_split();
  void set_has_sequencerepeat();
  void set_has_reorganizedata();
  void set_has_slice();
  void set_has_simplerecurrent();
  void set_has_gru();
  void set_has_unidirectionallstm();
  void set_has_bidirectionallstm();
  void set_has_custom();

  inline bool has_layer() const;
  void clear_layer();
  inline void clear_has_layer();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> input_;
  ::google::protobuf::RepeatedPtrField< ::std::string> output_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  union LayerUnion {
    LayerUnion() {}
    ::CoreML::Specification::ConvolutionLayerParams* convolution_;
    ::CoreML::Specification::PoolingLayerParams* pooling_;
    ::CoreML::Specification::ActivationParams* activation_;
    ::CoreML::Specification::InnerProductLayerParams* innerproduct_;
    ::CoreML::Specification::EmbeddingLayerParams* embedding_;
    ::CoreML::Specification::BatchnormLayerParams* batchnorm_;
    ::CoreML::Specification::MeanVarianceNormalizeLayerParams* mvn_;
    ::CoreML::Specification::L2NormalizeLayerParams* l2normalize_;
    ::CoreML::Specification::SoftmaxLayerParams* softmax_;
    ::CoreML::Specification::LRNLayerParams* lrn_;
    ::CoreML::Specification::CropLayerParams* crop_;
    ::CoreML::Specification::PaddingLayerParams* padding_;
    ::CoreML::Specification::UpsampleLayerParams* upsample_;
    ::CoreML::Specification::ResizeBilinearLayerParams* resizebilinear_;
    ::CoreML::Specification::CropResizeLayerParams* cropresize_;
    ::CoreML::Specification::UnaryFunctionLayerParams* unary_;
    ::CoreML::Specification::AddLayerParams* add_;
    ::CoreML::Specification::MultiplyLayerParams* multiply_;
    ::CoreML::Specification::AverageLayerParams* average_;
    ::CoreML::Specification::ScaleLayerParams* scale_;
    ::CoreML::Specification::BiasLayerParams* bias_;
    ::CoreML::Specification::MaxLayerParams* max_;
    ::CoreML::Specification::MinLayerParams* min_;
    ::CoreML::Specification::DotProductLayerParams* dot_;
    ::CoreML::Specification::ReduceLayerParams* reduce_;
    ::CoreML::Specification::LoadConstantLayerParams* loadconstant_;
    ::CoreML::Specification::ReshapeLayerParams* reshape_;
    ::CoreML::Specification::FlattenLayerParams* flatten_;
    ::CoreML::Specification::PermuteLayerParams* permute_;
    ::CoreML::Specification::ConcatLayerParams* concat_;
    ::CoreML::Specification::SplitLayerParams* split_;
    ::CoreML::Specification::SequenceRepeatLayerParams* sequencerepeat_;
    ::CoreML::Specification::ReorganizeDataLayerParams* reorganizedata_;
    ::CoreML::Specification::SliceLayerParams* slice_;
    ::CoreML::Specification::SimpleRecurrentLayerParams* simplerecurrent_;
    ::CoreML::Specification::GRULayerParams* gru_;
    ::CoreML::Specification::UniDirectionalLSTMLayerParams* unidirectionallstm_;
    ::CoreML::Specification::BiDirectionalLSTMLayerParams* bidirectionallstm_;
    ::CoreML::Specification::CustomLayerParams* custom_;
  } layer_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct protobuf_NeuralNetwork_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BorderAmounts_EdgeSizes : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.BorderAmounts.EdgeSizes) */ {
 public:
  BorderAmounts_EdgeSizes();
  virtual ~BorderAmounts_EdgeSizes();

  BorderAmounts_EdgeSizes(const BorderAmounts_EdgeSizes& from);

  inline BorderAmounts_EdgeSizes& operator=(const BorderAmounts_EdgeSizes& from) {
    CopyFrom(from);
    return *this;
  }

  static const BorderAmounts_EdgeSizes& default_instance();

  static inline const BorderAmounts_EdgeSizes* internal_default_instance() {
    return reinterpret_cast<const BorderAmounts_EdgeSizes*>(
               &_BorderAmounts_EdgeSizes_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    19;

  void Swap(BorderAmounts_EdgeSizes* other);

  // implements Message ----------------------------------------------

  inline BorderAmounts_EdgeSizes* New() const PROTOBUF_FINAL { return New(NULL); }

  BorderAmounts_EdgeSizes* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const BorderAmounts_EdgeSizes& from);
  void MergeFrom(const BorderAmounts_EdgeSizes& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BorderAmounts_EdgeSizes* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint64 startEdgeSize = 1;
  void clear_startedgesize();
  static const int kStartEdgeSizeFieldNumber = 1;
  ::google::protobuf::uint64 startedgesize() const;
  void set_startedgesize(::google::protobuf::uint64 value);

  // uint64 endEdgeSize = 2;
  void clear_endedgesize();
  static const int kEndEdgeSizeFieldNumber = 2;
  ::google::protobuf::uint64 endedgesize() const;
  void set_endedgesize(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:CoreML.Specification.BorderAmounts.EdgeSizes)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::uint64 startedgesize_;
  ::google::protobuf::uint64 endedgesize_;
  mutable int _cached_size_;
  friend struct protobuf_NeuralNetwork_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BorderAmounts : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.BorderAmounts) */ {
 public:
  BorderAmounts();
  virtual ~BorderAmounts();

  BorderAmounts(const BorderAmounts& from);

  inline BorderAmounts& operator=(const BorderAmounts& from) {
    CopyFrom(from);
    return *this;
  }

  static const BorderAmounts& default_instance();

  static inline const BorderAmounts* internal_default_instance() {
    return reinterpret_cast<const BorderAmounts*>(
               &_BorderAmounts_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    20;

  void Swap(BorderAmounts* other);

  // implements Message ----------------------------------------------

  inline BorderAmounts* New() const PROTOBUF_FINAL { return New(NULL); }

  BorderAmounts* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const BorderAmounts& from);
  void MergeFrom(const BorderAmounts& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BorderAmounts* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef BorderAmounts_EdgeSizes EdgeSizes;

  // accessors -------------------------------------------------------

  // repeated .CoreML.Specification.BorderAmounts.EdgeSizes borderAmounts = 10;
  int borderamounts_size() const;
  void clear_borderamounts();
  static const int kBorderAmountsFieldNumber = 10;
  const ::CoreML::Specification::BorderAmounts_EdgeSizes& borderamounts(int index) const;
  ::CoreML::Specification::BorderAmounts_EdgeSizes* mutable_borderamounts(int index);
  ::CoreML::Specification::BorderAmounts_EdgeSizes* add_borderamounts();
  ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::BorderAmounts_EdgeSizes >*
      mutable_borderamounts();
  const ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::BorderAmounts_EdgeSizes >&
      borderamounts() const;

  // @@protoc_insertion_point(class_scope:CoreML.Specification.BorderAmounts)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::BorderAmounts_EdgeSizes > borderamounts_;
  mutable int _cached_size_;
  friend struct protobuf_NeuralNetwork_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ValidPadding : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.ValidPadding) */ {
 public:
  ValidPadding();
  virtual ~ValidPadding();

  ValidPadding(const ValidPadding& from);

  inline ValidPadding& operator=(const ValidPadding& from) {
    CopyFrom(from);
    return *this;
  }

  static const ValidPadding& default_instance();

  static inline const ValidPadding* internal_default_instance() {
    return reinterpret_cast<const ValidPadding*>(
               &_ValidPadding_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    21;

  void Swap(ValidPadding* other);

  // implements Message ----------------------------------------------

  inline ValidPadding* New() const PROTOBUF_FINAL { return New(NULL); }

  ValidPadding* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const ValidPadding& from);
  void MergeFrom(const ValidPadding& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ValidPadding* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .CoreML.Specification.BorderAmounts paddingAmounts = 1;
  bool has_paddingamounts() const;
  void clear_paddingamounts();
  static const int kPaddingAmountsFieldNumber = 1;
  const ::CoreML::Specification::BorderAmounts& paddingamounts() const;
  ::CoreML::Specification::BorderAmounts* mutable_paddingamounts();
  ::CoreML::Specification::BorderAmounts* release_paddingamounts();
  void set_allocated_paddingamounts(::CoreML::Specification::BorderAmounts* paddingamounts);

  // @@protoc_insertion_point(class_scope:CoreML.Specification.ValidPadding)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::CoreML::Specification::BorderAmounts* paddingamounts_;
  mutable int _cached_size_;
  friend struct protobuf_NeuralNetwork_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SamePadding : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.SamePadding) */ {
 public:
  SamePadding();
  virtual ~SamePadding();

  SamePadding(const SamePadding& from);

  inline SamePadding& operator=(const SamePadding& from) {
    CopyFrom(from);
    return *this;
  }

  static const SamePadding& default_instance();

  static inline const SamePadding* internal_default_instance() {
    return reinterpret_cast<const SamePadding*>(
               &_SamePadding_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    22;

  void Swap(SamePadding* other);

  // implements Message ----------------------------------------------

  inline SamePadding* New() const PROTOBUF_FINAL { return New(NULL); }

  SamePadding* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const SamePadding& from);
  void MergeFrom(const SamePadding& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SamePadding* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef SamePadding_SamePaddingMode SamePaddingMode;
  static const SamePaddingMode BOTTOM_RIGHT_HEAVY =
    SamePadding_SamePaddingMode_BOTTOM_RIGHT_HEAVY;
  static const SamePaddingMode TOP_LEFT_HEAVY =
    SamePadding_SamePaddingMode_TOP_LEFT_HEAVY;
  static inline bool SamePaddingMode_IsValid(int value) {
    return SamePadding_SamePaddingMode_IsValid(value);
  }
  static const SamePaddingMode SamePaddingMode_MIN =
    SamePadding_SamePaddingMode_SamePaddingMode_MIN;
  static const SamePaddingMode SamePaddingMode_MAX =
    SamePadding_SamePaddingMode_SamePaddingMode_MAX;
  static const int SamePaddingMode_ARRAYSIZE =
    SamePadding_SamePaddingMode_SamePaddingMode_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // .CoreML.Specification.SamePadding.SamePaddingMode asymmetryMode = 1;
  void clear_asymmetrymode();
  static const int kAsymmetryModeFieldNumber = 1;
  ::CoreML::Specification::SamePadding_SamePaddingMode asymmetrymode() const;
  void set_asymmetrymode(::CoreML::Specification::SamePadding_SamePaddingMode value);

  // @@protoc_insertion_point(class_scope:CoreML.Specification.SamePadding)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  int asymmetrymode_;
  mutable int _cached_size_;
  friend struct protobuf_NeuralNetwork_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SamplingMode : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.SamplingMode) */ {
 public:
  SamplingMode();
  virtual ~SamplingMode();

  SamplingMode(const SamplingMode& from);

  inline SamplingMode& operator=(const SamplingMode& from) {
    CopyFrom(from);
    return *this;
  }

  static const SamplingMode& default_instance();

  static inline const SamplingMode* internal_default_instance() {
    return reinterpret_cast<const SamplingMode*>(
               &_SamplingMode_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    23;

  void Swap(SamplingMode* other);

  // implements Message ----------------------------------------------

  inline SamplingMode* New() const PROTOBUF_FINAL { return New(NULL); }

  SamplingMode* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const SamplingMode& from);
  void MergeFrom(const SamplingMode& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SamplingMode* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef SamplingMode_Method Method;
  static const Method STRICT_ALIGN_ENDPOINTS_MODE =
    SamplingMode_Method_STRICT_ALIGN_ENDPOINTS_MODE;
  static const Method ALIGN_ENDPOINTS_MODE =
    SamplingMode_Method_ALIGN_ENDPOINTS_MODE;
  static const Method UPSAMPLE_MODE =
    SamplingMode_Method_UPSAMPLE_MODE;
  static const Method ROI_ALIGN_MODE =
    SamplingMode_Method_ROI_ALIGN_MODE;
  static inline bool Method_IsValid(int value) {
    return SamplingMode_Method_IsValid(value);
  }
  static const Method Method_MIN =
    SamplingMode_Method_Method_MIN;
  static const Method Method_MAX =
    SamplingMode_Method_Method_MAX;
  static const int Method_ARRAYSIZE =
    SamplingMode_Method_Method_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // .CoreML.Specification.SamplingMode.Method samplingMethod = 1;
  void clear_samplingmethod();
  static const int kSamplingMethodFieldNumber = 1;
  ::CoreML::Specification::SamplingMode_Method samplingmethod() const;
  void set_samplingmethod(::CoreML::Specification::SamplingMode_Method value);

  // @@protoc_insertion_point(class_scope:CoreML.Specification.SamplingMode)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  int samplingmethod_;
  mutable int _cached_size_;
  friend struct protobuf_NeuralNetwork_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BoxCoordinatesMode : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.BoxCoordinatesMode) */ {
 public:
  BoxCoordinatesMode();
  virtual ~BoxCoordinatesMode();

  BoxCoordinatesMode(const BoxCoordinatesMode& from);

  inline BoxCoordinatesMode& operator=(const BoxCoordinatesMode& from) {
    CopyFrom(from);
    return *this;
  }

  static const BoxCoordinatesMode& default_instance();

  static inline const BoxCoordinatesMode* internal_default_instance() {
    return reinterpret_cast<const BoxCoordinatesMode*>(
               &_BoxCoordinatesMode_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    24;

  void Swap(BoxCoordinatesMode* other);

  // implements Message ----------------------------------------------

  inline BoxCoordinatesMode* New() const PROTOBUF_FINAL { return New(NULL); }

  BoxCoordinatesMode* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const BoxCoordinatesMode& from);
  void MergeFrom(const BoxCoordinatesMode& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BoxCoordinatesMode* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef BoxCoordinatesMode_Coordinates Coordinates;
  static const Coordinates CORNERS_HEIGHT_FIRST =
    BoxCoordinatesMode_Coordinates_CORNERS_HEIGHT_FIRST;
  static const Coordinates CORNERS_WIDTH_FIRST =
    BoxCoordinatesMode_Coordinates_CORNERS_WIDTH_FIRST;
  static const Coordinates CENTER_SIZE_HEIGHT_FIRST =
    BoxCoordinatesMode_Coordinates_CENTER_SIZE_HEIGHT_FIRST;
  static const Coordinates CENTER_SIZE_WIDTH_FIRST =
    BoxCoordinatesMode_Coordinates_CENTER_SIZE_WIDTH_FIRST;
  static inline bool Coordinates_IsValid(int value) {
    return BoxCoordinatesMode_Coordinates_IsValid(value);
  }
  static const Coordinates Coordinates_MIN =
    BoxCoordinatesMode_Coordinates_Coordinates_MIN;
  static const Coordinates Coordinates_MAX =
    BoxCoordinatesMode_Coordinates_Coordinates_MAX;
  static const int Coordinates_ARRAYSIZE =
    BoxCoordinatesMode_Coordinates_Coordinates_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // .CoreML.Specification.BoxCoordinatesMode.Coordinates boxMode = 1;
  void clear_boxmode();
  static const int kBoxModeFieldNumber = 1;
  ::CoreML::Specification::BoxCoordinatesMode_Coordinates boxmode() const;
  void set_boxmode(::CoreML::Specification::BoxCoordinatesMode_Coordinates value);

  // @@protoc_insertion_point(class_scope:CoreML.Specification.BoxCoordinatesMode)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  int boxmode_;
  mutable int _cached_size_;
  friend struct protobuf_NeuralNetwork_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class WeightParams : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.WeightParams) */ {
 public:
  WeightParams();
  virtual ~WeightParams();

  WeightParams(const WeightParams& from);

  inline WeightParams& operator=(const WeightParams& from) {
    CopyFrom(from);
    return *this;
  }

  static const WeightParams& default_instance();

  static inline const WeightParams* internal_default_instance() {
    return reinterpret_cast<const WeightParams*>(
               &_WeightParams_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    25;

  void Swap(WeightParams* other);

  // implements Message ----------------------------------------------

  inline WeightParams* New() const PROTOBUF_FINAL { return New(NULL); }

  WeightParams* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const WeightParams& from);
  void MergeFrom(const WeightParams& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(WeightParams* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated float floatValue = 1;
  int floatvalue_size() const;
  void clear_floatvalue();
  static const int kFloatValueFieldNumber = 1;
  float floatvalue(int index) const;
  void set_floatvalue(int index, float value);
  void add_floatvalue(float value);
  const ::google::protobuf::RepeatedField< float >&
      floatvalue() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_floatvalue();

  // bytes float16Value = 2;
  void clear_float16value();
  static const int kFloat16ValueFieldNumber = 2;
  const ::std::string& float16value() const;
  void set_float16value(const ::std::string& value);
  #if LANG_CXX11
  void set_float16value(::std::string&& value);
  #endif
  void set_float16value(const char* value);
  void set_float16value(const void* value, size_t size);
  ::std::string* mutable_float16value();
  ::std::string* release_float16value();
  void set_allocated_float16value(::std::string* float16value);

  // bytes rawValue = 30;
  void clear_rawvalue();
  static const int kRawValueFieldNumber = 30;
  const ::std::string& rawvalue() const;
  void set_rawvalue(const ::std::string& value);
  #if LANG_CXX11
  void set_rawvalue(::std::string&& value);
  #endif
  void set_rawvalue(const char* value);
  void set_rawvalue(const void* value, size_t size);
  ::std::string* mutable_rawvalue();
  ::std::string* release_rawvalue();
  void set_allocated_rawvalue(::std::string* rawvalue);

  // .CoreML.Specification.QuantizationParams quantization = 40;
  bool has_quantization() const;
  void clear_quantization();
  static const int kQuantizationFieldNumber = 40;
  const ::CoreML::Specification::QuantizationParams& quantization() const;
  ::CoreML::Specification::QuantizationParams* mutable_quantization();
  ::CoreML::Specification::QuantizationParams* release_quantization();
  void set_allocated_quantization(::CoreML::Specification::QuantizationParams* quantization);

  // @@protoc_insertion_point(class_scope:CoreML.Specification.WeightParams)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedField< float > floatvalue_;
  mutable int _floatvalue_cached_byte_size_;
  ::google::protobuf::internal::ArenaStringPtr float16value_;
  ::google::protobuf::internal::ArenaStringPtr rawvalue_;
  ::CoreML::Specification::QuantizationParams* quantization_;
  mutable int _cached_size_;
  friend struct protobuf_NeuralNetwork_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class QuantizationParams : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.QuantizationParams) */ {
 public:
  QuantizationParams();
  virtual ~QuantizationParams();

  QuantizationParams(const QuantizationParams& from);

  inline QuantizationParams& operator=(const QuantizationParams& from) {
    CopyFrom(from);
    return *this;
  }

  static const QuantizationParams& default_instance();

  enum QuantizationTypeCase {
    kLinearQuantization = 101,
    kLookupTableQuantization = 102,
    QUANTIZATIONTYPE_NOT_SET = 0,
  };

  static inline const QuantizationParams* internal_default_instance() {
    return reinterpret_cast<const QuantizationParams*>(
               &_QuantizationParams_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    26;

  void Swap(QuantizationParams* other);

  // implements Message ----------------------------------------------

  inline QuantizationParams* New() const PROTOBUF_FINAL { return New(NULL); }

  QuantizationParams* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const QuantizationParams& from);
  void MergeFrom(const QuantizationParams& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(QuantizationParams* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint64 numberOfBits = 1;
  void clear_numberofbits();
  static const int kNumberOfBitsFieldNumber = 1;
  ::google::protobuf::uint64 numberofbits() const;
  void set_numberofbits(::google::protobuf::uint64 value);

  // .CoreML.Specification.LinearQuantizationParams linearQuantization = 101;
  bool has_linearquantization() const;
  void clear_linearquantization();
  static const int kLinearQuantizationFieldNumber = 101;
  const ::CoreML::Specification::LinearQuantizationParams& linearquantization() const;
  ::CoreML::Specification::LinearQuantizationParams* mutable_linearquantization();
  ::CoreML::Specification::LinearQuantizationParams* release_linearquantization();
  void set_allocated_linearquantization(::CoreML::Specification::LinearQuantizationParams* linearquantization);

  // .CoreML.Specification.LookUpTableQuantizationParams lookupTableQuantization = 102;
  bool has_lookuptablequantization() const;
  void clear_lookuptablequantization();
  static const int kLookupTableQuantizationFieldNumber = 102;
  const ::CoreML::Specification::LookUpTableQuantizationParams& lookuptablequantization() const;
  ::CoreML::Specification::LookUpTableQuantizationParams* mutable_lookuptablequantization();
  ::CoreML::Specification::LookUpTableQuantizationParams* release_lookuptablequantization();
  void set_allocated_lookuptablequantization(::CoreML::Specification::LookUpTableQuantizationParams* lookuptablequantization);

  QuantizationTypeCase QuantizationType_case() const;
  // @@protoc_insertion_point(class_scope:CoreML.Specification.QuantizationParams)
 private:
  void set_has_linearquantization();
  void set_has_lookuptablequantization();

  inline bool has_QuantizationType() const;
  void clear_QuantizationType();
  inline void clear_has_QuantizationType();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::uint64 numberofbits_;
  union QuantizationTypeUnion {
    QuantizationTypeUnion() {}
    ::CoreML::Specification::LinearQuantizationParams* linearquantization_;
    ::CoreML::Specification::LookUpTableQuantizationParams* lookuptablequantization_;
  } QuantizationType_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct protobuf_NeuralNetwork_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LinearQuantizationParams : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.LinearQuantizationParams) */ {
 public:
  LinearQuantizationParams();
  virtual ~LinearQuantizationParams();

  LinearQuantizationParams(const LinearQuantizationParams& from);

  inline LinearQuantizationParams& operator=(const LinearQuantizationParams& from) {
    CopyFrom(from);
    return *this;
  }

  static const LinearQuantizationParams& default_instance();

  static inline const LinearQuantizationParams* internal_default_instance() {
    return reinterpret_cast<const LinearQuantizationParams*>(
               &_LinearQuantizationParams_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    27;

  void Swap(LinearQuantizationParams* other);

  // implements Message ----------------------------------------------

  inline LinearQuantizationParams* New() const PROTOBUF_FINAL { return New(NULL); }

  LinearQuantizationParams* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const LinearQuantizationParams& from);
  void MergeFrom(const LinearQuantizationParams& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LinearQuantizationParams* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated float scale = 1;
  int scale_size() const;
  void clear_scale();
  static const int kScaleFieldNumber = 1;
  float scale(int index) const;
  void set_scale(int index, float value);
  void add_scale(float value);
  const ::google::protobuf::RepeatedField< float >&
      scale() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_scale();

  // repeated float bias = 2;
  int bias_size() const;
  void clear_bias();
  static const int kBiasFieldNumber = 2;
  float bias(int index) const;
  void set_bias(int index, float value);
  void add_bias(float value);
  const ::google::protobuf::RepeatedField< float >&
      bias() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_bias();

  // @@protoc_insertion_point(class_scope:CoreML.Specification.LinearQuantizationParams)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedField< float > scale_;
  mutable int _scale_cached_byte_size_;
  ::google::protobuf::RepeatedField< float > bias_;
  mutable int _bias_cached_byte_size_;
  mutable int _cached_size_;
  friend struct protobuf_NeuralNetwork_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LookUpTableQuantizationParams : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.LookUpTableQuantizationParams) */ {
 public:
  LookUpTableQuantizationParams();
  virtual ~LookUpTableQuantizationParams();

  LookUpTableQuantizationParams(const LookUpTableQuantizationParams& from);

  inline LookUpTableQuantizationParams& operator=(const LookUpTableQuantizationParams& from) {
    CopyFrom(from);
    return *this;
  }

  static const LookUpTableQuantizationParams& default_instance();

  static inline const LookUpTableQuantizationParams* internal_default_instance() {
    return reinterpret_cast<const LookUpTableQuantizationParams*>(
               &_LookUpTableQuantizationParams_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    28;

  void Swap(LookUpTableQuantizationParams* other);

  // implements Message ----------------------------------------------

  inline LookUpTableQuantizationParams* New() const PROTOBUF_FINAL { return New(NULL); }

  LookUpTableQuantizationParams* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const LookUpTableQuantizationParams& from);
  void MergeFrom(const LookUpTableQuantizationParams& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LookUpTableQuantizationParams* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated float floatValue = 1;
  int floatvalue_size() const;
  void clear_floatvalue();
  static const int kFloatValueFieldNumber = 1;
  float floatvalue(int index) const;
  void set_floatvalue(int index, float value);
  void add_floatvalue(float value);
  const ::google::protobuf::RepeatedField< float >&
      floatvalue() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_floatvalue();

  // @@protoc_insertion_point(class_scope:CoreML.Specification.LookUpTableQuantizationParams)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedField< float > floatvalue_;
  mutable int _floatvalue_cached_byte_size_;
  mutable int _cached_size_;
  friend struct protobuf_NeuralNetwork_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ConvolutionLayerParams : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.ConvolutionLayerParams) */ {
 public:
  ConvolutionLayerParams();
  virtual ~ConvolutionLayerParams();

  ConvolutionLayerParams(const ConvolutionLayerParams& from);

  inline ConvolutionLayerParams& operator=(const ConvolutionLayerParams& from) {
    CopyFrom(from);
    return *this;
  }

  static const ConvolutionLayerParams& default_instance();

  enum ConvolutionPaddingTypeCase {
    kValid = 50,
    kSame = 51,
    CONVOLUTIONPADDINGTYPE_NOT_SET = 0,
  };

  static inline const ConvolutionLayerParams* internal_default_instance() {
    return reinterpret_cast<const ConvolutionLayerParams*>(
               &_ConvolutionLayerParams_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    29;

  void Swap(ConvolutionLayerParams* other);

  // implements Message ----------------------------------------------

  inline ConvolutionLayerParams* New() const PROTOBUF_FINAL { return New(NULL); }

  ConvolutionLayerParams* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const ConvolutionLayerParams& from);
  void MergeFrom(const ConvolutionLayerParams& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ConvolutionLayerParams* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint64 kernelSize = 20;
  int kernelsize_size() const;
  void clear_kernelsize();
  static const int kKernelSizeFieldNumber = 20;
  ::google::protobuf::uint64 kernelsize(int index) const;
  void set_kernelsize(int index, ::google::protobuf::uint64 value);
  void add_kernelsize(::google::protobuf::uint64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      kernelsize() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_kernelsize();

  // repeated uint64 stride = 30;
  int stride_size() const;
  void clear_stride();
  static const int kStrideFieldNumber = 30;
  ::google::protobuf::uint64 stride(int index) const;
  void set_stride(int index, ::google::protobuf::uint64 value);
  void add_stride(::google::protobuf::uint64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      stride() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_stride();

  // repeated uint64 dilationFactor = 40;
  int dilationfactor_size() const;
  void clear_dilationfactor();
  static const int kDilationFactorFieldNumber = 40;
  ::google::protobuf::uint64 dilationfactor(int index) const;
  void set_dilationfactor(int index, ::google::protobuf::uint64 value);
  void add_dilationfactor(::google::protobuf::uint64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      dilationfactor() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_dilationfactor();

  // repeated uint64 outputShape = 100;
  int outputshape_size() const;
  void clear_outputshape();
  static const int kOutputShapeFieldNumber = 100;
  ::google::protobuf::uint64 outputshape(int index) const;
  void set_outputshape(int index, ::google::protobuf::uint64 value);
  void add_outputshape(::google::protobuf::uint64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      outputshape() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_outputshape();

  // .CoreML.Specification.WeightParams weights = 90;
  bool has_weights() const;
  void clear_weights();
  static const int kWeightsFieldNumber = 90;
  const ::CoreML::Specification::WeightParams& weights() const;
  ::CoreML::Specification::WeightParams* mutable_weights();
  ::CoreML::Specification::WeightParams* release_weights();
  void set_allocated_weights(::CoreML::Specification::WeightParams* weights);

  // .CoreML.Specification.WeightParams bias = 91;
  bool has_bias() const;
  void clear_bias();
  static const int kBiasFieldNumber = 91;
  const ::CoreML::Specification::WeightParams& bias() const;
  ::CoreML::Specification::WeightParams* mutable_bias();
  ::CoreML::Specification::WeightParams* release_bias();
  void set_allocated_bias(::CoreML::Specification::WeightParams* bias);

  // uint64 outputChannels = 1;
  void clear_outputchannels();
  static const int kOutputChannelsFieldNumber = 1;
  ::google::protobuf::uint64 outputchannels() const;
  void set_outputchannels(::google::protobuf::uint64 value);

  // uint64 kernelChannels = 2;
  void clear_kernelchannels();
  static const int kKernelChannelsFieldNumber = 2;
  ::google::protobuf::uint64 kernelchannels() const;
  void set_kernelchannels(::google::protobuf::uint64 value);

  // uint64 nGroups = 10;
  void clear_ngroups();
  static const int kNGroupsFieldNumber = 10;
  ::google::protobuf::uint64 ngroups() const;
  void set_ngroups(::google::protobuf::uint64 value);

  // bool isDeconvolution = 60;
  void clear_isdeconvolution();
  static const int kIsDeconvolutionFieldNumber = 60;
  bool isdeconvolution() const;
  void set_isdeconvolution(bool value);

  // bool hasBias = 70;
  void clear_hasbias();
  static const int kHasBiasFieldNumber = 70;
  bool hasbias() const;
  void set_hasbias(bool value);

  // .CoreML.Specification.ValidPadding valid = 50;
  bool has_valid() const;
  void clear_valid();
  static const int kValidFieldNumber = 50;
  const ::CoreML::Specification::ValidPadding& valid() const;
  ::CoreML::Specification::ValidPadding* mutable_valid();
  ::CoreML::Specification::ValidPadding* release_valid();
  void set_allocated_valid(::CoreML::Specification::ValidPadding* valid);

  // .CoreML.Specification.SamePadding same = 51;
  bool has_same() const;
  void clear_same();
  static const int kSameFieldNumber = 51;
  const ::CoreML::Specification::SamePadding& same() const;
  ::CoreML::Specification::SamePadding* mutable_same();
  ::CoreML::Specification::SamePadding* release_same();
  void set_allocated_same(::CoreML::Specification::SamePadding* same);

  ConvolutionPaddingTypeCase ConvolutionPaddingType_case() const;
  // @@protoc_insertion_point(class_scope:CoreML.Specification.ConvolutionLayerParams)
 private:
  void set_has_valid();
  void set_has_same();

  inline bool has_ConvolutionPaddingType() const;
  void clear_ConvolutionPaddingType();
  inline void clear_has_ConvolutionPaddingType();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > kernelsize_;
  mutable int _kernelsize_cached_byte_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > stride_;
  mutable int _stride_cached_byte_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > dilationfactor_;
  mutable int _dilationfactor_cached_byte_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > outputshape_;
  mutable int _outputshape_cached_byte_size_;
  ::CoreML::Specification::WeightParams* weights_;
  ::CoreML::Specification::WeightParams* bias_;
  ::google::protobuf::uint64 outputchannels_;
  ::google::protobuf::uint64 kernelchannels_;
  ::google::protobuf::uint64 ngroups_;
  bool isdeconvolution_;
  bool hasbias_;
  union ConvolutionPaddingTypeUnion {
    ConvolutionPaddingTypeUnion() {}
    ::CoreML::Specification::ValidPadding* valid_;
    ::CoreML::Specification::SamePadding* same_;
  } ConvolutionPaddingType_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct protobuf_NeuralNetwork_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class InnerProductLayerParams : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.InnerProductLayerParams) */ {
 public:
  InnerProductLayerParams();
  virtual ~InnerProductLayerParams();

  InnerProductLayerParams(const InnerProductLayerParams& from);

  inline InnerProductLayerParams& operator=(const InnerProductLayerParams& from) {
    CopyFrom(from);
    return *this;
  }

  static const InnerProductLayerParams& default_instance();

  static inline const InnerProductLayerParams* internal_default_instance() {
    return reinterpret_cast<const InnerProductLayerParams*>(
               &_InnerProductLayerParams_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    30;

  void Swap(InnerProductLayerParams* other);

  // implements Message ----------------------------------------------

  inline InnerProductLayerParams* New() const PROTOBUF_FINAL { return New(NULL); }

  InnerProductLayerParams* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const InnerProductLayerParams& from);
  void MergeFrom(const InnerProductLayerParams& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(InnerProductLayerParams* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .CoreML.Specification.WeightParams weights = 20;
  bool has_weights() const;
  void clear_weights();
  static const int kWeightsFieldNumber = 20;
  const ::CoreML::Specification::WeightParams& weights() const;
  ::CoreML::Specification::WeightParams* mutable_weights();
  ::CoreML::Specification::WeightParams* release_weights();
  void set_allocated_weights(::CoreML::Specification::WeightParams* weights);

  // .CoreML.Specification.WeightParams bias = 21;
  bool has_bias() const;
  void clear_bias();
  static const int kBiasFieldNumber = 21;
  const ::CoreML::Specification::WeightParams& bias() const;
  ::CoreML::Specification::WeightParams* mutable_bias();
  ::CoreML::Specification::WeightParams* release_bias();
  void set_allocated_bias(::CoreML::Specification::WeightParams* bias);

  // uint64 inputChannels = 1;
  void clear_inputchannels();
  static const int kInputChannelsFieldNumber = 1;
  ::google::protobuf::uint64 inputchannels() const;
  void set_inputchannels(::google::protobuf::uint64 value);

  // uint64 outputChannels = 2;
  void clear_outputchannels();
  static const int kOutputChannelsFieldNumber = 2;
  ::google::protobuf::uint64 outputchannels() const;
  void set_outputchannels(::google::protobuf::uint64 value);

  // bool hasBias = 10;
  void clear_hasbias();
  static const int kHasBiasFieldNumber = 10;
  bool hasbias() const;
  void set_hasbias(bool value);

  // @@protoc_insertion_point(class_scope:CoreML.Specification.InnerProductLayerParams)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::CoreML::Specification::WeightParams* weights_;
  ::CoreML::Specification::WeightParams* bias_;
  ::google::protobuf::uint64 inputchannels_;
  ::google::protobuf::uint64 outputchannels_;
  bool hasbias_;
  mutable int _cached_size_;
  friend struct protobuf_NeuralNetwork_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class EmbeddingLayerParams : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.EmbeddingLayerParams) */ {
 public:
  EmbeddingLayerParams();
  virtual ~EmbeddingLayerParams();

  EmbeddingLayerParams(const EmbeddingLayerParams& from);

  inline EmbeddingLayerParams& operator=(const EmbeddingLayerParams& from) {
    CopyFrom(from);
    return *this;
  }

  static const EmbeddingLayerParams& default_instance();

  static inline const EmbeddingLayerParams* internal_default_instance() {
    return reinterpret_cast<const EmbeddingLayerParams*>(
               &_EmbeddingLayerParams_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    31;

  void Swap(EmbeddingLayerParams* other);

  // implements Message ----------------------------------------------

  inline EmbeddingLayerParams* New() const PROTOBUF_FINAL { return New(NULL); }

  EmbeddingLayerParams* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const EmbeddingLayerParams& from);
  void MergeFrom(const EmbeddingLayerParams& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(EmbeddingLayerParams* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .CoreML.Specification.WeightParams weights = 20;
  bool has_weights() const;
  void clear_weights();
  static const int kWeightsFieldNumber = 20;
  const ::CoreML::Specification::WeightParams& weights() const;
  ::CoreML::Specification::WeightParams* mutable_weights();
  ::CoreML::Specification::WeightParams* release_weights();
  void set_allocated_weights(::CoreML::Specification::WeightParams* weights);

  // .CoreML.Specification.WeightParams bias = 21;
  bool has_bias() const;
  void clear_bias();
  static const int kBiasFieldNumber = 21;
  const ::CoreML::Specification::WeightParams& bias() const;
  ::CoreML::Specification::WeightParams* mutable_bias();
  ::CoreML::Specification::WeightParams* release_bias();
  void set_allocated_bias(::CoreML::Specification::WeightParams* bias);

  // uint64 inputDim = 1;
  void clear_inputdim();
  static const int kInputDimFieldNumber = 1;
  ::google::protobuf::uint64 inputdim() const;
  void set_inputdim(::google::protobuf::uint64 value);

  // uint64 outputChannels = 2;
  void clear_outputchannels();
  static const int kOutputChannelsFieldNumber = 2;
  ::google::protobuf::uint64 outputchannels() const;
  void set_outputchannels(::google::protobuf::uint64 value);

  // bool hasBias = 10;
  void clear_hasbias();
  static const int kHasBiasFieldNumber = 10;
  bool hasbias() const;
  void set_hasbias(bool value);

  // @@protoc_insertion_point(class_scope:CoreML.Specification.EmbeddingLayerParams)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::CoreML::Specification::WeightParams* weights_;
  ::CoreML::Specification::WeightParams* bias_;
  ::google::protobuf::uint64 inputdim_;
  ::google::protobuf::uint64 outputchannels_;
  bool hasbias_;
  mutable int _cached_size_;
  friend struct protobuf_NeuralNetwork_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BatchnormLayerParams : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.BatchnormLayerParams) */ {
 public:
  BatchnormLayerParams();
  virtual ~BatchnormLayerParams();

  BatchnormLayerParams(const BatchnormLayerParams& from);

  inline BatchnormLayerParams& operator=(const BatchnormLayerParams& from) {
    CopyFrom(from);
    return *this;
  }

  static const BatchnormLayerParams& default_instance();

  static inline const BatchnormLayerParams* internal_default_instance() {
    return reinterpret_cast<const BatchnormLayerParams*>(
               &_BatchnormLayerParams_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    32;

  void Swap(BatchnormLayerParams* other);

  // implements Message ----------------------------------------------

  inline BatchnormLayerParams* New() const PROTOBUF_FINAL { return New(NULL); }

  BatchnormLayerParams* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const BatchnormLayerParams& from);
  void MergeFrom(const BatchnormLayerParams& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BatchnormLayerParams* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .CoreML.Specification.WeightParams gamma = 15;
  bool has_gamma() const;
  void clear_gamma();
  static const int kGammaFieldNumber = 15;
  const ::CoreML::Specification::WeightParams& gamma() const;
  ::CoreML::Specification::WeightParams* mutable_gamma();
  ::CoreML::Specification::WeightParams* release_gamma();
  void set_allocated_gamma(::CoreML::Specification::WeightParams* gamma);

  // .CoreML.Specification.WeightParams beta = 16;
  bool has_beta() const;
  void clear_beta();
  static const int kBetaFieldNumber = 16;
  const ::CoreML::Specification::WeightParams& beta() const;
  ::CoreML::Specification::WeightParams* mutable_beta();
  ::CoreML::Specification::WeightParams* release_beta();
  void set_allocated_beta(::CoreML::Specification::WeightParams* beta);

  // .CoreML.Specification.WeightParams mean = 17;
  bool has_mean() const;
  void clear_mean();
  static const int kMeanFieldNumber = 17;
  const ::CoreML::Specification::WeightParams& mean() const;
  ::CoreML::Specification::WeightParams* mutable_mean();
  ::CoreML::Specification::WeightParams* release_mean();
  void set_allocated_mean(::CoreML::Specification::WeightParams* mean);

  // .CoreML.Specification.WeightParams variance = 18;
  bool has_variance() const;
  void clear_variance();
  static const int kVarianceFieldNumber = 18;
  const ::CoreML::Specification::WeightParams& variance() const;
  ::CoreML::Specification::WeightParams* mutable_variance();
  ::CoreML::Specification::WeightParams* release_variance();
  void set_allocated_variance(::CoreML::Specification::WeightParams* variance);

  // uint64 channels = 1;
  void clear_channels();
  static const int kChannelsFieldNumber = 1;
  ::google::protobuf::uint64 channels() const;
  void set_channels(::google::protobuf::uint64 value);

  // bool computeMeanVar = 5;
  void clear_computemeanvar();
  static const int kComputeMeanVarFieldNumber = 5;
  bool computemeanvar() const;
  void set_computemeanvar(bool value);

  // bool instanceNormalization = 6;
  void clear_instancenormalization();
  static const int kInstanceNormalizationFieldNumber = 6;
  bool instancenormalization() const;
  void set_instancenormalization(bool value);

  // float epsilon = 10;
  void clear_epsilon();
  static const int kEpsilonFieldNumber = 10;
  float epsilon() const;
  void set_epsilon(float value);

  // @@protoc_insertion_point(class_scope:CoreML.Specification.BatchnormLayerParams)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::CoreML::Specification::WeightParams* gamma_;
  ::CoreML::Specification::WeightParams* beta_;
  ::CoreML::Specification::WeightParams* mean_;
  ::CoreML::Specification::WeightParams* variance_;
  ::google::protobuf::uint64 channels_;
  bool computemeanvar_;
  bool instancenormalization_;
  float epsilon_;
  mutable int _cached_size_;
  friend struct protobuf_NeuralNetwork_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PoolingLayerParams_ValidCompletePadding : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.PoolingLayerParams.ValidCompletePadding) */ {
 public:
  PoolingLayerParams_ValidCompletePadding();
  virtual ~PoolingLayerParams_ValidCompletePadding();

  PoolingLayerParams_ValidCompletePadding(const PoolingLayerParams_ValidCompletePadding& from);

  inline PoolingLayerParams_ValidCompletePadding& operator=(const PoolingLayerParams_ValidCompletePadding& from) {
    CopyFrom(from);
    return *this;
  }

  static const PoolingLayerParams_ValidCompletePadding& default_instance();

  static inline const PoolingLayerParams_ValidCompletePadding* internal_default_instance() {
    return reinterpret_cast<const PoolingLayerParams_ValidCompletePadding*>(
               &_PoolingLayerParams_ValidCompletePadding_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    33;

  void Swap(PoolingLayerParams_ValidCompletePadding* other);

  // implements Message ----------------------------------------------

  inline PoolingLayerParams_ValidCompletePadding* New() const PROTOBUF_FINAL { return New(NULL); }

  PoolingLayerParams_ValidCompletePadding* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const PoolingLayerParams_ValidCompletePadding& from);
  void MergeFrom(const PoolingLayerParams_ValidCompletePadding& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PoolingLayerParams_ValidCompletePadding* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint64 paddingAmounts = 10;
  int paddingamounts_size() const;
  void clear_paddingamounts();
  static const int kPaddingAmountsFieldNumber = 10;
  ::google::protobuf::uint64 paddingamounts(int index) const;
  void set_paddingamounts(int index, ::google::protobuf::uint64 value);
  void add_paddingamounts(::google::protobuf::uint64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      paddingamounts() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_paddingamounts();

  // @@protoc_insertion_point(class_scope:CoreML.Specification.PoolingLayerParams.ValidCompletePadding)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > paddingamounts_;
  mutable int _paddingamounts_cached_byte_size_;
  mutable int _cached_size_;
  friend struct protobuf_NeuralNetwork_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PoolingLayerParams : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.PoolingLayerParams) */ {
 public:
  PoolingLayerParams();
  virtual ~PoolingLayerParams();

  PoolingLayerParams(const PoolingLayerParams& from);

  inline PoolingLayerParams& operator=(const PoolingLayerParams& from) {
    CopyFrom(from);
    return *this;
  }

  static const PoolingLayerParams& default_instance();

  enum PoolingPaddingTypeCase {
    kValid = 30,
    kSame = 31,
    kIncludeLastPixel = 32,
    POOLINGPADDINGTYPE_NOT_SET = 0,
  };

  static inline const PoolingLayerParams* internal_default_instance() {
    return reinterpret_cast<const PoolingLayerParams*>(
               &_PoolingLayerParams_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    34;

  void Swap(PoolingLayerParams* other);

  // implements Message ----------------------------------------------

  inline PoolingLayerParams* New() const PROTOBUF_FINAL { return New(NULL); }

  PoolingLayerParams* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const PoolingLayerParams& from);
  void MergeFrom(const PoolingLayerParams& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PoolingLayerParams* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef PoolingLayerParams_ValidCompletePadding ValidCompletePadding;

  typedef PoolingLayerParams_PoolingType PoolingType;
  static const PoolingType MAX =
    PoolingLayerParams_PoolingType_MAX;
  static const PoolingType AVERAGE =
    PoolingLayerParams_PoolingType_AVERAGE;
  static const PoolingType L2 =
    PoolingLayerParams_PoolingType_L2;
  static inline bool PoolingType_IsValid(int value) {
    return PoolingLayerParams_PoolingType_IsValid(value);
  }
  static const PoolingType PoolingType_MIN =
    PoolingLayerParams_PoolingType_PoolingType_MIN;
  static const PoolingType PoolingType_MAX =
    PoolingLayerParams_PoolingType_PoolingType_MAX;
  static const int PoolingType_ARRAYSIZE =
    PoolingLayerParams_PoolingType_PoolingType_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // repeated uint64 kernelSize = 10;
  int kernelsize_size() const;
  void clear_kernelsize();
  static const int kKernelSizeFieldNumber = 10;
  ::google::protobuf::uint64 kernelsize(int index) const;
  void set_kernelsize(int index, ::google::protobuf::uint64 value);
  void add_kernelsize(::google::protobuf::uint64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      kernelsize() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_kernelsize();

  // repeated uint64 stride = 20;
  int stride_size() const;
  void clear_stride();
  static const int kStrideFieldNumber = 20;
  ::google::protobuf::uint64 stride(int index) const;
  void set_stride(int index, ::google::protobuf::uint64 value);
  void add_stride(::google::protobuf::uint64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      stride() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_stride();

  // .CoreML.Specification.PoolingLayerParams.PoolingType type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::CoreML::Specification::PoolingLayerParams_PoolingType type() const;
  void set_type(::CoreML::Specification::PoolingLayerParams_PoolingType value);

  // bool avgPoolExcludePadding = 50;
  void clear_avgpoolexcludepadding();
  static const int kAvgPoolExcludePaddingFieldNumber = 50;
  bool avgpoolexcludepadding() const;
  void set_avgpoolexcludepadding(bool value);

  // bool globalPooling = 60;
  void clear_globalpooling();
  static const int kGlobalPoolingFieldNumber = 60;
  bool globalpooling() const;
  void set_globalpooling(bool value);

  // .CoreML.Specification.ValidPadding valid = 30;
  bool has_valid() const;
  void clear_valid();
  static const int kValidFieldNumber = 30;
  const ::CoreML::Specification::ValidPadding& valid() const;
  ::CoreML::Specification::ValidPadding* mutable_valid();
  ::CoreML::Specification::ValidPadding* release_valid();
  void set_allocated_valid(::CoreML::Specification::ValidPadding* valid);

  // .CoreML.Specification.SamePadding same = 31;
  bool has_same() const;
  void clear_same();
  static const int kSameFieldNumber = 31;
  const ::CoreML::Specification::SamePadding& same() const;
  ::CoreML::Specification::SamePadding* mutable_same();
  ::CoreML::Specification::SamePadding* release_same();
  void set_allocated_same(::CoreML::Specification::SamePadding* same);

  // .CoreML.Specification.PoolingLayerParams.ValidCompletePadding includeLastPixel = 32;
  bool has_includelastpixel() const;
  void clear_includelastpixel();
  static const int kIncludeLastPixelFieldNumber = 32;
  const ::CoreML::Specification::PoolingLayerParams_ValidCompletePadding& includelastpixel() const;
  ::CoreML::Specification::PoolingLayerParams_ValidCompletePadding* mutable_includelastpixel();
  ::CoreML::Specification::PoolingLayerParams_ValidCompletePadding* release_includelastpixel();
  void set_allocated_includelastpixel(::CoreML::Specification::PoolingLayerParams_ValidCompletePadding* includelastpixel);

  PoolingPaddingTypeCase PoolingPaddingType_case() const;
  // @@protoc_insertion_point(class_scope:CoreML.Specification.PoolingLayerParams)
 private:
  void set_has_valid();
  void set_has_same();
  void set_has_includelastpixel();

  inline bool has_PoolingPaddingType() const;
  void clear_PoolingPaddingType();
  inline void clear_has_PoolingPaddingType();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > kernelsize_;
  mutable int _kernelsize_cached_byte_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > stride_;
  mutable int _stride_cached_byte_size_;
  int type_;
  bool avgpoolexcludepadding_;
  bool globalpooling_;
  union PoolingPaddingTypeUnion {
    PoolingPaddingTypeUnion() {}
    ::CoreML::Specification::ValidPadding* valid_;
    ::CoreML::Specification::SamePadding* same_;
    ::CoreML::Specification::PoolingLayerParams_ValidCompletePadding* includelastpixel_;
  } PoolingPaddingType_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct protobuf_NeuralNetwork_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PaddingLayerParams_PaddingConstant : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.PaddingLayerParams.PaddingConstant) */ {
 public:
  PaddingLayerParams_PaddingConstant();
  virtual ~PaddingLayerParams_PaddingConstant();

  PaddingLayerParams_PaddingConstant(const PaddingLayerParams_PaddingConstant& from);

  inline PaddingLayerParams_PaddingConstant& operator=(const PaddingLayerParams_PaddingConstant& from) {
    CopyFrom(from);
    return *this;
  }

  static const PaddingLayerParams_PaddingConstant& default_instance();

  static inline const PaddingLayerParams_PaddingConstant* internal_default_instance() {
    return reinterpret_cast<const PaddingLayerParams_PaddingConstant*>(
               &_PaddingLayerParams_PaddingConstant_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    35;

  void Swap(PaddingLayerParams_PaddingConstant* other);

  // implements Message ----------------------------------------------

  inline PaddingLayerParams_PaddingConstant* New() const PROTOBUF_FINAL { return New(NULL); }

  PaddingLayerParams_PaddingConstant* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const PaddingLayerParams_PaddingConstant& from);
  void MergeFrom(const PaddingLayerParams_PaddingConstant& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PaddingLayerParams_PaddingConstant* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float value = 1;
  void clear_value();
  static const int kValueFieldNumber = 1;
  float value() const;
  void set_value(float value);

  // @@protoc_insertion_point(class_scope:CoreML.Specification.PaddingLayerParams.PaddingConstant)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  float value_;
  mutable int _cached_size_;
  friend struct protobuf_NeuralNetwork_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PaddingLayerParams_PaddingReflection : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.PaddingLayerParams.PaddingReflection) */ {
 public:
  PaddingLayerParams_PaddingReflection();
  virtual ~PaddingLayerParams_PaddingReflection();

  PaddingLayerParams_PaddingReflection(const PaddingLayerParams_PaddingReflection& from);

  inline PaddingLayerParams_PaddingReflection& operator=(const PaddingLayerParams_PaddingReflection& from) {
    CopyFrom(from);
    return *this;
  }

  static const PaddingLayerParams_PaddingReflection& default_instance();

  static inline const PaddingLayerParams_PaddingReflection* internal_default_instance() {
    return reinterpret_cast<const PaddingLayerParams_PaddingReflection*>(
               &_PaddingLayerParams_PaddingReflection_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    36;

  void Swap(PaddingLayerParams_PaddingReflection* other);

  // implements Message ----------------------------------------------

  inline PaddingLayerParams_PaddingReflection* New() const PROTOBUF_FINAL { return New(NULL); }

  PaddingLayerParams_PaddingReflection* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const PaddingLayerParams_PaddingReflection& from);
  void MergeFrom(const PaddingLayerParams_PaddingReflection& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PaddingLayerParams_PaddingReflection* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:CoreML.Specification.PaddingLayerParams.PaddingReflection)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  mutable int _cached_size_;
  friend struct protobuf_NeuralNetwork_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PaddingLayerParams_PaddingReplication : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.PaddingLayerParams.PaddingReplication) */ {
 public:
  PaddingLayerParams_PaddingReplication();
  virtual ~PaddingLayerParams_PaddingReplication();

  PaddingLayerParams_PaddingReplication(const PaddingLayerParams_PaddingReplication& from);

  inline PaddingLayerParams_PaddingReplication& operator=(const PaddingLayerParams_PaddingReplication& from) {
    CopyFrom(from);
    return *this;
  }

  static const PaddingLayerParams_PaddingReplication& default_instance();

  static inline const PaddingLayerParams_PaddingReplication* internal_default_instance() {
    return reinterpret_cast<const PaddingLayerParams_PaddingReplication*>(
               &_PaddingLayerParams_PaddingReplication_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    37;

  void Swap(PaddingLayerParams_PaddingReplication* other);

  // implements Message ----------------------------------------------

  inline PaddingLayerParams_PaddingReplication* New() const PROTOBUF_FINAL { return New(NULL); }

  PaddingLayerParams_PaddingReplication* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const PaddingLayerParams_PaddingReplication& from);
  void MergeFrom(const PaddingLayerParams_PaddingReplication& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PaddingLayerParams_PaddingReplication* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:CoreML.Specification.PaddingLayerParams.PaddingReplication)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  mutable int _cached_size_;
  friend struct protobuf_NeuralNetwork_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PaddingLayerParams : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.PaddingLayerParams) */ {
 public:
  PaddingLayerParams();
  virtual ~PaddingLayerParams();

  PaddingLayerParams(const PaddingLayerParams& from);

  inline PaddingLayerParams& operator=(const PaddingLayerParams& from) {
    CopyFrom(from);
    return *this;
  }

  static const PaddingLayerParams& default_instance();

  enum PaddingTypeCase {
    kConstant = 1,
    kReflection = 2,
    kReplication = 3,
    PADDINGTYPE_NOT_SET = 0,
  };

  static inline const PaddingLayerParams* internal_default_instance() {
    return reinterpret_cast<const PaddingLayerParams*>(
               &_PaddingLayerParams_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    38;

  void Swap(PaddingLayerParams* other);

  // implements Message ----------------------------------------------

  inline PaddingLayerParams* New() const PROTOBUF_FINAL { return New(NULL); }

  PaddingLayerParams* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const PaddingLayerParams& from);
  void MergeFrom(const PaddingLayerParams& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PaddingLayerParams* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef PaddingLayerParams_PaddingConstant PaddingConstant;
  typedef PaddingLayerParams_PaddingReflection PaddingReflection;
  typedef PaddingLayerParams_PaddingReplication PaddingReplication;

  // accessors -------------------------------------------------------

  // .CoreML.Specification.BorderAmounts paddingAmounts = 10;
  bool has_paddingamounts() const;
  void clear_paddingamounts();
  static const int kPaddingAmountsFieldNumber = 10;
  const ::CoreML::Specification::BorderAmounts& paddingamounts() const;
  ::CoreML::Specification::BorderAmounts* mutable_paddingamounts();
  ::CoreML::Specification::BorderAmounts* release_paddingamounts();
  void set_allocated_paddingamounts(::CoreML::Specification::BorderAmounts* paddingamounts);

  // .CoreML.Specification.PaddingLayerParams.PaddingConstant constant = 1;
  bool has_constant() const;
  void clear_constant();
  static const int kConstantFieldNumber = 1;
  const ::CoreML::Specification::PaddingLayerParams_PaddingConstant& constant() const;
  ::CoreML::Specification::PaddingLayerParams_PaddingConstant* mutable_constant();
  ::CoreML::Specification::PaddingLayerParams_PaddingConstant* release_constant();
  void set_allocated_constant(::CoreML::Specification::PaddingLayerParams_PaddingConstant* constant);

  // .CoreML.Specification.PaddingLayerParams.PaddingReflection reflection = 2;
  bool has_reflection() const;
  void clear_reflection();
  static const int kReflectionFieldNumber = 2;
  const ::CoreML::Specification::PaddingLayerParams_PaddingReflection& reflection() const;
  ::CoreML::Specification::PaddingLayerParams_PaddingReflection* mutable_reflection();
  ::CoreML::Specification::PaddingLayerParams_PaddingReflection* release_reflection();
  void set_allocated_reflection(::CoreML::Specification::PaddingLayerParams_PaddingReflection* reflection);

  // .CoreML.Specification.PaddingLayerParams.PaddingReplication replication = 3;
  bool has_replication() const;
  void clear_replication();
  static const int kReplicationFieldNumber = 3;
  const ::CoreML::Specification::PaddingLayerParams_PaddingReplication& replication() const;
  ::CoreML::Specification::PaddingLayerParams_PaddingReplication* mutable_replication();
  ::CoreML::Specification::PaddingLayerParams_PaddingReplication* release_replication();
  void set_allocated_replication(::CoreML::Specification::PaddingLayerParams_PaddingReplication* replication);

  PaddingTypeCase PaddingType_case() const;
  // @@protoc_insertion_point(class_scope:CoreML.Specification.PaddingLayerParams)
 private:
  void set_has_constant();
  void set_has_reflection();
  void set_has_replication();

  inline bool has_PaddingType() const;
  void clear_PaddingType();
  inline void clear_has_PaddingType();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::CoreML::Specification::BorderAmounts* paddingamounts_;
  union PaddingTypeUnion {
    PaddingTypeUnion() {}
    ::CoreML::Specification::PaddingLayerParams_PaddingConstant* constant_;
    ::CoreML::Specification::PaddingLayerParams_PaddingReflection* reflection_;
    ::CoreML::Specification::PaddingLayerParams_PaddingReplication* replication_;
  } PaddingType_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct protobuf_NeuralNetwork_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ConcatLayerParams : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.ConcatLayerParams) */ {
 public:
  ConcatLayerParams();
  virtual ~ConcatLayerParams();

  ConcatLayerParams(const ConcatLayerParams& from);

  inline ConcatLayerParams& operator=(const ConcatLayerParams& from) {
    CopyFrom(from);
    return *this;
  }

  static const ConcatLayerParams& default_instance();

  static inline const ConcatLayerParams* internal_default_instance() {
    return reinterpret_cast<const ConcatLayerParams*>(
               &_ConcatLayerParams_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    39;

  void Swap(ConcatLayerParams* other);

  // implements Message ----------------------------------------------

  inline ConcatLayerParams* New() const PROTOBUF_FINAL { return New(NULL); }

  ConcatLayerParams* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const ConcatLayerParams& from);
  void MergeFrom(const ConcatLayerParams& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ConcatLayerParams* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bool sequenceConcat = 100;
  void clear_sequenceconcat();
  static const int kSequenceConcatFieldNumber = 100;
  bool sequenceconcat() const;
  void set_sequenceconcat(bool value);

  // @@protoc_insertion_point(class_scope:CoreML.Specification.ConcatLayerParams)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  bool sequenceconcat_;
  mutable int _cached_size_;
  friend struct protobuf_NeuralNetwork_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LRNLayerParams : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.LRNLayerParams) */ {
 public:
  LRNLayerParams();
  virtual ~LRNLayerParams();

  LRNLayerParams(const LRNLayerParams& from);

  inline LRNLayerParams& operator=(const LRNLayerParams& from) {
    CopyFrom(from);
    return *this;
  }

  static const LRNLayerParams& default_instance();

  static inline const LRNLayerParams* internal_default_instance() {
    return reinterpret_cast<const LRNLayerParams*>(
               &_LRNLayerParams_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    40;

  void Swap(LRNLayerParams* other);

  // implements Message ----------------------------------------------

  inline LRNLayerParams* New() const PROTOBUF_FINAL { return New(NULL); }

  LRNLayerParams* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const LRNLayerParams& from);
  void MergeFrom(const LRNLayerParams& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LRNLayerParams* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float alpha = 1;
  void clear_alpha();
  static const int kAlphaFieldNumber = 1;
  float alpha() const;
  void set_alpha(float value);

  // float beta = 2;
  void clear_beta();
  static const int kBetaFieldNumber = 2;
  float beta() const;
  void set_beta(float value);

  // uint64 localSize = 3;
  void clear_localsize();
  static const int kLocalSizeFieldNumber = 3;
  ::google::protobuf::uint64 localsize() const;
  void set_localsize(::google::protobuf::uint64 value);

  // float k = 4;
  void clear_k();
  static const int kKFieldNumber = 4;
  float k() const;
  void set_k(float value);

  // @@protoc_insertion_point(class_scope:CoreML.Specification.LRNLayerParams)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  float alpha_;
  float beta_;
  ::google::protobuf::uint64 localsize_;
  float k_;
  mutable int _cached_size_;
  friend struct protobuf_NeuralNetwork_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SoftmaxLayerParams : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.SoftmaxLayerParams) */ {
 public:
  SoftmaxLayerParams();
  virtual ~SoftmaxLayerParams();

  SoftmaxLayerParams(const SoftmaxLayerParams& from);

  inline SoftmaxLayerParams& operator=(const SoftmaxLayerParams& from) {
    CopyFrom(from);
    return *this;
  }

  static const SoftmaxLayerParams& default_instance();

  static inline const SoftmaxLayerParams* internal_default_instance() {
    return reinterpret_cast<const SoftmaxLayerParams*>(
               &_SoftmaxLayerParams_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    41;

  void Swap(SoftmaxLayerParams* other);

  // implements Message ----------------------------------------------

  inline SoftmaxLayerParams* New() const PROTOBUF_FINAL { return New(NULL); }

  SoftmaxLayerParams* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const SoftmaxLayerParams& from);
  void MergeFrom(const SoftmaxLayerParams& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SoftmaxLayerParams* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:CoreML.Specification.SoftmaxLayerParams)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  mutable int _cached_size_;
  friend struct protobuf_NeuralNetwork_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SplitLayerParams : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.SplitLayerParams) */ {
 public:
  SplitLayerParams();
  virtual ~SplitLayerParams();

  SplitLayerParams(const SplitLayerParams& from);

  inline SplitLayerParams& operator=(const SplitLayerParams& from) {
    CopyFrom(from);
    return *this;
  }

  static const SplitLayerParams& default_instance();

  static inline const SplitLayerParams* internal_default_instance() {
    return reinterpret_cast<const SplitLayerParams*>(
               &_SplitLayerParams_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    42;

  void Swap(SplitLayerParams* other);

  // implements Message ----------------------------------------------

  inline SplitLayerParams* New() const PROTOBUF_FINAL { return New(NULL); }

  SplitLayerParams* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const SplitLayerParams& from);
  void MergeFrom(const SplitLayerParams& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SplitLayerParams* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint64 nOutputs = 1;
  void clear_noutputs();
  static const int kNOutputsFieldNumber = 1;
  ::google::protobuf::uint64 noutputs() const;
  void set_noutputs(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:CoreML.Specification.SplitLayerParams)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::uint64 noutputs_;
  mutable int _cached_size_;
  friend struct protobuf_NeuralNetwork_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AddLayerParams : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.AddLayerParams) */ {
 public:
  AddLayerParams();
  virtual ~AddLayerParams();

  AddLayerParams(const AddLayerParams& from);

  inline AddLayerParams& operator=(const AddLayerParams& from) {
    CopyFrom(from);
    return *this;
  }

  static const AddLayerParams& default_instance();

  static inline const AddLayerParams* internal_default_instance() {
    return reinterpret_cast<const AddLayerParams*>(
               &_AddLayerParams_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    43;

  void Swap(AddLayerParams* other);

  // implements Message ----------------------------------------------

  inline AddLayerParams* New() const PROTOBUF_FINAL { return New(NULL); }

  AddLayerParams* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const AddLayerParams& from);
  void MergeFrom(const AddLayerParams& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AddLayerParams* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float alpha = 1;
  void clear_alpha();
  static const int kAlphaFieldNumber = 1;
  float alpha() const;
  void set_alpha(float value);

  // @@protoc_insertion_point(class_scope:CoreML.Specification.AddLayerParams)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  float alpha_;
  mutable int _cached_size_;
  friend struct protobuf_NeuralNetwork_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MultiplyLayerParams : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.MultiplyLayerParams) */ {
 public:
  MultiplyLayerParams();
  virtual ~MultiplyLayerParams();

  MultiplyLayerParams(const MultiplyLayerParams& from);

  inline MultiplyLayerParams& operator=(const MultiplyLayerParams& from) {
    CopyFrom(from);
    return *this;
  }

  static const MultiplyLayerParams& default_instance();

  static inline const MultiplyLayerParams* internal_default_instance() {
    return reinterpret_cast<const MultiplyLayerParams*>(
               &_MultiplyLayerParams_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    44;

  void Swap(MultiplyLayerParams* other);

  // implements Message ----------------------------------------------

  inline MultiplyLayerParams* New() const PROTOBUF_FINAL { return New(NULL); }

  MultiplyLayerParams* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const MultiplyLayerParams& from);
  void MergeFrom(const MultiplyLayerParams& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MultiplyLayerParams* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float alpha = 1;
  void clear_alpha();
  static const int kAlphaFieldNumber = 1;
  float alpha() const;
  void set_alpha(float value);

  // @@protoc_insertion_point(class_scope:CoreML.Specification.MultiplyLayerParams)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  float alpha_;
  mutable int _cached_size_;
  friend struct protobuf_NeuralNetwork_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UnaryFunctionLayerParams : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.UnaryFunctionLayerParams) */ {
 public:
  UnaryFunctionLayerParams();
  virtual ~UnaryFunctionLayerParams();

  UnaryFunctionLayerParams(const UnaryFunctionLayerParams& from);

  inline UnaryFunctionLayerParams& operator=(const UnaryFunctionLayerParams& from) {
    CopyFrom(from);
    return *this;
  }

  static const UnaryFunctionLayerParams& default_instance();

  static inline const UnaryFunctionLayerParams* internal_default_instance() {
    return reinterpret_cast<const UnaryFunctionLayerParams*>(
               &_UnaryFunctionLayerParams_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    45;

  void Swap(UnaryFunctionLayerParams* other);

  // implements Message ----------------------------------------------

  inline UnaryFunctionLayerParams* New() const PROTOBUF_FINAL { return New(NULL); }

  UnaryFunctionLayerParams* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const UnaryFunctionLayerParams& from);
  void MergeFrom(const UnaryFunctionLayerParams& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(UnaryFunctionLayerParams* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef UnaryFunctionLayerParams_Operation Operation;
  static const Operation SQRT =
    UnaryFunctionLayerParams_Operation_SQRT;
  static const Operation RSQRT =
    UnaryFunctionLayerParams_Operation_RSQRT;
  static const Operation INVERSE =
    UnaryFunctionLayerParams_Operation_INVERSE;
  static const Operation POWER =
    UnaryFunctionLayerParams_Operation_POWER;
  static const Operation EXP =
    UnaryFunctionLayerParams_Operation_EXP;
  static const Operation LOG =
    UnaryFunctionLayerParams_Operation_LOG;
  static const Operation ABS =
    UnaryFunctionLayerParams_Operation_ABS;
  static const Operation THRESHOLD =
    UnaryFunctionLayerParams_Operation_THRESHOLD;
  static inline bool Operation_IsValid(int value) {
    return UnaryFunctionLayerParams_Operation_IsValid(value);
  }
  static const Operation Operation_MIN =
    UnaryFunctionLayerParams_Operation_Operation_MIN;
  static const Operation Operation_MAX =
    UnaryFunctionLayerParams_Operation_Operation_MAX;
  static const int Operation_ARRAYSIZE =
    UnaryFunctionLayerParams_Operation_Operation_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // .CoreML.Specification.UnaryFunctionLayerParams.Operation type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::CoreML::Specification::UnaryFunctionLayerParams_Operation type() const;
  void set_type(::CoreML::Specification::UnaryFunctionLayerParams_Operation value);

  // float alpha = 2;
  void clear_alpha();
  static const int kAlphaFieldNumber = 2;
  float alpha() const;
  void set_alpha(float value);

  // float epsilon = 3;
  void clear_epsilon();
  static const int kEpsilonFieldNumber = 3;
  float epsilon() const;
  void set_epsilon(float value);

  // float shift = 4;
  void clear_shift();
  static const int kShiftFieldNumber = 4;
  float shift() const;
  void set_shift(float value);

  // float scale = 5;
  void clear_scale();
  static const int kScaleFieldNumber = 5;
  float scale() const;
  void set_scale(float value);

  // @@protoc_insertion_point(class_scope:CoreML.Specification.UnaryFunctionLayerParams)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  int type_;
  float alpha_;
  float epsilon_;
  float shift_;
  float scale_;
  mutable int _cached_size_;
  friend struct protobuf_NeuralNetwork_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UpsampleLayerParams : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.UpsampleLayerParams) */ {
 public:
  UpsampleLayerParams();
  virtual ~UpsampleLayerParams();

  UpsampleLayerParams(const UpsampleLayerParams& from);

  inline UpsampleLayerParams& operator=(const UpsampleLayerParams& from) {
    CopyFrom(from);
    return *this;
  }

  static const UpsampleLayerParams& default_instance();

  static inline const UpsampleLayerParams* internal_default_instance() {
    return reinterpret_cast<const UpsampleLayerParams*>(
               &_UpsampleLayerParams_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    46;

  void Swap(UpsampleLayerParams* other);

  // implements Message ----------------------------------------------

  inline UpsampleLayerParams* New() const PROTOBUF_FINAL { return New(NULL); }

  UpsampleLayerParams* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const UpsampleLayerParams& from);
  void MergeFrom(const UpsampleLayerParams& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(UpsampleLayerParams* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef UpsampleLayerParams_InterpolationMode InterpolationMode;
  static const InterpolationMode NN =
    UpsampleLayerParams_InterpolationMode_NN;
  static const InterpolationMode BILINEAR =
    UpsampleLayerParams_InterpolationMode_BILINEAR;
  static inline bool InterpolationMode_IsValid(int value) {
    return UpsampleLayerParams_InterpolationMode_IsValid(value);
  }
  static const InterpolationMode InterpolationMode_MIN =
    UpsampleLayerParams_InterpolationMode_InterpolationMode_MIN;
  static const InterpolationMode InterpolationMode_MAX =
    UpsampleLayerParams_InterpolationMode_InterpolationMode_MAX;
  static const int InterpolationMode_ARRAYSIZE =
    UpsampleLayerParams_InterpolationMode_InterpolationMode_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // repeated uint64 scalingFactor = 1;
  int scalingfactor_size() const;
  void clear_scalingfactor();
  static const int kScalingFactorFieldNumber = 1;
  ::google::protobuf::uint64 scalingfactor(int index) const;
  void set_scalingfactor(int index, ::google::protobuf::uint64 value);
  void add_scalingfactor(::google::protobuf::uint64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      scalingfactor() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_scalingfactor();

  // .CoreML.Specification.UpsampleLayerParams.InterpolationMode mode = 5;
  void clear_mode();
  static const int kModeFieldNumber = 5;
  ::CoreML::Specification::UpsampleLayerParams_InterpolationMode mode() const;
  void set_mode(::CoreML::Specification::UpsampleLayerParams_InterpolationMode value);

  // @@protoc_insertion_point(class_scope:CoreML.Specification.UpsampleLayerParams)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > scalingfactor_;
  mutable int _scalingfactor_cached_byte_size_;
  int mode_;
  mutable int _cached_size_;
  friend struct protobuf_NeuralNetwork_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ResizeBilinearLayerParams : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.ResizeBilinearLayerParams) */ {
 public:
  ResizeBilinearLayerParams();
  virtual ~ResizeBilinearLayerParams();

  ResizeBilinearLayerParams(const ResizeBilinearLayerParams& from);

  inline ResizeBilinearLayerParams& operator=(const ResizeBilinearLayerParams& from) {
    CopyFrom(from);
    return *this;
  }

  static const ResizeBilinearLayerParams& default_instance();

  static inline const ResizeBilinearLayerParams* internal_default_instance() {
    return reinterpret_cast<const ResizeBilinearLayerParams*>(
               &_ResizeBilinearLayerParams_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    47;

  void Swap(ResizeBilinearLayerParams* other);

  // implements Message ----------------------------------------------

  inline ResizeBilinearLayerParams* New() const PROTOBUF_FINAL { return New(NULL); }

  ResizeBilinearLayerParams* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const ResizeBilinearLayerParams& from);
  void MergeFrom(const ResizeBilinearLayerParams& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ResizeBilinearLayerParams* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint64 targetSize = 1;
  int targetsize_size() const;
  void clear_targetsize();
  static const int kTargetSizeFieldNumber = 1;
  ::google::protobuf::uint64 targetsize(int index) const;
  void set_targetsize(int index, ::google::protobuf::uint64 value);
  void add_targetsize(::google::protobuf::uint64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      targetsize() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_targetsize();

  // .CoreML.Specification.SamplingMode mode = 2;
  bool has_mode() const;
  void clear_mode();
  static const int kModeFieldNumber = 2;
  const ::CoreML::Specification::SamplingMode& mode() const;
  ::CoreML::Specification::SamplingMode* mutable_mode();
  ::CoreML::Specification::SamplingMode* release_mode();
  void set_allocated_mode(::CoreML::Specification::SamplingMode* mode);

  // @@protoc_insertion_point(class_scope:CoreML.Specification.ResizeBilinearLayerParams)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > targetsize_;
  mutable int _targetsize_cached_byte_size_;
  ::CoreML::Specification::SamplingMode* mode_;
  mutable int _cached_size_;
  friend struct protobuf_NeuralNetwork_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CropResizeLayerParams : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.CropResizeLayerParams) */ {
 public:
  CropResizeLayerParams();
  virtual ~CropResizeLayerParams();

  CropResizeLayerParams(const CropResizeLayerParams& from);

  inline CropResizeLayerParams& operator=(const CropResizeLayerParams& from) {
    CopyFrom(from);
    return *this;
  }

  static const CropResizeLayerParams& default_instance();

  static inline const CropResizeLayerParams* internal_default_instance() {
    return reinterpret_cast<const CropResizeLayerParams*>(
               &_CropResizeLayerParams_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    48;

  void Swap(CropResizeLayerParams* other);

  // implements Message ----------------------------------------------

  inline CropResizeLayerParams* New() const PROTOBUF_FINAL { return New(NULL); }

  CropResizeLayerParams* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const CropResizeLayerParams& from);
  void MergeFrom(const CropResizeLayerParams& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CropResizeLayerParams* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint64 targetSize = 1;
  int targetsize_size() const;
  void clear_targetsize();
  static const int kTargetSizeFieldNumber = 1;
  ::google::protobuf::uint64 targetsize(int index) const;
  void set_targetsize(int index, ::google::protobuf::uint64 value);
  void add_targetsize(::google::protobuf::uint64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      targetsize() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_targetsize();

  // .CoreML.Specification.SamplingMode mode = 3;
  bool has_mode() const;
  void clear_mode();
  static const int kModeFieldNumber = 3;
  const ::CoreML::Specification::SamplingMode& mode() const;
  ::CoreML::Specification::SamplingMode* mutable_mode();
  ::CoreML::Specification::SamplingMode* release_mode();
  void set_allocated_mode(::CoreML::Specification::SamplingMode* mode);

  // .CoreML.Specification.BoxCoordinatesMode boxIndicesMode = 4;
  bool has_boxindicesmode() const;
  void clear_boxindicesmode();
  static const int kBoxIndicesModeFieldNumber = 4;
  const ::CoreML::Specification::BoxCoordinatesMode& boxindicesmode() const;
  ::CoreML::Specification::BoxCoordinatesMode* mutable_boxindicesmode();
  ::CoreML::Specification::BoxCoordinatesMode* release_boxindicesmode();
  void set_allocated_boxindicesmode(::CoreML::Specification::BoxCoordinatesMode* boxindicesmode);

  // bool normalizedCoordinates = 2;
  void clear_normalizedcoordinates();
  static const int kNormalizedCoordinatesFieldNumber = 2;
  bool normalizedcoordinates() const;
  void set_normalizedcoordinates(bool value);

  // float spatialScale = 5;
  void clear_spatialscale();
  static const int kSpatialScaleFieldNumber = 5;
  float spatialscale() const;
  void set_spatialscale(float value);

  // @@protoc_insertion_point(class_scope:CoreML.Specification.CropResizeLayerParams)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > targetsize_;
  mutable int _targetsize_cached_byte_size_;
  ::CoreML::Specification::SamplingMode* mode_;
  ::CoreML::Specification::BoxCoordinatesMode* boxindicesmode_;
  bool normalizedcoordinates_;
  float spatialscale_;
  mutable int _cached_size_;
  friend struct protobuf_NeuralNetwork_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BiasLayerParams : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.BiasLayerParams) */ {
 public:
  BiasLayerParams();
  virtual ~BiasLayerParams();

  BiasLayerParams(const BiasLayerParams& from);

  inline BiasLayerParams& operator=(const BiasLayerParams& from) {
    CopyFrom(from);
    return *this;
  }

  static const BiasLayerParams& default_instance();

  static inline const BiasLayerParams* internal_default_instance() {
    return reinterpret_cast<const BiasLayerParams*>(
               &_BiasLayerParams_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    49;

  void Swap(BiasLayerParams* other);

  // implements Message ----------------------------------------------

  inline BiasLayerParams* New() const PROTOBUF_FINAL { return New(NULL); }

  BiasLayerParams* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const BiasLayerParams& from);
  void MergeFrom(const BiasLayerParams& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BiasLayerParams* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint64 shape = 1;
  int shape_size() const;
  void clear_shape();
  static const int kShapeFieldNumber = 1;
  ::google::protobuf::uint64 shape(int index) const;
  void set_shape(int index, ::google::protobuf::uint64 value);
  void add_shape(::google::protobuf::uint64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      shape() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_shape();

  // .CoreML.Specification.WeightParams bias = 2;
  bool has_bias() const;
  void clear_bias();
  static const int kBiasFieldNumber = 2;
  const ::CoreML::Specification::WeightParams& bias() const;
  ::CoreML::Specification::WeightParams* mutable_bias();
  ::CoreML::Specification::WeightParams* release_bias();
  void set_allocated_bias(::CoreML::Specification::WeightParams* bias);

  // @@protoc_insertion_point(class_scope:CoreML.Specification.BiasLayerParams)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > shape_;
  mutable int _shape_cached_byte_size_;
  ::CoreML::Specification::WeightParams* bias_;
  mutable int _cached_size_;
  friend struct protobuf_NeuralNetwork_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ScaleLayerParams : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.ScaleLayerParams) */ {
 public:
  ScaleLayerParams();
  virtual ~ScaleLayerParams();

  ScaleLayerParams(const ScaleLayerParams& from);

  inline ScaleLayerParams& operator=(const ScaleLayerParams& from) {
    CopyFrom(from);
    return *this;
  }

  static const ScaleLayerParams& default_instance();

  static inline const ScaleLayerParams* internal_default_instance() {
    return reinterpret_cast<const ScaleLayerParams*>(
               &_ScaleLayerParams_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    50;

  void Swap(ScaleLayerParams* other);

  // implements Message ----------------------------------------------

  inline ScaleLayerParams* New() const PROTOBUF_FINAL { return New(NULL); }

  ScaleLayerParams* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const ScaleLayerParams& from);
  void MergeFrom(const ScaleLayerParams& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ScaleLayerParams* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint64 shapeScale = 1;
  int shapescale_size() const;
  void clear_shapescale();
  static const int kShapeScaleFieldNumber = 1;
  ::google::protobuf::uint64 shapescale(int index) const;
  void set_shapescale(int index, ::google::protobuf::uint64 value);
  void add_shapescale(::google::protobuf::uint64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      shapescale() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_shapescale();

  // repeated uint64 shapeBias = 4;
  int shapebias_size() const;
  void clear_shapebias();
  static const int kShapeBiasFieldNumber = 4;
  ::google::protobuf::uint64 shapebias(int index) const;
  void set_shapebias(int index, ::google::protobuf::uint64 value);
  void add_shapebias(::google::protobuf::uint64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      shapebias() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_shapebias();

  // .CoreML.Specification.WeightParams scale = 2;
  bool has_scale() const;
  void clear_scale();
  static const int kScaleFieldNumber = 2;
  const ::CoreML::Specification::WeightParams& scale() const;
  ::CoreML::Specification::WeightParams* mutable_scale();
  ::CoreML::Specification::WeightParams* release_scale();
  void set_allocated_scale(::CoreML::Specification::WeightParams* scale);

  // .CoreML.Specification.WeightParams bias = 5;
  bool has_bias() const;
  void clear_bias();
  static const int kBiasFieldNumber = 5;
  const ::CoreML::Specification::WeightParams& bias() const;
  ::CoreML::Specification::WeightParams* mutable_bias();
  ::CoreML::Specification::WeightParams* release_bias();
  void set_allocated_bias(::CoreML::Specification::WeightParams* bias);

  // bool hasBias = 3;
  void clear_hasbias();
  static const int kHasBiasFieldNumber = 3;
  bool hasbias() const;
  void set_hasbias(bool value);

  // @@protoc_insertion_point(class_scope:CoreML.Specification.ScaleLayerParams)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > shapescale_;
  mutable int _shapescale_cached_byte_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > shapebias_;
  mutable int _shapebias_cached_byte_size_;
  ::CoreML::Specification::WeightParams* scale_;
  ::CoreML::Specification::WeightParams* bias_;
  bool hasbias_;
  mutable int _cached_size_;
  friend struct protobuf_NeuralNetwork_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LoadConstantLayerParams : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.LoadConstantLayerParams) */ {
 public:
  LoadConstantLayerParams();
  virtual ~LoadConstantLayerParams();

  LoadConstantLayerParams(const LoadConstantLayerParams& from);

  inline LoadConstantLayerParams& operator=(const LoadConstantLayerParams& from) {
    CopyFrom(from);
    return *this;
  }

  static const LoadConstantLayerParams& default_instance();

  static inline const LoadConstantLayerParams* internal_default_instance() {
    return reinterpret_cast<const LoadConstantLayerParams*>(
               &_LoadConstantLayerParams_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    51;

  void Swap(LoadConstantLayerParams* other);

  // implements Message ----------------------------------------------

  inline LoadConstantLayerParams* New() const PROTOBUF_FINAL { return New(NULL); }

  LoadConstantLayerParams* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const LoadConstantLayerParams& from);
  void MergeFrom(const LoadConstantLayerParams& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LoadConstantLayerParams* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint64 shape = 1;
  int shape_size() const;
  void clear_shape();
  static const int kShapeFieldNumber = 1;
  ::google::protobuf::uint64 shape(int index) const;
  void set_shape(int index, ::google::protobuf::uint64 value);
  void add_shape(::google::protobuf::uint64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      shape() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_shape();

  // .CoreML.Specification.WeightParams data = 2;
  bool has_data() const;
  void clear_data();
  static const int kDataFieldNumber = 2;
  const ::CoreML::Specification::WeightParams& data() const;
  ::CoreML::Specification::WeightParams* mutable_data();
  ::CoreML::Specification::WeightParams* release_data();
  void set_allocated_data(::CoreML::Specification::WeightParams* data);

  // @@protoc_insertion_point(class_scope:CoreML.Specification.LoadConstantLayerParams)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > shape_;
  mutable int _shape_cached_byte_size_;
  ::CoreML::Specification::WeightParams* data_;
  mutable int _cached_size_;
  friend struct protobuf_NeuralNetwork_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class L2NormalizeLayerParams : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.L2NormalizeLayerParams) */ {
 public:
  L2NormalizeLayerParams();
  virtual ~L2NormalizeLayerParams();

  L2NormalizeLayerParams(const L2NormalizeLayerParams& from);

  inline L2NormalizeLayerParams& operator=(const L2NormalizeLayerParams& from) {
    CopyFrom(from);
    return *this;
  }

  static const L2NormalizeLayerParams& default_instance();

  static inline const L2NormalizeLayerParams* internal_default_instance() {
    return reinterpret_cast<const L2NormalizeLayerParams*>(
               &_L2NormalizeLayerParams_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    52;

  void Swap(L2NormalizeLayerParams* other);

  // implements Message ----------------------------------------------

  inline L2NormalizeLayerParams* New() const PROTOBUF_FINAL { return New(NULL); }

  L2NormalizeLayerParams* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const L2NormalizeLayerParams& from);
  void MergeFrom(const L2NormalizeLayerParams& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(L2NormalizeLayerParams* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float epsilon = 1;
  void clear_epsilon();
  static const int kEpsilonFieldNumber = 1;
  float epsilon() const;
  void set_epsilon(float value);

  // @@protoc_insertion_point(class_scope:CoreML.Specification.L2NormalizeLayerParams)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  float epsilon_;
  mutable int _cached_size_;
  friend struct protobuf_NeuralNetwork_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FlattenLayerParams : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.FlattenLayerParams) */ {
 public:
  FlattenLayerParams();
  virtual ~FlattenLayerParams();

  FlattenLayerParams(const FlattenLayerParams& from);

  inline FlattenLayerParams& operator=(const FlattenLayerParams& from) {
    CopyFrom(from);
    return *this;
  }

  static const FlattenLayerParams& default_instance();

  static inline const FlattenLayerParams* internal_default_instance() {
    return reinterpret_cast<const FlattenLayerParams*>(
               &_FlattenLayerParams_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    53;

  void Swap(FlattenLayerParams* other);

  // implements Message ----------------------------------------------

  inline FlattenLayerParams* New() const PROTOBUF_FINAL { return New(NULL); }

  FlattenLayerParams* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const FlattenLayerParams& from);
  void MergeFrom(const FlattenLayerParams& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(FlattenLayerParams* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef FlattenLayerParams_FlattenOrder FlattenOrder;
  static const FlattenOrder CHANNEL_FIRST =
    FlattenLayerParams_FlattenOrder_CHANNEL_FIRST;
  static const FlattenOrder CHANNEL_LAST =
    FlattenLayerParams_FlattenOrder_CHANNEL_LAST;
  static inline bool FlattenOrder_IsValid(int value) {
    return FlattenLayerParams_FlattenOrder_IsValid(value);
  }
  static const FlattenOrder FlattenOrder_MIN =
    FlattenLayerParams_FlattenOrder_FlattenOrder_MIN;
  static const FlattenOrder FlattenOrder_MAX =
    FlattenLayerParams_FlattenOrder_FlattenOrder_MAX;
  static const int FlattenOrder_ARRAYSIZE =
    FlattenLayerParams_FlattenOrder_FlattenOrder_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // .CoreML.Specification.FlattenLayerParams.FlattenOrder mode = 1;
  void clear_mode();
  static const int kModeFieldNumber = 1;
  ::CoreML::Specification::FlattenLayerParams_FlattenOrder mode() const;
  void set_mode(::CoreML::Specification::FlattenLayerParams_FlattenOrder value);

  // @@protoc_insertion_point(class_scope:CoreML.Specification.FlattenLayerParams)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  int mode_;
  mutable int _cached_size_;
  friend struct protobuf_NeuralNetwork_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ReshapeLayerParams : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.ReshapeLayerParams) */ {
 public:
  ReshapeLayerParams();
  virtual ~ReshapeLayerParams();

  ReshapeLayerParams(const ReshapeLayerParams& from);

  inline ReshapeLayerParams& operator=(const ReshapeLayerParams& from) {
    CopyFrom(from);
    return *this;
  }

  static const ReshapeLayerParams& default_instance();

  static inline const ReshapeLayerParams* internal_default_instance() {
    return reinterpret_cast<const ReshapeLayerParams*>(
               &_ReshapeLayerParams_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    54;

  void Swap(ReshapeLayerParams* other);

  // implements Message ----------------------------------------------

  inline ReshapeLayerParams* New() const PROTOBUF_FINAL { return New(NULL); }

  ReshapeLayerParams* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const ReshapeLayerParams& from);
  void MergeFrom(const ReshapeLayerParams& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ReshapeLayerParams* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef ReshapeLayerParams_ReshapeOrder ReshapeOrder;
  static const ReshapeOrder CHANNEL_FIRST =
    ReshapeLayerParams_ReshapeOrder_CHANNEL_FIRST;
  static const ReshapeOrder CHANNEL_LAST =
    ReshapeLayerParams_ReshapeOrder_CHANNEL_LAST;
  static inline bool ReshapeOrder_IsValid(int value) {
    return ReshapeLayerParams_ReshapeOrder_IsValid(value);
  }
  static const ReshapeOrder ReshapeOrder_MIN =
    ReshapeLayerParams_ReshapeOrder_ReshapeOrder_MIN;
  static const ReshapeOrder ReshapeOrder_MAX =
    ReshapeLayerParams_ReshapeOrder_ReshapeOrder_MAX;
  static const int ReshapeOrder_ARRAYSIZE =
    ReshapeLayerParams_ReshapeOrder_ReshapeOrder_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // repeated int64 targetShape = 1;
  int targetshape_size() const;
  void clear_targetshape();
  static const int kTargetShapeFieldNumber = 1;
  ::google::protobuf::int64 targetshape(int index) const;
  void set_targetshape(int index, ::google::protobuf::int64 value);
  void add_targetshape(::google::protobuf::int64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      targetshape() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_targetshape();

  // .CoreML.Specification.ReshapeLayerParams.ReshapeOrder mode = 2;
  void clear_mode();
  static const int kModeFieldNumber = 2;
  ::CoreML::Specification::ReshapeLayerParams_ReshapeOrder mode() const;
  void set_mode(::CoreML::Specification::ReshapeLayerParams_ReshapeOrder value);

  // @@protoc_insertion_point(class_scope:CoreML.Specification.ReshapeLayerParams)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > targetshape_;
  mutable int _targetshape_cached_byte_size_;
  int mode_;
  mutable int _cached_size_;
  friend struct protobuf_NeuralNetwork_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PermuteLayerParams : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.PermuteLayerParams) */ {
 public:
  PermuteLayerParams();
  virtual ~PermuteLayerParams();

  PermuteLayerParams(const PermuteLayerParams& from);

  inline PermuteLayerParams& operator=(const PermuteLayerParams& from) {
    CopyFrom(from);
    return *this;
  }

  static const PermuteLayerParams& default_instance();

  static inline const PermuteLayerParams* internal_default_instance() {
    return reinterpret_cast<const PermuteLayerParams*>(
               &_PermuteLayerParams_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    55;

  void Swap(PermuteLayerParams* other);

  // implements Message ----------------------------------------------

  inline PermuteLayerParams* New() const PROTOBUF_FINAL { return New(NULL); }

  PermuteLayerParams* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const PermuteLayerParams& from);
  void MergeFrom(const PermuteLayerParams& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PermuteLayerParams* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint64 axis = 1;
  int axis_size() const;
  void clear_axis();
  static const int kAxisFieldNumber = 1;
  ::google::protobuf::uint64 axis(int index) const;
  void set_axis(int index, ::google::protobuf::uint64 value);
  void add_axis(::google::protobuf::uint64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      axis() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_axis();

  // @@protoc_insertion_point(class_scope:CoreML.Specification.PermuteLayerParams)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > axis_;
  mutable int _axis_cached_byte_size_;
  mutable int _cached_size_;
  friend struct protobuf_NeuralNetwork_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ReorganizeDataLayerParams : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.ReorganizeDataLayerParams) */ {
 public:
  ReorganizeDataLayerParams();
  virtual ~ReorganizeDataLayerParams();

  ReorganizeDataLayerParams(const ReorganizeDataLayerParams& from);

  inline ReorganizeDataLayerParams& operator=(const ReorganizeDataLayerParams& from) {
    CopyFrom(from);
    return *this;
  }

  static const ReorganizeDataLayerParams& default_instance();

  static inline const ReorganizeDataLayerParams* internal_default_instance() {
    return reinterpret_cast<const ReorganizeDataLayerParams*>(
               &_ReorganizeDataLayerParams_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    56;

  void Swap(ReorganizeDataLayerParams* other);

  // implements Message ----------------------------------------------

  inline ReorganizeDataLayerParams* New() const PROTOBUF_FINAL { return New(NULL); }

  ReorganizeDataLayerParams* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const ReorganizeDataLayerParams& from);
  void MergeFrom(const ReorganizeDataLayerParams& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ReorganizeDataLayerParams* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef ReorganizeDataLayerParams_ReorganizationType ReorganizationType;
  static const ReorganizationType SPACE_TO_DEPTH =
    ReorganizeDataLayerParams_ReorganizationType_SPACE_TO_DEPTH;
  static const ReorganizationType DEPTH_TO_SPACE =
    ReorganizeDataLayerParams_ReorganizationType_DEPTH_TO_SPACE;
  static inline bool ReorganizationType_IsValid(int value) {
    return ReorganizeDataLayerParams_ReorganizationType_IsValid(value);
  }
  static const ReorganizationType ReorganizationType_MIN =
    ReorganizeDataLayerParams_ReorganizationType_ReorganizationType_MIN;
  static const ReorganizationType ReorganizationType_MAX =
    ReorganizeDataLayerParams_ReorganizationType_ReorganizationType_MAX;
  static const int ReorganizationType_ARRAYSIZE =
    ReorganizeDataLayerParams_ReorganizationType_ReorganizationType_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // uint64 blockSize = 2;
  void clear_blocksize();
  static const int kBlockSizeFieldNumber = 2;
  ::google::protobuf::uint64 blocksize() const;
  void set_blocksize(::google::protobuf::uint64 value);

  // .CoreML.Specification.ReorganizeDataLayerParams.ReorganizationType mode = 1;
  void clear_mode();
  static const int kModeFieldNumber = 1;
  ::CoreML::Specification::ReorganizeDataLayerParams_ReorganizationType mode() const;
  void set_mode(::CoreML::Specification::ReorganizeDataLayerParams_ReorganizationType value);

  // @@protoc_insertion_point(class_scope:CoreML.Specification.ReorganizeDataLayerParams)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::uint64 blocksize_;
  int mode_;
  mutable int _cached_size_;
  friend struct protobuf_NeuralNetwork_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SliceLayerParams : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.SliceLayerParams) */ {
 public:
  SliceLayerParams();
  virtual ~SliceLayerParams();

  SliceLayerParams(const SliceLayerParams& from);

  inline SliceLayerParams& operator=(const SliceLayerParams& from) {
    CopyFrom(from);
    return *this;
  }

  static const SliceLayerParams& default_instance();

  static inline const SliceLayerParams* internal_default_instance() {
    return reinterpret_cast<const SliceLayerParams*>(
               &_SliceLayerParams_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    57;

  void Swap(SliceLayerParams* other);

  // implements Message ----------------------------------------------

  inline SliceLayerParams* New() const PROTOBUF_FINAL { return New(NULL); }

  SliceLayerParams* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const SliceLayerParams& from);
  void MergeFrom(const SliceLayerParams& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SliceLayerParams* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef SliceLayerParams_SliceAxis SliceAxis;
  static const SliceAxis CHANNEL_AXIS =
    SliceLayerParams_SliceAxis_CHANNEL_AXIS;
  static const SliceAxis HEIGHT_AXIS =
    SliceLayerParams_SliceAxis_HEIGHT_AXIS;
  static const SliceAxis WIDTH_AXIS =
    SliceLayerParams_SliceAxis_WIDTH_AXIS;
  static inline bool SliceAxis_IsValid(int value) {
    return SliceLayerParams_SliceAxis_IsValid(value);
  }
  static const SliceAxis SliceAxis_MIN =
    SliceLayerParams_SliceAxis_SliceAxis_MIN;
  static const SliceAxis SliceAxis_MAX =
    SliceLayerParams_SliceAxis_SliceAxis_MAX;
  static const int SliceAxis_ARRAYSIZE =
    SliceLayerParams_SliceAxis_SliceAxis_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // int64 startIndex = 1;
  void clear_startindex();
  static const int kStartIndexFieldNumber = 1;
  ::google::protobuf::int64 startindex() const;
  void set_startindex(::google::protobuf::int64 value);

  // int64 endIndex = 2;
  void clear_endindex();
  static const int kEndIndexFieldNumber = 2;
  ::google::protobuf::int64 endindex() const;
  void set_endindex(::google::protobuf::int64 value);

  // uint64 stride = 3;
  void clear_stride();
  static const int kStrideFieldNumber = 3;
  ::google::protobuf::uint64 stride() const;
  void set_stride(::google::protobuf::uint64 value);

  // .CoreML.Specification.SliceLayerParams.SliceAxis axis = 4;
  void clear_axis();
  static const int kAxisFieldNumber = 4;
  ::CoreML::Specification::SliceLayerParams_SliceAxis axis() const;
  void set_axis(::CoreML::Specification::SliceLayerParams_SliceAxis value);

  // @@protoc_insertion_point(class_scope:CoreML.Specification.SliceLayerParams)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::int64 startindex_;
  ::google::protobuf::int64 endindex_;
  ::google::protobuf::uint64 stride_;
  int axis_;
  mutable int _cached_size_;
  friend struct protobuf_NeuralNetwork_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ReduceLayerParams : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.ReduceLayerParams) */ {
 public:
  ReduceLayerParams();
  virtual ~ReduceLayerParams();

  ReduceLayerParams(const ReduceLayerParams& from);

  inline ReduceLayerParams& operator=(const ReduceLayerParams& from) {
    CopyFrom(from);
    return *this;
  }

  static const ReduceLayerParams& default_instance();

  static inline const ReduceLayerParams* internal_default_instance() {
    return reinterpret_cast<const ReduceLayerParams*>(
               &_ReduceLayerParams_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    58;

  void Swap(ReduceLayerParams* other);

  // implements Message ----------------------------------------------

  inline ReduceLayerParams* New() const PROTOBUF_FINAL { return New(NULL); }

  ReduceLayerParams* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const ReduceLayerParams& from);
  void MergeFrom(const ReduceLayerParams& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ReduceLayerParams* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef ReduceLayerParams_ReduceOperation ReduceOperation;
  static const ReduceOperation SUM =
    ReduceLayerParams_ReduceOperation_SUM;
  static const ReduceOperation AVG =
    ReduceLayerParams_ReduceOperation_AVG;
  static const ReduceOperation PROD =
    ReduceLayerParams_ReduceOperation_PROD;
  static const ReduceOperation LOGSUM =
    ReduceLayerParams_ReduceOperation_LOGSUM;
  static const ReduceOperation SUMSQUARE =
    ReduceLayerParams_ReduceOperation_SUMSQUARE;
  static const ReduceOperation L1 =
    ReduceLayerParams_ReduceOperation_L1;
  static const ReduceOperation L2 =
    ReduceLayerParams_ReduceOperation_L2;
  static const ReduceOperation MAX =
    ReduceLayerParams_ReduceOperation_MAX;
  static const ReduceOperation MIN =
    ReduceLayerParams_ReduceOperation_MIN;
  static const ReduceOperation ARGMAX =
    ReduceLayerParams_ReduceOperation_ARGMAX;
  static inline bool ReduceOperation_IsValid(int value) {
    return ReduceLayerParams_ReduceOperation_IsValid(value);
  }
  static const ReduceOperation ReduceOperation_MIN =
    ReduceLayerParams_ReduceOperation_ReduceOperation_MIN;
  static const ReduceOperation ReduceOperation_MAX =
    ReduceLayerParams_ReduceOperation_ReduceOperation_MAX;
  static const int ReduceOperation_ARRAYSIZE =
    ReduceLayerParams_ReduceOperation_ReduceOperation_ARRAYSIZE;

  typedef ReduceLayerParams_ReduceAxis ReduceAxis;
  static const ReduceAxis CHW =
    ReduceLayerParams_ReduceAxis_CHW;
  static const ReduceAxis HW =
    ReduceLayerParams_ReduceAxis_HW;
  static const ReduceAxis C =
    ReduceLayerParams_ReduceAxis_C;
  static const ReduceAxis H =
    ReduceLayerParams_ReduceAxis_H;
  static const ReduceAxis W =
    ReduceLayerParams_ReduceAxis_W;
  static inline bool ReduceAxis_IsValid(int value) {
    return ReduceLayerParams_ReduceAxis_IsValid(value);
  }
  static const ReduceAxis ReduceAxis_MIN =
    ReduceLayerParams_ReduceAxis_ReduceAxis_MIN;
  static const ReduceAxis ReduceAxis_MAX =
    ReduceLayerParams_ReduceAxis_ReduceAxis_MAX;
  static const int ReduceAxis_ARRAYSIZE =
    ReduceLayerParams_ReduceAxis_ReduceAxis_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // .CoreML.Specification.ReduceLayerParams.ReduceOperation mode = 1;
  void clear_mode();
  static const int kModeFieldNumber = 1;
  ::CoreML::Specification::ReduceLayerParams_ReduceOperation mode() const;
  void set_mode(::CoreML::Specification::ReduceLayerParams_ReduceOperation value);

  // float epsilon = 2;
  void clear_epsilon();
  static const int kEpsilonFieldNumber = 2;
  float epsilon() const;
  void set_epsilon(float value);

  // .CoreML.Specification.ReduceLayerParams.ReduceAxis axis = 3;
  void clear_axis();
  static const int kAxisFieldNumber = 3;
  ::CoreML::Specification::ReduceLayerParams_ReduceAxis axis() const;
  void set_axis(::CoreML::Specification::ReduceLayerParams_ReduceAxis value);

  // @@protoc_insertion_point(class_scope:CoreML.Specification.ReduceLayerParams)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  int mode_;
  float epsilon_;
  int axis_;
  mutable int _cached_size_;
  friend struct protobuf_NeuralNetwork_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CropLayerParams : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.CropLayerParams) */ {
 public:
  CropLayerParams();
  virtual ~CropLayerParams();

  CropLayerParams(const CropLayerParams& from);

  inline CropLayerParams& operator=(const CropLayerParams& from) {
    CopyFrom(from);
    return *this;
  }

  static const CropLayerParams& default_instance();

  static inline const CropLayerParams* internal_default_instance() {
    return reinterpret_cast<const CropLayerParams*>(
               &_CropLayerParams_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    59;

  void Swap(CropLayerParams* other);

  // implements Message ----------------------------------------------

  inline CropLayerParams* New() const PROTOBUF_FINAL { return New(NULL); }

  CropLayerParams* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const CropLayerParams& from);
  void MergeFrom(const CropLayerParams& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CropLayerParams* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint64 offset = 5;
  int offset_size() const;
  void clear_offset();
  static const int kOffsetFieldNumber = 5;
  ::google::protobuf::uint64 offset(int index) const;
  void set_offset(int index, ::google::protobuf::uint64 value);
  void add_offset(::google::protobuf::uint64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      offset() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_offset();

  // .CoreML.Specification.BorderAmounts cropAmounts = 1;
  bool has_cropamounts() const;
  void clear_cropamounts();
  static const int kCropAmountsFieldNumber = 1;
  const ::CoreML::Specification::BorderAmounts& cropamounts() const;
  ::CoreML::Specification::BorderAmounts* mutable_cropamounts();
  ::CoreML::Specification::BorderAmounts* release_cropamounts();
  void set_allocated_cropamounts(::CoreML::Specification::BorderAmounts* cropamounts);

  // @@protoc_insertion_point(class_scope:CoreML.Specification.CropLayerParams)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > offset_;
  mutable int _offset_cached_byte_size_;
  ::CoreML::Specification::BorderAmounts* cropamounts_;
  mutable int _cached_size_;
  friend struct protobuf_NeuralNetwork_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AverageLayerParams : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.AverageLayerParams) */ {
 public:
  AverageLayerParams();
  virtual ~AverageLayerParams();

  AverageLayerParams(const AverageLayerParams& from);

  inline AverageLayerParams& operator=(const AverageLayerParams& from) {
    CopyFrom(from);
    return *this;
  }

  static const AverageLayerParams& default_instance();

  static inline const AverageLayerParams* internal_default_instance() {
    return reinterpret_cast<const AverageLayerParams*>(
               &_AverageLayerParams_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    60;

  void Swap(AverageLayerParams* other);

  // implements Message ----------------------------------------------

  inline AverageLayerParams* New() const PROTOBUF_FINAL { return New(NULL); }

  AverageLayerParams* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const AverageLayerParams& from);
  void MergeFrom(const AverageLayerParams& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AverageLayerParams* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:CoreML.Specification.AverageLayerParams)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  mutable int _cached_size_;
  friend struct protobuf_NeuralNetwork_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MaxLayerParams : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.MaxLayerParams) */ {
 public:
  MaxLayerParams();
  virtual ~MaxLayerParams();

  MaxLayerParams(const MaxLayerParams& from);

  inline MaxLayerParams& operator=(const MaxLayerParams& from) {
    CopyFrom(from);
    return *this;
  }

  static const MaxLayerParams& default_instance();

  static inline const MaxLayerParams* internal_default_instance() {
    return reinterpret_cast<const MaxLayerParams*>(
               &_MaxLayerParams_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    61;

  void Swap(MaxLayerParams* other);

  // implements Message ----------------------------------------------

  inline MaxLayerParams* New() const PROTOBUF_FINAL { return New(NULL); }

  MaxLayerParams* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const MaxLayerParams& from);
  void MergeFrom(const MaxLayerParams& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MaxLayerParams* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:CoreML.Specification.MaxLayerParams)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  mutable int _cached_size_;
  friend struct protobuf_NeuralNetwork_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MinLayerParams : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.MinLayerParams) */ {
 public:
  MinLayerParams();
  virtual ~MinLayerParams();

  MinLayerParams(const MinLayerParams& from);

  inline MinLayerParams& operator=(const MinLayerParams& from) {
    CopyFrom(from);
    return *this;
  }

  static const MinLayerParams& default_instance();

  static inline const MinLayerParams* internal_default_instance() {
    return reinterpret_cast<const MinLayerParams*>(
               &_MinLayerParams_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    62;

  void Swap(MinLayerParams* other);

  // implements Message ----------------------------------------------

  inline MinLayerParams* New() const PROTOBUF_FINAL { return New(NULL); }

  MinLayerParams* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const MinLayerParams& from);
  void MergeFrom(const MinLayerParams& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MinLayerParams* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:CoreML.Specification.MinLayerParams)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  mutable int _cached_size_;
  friend struct protobuf_NeuralNetwork_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DotProductLayerParams : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.DotProductLayerParams) */ {
 public:
  DotProductLayerParams();
  virtual ~DotProductLayerParams();

  DotProductLayerParams(const DotProductLayerParams& from);

  inline DotProductLayerParams& operator=(const DotProductLayerParams& from) {
    CopyFrom(from);
    return *this;
  }

  static const DotProductLayerParams& default_instance();

  static inline const DotProductLayerParams* internal_default_instance() {
    return reinterpret_cast<const DotProductLayerParams*>(
               &_DotProductLayerParams_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    63;

  void Swap(DotProductLayerParams* other);

  // implements Message ----------------------------------------------

  inline DotProductLayerParams* New() const PROTOBUF_FINAL { return New(NULL); }

  DotProductLayerParams* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const DotProductLayerParams& from);
  void MergeFrom(const DotProductLayerParams& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DotProductLayerParams* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bool cosineSimilarity = 1;
  void clear_cosinesimilarity();
  static const int kCosineSimilarityFieldNumber = 1;
  bool cosinesimilarity() const;
  void set_cosinesimilarity(bool value);

  // @@protoc_insertion_point(class_scope:CoreML.Specification.DotProductLayerParams)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  bool cosinesimilarity_;
  mutable int _cached_size_;
  friend struct protobuf_NeuralNetwork_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MeanVarianceNormalizeLayerParams : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.MeanVarianceNormalizeLayerParams) */ {
 public:
  MeanVarianceNormalizeLayerParams();
  virtual ~MeanVarianceNormalizeLayerParams();

  MeanVarianceNormalizeLayerParams(const MeanVarianceNormalizeLayerParams& from);

  inline MeanVarianceNormalizeLayerParams& operator=(const MeanVarianceNormalizeLayerParams& from) {
    CopyFrom(from);
    return *this;
  }

  static const MeanVarianceNormalizeLayerParams& default_instance();

  static inline const MeanVarianceNormalizeLayerParams* internal_default_instance() {
    return reinterpret_cast<const MeanVarianceNormalizeLayerParams*>(
               &_MeanVarianceNormalizeLayerParams_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    64;

  void Swap(MeanVarianceNormalizeLayerParams* other);

  // implements Message ----------------------------------------------

  inline MeanVarianceNormalizeLayerParams* New() const PROTOBUF_FINAL { return New(NULL); }

  MeanVarianceNormalizeLayerParams* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const MeanVarianceNormalizeLayerParams& from);
  void MergeFrom(const MeanVarianceNormalizeLayerParams& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MeanVarianceNormalizeLayerParams* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bool acrossChannels = 1;
  void clear_acrosschannels();
  static const int kAcrossChannelsFieldNumber = 1;
  bool acrosschannels() const;
  void set_acrosschannels(bool value);

  // bool normalizeVariance = 2;
  void clear_normalizevariance();
  static const int kNormalizeVarianceFieldNumber = 2;
  bool normalizevariance() const;
  void set_normalizevariance(bool value);

  // float epsilon = 3;
  void clear_epsilon();
  static const int kEpsilonFieldNumber = 3;
  float epsilon() const;
  void set_epsilon(float value);

  // @@protoc_insertion_point(class_scope:CoreML.Specification.MeanVarianceNormalizeLayerParams)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  bool acrosschannels_;
  bool normalizevariance_;
  float epsilon_;
  mutable int _cached_size_;
  friend struct protobuf_NeuralNetwork_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SequenceRepeatLayerParams : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.SequenceRepeatLayerParams) */ {
 public:
  SequenceRepeatLayerParams();
  virtual ~SequenceRepeatLayerParams();

  SequenceRepeatLayerParams(const SequenceRepeatLayerParams& from);

  inline SequenceRepeatLayerParams& operator=(const SequenceRepeatLayerParams& from) {
    CopyFrom(from);
    return *this;
  }

  static const SequenceRepeatLayerParams& default_instance();

  static inline const SequenceRepeatLayerParams* internal_default_instance() {
    return reinterpret_cast<const SequenceRepeatLayerParams*>(
               &_SequenceRepeatLayerParams_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    65;

  void Swap(SequenceRepeatLayerParams* other);

  // implements Message ----------------------------------------------

  inline SequenceRepeatLayerParams* New() const PROTOBUF_FINAL { return New(NULL); }

  SequenceRepeatLayerParams* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const SequenceRepeatLayerParams& from);
  void MergeFrom(const SequenceRepeatLayerParams& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SequenceRepeatLayerParams* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint64 nRepetitions = 1;
  void clear_nrepetitions();
  static const int kNRepetitionsFieldNumber = 1;
  ::google::protobuf::uint64 nrepetitions() const;
  void set_nrepetitions(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:CoreML.Specification.SequenceRepeatLayerParams)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::uint64 nrepetitions_;
  mutable int _cached_size_;
  friend struct protobuf_NeuralNetwork_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SimpleRecurrentLayerParams : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.SimpleRecurrentLayerParams) */ {
 public:
  SimpleRecurrentLayerParams();
  virtual ~SimpleRecurrentLayerParams();

  SimpleRecurrentLayerParams(const SimpleRecurrentLayerParams& from);

  inline SimpleRecurrentLayerParams& operator=(const SimpleRecurrentLayerParams& from) {
    CopyFrom(from);
    return *this;
  }

  static const SimpleRecurrentLayerParams& default_instance();

  static inline const SimpleRecurrentLayerParams* internal_default_instance() {
    return reinterpret_cast<const SimpleRecurrentLayerParams*>(
               &_SimpleRecurrentLayerParams_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    66;

  void Swap(SimpleRecurrentLayerParams* other);

  // implements Message ----------------------------------------------

  inline SimpleRecurrentLayerParams* New() const PROTOBUF_FINAL { return New(NULL); }

  SimpleRecurrentLayerParams* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const SimpleRecurrentLayerParams& from);
  void MergeFrom(const SimpleRecurrentLayerParams& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SimpleRecurrentLayerParams* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .CoreML.Specification.ActivationParams activation = 10;
  bool has_activation() const;
  void clear_activation();
  static const int kActivationFieldNumber = 10;
  const ::CoreML::Specification::ActivationParams& activation() const;
  ::CoreML::Specification::ActivationParams* mutable_activation();
  ::CoreML::Specification::ActivationParams* release_activation();
  void set_allocated_activation(::CoreML::Specification::ActivationParams* activation);

  // .CoreML.Specification.WeightParams weightMatrix = 30;
  bool has_weightmatrix() const;
  void clear_weightmatrix();
  static const int kWeightMatrixFieldNumber = 30;
  const ::CoreML::Specification::WeightParams& weightmatrix() const;
  ::CoreML::Specification::WeightParams* mutable_weightmatrix();
  ::CoreML::Specification::WeightParams* release_weightmatrix();
  void set_allocated_weightmatrix(::CoreML::Specification::WeightParams* weightmatrix);

  // .CoreML.Specification.WeightParams recursionMatrix = 31;
  bool has_recursionmatrix() const;
  void clear_recursionmatrix();
  static const int kRecursionMatrixFieldNumber = 31;
  const ::CoreML::Specification::WeightParams& recursionmatrix() const;
  ::CoreML::Specification::WeightParams* mutable_recursionmatrix();
  ::CoreML::Specification::WeightParams* release_recursionmatrix();
  void set_allocated_recursionmatrix(::CoreML::Specification::WeightParams* recursionmatrix);

  // .CoreML.Specification.WeightParams biasVector = 32;
  bool has_biasvector() const;
  void clear_biasvector();
  static const int kBiasVectorFieldNumber = 32;
  const ::CoreML::Specification::WeightParams& biasvector() const;
  ::CoreML::Specification::WeightParams* mutable_biasvector();
  ::CoreML::Specification::WeightParams* release_biasvector();
  void set_allocated_biasvector(::CoreML::Specification::WeightParams* biasvector);

  // uint64 inputVectorSize = 1;
  void clear_inputvectorsize();
  static const int kInputVectorSizeFieldNumber = 1;
  ::google::protobuf::uint64 inputvectorsize() const;
  void set_inputvectorsize(::google::protobuf::uint64 value);

  // uint64 outputVectorSize = 2;
  void clear_outputvectorsize();
  static const int kOutputVectorSizeFieldNumber = 2;
  ::google::protobuf::uint64 outputvectorsize() const;
  void set_outputvectorsize(::google::protobuf::uint64 value);

  // bool sequenceOutput = 15;
  void clear_sequenceoutput();
  static const int kSequenceOutputFieldNumber = 15;
  bool sequenceoutput() const;
  void set_sequenceoutput(bool value);

  // bool hasBiasVector = 20;
  void clear_hasbiasvector();
  static const int kHasBiasVectorFieldNumber = 20;
  bool hasbiasvector() const;
  void set_hasbiasvector(bool value);

  // bool reverseInput = 100;
  void clear_reverseinput();
  static const int kReverseInputFieldNumber = 100;
  bool reverseinput() const;
  void set_reverseinput(bool value);

  // @@protoc_insertion_point(class_scope:CoreML.Specification.SimpleRecurrentLayerParams)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::CoreML::Specification::ActivationParams* activation_;
  ::CoreML::Specification::WeightParams* weightmatrix_;
  ::CoreML::Specification::WeightParams* recursionmatrix_;
  ::CoreML::Specification::WeightParams* biasvector_;
  ::google::protobuf::uint64 inputvectorsize_;
  ::google::protobuf::uint64 outputvectorsize_;
  bool sequenceoutput_;
  bool hasbiasvector_;
  bool reverseinput_;
  mutable int _cached_size_;
  friend struct protobuf_NeuralNetwork_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GRULayerParams : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.GRULayerParams) */ {
 public:
  GRULayerParams();
  virtual ~GRULayerParams();

  GRULayerParams(const GRULayerParams& from);

  inline GRULayerParams& operator=(const GRULayerParams& from) {
    CopyFrom(from);
    return *this;
  }

  static const GRULayerParams& default_instance();

  static inline const GRULayerParams* internal_default_instance() {
    return reinterpret_cast<const GRULayerParams*>(
               &_GRULayerParams_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    67;

  void Swap(GRULayerParams* other);

  // implements Message ----------------------------------------------

  inline GRULayerParams* New() const PROTOBUF_FINAL { return New(NULL); }

  GRULayerParams* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const GRULayerParams& from);
  void MergeFrom(const GRULayerParams& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GRULayerParams* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .CoreML.Specification.ActivationParams activations = 10;
  int activations_size() const;
  void clear_activations();
  static const int kActivationsFieldNumber = 10;
  const ::CoreML::Specification::ActivationParams& activations(int index) const;
  ::CoreML::Specification::ActivationParams* mutable_activations(int index);
  ::CoreML::Specification::ActivationParams* add_activations();
  ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::ActivationParams >*
      mutable_activations();
  const ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::ActivationParams >&
      activations() const;

  // .CoreML.Specification.WeightParams updateGateWeightMatrix = 30;
  bool has_updategateweightmatrix() const;
  void clear_updategateweightmatrix();
  static const int kUpdateGateWeightMatrixFieldNumber = 30;
  const ::CoreML::Specification::WeightParams& updategateweightmatrix() const;
  ::CoreML::Specification::WeightParams* mutable_updategateweightmatrix();
  ::CoreML::Specification::WeightParams* release_updategateweightmatrix();
  void set_allocated_updategateweightmatrix(::CoreML::Specification::WeightParams* updategateweightmatrix);

  // .CoreML.Specification.WeightParams resetGateWeightMatrix = 31;
  bool has_resetgateweightmatrix() const;
  void clear_resetgateweightmatrix();
  static const int kResetGateWeightMatrixFieldNumber = 31;
  const ::CoreML::Specification::WeightParams& resetgateweightmatrix() const;
  ::CoreML::Specification::WeightParams* mutable_resetgateweightmatrix();
  ::CoreML::Specification::WeightParams* release_resetgateweightmatrix();
  void set_allocated_resetgateweightmatrix(::CoreML::Specification::WeightParams* resetgateweightmatrix);

  // .CoreML.Specification.WeightParams outputGateWeightMatrix = 32;
  bool has_outputgateweightmatrix() const;
  void clear_outputgateweightmatrix();
  static const int kOutputGateWeightMatrixFieldNumber = 32;
  const ::CoreML::Specification::WeightParams& outputgateweightmatrix() const;
  ::CoreML::Specification::WeightParams* mutable_outputgateweightmatrix();
  ::CoreML::Specification::WeightParams* release_outputgateweightmatrix();
  void set_allocated_outputgateweightmatrix(::CoreML::Specification::WeightParams* outputgateweightmatrix);

  // .CoreML.Specification.WeightParams updateGateRecursionMatrix = 50;
  bool has_updategaterecursionmatrix() const;
  void clear_updategaterecursionmatrix();
  static const int kUpdateGateRecursionMatrixFieldNumber = 50;
  const ::CoreML::Specification::WeightParams& updategaterecursionmatrix() const;
  ::CoreML::Specification::WeightParams* mutable_updategaterecursionmatrix();
  ::CoreML::Specification::WeightParams* release_updategaterecursionmatrix();
  void set_allocated_updategaterecursionmatrix(::CoreML::Specification::WeightParams* updategaterecursionmatrix);

  // .CoreML.Specification.WeightParams resetGateRecursionMatrix = 51;
  bool has_resetgaterecursionmatrix() const;
  void clear_resetgaterecursionmatrix();
  static const int kResetGateRecursionMatrixFieldNumber = 51;
  const ::CoreML::Specification::WeightParams& resetgaterecursionmatrix() const;
  ::CoreML::Specification::WeightParams* mutable_resetgaterecursionmatrix();
  ::CoreML::Specification::WeightParams* release_resetgaterecursionmatrix();
  void set_allocated_resetgaterecursionmatrix(::CoreML::Specification::WeightParams* resetgaterecursionmatrix);

  // .CoreML.Specification.WeightParams outputGateRecursionMatrix = 52;
  bool has_outputgaterecursionmatrix() const;
  void clear_outputgaterecursionmatrix();
  static const int kOutputGateRecursionMatrixFieldNumber = 52;
  const ::CoreML::Specification::WeightParams& outputgaterecursionmatrix() const;
  ::CoreML::Specification::WeightParams* mutable_outputgaterecursionmatrix();
  ::CoreML::Specification::WeightParams* release_outputgaterecursionmatrix();
  void set_allocated_outputgaterecursionmatrix(::CoreML::Specification::WeightParams* outputgaterecursionmatrix);

  // .CoreML.Specification.WeightParams updateGateBiasVector = 70;
  bool has_updategatebiasvector() const;
  void clear_updategatebiasvector();
  static const int kUpdateGateBiasVectorFieldNumber = 70;
  const ::CoreML::Specification::WeightParams& updategatebiasvector() const;
  ::CoreML::Specification::WeightParams* mutable_updategatebiasvector();
  ::CoreML::Specification::WeightParams* release_updategatebiasvector();
  void set_allocated_updategatebiasvector(::CoreML::Specification::WeightParams* updategatebiasvector);

  // .CoreML.Specification.WeightParams resetGateBiasVector = 71;
  bool has_resetgatebiasvector() const;
  void clear_resetgatebiasvector();
  static const int kResetGateBiasVectorFieldNumber = 71;
  const ::CoreML::Specification::WeightParams& resetgatebiasvector() const;
  ::CoreML::Specification::WeightParams* mutable_resetgatebiasvector();
  ::CoreML::Specification::WeightParams* release_resetgatebiasvector();
  void set_allocated_resetgatebiasvector(::CoreML::Specification::WeightParams* resetgatebiasvector);

  // .CoreML.Specification.WeightParams outputGateBiasVector = 72;
  bool has_outputgatebiasvector() const;
  void clear_outputgatebiasvector();
  static const int kOutputGateBiasVectorFieldNumber = 72;
  const ::CoreML::Specification::WeightParams& outputgatebiasvector() const;
  ::CoreML::Specification::WeightParams* mutable_outputgatebiasvector();
  ::CoreML::Specification::WeightParams* release_outputgatebiasvector();
  void set_allocated_outputgatebiasvector(::CoreML::Specification::WeightParams* outputgatebiasvector);

  // uint64 inputVectorSize = 1;
  void clear_inputvectorsize();
  static const int kInputVectorSizeFieldNumber = 1;
  ::google::protobuf::uint64 inputvectorsize() const;
  void set_inputvectorsize(::google::protobuf::uint64 value);

  // uint64 outputVectorSize = 2;
  void clear_outputvectorsize();
  static const int kOutputVectorSizeFieldNumber = 2;
  ::google::protobuf::uint64 outputvectorsize() const;
  void set_outputvectorsize(::google::protobuf::uint64 value);

  // bool sequenceOutput = 15;
  void clear_sequenceoutput();
  static const int kSequenceOutputFieldNumber = 15;
  bool sequenceoutput() const;
  void set_sequenceoutput(bool value);

  // bool hasBiasVectors = 20;
  void clear_hasbiasvectors();
  static const int kHasBiasVectorsFieldNumber = 20;
  bool hasbiasvectors() const;
  void set_hasbiasvectors(bool value);

  // bool reverseInput = 100;
  void clear_reverseinput();
  static const int kReverseInputFieldNumber = 100;
  bool reverseinput() const;
  void set_reverseinput(bool value);

  // @@protoc_insertion_point(class_scope:CoreML.Specification.GRULayerParams)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::ActivationParams > activations_;
  ::CoreML::Specification::WeightParams* updategateweightmatrix_;
  ::CoreML::Specification::WeightParams* resetgateweightmatrix_;
  ::CoreML::Specification::WeightParams* outputgateweightmatrix_;
  ::CoreML::Specification::WeightParams* updategaterecursionmatrix_;
  ::CoreML::Specification::WeightParams* resetgaterecursionmatrix_;
  ::CoreML::Specification::WeightParams* outputgaterecursionmatrix_;
  ::CoreML::Specification::WeightParams* updategatebiasvector_;
  ::CoreML::Specification::WeightParams* resetgatebiasvector_;
  ::CoreML::Specification::WeightParams* outputgatebiasvector_;
  ::google::protobuf::uint64 inputvectorsize_;
  ::google::protobuf::uint64 outputvectorsize_;
  bool sequenceoutput_;
  bool hasbiasvectors_;
  bool reverseinput_;
  mutable int _cached_size_;
  friend struct protobuf_NeuralNetwork_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LSTMParams : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.LSTMParams) */ {
 public:
  LSTMParams();
  virtual ~LSTMParams();

  LSTMParams(const LSTMParams& from);

  inline LSTMParams& operator=(const LSTMParams& from) {
    CopyFrom(from);
    return *this;
  }

  static const LSTMParams& default_instance();

  static inline const LSTMParams* internal_default_instance() {
    return reinterpret_cast<const LSTMParams*>(
               &_LSTMParams_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    68;

  void Swap(LSTMParams* other);

  // implements Message ----------------------------------------------

  inline LSTMParams* New() const PROTOBUF_FINAL { return New(NULL); }

  LSTMParams* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const LSTMParams& from);
  void MergeFrom(const LSTMParams& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LSTMParams* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float cellClipThreshold = 60;
  void clear_cellclipthreshold();
  static const int kCellClipThresholdFieldNumber = 60;
  float cellclipthreshold() const;
  void set_cellclipthreshold(float value);

  // bool sequenceOutput = 10;
  void clear_sequenceoutput();
  static const int kSequenceOutputFieldNumber = 10;
  bool sequenceoutput() const;
  void set_sequenceoutput(bool value);

  // bool hasBiasVectors = 20;
  void clear_hasbiasvectors();
  static const int kHasBiasVectorsFieldNumber = 20;
  bool hasbiasvectors() const;
  void set_hasbiasvectors(bool value);

  // bool forgetBias = 30;
  void clear_forgetbias();
  static const int kForgetBiasFieldNumber = 30;
  bool forgetbias() const;
  void set_forgetbias(bool value);

  // bool hasPeepholeVectors = 40;
  void clear_haspeepholevectors();
  static const int kHasPeepholeVectorsFieldNumber = 40;
  bool haspeepholevectors() const;
  void set_haspeepholevectors(bool value);

  // bool coupledInputAndForgetGate = 50;
  void clear_coupledinputandforgetgate();
  static const int kCoupledInputAndForgetGateFieldNumber = 50;
  bool coupledinputandforgetgate() const;
  void set_coupledinputandforgetgate(bool value);

  // @@protoc_insertion_point(class_scope:CoreML.Specification.LSTMParams)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  float cellclipthreshold_;
  bool sequenceoutput_;
  bool hasbiasvectors_;
  bool forgetbias_;
  bool haspeepholevectors_;
  bool coupledinputandforgetgate_;
  mutable int _cached_size_;
  friend struct protobuf_NeuralNetwork_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LSTMWeightParams : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.LSTMWeightParams) */ {
 public:
  LSTMWeightParams();
  virtual ~LSTMWeightParams();

  LSTMWeightParams(const LSTMWeightParams& from);

  inline LSTMWeightParams& operator=(const LSTMWeightParams& from) {
    CopyFrom(from);
    return *this;
  }

  static const LSTMWeightParams& default_instance();

  static inline const LSTMWeightParams* internal_default_instance() {
    return reinterpret_cast<const LSTMWeightParams*>(
               &_LSTMWeightParams_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    69;

  void Swap(LSTMWeightParams* other);

  // implements Message ----------------------------------------------

  inline LSTMWeightParams* New() const PROTOBUF_FINAL { return New(NULL); }

  LSTMWeightParams* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const LSTMWeightParams& from);
  void MergeFrom(const LSTMWeightParams& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LSTMWeightParams* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .CoreML.Specification.WeightParams inputGateWeightMatrix = 1;
  bool has_inputgateweightmatrix() const;
  void clear_inputgateweightmatrix();
  static const int kInputGateWeightMatrixFieldNumber = 1;
  const ::CoreML::Specification::WeightParams& inputgateweightmatrix() const;
  ::CoreML::Specification::WeightParams* mutable_inputgateweightmatrix();
  ::CoreML::Specification::WeightParams* release_inputgateweightmatrix();
  void set_allocated_inputgateweightmatrix(::CoreML::Specification::WeightParams* inputgateweightmatrix);

  // .CoreML.Specification.WeightParams forgetGateWeightMatrix = 2;
  bool has_forgetgateweightmatrix() const;
  void clear_forgetgateweightmatrix();
  static const int kForgetGateWeightMatrixFieldNumber = 2;
  const ::CoreML::Specification::WeightParams& forgetgateweightmatrix() const;
  ::CoreML::Specification::WeightParams* mutable_forgetgateweightmatrix();
  ::CoreML::Specification::WeightParams* release_forgetgateweightmatrix();
  void set_allocated_forgetgateweightmatrix(::CoreML::Specification::WeightParams* forgetgateweightmatrix);

  // .CoreML.Specification.WeightParams blockInputWeightMatrix = 3;
  bool has_blockinputweightmatrix() const;
  void clear_blockinputweightmatrix();
  static const int kBlockInputWeightMatrixFieldNumber = 3;
  const ::CoreML::Specification::WeightParams& blockinputweightmatrix() const;
  ::CoreML::Specification::WeightParams* mutable_blockinputweightmatrix();
  ::CoreML::Specification::WeightParams* release_blockinputweightmatrix();
  void set_allocated_blockinputweightmatrix(::CoreML::Specification::WeightParams* blockinputweightmatrix);

  // .CoreML.Specification.WeightParams outputGateWeightMatrix = 4;
  bool has_outputgateweightmatrix() const;
  void clear_outputgateweightmatrix();
  static const int kOutputGateWeightMatrixFieldNumber = 4;
  const ::CoreML::Specification::WeightParams& outputgateweightmatrix() const;
  ::CoreML::Specification::WeightParams* mutable_outputgateweightmatrix();
  ::CoreML::Specification::WeightParams* release_outputgateweightmatrix();
  void set_allocated_outputgateweightmatrix(::CoreML::Specification::WeightParams* outputgateweightmatrix);

  // .CoreML.Specification.WeightParams inputGateRecursionMatrix = 20;
  bool has_inputgaterecursionmatrix() const;
  void clear_inputgaterecursionmatrix();
  static const int kInputGateRecursionMatrixFieldNumber = 20;
  const ::CoreML::Specification::WeightParams& inputgaterecursionmatrix() const;
  ::CoreML::Specification::WeightParams* mutable_inputgaterecursionmatrix();
  ::CoreML::Specification::WeightParams* release_inputgaterecursionmatrix();
  void set_allocated_inputgaterecursionmatrix(::CoreML::Specification::WeightParams* inputgaterecursionmatrix);

  // .CoreML.Specification.WeightParams forgetGateRecursionMatrix = 21;
  bool has_forgetgaterecursionmatrix() const;
  void clear_forgetgaterecursionmatrix();
  static const int kForgetGateRecursionMatrixFieldNumber = 21;
  const ::CoreML::Specification::WeightParams& forgetgaterecursionmatrix() const;
  ::CoreML::Specification::WeightParams* mutable_forgetgaterecursionmatrix();
  ::CoreML::Specification::WeightParams* release_forgetgaterecursionmatrix();
  void set_allocated_forgetgaterecursionmatrix(::CoreML::Specification::WeightParams* forgetgaterecursionmatrix);

  // .CoreML.Specification.WeightParams blockInputRecursionMatrix = 22;
  bool has_blockinputrecursionmatrix() const;
  void clear_blockinputrecursionmatrix();
  static const int kBlockInputRecursionMatrixFieldNumber = 22;
  const ::CoreML::Specification::WeightParams& blockinputrecursionmatrix() const;
  ::CoreML::Specification::WeightParams* mutable_blockinputrecursionmatrix();
  ::CoreML::Specification::WeightParams* release_blockinputrecursionmatrix();
  void set_allocated_blockinputrecursionmatrix(::CoreML::Specification::WeightParams* blockinputrecursionmatrix);

  // .CoreML.Specification.WeightParams outputGateRecursionMatrix = 23;
  bool has_outputgaterecursionmatrix() const;
  void clear_outputgaterecursionmatrix();
  static const int kOutputGateRecursionMatrixFieldNumber = 23;
  const ::CoreML::Specification::WeightParams& outputgaterecursionmatrix() const;
  ::CoreML::Specification::WeightParams* mutable_outputgaterecursionmatrix();
  ::CoreML::Specification::WeightParams* release_outputgaterecursionmatrix();
  void set_allocated_outputgaterecursionmatrix(::CoreML::Specification::WeightParams* outputgaterecursionmatrix);

  // .CoreML.Specification.WeightParams inputGateBiasVector = 40;
  bool has_inputgatebiasvector() const;
  void clear_inputgatebiasvector();
  static const int kInputGateBiasVectorFieldNumber = 40;
  const ::CoreML::Specification::WeightParams& inputgatebiasvector() const;
  ::CoreML::Specification::WeightParams* mutable_inputgatebiasvector();
  ::CoreML::Specification::WeightParams* release_inputgatebiasvector();
  void set_allocated_inputgatebiasvector(::CoreML::Specification::WeightParams* inputgatebiasvector);

  // .CoreML.Specification.WeightParams forgetGateBiasVector = 41;
  bool has_forgetgatebiasvector() const;
  void clear_forgetgatebiasvector();
  static const int kForgetGateBiasVectorFieldNumber = 41;
  const ::CoreML::Specification::WeightParams& forgetgatebiasvector() const;
  ::CoreML::Specification::WeightParams* mutable_forgetgatebiasvector();
  ::CoreML::Specification::WeightParams* release_forgetgatebiasvector();
  void set_allocated_forgetgatebiasvector(::CoreML::Specification::WeightParams* forgetgatebiasvector);

  // .CoreML.Specification.WeightParams blockInputBiasVector = 42;
  bool has_blockinputbiasvector() const;
  void clear_blockinputbiasvector();
  static const int kBlockInputBiasVectorFieldNumber = 42;
  const ::CoreML::Specification::WeightParams& blockinputbiasvector() const;
  ::CoreML::Specification::WeightParams* mutable_blockinputbiasvector();
  ::CoreML::Specification::WeightParams* release_blockinputbiasvector();
  void set_allocated_blockinputbiasvector(::CoreML::Specification::WeightParams* blockinputbiasvector);

  // .CoreML.Specification.WeightParams outputGateBiasVector = 43;
  bool has_outputgatebiasvector() const;
  void clear_outputgatebiasvector();
  static const int kOutputGateBiasVectorFieldNumber = 43;
  const ::CoreML::Specification::WeightParams& outputgatebiasvector() const;
  ::CoreML::Specification::WeightParams* mutable_outputgatebiasvector();
  ::CoreML::Specification::WeightParams* release_outputgatebiasvector();
  void set_allocated_outputgatebiasvector(::CoreML::Specification::WeightParams* outputgatebiasvector);

  // .CoreML.Specification.WeightParams inputGatePeepholeVector = 60;
  bool has_inputgatepeepholevector() const;
  void clear_inputgatepeepholevector();
  static const int kInputGatePeepholeVectorFieldNumber = 60;
  const ::CoreML::Specification::WeightParams& inputgatepeepholevector() const;
  ::CoreML::Specification::WeightParams* mutable_inputgatepeepholevector();
  ::CoreML::Specification::WeightParams* release_inputgatepeepholevector();
  void set_allocated_inputgatepeepholevector(::CoreML::Specification::WeightParams* inputgatepeepholevector);

  // .CoreML.Specification.WeightParams forgetGatePeepholeVector = 61;
  bool has_forgetgatepeepholevector() const;
  void clear_forgetgatepeepholevector();
  static const int kForgetGatePeepholeVectorFieldNumber = 61;
  const ::CoreML::Specification::WeightParams& forgetgatepeepholevector() const;
  ::CoreML::Specification::WeightParams* mutable_forgetgatepeepholevector();
  ::CoreML::Specification::WeightParams* release_forgetgatepeepholevector();
  void set_allocated_forgetgatepeepholevector(::CoreML::Specification::WeightParams* forgetgatepeepholevector);

  // .CoreML.Specification.WeightParams outputGatePeepholeVector = 62;
  bool has_outputgatepeepholevector() const;
  void clear_outputgatepeepholevector();
  static const int kOutputGatePeepholeVectorFieldNumber = 62;
  const ::CoreML::Specification::WeightParams& outputgatepeepholevector() const;
  ::CoreML::Specification::WeightParams* mutable_outputgatepeepholevector();
  ::CoreML::Specification::WeightParams* release_outputgatepeepholevector();
  void set_allocated_outputgatepeepholevector(::CoreML::Specification::WeightParams* outputgatepeepholevector);

  // @@protoc_insertion_point(class_scope:CoreML.Specification.LSTMWeightParams)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::CoreML::Specification::WeightParams* inputgateweightmatrix_;
  ::CoreML::Specification::WeightParams* forgetgateweightmatrix_;
  ::CoreML::Specification::WeightParams* blockinputweightmatrix_;
  ::CoreML::Specification::WeightParams* outputgateweightmatrix_;
  ::CoreML::Specification::WeightParams* inputgaterecursionmatrix_;
  ::CoreML::Specification::WeightParams* forgetgaterecursionmatrix_;
  ::CoreML::Specification::WeightParams* blockinputrecursionmatrix_;
  ::CoreML::Specification::WeightParams* outputgaterecursionmatrix_;
  ::CoreML::Specification::WeightParams* inputgatebiasvector_;
  ::CoreML::Specification::WeightParams* forgetgatebiasvector_;
  ::CoreML::Specification::WeightParams* blockinputbiasvector_;
  ::CoreML::Specification::WeightParams* outputgatebiasvector_;
  ::CoreML::Specification::WeightParams* inputgatepeepholevector_;
  ::CoreML::Specification::WeightParams* forgetgatepeepholevector_;
  ::CoreML::Specification::WeightParams* outputgatepeepholevector_;
  mutable int _cached_size_;
  friend struct protobuf_NeuralNetwork_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UniDirectionalLSTMLayerParams : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.UniDirectionalLSTMLayerParams) */ {
 public:
  UniDirectionalLSTMLayerParams();
  virtual ~UniDirectionalLSTMLayerParams();

  UniDirectionalLSTMLayerParams(const UniDirectionalLSTMLayerParams& from);

  inline UniDirectionalLSTMLayerParams& operator=(const UniDirectionalLSTMLayerParams& from) {
    CopyFrom(from);
    return *this;
  }

  static const UniDirectionalLSTMLayerParams& default_instance();

  static inline const UniDirectionalLSTMLayerParams* internal_default_instance() {
    return reinterpret_cast<const UniDirectionalLSTMLayerParams*>(
               &_UniDirectionalLSTMLayerParams_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    70;

  void Swap(UniDirectionalLSTMLayerParams* other);

  // implements Message ----------------------------------------------

  inline UniDirectionalLSTMLayerParams* New() const PROTOBUF_FINAL { return New(NULL); }

  UniDirectionalLSTMLayerParams* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const UniDirectionalLSTMLayerParams& from);
  void MergeFrom(const UniDirectionalLSTMLayerParams& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(UniDirectionalLSTMLayerParams* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .CoreML.Specification.ActivationParams activations = 10;
  int activations_size() const;
  void clear_activations();
  static const int kActivationsFieldNumber = 10;
  const ::CoreML::Specification::ActivationParams& activations(int index) const;
  ::CoreML::Specification::ActivationParams* mutable_activations(int index);
  ::CoreML::Specification::ActivationParams* add_activations();
  ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::ActivationParams >*
      mutable_activations();
  const ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::ActivationParams >&
      activations() const;

  // .CoreML.Specification.LSTMParams params = 15;
  bool has_params() const;
  void clear_params();
  static const int kParamsFieldNumber = 15;
  const ::CoreML::Specification::LSTMParams& params() const;
  ::CoreML::Specification::LSTMParams* mutable_params();
  ::CoreML::Specification::LSTMParams* release_params();
  void set_allocated_params(::CoreML::Specification::LSTMParams* params);

  // .CoreML.Specification.LSTMWeightParams weightParams = 20;
  bool has_weightparams() const;
  void clear_weightparams();
  static const int kWeightParamsFieldNumber = 20;
  const ::CoreML::Specification::LSTMWeightParams& weightparams() const;
  ::CoreML::Specification::LSTMWeightParams* mutable_weightparams();
  ::CoreML::Specification::LSTMWeightParams* release_weightparams();
  void set_allocated_weightparams(::CoreML::Specification::LSTMWeightParams* weightparams);

  // uint64 inputVectorSize = 1;
  void clear_inputvectorsize();
  static const int kInputVectorSizeFieldNumber = 1;
  ::google::protobuf::uint64 inputvectorsize() const;
  void set_inputvectorsize(::google::protobuf::uint64 value);

  // uint64 outputVectorSize = 2;
  void clear_outputvectorsize();
  static const int kOutputVectorSizeFieldNumber = 2;
  ::google::protobuf::uint64 outputvectorsize() const;
  void set_outputvectorsize(::google::protobuf::uint64 value);

  // bool reverseInput = 100;
  void clear_reverseinput();
  static const int kReverseInputFieldNumber = 100;
  bool reverseinput() const;
  void set_reverseinput(bool value);

  // @@protoc_insertion_point(class_scope:CoreML.Specification.UniDirectionalLSTMLayerParams)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::ActivationParams > activations_;
  ::CoreML::Specification::LSTMParams* params_;
  ::CoreML::Specification::LSTMWeightParams* weightparams_;
  ::google::protobuf::uint64 inputvectorsize_;
  ::google::protobuf::uint64 outputvectorsize_;
  bool reverseinput_;
  mutable int _cached_size_;
  friend struct protobuf_NeuralNetwork_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BiDirectionalLSTMLayerParams : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.BiDirectionalLSTMLayerParams) */ {
 public:
  BiDirectionalLSTMLayerParams();
  virtual ~BiDirectionalLSTMLayerParams();

  BiDirectionalLSTMLayerParams(const BiDirectionalLSTMLayerParams& from);

  inline BiDirectionalLSTMLayerParams& operator=(const BiDirectionalLSTMLayerParams& from) {
    CopyFrom(from);
    return *this;
  }

  static const BiDirectionalLSTMLayerParams& default_instance();

  static inline const BiDirectionalLSTMLayerParams* internal_default_instance() {
    return reinterpret_cast<const BiDirectionalLSTMLayerParams*>(
               &_BiDirectionalLSTMLayerParams_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    71;

  void Swap(BiDirectionalLSTMLayerParams* other);

  // implements Message ----------------------------------------------

  inline BiDirectionalLSTMLayerParams* New() const PROTOBUF_FINAL { return New(NULL); }

  BiDirectionalLSTMLayerParams* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const BiDirectionalLSTMLayerParams& from);
  void MergeFrom(const BiDirectionalLSTMLayerParams& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BiDirectionalLSTMLayerParams* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .CoreML.Specification.ActivationParams activationsForwardLSTM = 10;
  int activationsforwardlstm_size() const;
  void clear_activationsforwardlstm();
  static const int kActivationsForwardLSTMFieldNumber = 10;
  const ::CoreML::Specification::ActivationParams& activationsforwardlstm(int index) const;
  ::CoreML::Specification::ActivationParams* mutable_activationsforwardlstm(int index);
  ::CoreML::Specification::ActivationParams* add_activationsforwardlstm();
  ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::ActivationParams >*
      mutable_activationsforwardlstm();
  const ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::ActivationParams >&
      activationsforwardlstm() const;

  // repeated .CoreML.Specification.ActivationParams activationsBackwardLSTM = 11;
  int activationsbackwardlstm_size() const;
  void clear_activationsbackwardlstm();
  static const int kActivationsBackwardLSTMFieldNumber = 11;
  const ::CoreML::Specification::ActivationParams& activationsbackwardlstm(int index) const;
  ::CoreML::Specification::ActivationParams* mutable_activationsbackwardlstm(int index);
  ::CoreML::Specification::ActivationParams* add_activationsbackwardlstm();
  ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::ActivationParams >*
      mutable_activationsbackwardlstm();
  const ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::ActivationParams >&
      activationsbackwardlstm() const;

  // repeated .CoreML.Specification.LSTMWeightParams weightParams = 20;
  int weightparams_size() const;
  void clear_weightparams();
  static const int kWeightParamsFieldNumber = 20;
  const ::CoreML::Specification::LSTMWeightParams& weightparams(int index) const;
  ::CoreML::Specification::LSTMWeightParams* mutable_weightparams(int index);
  ::CoreML::Specification::LSTMWeightParams* add_weightparams();
  ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::LSTMWeightParams >*
      mutable_weightparams();
  const ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::LSTMWeightParams >&
      weightparams() const;

  // .CoreML.Specification.LSTMParams params = 15;
  bool has_params() const;
  void clear_params();
  static const int kParamsFieldNumber = 15;
  const ::CoreML::Specification::LSTMParams& params() const;
  ::CoreML::Specification::LSTMParams* mutable_params();
  ::CoreML::Specification::LSTMParams* release_params();
  void set_allocated_params(::CoreML::Specification::LSTMParams* params);

  // uint64 inputVectorSize = 1;
  void clear_inputvectorsize();
  static const int kInputVectorSizeFieldNumber = 1;
  ::google::protobuf::uint64 inputvectorsize() const;
  void set_inputvectorsize(::google::protobuf::uint64 value);

  // uint64 outputVectorSize = 2;
  void clear_outputvectorsize();
  static const int kOutputVectorSizeFieldNumber = 2;
  ::google::protobuf::uint64 outputvectorsize() const;
  void set_outputvectorsize(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:CoreML.Specification.BiDirectionalLSTMLayerParams)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::ActivationParams > activationsforwardlstm_;
  ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::ActivationParams > activationsbackwardlstm_;
  ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::LSTMWeightParams > weightparams_;
  ::CoreML::Specification::LSTMParams* params_;
  ::google::protobuf::uint64 inputvectorsize_;
  ::google::protobuf::uint64 outputvectorsize_;
  mutable int _cached_size_;
  friend struct protobuf_NeuralNetwork_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CustomLayerParams_CustomLayerParamValue : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.CustomLayerParams.CustomLayerParamValue) */ {
 public:
  CustomLayerParams_CustomLayerParamValue();
  virtual ~CustomLayerParams_CustomLayerParamValue();

  CustomLayerParams_CustomLayerParamValue(const CustomLayerParams_CustomLayerParamValue& from);

  inline CustomLayerParams_CustomLayerParamValue& operator=(const CustomLayerParams_CustomLayerParamValue& from) {
    CopyFrom(from);
    return *this;
  }

  static const CustomLayerParams_CustomLayerParamValue& default_instance();

  enum ValueCase {
    kDoubleValue = 10,
    kStringValue = 20,
    kIntValue = 30,
    kLongValue = 40,
    kBoolValue = 50,
    VALUE_NOT_SET = 0,
  };

  static inline const CustomLayerParams_CustomLayerParamValue* internal_default_instance() {
    return reinterpret_cast<const CustomLayerParams_CustomLayerParamValue*>(
               &_CustomLayerParams_CustomLayerParamValue_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    72;

  void Swap(CustomLayerParams_CustomLayerParamValue* other);

  // implements Message ----------------------------------------------

  inline CustomLayerParams_CustomLayerParamValue* New() const PROTOBUF_FINAL { return New(NULL); }

  CustomLayerParams_CustomLayerParamValue* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const CustomLayerParams_CustomLayerParamValue& from);
  void MergeFrom(const CustomLayerParams_CustomLayerParamValue& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CustomLayerParams_CustomLayerParamValue* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // double doubleValue = 10;
  private:
  bool has_doublevalue() const;
  public:
  void clear_doublevalue();
  static const int kDoubleValueFieldNumber = 10;
  double doublevalue() const;
  void set_doublevalue(double value);

  // string stringValue = 20;
  private:
  bool has_stringvalue() const;
  public:
  void clear_stringvalue();
  static const int kStringValueFieldNumber = 20;
  const ::std::string& stringvalue() const;
  void set_stringvalue(const ::std::string& value);
  #if LANG_CXX11
  void set_stringvalue(::std::string&& value);
  #endif
  void set_stringvalue(const char* value);
  void set_stringvalue(const char* value, size_t size);
  ::std::string* mutable_stringvalue();
  ::std::string* release_stringvalue();
  void set_allocated_stringvalue(::std::string* stringvalue);

  // int32 intValue = 30;
  private:
  bool has_intvalue() const;
  public:
  void clear_intvalue();
  static const int kIntValueFieldNumber = 30;
  ::google::protobuf::int32 intvalue() const;
  void set_intvalue(::google::protobuf::int32 value);

  // int64 longValue = 40;
  private:
  bool has_longvalue() const;
  public:
  void clear_longvalue();
  static const int kLongValueFieldNumber = 40;
  ::google::protobuf::int64 longvalue() const;
  void set_longvalue(::google::protobuf::int64 value);

  // bool boolValue = 50;
  private:
  bool has_boolvalue() const;
  public:
  void clear_boolvalue();
  static const int kBoolValueFieldNumber = 50;
  bool boolvalue() const;
  void set_boolvalue(bool value);

  ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:CoreML.Specification.CustomLayerParams.CustomLayerParamValue)
 private:
  void set_has_doublevalue();
  void set_has_stringvalue();
  void set_has_intvalue();
  void set_has_longvalue();
  void set_has_boolvalue();

  inline bool has_value() const;
  void clear_value();
  inline void clear_has_value();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  union ValueUnion {
    ValueUnion() {}
    double doublevalue_;
    ::google::protobuf::internal::ArenaStringPtr stringvalue_;
    ::google::protobuf::int32 intvalue_;
    ::google::protobuf::int64 longvalue_;
    bool boolvalue_;
  } value_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct protobuf_NeuralNetwork_2eproto::TableStruct;
};
// -------------------------------------------------------------------


// -------------------------------------------------------------------

class CustomLayerParams : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.CustomLayerParams) */ {
 public:
  CustomLayerParams();
  virtual ~CustomLayerParams();

  CustomLayerParams(const CustomLayerParams& from);

  inline CustomLayerParams& operator=(const CustomLayerParams& from) {
    CopyFrom(from);
    return *this;
  }

  static const CustomLayerParams& default_instance();

  static inline const CustomLayerParams* internal_default_instance() {
    return reinterpret_cast<const CustomLayerParams*>(
               &_CustomLayerParams_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    74;

  void Swap(CustomLayerParams* other);

  // implements Message ----------------------------------------------

  inline CustomLayerParams* New() const PROTOBUF_FINAL { return New(NULL); }

  CustomLayerParams* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const CustomLayerParams& from);
  void MergeFrom(const CustomLayerParams& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CustomLayerParams* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef CustomLayerParams_CustomLayerParamValue CustomLayerParamValue;

  // accessors -------------------------------------------------------

  // repeated .CoreML.Specification.WeightParams weights = 20;
  int weights_size() const;
  void clear_weights();
  static const int kWeightsFieldNumber = 20;
  const ::CoreML::Specification::WeightParams& weights(int index) const;
  ::CoreML::Specification::WeightParams* mutable_weights(int index);
  ::CoreML::Specification::WeightParams* add_weights();
  ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::WeightParams >*
      mutable_weights();
  const ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::WeightParams >&
      weights() const;

  // map<string, .CoreML.Specification.CustomLayerParams.CustomLayerParamValue> parameters = 30;
  int parameters_size() const;
  void clear_parameters();
  static const int kParametersFieldNumber = 30;
  const ::google::protobuf::Map< ::std::string, ::CoreML::Specification::CustomLayerParams_CustomLayerParamValue >&
      parameters() const;
  ::google::protobuf::Map< ::std::string, ::CoreML::Specification::CustomLayerParams_CustomLayerParamValue >*
      mutable_parameters();

  // string className = 10;
  void clear_classname();
  static const int kClassNameFieldNumber = 10;
  const ::std::string& classname() const;
  void set_classname(const ::std::string& value);
  #if LANG_CXX11
  void set_classname(::std::string&& value);
  #endif
  void set_classname(const char* value);
  void set_classname(const char* value, size_t size);
  ::std::string* mutable_classname();
  ::std::string* release_classname();
  void set_allocated_classname(::std::string* classname);

  // string description = 40;
  void clear_description();
  static const int kDescriptionFieldNumber = 40;
  const ::std::string& description() const;
  void set_description(const ::std::string& value);
  #if LANG_CXX11
  void set_description(::std::string&& value);
  #endif
  void set_description(const char* value);
  void set_description(const char* value, size_t size);
  ::std::string* mutable_description();
  ::std::string* release_description();
  void set_allocated_description(::std::string* description);

  // @@protoc_insertion_point(class_scope:CoreML.Specification.CustomLayerParams)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::WeightParams > weights_;
  public:
  typedef ::google::protobuf::internal::MapEntryLite<
      ::std::string, ::CoreML::Specification::CustomLayerParams_CustomLayerParamValue,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 >
      CustomLayerParams_ParametersEntry;
  ::google::protobuf::internal::MapFieldLite<
      CustomLayerParams_ParametersEntry,
      ::std::string, ::CoreML::Specification::CustomLayerParams_CustomLayerParamValue,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 > parameters_;
  private:
  ::google::protobuf::internal::ArenaStringPtr classname_;
  ::google::protobuf::internal::ArenaStringPtr description_;
  mutable int _cached_size_;
  friend struct protobuf_NeuralNetwork_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class NeuralNetworkClassifier : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.NeuralNetworkClassifier) */ {
 public:
  NeuralNetworkClassifier();
  virtual ~NeuralNetworkClassifier();

  NeuralNetworkClassifier(const NeuralNetworkClassifier& from);

  inline NeuralNetworkClassifier& operator=(const NeuralNetworkClassifier& from) {
    CopyFrom(from);
    return *this;
  }

  static const NeuralNetworkClassifier& default_instance();

  enum ClassLabelsCase {
    kStringClassLabels = 100,
    kInt64ClassLabels = 101,
    CLASSLABELS_NOT_SET = 0,
  };

  static inline const NeuralNetworkClassifier* internal_default_instance() {
    return reinterpret_cast<const NeuralNetworkClassifier*>(
               &_NeuralNetworkClassifier_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    75;

  void Swap(NeuralNetworkClassifier* other);

  // implements Message ----------------------------------------------

  inline NeuralNetworkClassifier* New() const PROTOBUF_FINAL { return New(NULL); }

  NeuralNetworkClassifier* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const NeuralNetworkClassifier& from);
  void MergeFrom(const NeuralNetworkClassifier& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(NeuralNetworkClassifier* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .CoreML.Specification.NeuralNetworkLayer layers = 1;
  int layers_size() const;
  void clear_layers();
  static const int kLayersFieldNumber = 1;
  const ::CoreML::Specification::NeuralNetworkLayer& layers(int index) const;
  ::CoreML::Specification::NeuralNetworkLayer* mutable_layers(int index);
  ::CoreML::Specification::NeuralNetworkLayer* add_layers();
  ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::NeuralNetworkLayer >*
      mutable_layers();
  const ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::NeuralNetworkLayer >&
      layers() const;

  // repeated .CoreML.Specification.NeuralNetworkPreprocessing preprocessing = 2;
  int preprocessing_size() const;
  void clear_preprocessing();
  static const int kPreprocessingFieldNumber = 2;
  const ::CoreML::Specification::NeuralNetworkPreprocessing& preprocessing(int index) const;
  ::CoreML::Specification::NeuralNetworkPreprocessing* mutable_preprocessing(int index);
  ::CoreML::Specification::NeuralNetworkPreprocessing* add_preprocessing();
  ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::NeuralNetworkPreprocessing >*
      mutable_preprocessing();
  const ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::NeuralNetworkPreprocessing >&
      preprocessing() const;

  // string labelProbabilityLayerName = 200;
  void clear_labelprobabilitylayername();
  static const int kLabelProbabilityLayerNameFieldNumber = 200;
  const ::std::string& labelprobabilitylayername() const;
  void set_labelprobabilitylayername(const ::std::string& value);
  #if LANG_CXX11
  void set_labelprobabilitylayername(::std::string&& value);
  #endif
  void set_labelprobabilitylayername(const char* value);
  void set_labelprobabilitylayername(const char* value, size_t size);
  ::std::string* mutable_labelprobabilitylayername();
  ::std::string* release_labelprobabilitylayername();
  void set_allocated_labelprobabilitylayername(::std::string* labelprobabilitylayername);

  // .CoreML.Specification.StringVector stringClassLabels = 100;
  bool has_stringclasslabels() const;
  void clear_stringclasslabels();
  static const int kStringClassLabelsFieldNumber = 100;
  const ::CoreML::Specification::StringVector& stringclasslabels() const;
  ::CoreML::Specification::StringVector* mutable_stringclasslabels();
  ::CoreML::Specification::StringVector* release_stringclasslabels();
  void set_allocated_stringclasslabels(::CoreML::Specification::StringVector* stringclasslabels);

  // .CoreML.Specification.Int64Vector int64ClassLabels = 101;
  bool has_int64classlabels() const;
  void clear_int64classlabels();
  static const int kInt64ClassLabelsFieldNumber = 101;
  const ::CoreML::Specification::Int64Vector& int64classlabels() const;
  ::CoreML::Specification::Int64Vector* mutable_int64classlabels();
  ::CoreML::Specification::Int64Vector* release_int64classlabels();
  void set_allocated_int64classlabels(::CoreML::Specification::Int64Vector* int64classlabels);

  ClassLabelsCase ClassLabels_case() const;
  // @@protoc_insertion_point(class_scope:CoreML.Specification.NeuralNetworkClassifier)
 private:
  void set_has_stringclasslabels();
  void set_has_int64classlabels();

  inline bool has_ClassLabels() const;
  void clear_ClassLabels();
  inline void clear_has_ClassLabels();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::NeuralNetworkLayer > layers_;
  ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::NeuralNetworkPreprocessing > preprocessing_;
  ::google::protobuf::internal::ArenaStringPtr labelprobabilitylayername_;
  union ClassLabelsUnion {
    ClassLabelsUnion() {}
    ::CoreML::Specification::StringVector* stringclasslabels_;
    ::CoreML::Specification::Int64Vector* int64classlabels_;
  } ClassLabels_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct protobuf_NeuralNetwork_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class NeuralNetworkRegressor : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:CoreML.Specification.NeuralNetworkRegressor) */ {
 public:
  NeuralNetworkRegressor();
  virtual ~NeuralNetworkRegressor();

  NeuralNetworkRegressor(const NeuralNetworkRegressor& from);

  inline NeuralNetworkRegressor& operator=(const NeuralNetworkRegressor& from) {
    CopyFrom(from);
    return *this;
  }

  static const NeuralNetworkRegressor& default_instance();

  static inline const NeuralNetworkRegressor* internal_default_instance() {
    return reinterpret_cast<const NeuralNetworkRegressor*>(
               &_NeuralNetworkRegressor_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    76;

  void Swap(NeuralNetworkRegressor* other);

  // implements Message ----------------------------------------------

  inline NeuralNetworkRegressor* New() const PROTOBUF_FINAL { return New(NULL); }

  NeuralNetworkRegressor* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const NeuralNetworkRegressor& from);
  void MergeFrom(const NeuralNetworkRegressor& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(NeuralNetworkRegressor* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .CoreML.Specification.NeuralNetworkLayer layers = 1;
  int layers_size() const;
  void clear_layers();
  static const int kLayersFieldNumber = 1;
  const ::CoreML::Specification::NeuralNetworkLayer& layers(int index) const;
  ::CoreML::Specification::NeuralNetworkLayer* mutable_layers(int index);
  ::CoreML::Specification::NeuralNetworkLayer* add_layers();
  ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::NeuralNetworkLayer >*
      mutable_layers();
  const ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::NeuralNetworkLayer >&
      layers() const;

  // repeated .CoreML.Specification.NeuralNetworkPreprocessing preprocessing = 2;
  int preprocessing_size() const;
  void clear_preprocessing();
  static const int kPreprocessingFieldNumber = 2;
  const ::CoreML::Specification::NeuralNetworkPreprocessing& preprocessing(int index) const;
  ::CoreML::Specification::NeuralNetworkPreprocessing* mutable_preprocessing(int index);
  ::CoreML::Specification::NeuralNetworkPreprocessing* add_preprocessing();
  ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::NeuralNetworkPreprocessing >*
      mutable_preprocessing();
  const ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::NeuralNetworkPreprocessing >&
      preprocessing() const;

  // @@protoc_insertion_point(class_scope:CoreML.Specification.NeuralNetworkRegressor)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::NeuralNetworkLayer > layers_;
  ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::NeuralNetworkPreprocessing > preprocessing_;
  mutable int _cached_size_;
  friend struct protobuf_NeuralNetwork_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// NeuralNetwork

// repeated .CoreML.Specification.NeuralNetworkLayer layers = 1;
inline int NeuralNetwork::layers_size() const {
  return layers_.size();
}
inline void NeuralNetwork::clear_layers() {
  layers_.Clear();
}
inline const ::CoreML::Specification::NeuralNetworkLayer& NeuralNetwork::layers(int index) const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.NeuralNetwork.layers)
  return layers_.Get(index);
}
inline ::CoreML::Specification::NeuralNetworkLayer* NeuralNetwork::mutable_layers(int index) {
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.NeuralNetwork.layers)
  return layers_.Mutable(index);
}
inline ::CoreML::Specification::NeuralNetworkLayer* NeuralNetwork::add_layers() {
  // @@protoc_insertion_point(field_add:CoreML.Specification.NeuralNetwork.layers)
  return layers_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::NeuralNetworkLayer >*
NeuralNetwork::mutable_layers() {
  // @@protoc_insertion_point(field_mutable_list:CoreML.Specification.NeuralNetwork.layers)
  return &layers_;
}
inline const ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::NeuralNetworkLayer >&
NeuralNetwork::layers() const {
  // @@protoc_insertion_point(field_list:CoreML.Specification.NeuralNetwork.layers)
  return layers_;
}

// repeated .CoreML.Specification.NeuralNetworkPreprocessing preprocessing = 2;
inline int NeuralNetwork::preprocessing_size() const {
  return preprocessing_.size();
}
inline void NeuralNetwork::clear_preprocessing() {
  preprocessing_.Clear();
}
inline const ::CoreML::Specification::NeuralNetworkPreprocessing& NeuralNetwork::preprocessing(int index) const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.NeuralNetwork.preprocessing)
  return preprocessing_.Get(index);
}
inline ::CoreML::Specification::NeuralNetworkPreprocessing* NeuralNetwork::mutable_preprocessing(int index) {
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.NeuralNetwork.preprocessing)
  return preprocessing_.Mutable(index);
}
inline ::CoreML::Specification::NeuralNetworkPreprocessing* NeuralNetwork::add_preprocessing() {
  // @@protoc_insertion_point(field_add:CoreML.Specification.NeuralNetwork.preprocessing)
  return preprocessing_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::NeuralNetworkPreprocessing >*
NeuralNetwork::mutable_preprocessing() {
  // @@protoc_insertion_point(field_mutable_list:CoreML.Specification.NeuralNetwork.preprocessing)
  return &preprocessing_;
}
inline const ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::NeuralNetworkPreprocessing >&
NeuralNetwork::preprocessing() const {
  // @@protoc_insertion_point(field_list:CoreML.Specification.NeuralNetwork.preprocessing)
  return preprocessing_;
}

// -------------------------------------------------------------------

// NeuralNetworkImageScaler

// float channelScale = 10;
inline void NeuralNetworkImageScaler::clear_channelscale() {
  channelscale_ = 0;
}
inline float NeuralNetworkImageScaler::channelscale() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.NeuralNetworkImageScaler.channelScale)
  return channelscale_;
}
inline void NeuralNetworkImageScaler::set_channelscale(float value) {

  channelscale_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.NeuralNetworkImageScaler.channelScale)
}

// float blueBias = 20;
inline void NeuralNetworkImageScaler::clear_bluebias() {
  bluebias_ = 0;
}
inline float NeuralNetworkImageScaler::bluebias() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.NeuralNetworkImageScaler.blueBias)
  return bluebias_;
}
inline void NeuralNetworkImageScaler::set_bluebias(float value) {

  bluebias_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.NeuralNetworkImageScaler.blueBias)
}

// float greenBias = 21;
inline void NeuralNetworkImageScaler::clear_greenbias() {
  greenbias_ = 0;
}
inline float NeuralNetworkImageScaler::greenbias() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.NeuralNetworkImageScaler.greenBias)
  return greenbias_;
}
inline void NeuralNetworkImageScaler::set_greenbias(float value) {

  greenbias_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.NeuralNetworkImageScaler.greenBias)
}

// float redBias = 22;
inline void NeuralNetworkImageScaler::clear_redbias() {
  redbias_ = 0;
}
inline float NeuralNetworkImageScaler::redbias() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.NeuralNetworkImageScaler.redBias)
  return redbias_;
}
inline void NeuralNetworkImageScaler::set_redbias(float value) {

  redbias_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.NeuralNetworkImageScaler.redBias)
}

// float grayBias = 30;
inline void NeuralNetworkImageScaler::clear_graybias() {
  graybias_ = 0;
}
inline float NeuralNetworkImageScaler::graybias() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.NeuralNetworkImageScaler.grayBias)
  return graybias_;
}
inline void NeuralNetworkImageScaler::set_graybias(float value) {

  graybias_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.NeuralNetworkImageScaler.grayBias)
}

// -------------------------------------------------------------------

// NeuralNetworkMeanImage

// repeated float meanImage = 1;
inline int NeuralNetworkMeanImage::meanimage_size() const {
  return meanimage_.size();
}
inline void NeuralNetworkMeanImage::clear_meanimage() {
  meanimage_.Clear();
}
inline float NeuralNetworkMeanImage::meanimage(int index) const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.NeuralNetworkMeanImage.meanImage)
  return meanimage_.Get(index);
}
inline void NeuralNetworkMeanImage::set_meanimage(int index, float value) {
  meanimage_.Set(index, value);
  // @@protoc_insertion_point(field_set:CoreML.Specification.NeuralNetworkMeanImage.meanImage)
}
inline void NeuralNetworkMeanImage::add_meanimage(float value) {
  meanimage_.Add(value);
  // @@protoc_insertion_point(field_add:CoreML.Specification.NeuralNetworkMeanImage.meanImage)
}
inline const ::google::protobuf::RepeatedField< float >&
NeuralNetworkMeanImage::meanimage() const {
  // @@protoc_insertion_point(field_list:CoreML.Specification.NeuralNetworkMeanImage.meanImage)
  return meanimage_;
}
inline ::google::protobuf::RepeatedField< float >*
NeuralNetworkMeanImage::mutable_meanimage() {
  // @@protoc_insertion_point(field_mutable_list:CoreML.Specification.NeuralNetworkMeanImage.meanImage)
  return &meanimage_;
}

// -------------------------------------------------------------------

// NeuralNetworkPreprocessing

// string featureName = 1;
inline void NeuralNetworkPreprocessing::clear_featurename() {
  featurename_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& NeuralNetworkPreprocessing::featurename() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.NeuralNetworkPreprocessing.featureName)
  return featurename_.GetNoArena();
}
inline void NeuralNetworkPreprocessing::set_featurename(const ::std::string& value) {

  featurename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:CoreML.Specification.NeuralNetworkPreprocessing.featureName)
}
#if LANG_CXX11
inline void NeuralNetworkPreprocessing::set_featurename(::std::string&& value) {

  featurename_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:CoreML.Specification.NeuralNetworkPreprocessing.featureName)
}
#endif
inline void NeuralNetworkPreprocessing::set_featurename(const char* value) {
  GOOGLE_DCHECK(value != NULL);

  featurename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:CoreML.Specification.NeuralNetworkPreprocessing.featureName)
}
inline void NeuralNetworkPreprocessing::set_featurename(const char* value, size_t size) {

  featurename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:CoreML.Specification.NeuralNetworkPreprocessing.featureName)
}
inline ::std::string* NeuralNetworkPreprocessing::mutable_featurename() {

  // @@protoc_insertion_point(field_mutable:CoreML.Specification.NeuralNetworkPreprocessing.featureName)
  return featurename_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NeuralNetworkPreprocessing::release_featurename() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.NeuralNetworkPreprocessing.featureName)

  return featurename_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NeuralNetworkPreprocessing::set_allocated_featurename(::std::string* featurename) {
  if (featurename != NULL) {

  } else {

  }
  featurename_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), featurename);
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkPreprocessing.featureName)
}

// .CoreML.Specification.NeuralNetworkImageScaler scaler = 10;
inline bool NeuralNetworkPreprocessing::has_scaler() const {
  return preprocessor_case() == kScaler;
}
inline void NeuralNetworkPreprocessing::set_has_scaler() {
  _oneof_case_[0] = kScaler;
}
inline void NeuralNetworkPreprocessing::clear_scaler() {
  if (has_scaler()) {
    delete preprocessor_.scaler_;
    clear_has_preprocessor();
  }
}
inline  const ::CoreML::Specification::NeuralNetworkImageScaler& NeuralNetworkPreprocessing::scaler() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.NeuralNetworkPreprocessing.scaler)
  return has_scaler()
      ? *preprocessor_.scaler_
      : ::CoreML::Specification::NeuralNetworkImageScaler::default_instance();
}
inline ::CoreML::Specification::NeuralNetworkImageScaler* NeuralNetworkPreprocessing::mutable_scaler() {
  if (!has_scaler()) {
    clear_preprocessor();
    set_has_scaler();
    preprocessor_.scaler_ = new ::CoreML::Specification::NeuralNetworkImageScaler;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.NeuralNetworkPreprocessing.scaler)
  return preprocessor_.scaler_;
}
inline ::CoreML::Specification::NeuralNetworkImageScaler* NeuralNetworkPreprocessing::release_scaler() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.NeuralNetworkPreprocessing.scaler)
  if (has_scaler()) {
    clear_has_preprocessor();
    ::CoreML::Specification::NeuralNetworkImageScaler* temp = preprocessor_.scaler_;
    preprocessor_.scaler_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void NeuralNetworkPreprocessing::set_allocated_scaler(::CoreML::Specification::NeuralNetworkImageScaler* scaler) {
  clear_preprocessor();
  if (scaler) {
    set_has_scaler();
    preprocessor_.scaler_ = scaler;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkPreprocessing.scaler)
}

// .CoreML.Specification.NeuralNetworkMeanImage meanImage = 11;
inline bool NeuralNetworkPreprocessing::has_meanimage() const {
  return preprocessor_case() == kMeanImage;
}
inline void NeuralNetworkPreprocessing::set_has_meanimage() {
  _oneof_case_[0] = kMeanImage;
}
inline void NeuralNetworkPreprocessing::clear_meanimage() {
  if (has_meanimage()) {
    delete preprocessor_.meanimage_;
    clear_has_preprocessor();
  }
}
inline  const ::CoreML::Specification::NeuralNetworkMeanImage& NeuralNetworkPreprocessing::meanimage() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.NeuralNetworkPreprocessing.meanImage)
  return has_meanimage()
      ? *preprocessor_.meanimage_
      : ::CoreML::Specification::NeuralNetworkMeanImage::default_instance();
}
inline ::CoreML::Specification::NeuralNetworkMeanImage* NeuralNetworkPreprocessing::mutable_meanimage() {
  if (!has_meanimage()) {
    clear_preprocessor();
    set_has_meanimage();
    preprocessor_.meanimage_ = new ::CoreML::Specification::NeuralNetworkMeanImage;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.NeuralNetworkPreprocessing.meanImage)
  return preprocessor_.meanimage_;
}
inline ::CoreML::Specification::NeuralNetworkMeanImage* NeuralNetworkPreprocessing::release_meanimage() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.NeuralNetworkPreprocessing.meanImage)
  if (has_meanimage()) {
    clear_has_preprocessor();
    ::CoreML::Specification::NeuralNetworkMeanImage* temp = preprocessor_.meanimage_;
    preprocessor_.meanimage_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void NeuralNetworkPreprocessing::set_allocated_meanimage(::CoreML::Specification::NeuralNetworkMeanImage* meanimage) {
  clear_preprocessor();
  if (meanimage) {
    set_has_meanimage();
    preprocessor_.meanimage_ = meanimage;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkPreprocessing.meanImage)
}

inline bool NeuralNetworkPreprocessing::has_preprocessor() const {
  return preprocessor_case() != PREPROCESSOR_NOT_SET;
}
inline void NeuralNetworkPreprocessing::clear_has_preprocessor() {
  _oneof_case_[0] = PREPROCESSOR_NOT_SET;
}
inline NeuralNetworkPreprocessing::PreprocessorCase NeuralNetworkPreprocessing::preprocessor_case() const {
  return NeuralNetworkPreprocessing::PreprocessorCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ActivationReLU

// -------------------------------------------------------------------

// ActivationLeakyReLU

// float alpha = 1;
inline void ActivationLeakyReLU::clear_alpha() {
  alpha_ = 0;
}
inline float ActivationLeakyReLU::alpha() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.ActivationLeakyReLU.alpha)
  return alpha_;
}
inline void ActivationLeakyReLU::set_alpha(float value) {

  alpha_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.ActivationLeakyReLU.alpha)
}

// -------------------------------------------------------------------

// ActivationTanh

// -------------------------------------------------------------------

// ActivationScaledTanh

// float alpha = 1;
inline void ActivationScaledTanh::clear_alpha() {
  alpha_ = 0;
}
inline float ActivationScaledTanh::alpha() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.ActivationScaledTanh.alpha)
  return alpha_;
}
inline void ActivationScaledTanh::set_alpha(float value) {

  alpha_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.ActivationScaledTanh.alpha)
}

// float beta = 2;
inline void ActivationScaledTanh::clear_beta() {
  beta_ = 0;
}
inline float ActivationScaledTanh::beta() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.ActivationScaledTanh.beta)
  return beta_;
}
inline void ActivationScaledTanh::set_beta(float value) {

  beta_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.ActivationScaledTanh.beta)
}

// -------------------------------------------------------------------

// ActivationSigmoid

// -------------------------------------------------------------------

// ActivationLinear

// float alpha = 1;
inline void ActivationLinear::clear_alpha() {
  alpha_ = 0;
}
inline float ActivationLinear::alpha() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.ActivationLinear.alpha)
  return alpha_;
}
inline void ActivationLinear::set_alpha(float value) {

  alpha_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.ActivationLinear.alpha)
}

// float beta = 2;
inline void ActivationLinear::clear_beta() {
  beta_ = 0;
}
inline float ActivationLinear::beta() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.ActivationLinear.beta)
  return beta_;
}
inline void ActivationLinear::set_beta(float value) {

  beta_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.ActivationLinear.beta)
}

// -------------------------------------------------------------------

// ActivationSigmoidHard

// float alpha = 1;
inline void ActivationSigmoidHard::clear_alpha() {
  alpha_ = 0;
}
inline float ActivationSigmoidHard::alpha() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.ActivationSigmoidHard.alpha)
  return alpha_;
}
inline void ActivationSigmoidHard::set_alpha(float value) {

  alpha_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.ActivationSigmoidHard.alpha)
}

// float beta = 2;
inline void ActivationSigmoidHard::clear_beta() {
  beta_ = 0;
}
inline float ActivationSigmoidHard::beta() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.ActivationSigmoidHard.beta)
  return beta_;
}
inline void ActivationSigmoidHard::set_beta(float value) {

  beta_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.ActivationSigmoidHard.beta)
}

// -------------------------------------------------------------------

// ActivationPReLU

// .CoreML.Specification.WeightParams alpha = 1;
inline bool ActivationPReLU::has_alpha() const {
  return this != internal_default_instance() && alpha_ != NULL;
}
inline void ActivationPReLU::clear_alpha() {
  if (GetArenaNoVirtual() == NULL && alpha_ != NULL) delete alpha_;
  alpha_ = NULL;
}
inline const ::CoreML::Specification::WeightParams& ActivationPReLU::alpha() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.ActivationPReLU.alpha)
  return alpha_ != NULL ? *alpha_
                         : *::CoreML::Specification::WeightParams::internal_default_instance();
}
inline ::CoreML::Specification::WeightParams* ActivationPReLU::mutable_alpha() {

  if (alpha_ == NULL) {
    alpha_ = new ::CoreML::Specification::WeightParams;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.ActivationPReLU.alpha)
  return alpha_;
}
inline ::CoreML::Specification::WeightParams* ActivationPReLU::release_alpha() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.ActivationPReLU.alpha)

  ::CoreML::Specification::WeightParams* temp = alpha_;
  alpha_ = NULL;
  return temp;
}
inline void ActivationPReLU::set_allocated_alpha(::CoreML::Specification::WeightParams* alpha) {
  delete alpha_;
  alpha_ = alpha;
  if (alpha) {

  } else {

  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.ActivationPReLU.alpha)
}

// -------------------------------------------------------------------

// ActivationELU

// float alpha = 1;
inline void ActivationELU::clear_alpha() {
  alpha_ = 0;
}
inline float ActivationELU::alpha() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.ActivationELU.alpha)
  return alpha_;
}
inline void ActivationELU::set_alpha(float value) {

  alpha_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.ActivationELU.alpha)
}

// -------------------------------------------------------------------

// ActivationThresholdedReLU

// float alpha = 1;
inline void ActivationThresholdedReLU::clear_alpha() {
  alpha_ = 0;
}
inline float ActivationThresholdedReLU::alpha() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.ActivationThresholdedReLU.alpha)
  return alpha_;
}
inline void ActivationThresholdedReLU::set_alpha(float value) {

  alpha_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.ActivationThresholdedReLU.alpha)
}

// -------------------------------------------------------------------

// ActivationSoftsign

// -------------------------------------------------------------------

// ActivationSoftplus

// -------------------------------------------------------------------

// ActivationParametricSoftplus

// .CoreML.Specification.WeightParams alpha = 1;
inline bool ActivationParametricSoftplus::has_alpha() const {
  return this != internal_default_instance() && alpha_ != NULL;
}
inline void ActivationParametricSoftplus::clear_alpha() {
  if (GetArenaNoVirtual() == NULL && alpha_ != NULL) delete alpha_;
  alpha_ = NULL;
}
inline const ::CoreML::Specification::WeightParams& ActivationParametricSoftplus::alpha() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.ActivationParametricSoftplus.alpha)
  return alpha_ != NULL ? *alpha_
                         : *::CoreML::Specification::WeightParams::internal_default_instance();
}
inline ::CoreML::Specification::WeightParams* ActivationParametricSoftplus::mutable_alpha() {

  if (alpha_ == NULL) {
    alpha_ = new ::CoreML::Specification::WeightParams;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.ActivationParametricSoftplus.alpha)
  return alpha_;
}
inline ::CoreML::Specification::WeightParams* ActivationParametricSoftplus::release_alpha() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.ActivationParametricSoftplus.alpha)

  ::CoreML::Specification::WeightParams* temp = alpha_;
  alpha_ = NULL;
  return temp;
}
inline void ActivationParametricSoftplus::set_allocated_alpha(::CoreML::Specification::WeightParams* alpha) {
  delete alpha_;
  alpha_ = alpha;
  if (alpha) {

  } else {

  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.ActivationParametricSoftplus.alpha)
}

// .CoreML.Specification.WeightParams beta = 2;
inline bool ActivationParametricSoftplus::has_beta() const {
  return this != internal_default_instance() && beta_ != NULL;
}
inline void ActivationParametricSoftplus::clear_beta() {
  if (GetArenaNoVirtual() == NULL && beta_ != NULL) delete beta_;
  beta_ = NULL;
}
inline const ::CoreML::Specification::WeightParams& ActivationParametricSoftplus::beta() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.ActivationParametricSoftplus.beta)
  return beta_ != NULL ? *beta_
                         : *::CoreML::Specification::WeightParams::internal_default_instance();
}
inline ::CoreML::Specification::WeightParams* ActivationParametricSoftplus::mutable_beta() {

  if (beta_ == NULL) {
    beta_ = new ::CoreML::Specification::WeightParams;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.ActivationParametricSoftplus.beta)
  return beta_;
}
inline ::CoreML::Specification::WeightParams* ActivationParametricSoftplus::release_beta() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.ActivationParametricSoftplus.beta)

  ::CoreML::Specification::WeightParams* temp = beta_;
  beta_ = NULL;
  return temp;
}
inline void ActivationParametricSoftplus::set_allocated_beta(::CoreML::Specification::WeightParams* beta) {
  delete beta_;
  beta_ = beta;
  if (beta) {

  } else {

  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.ActivationParametricSoftplus.beta)
}

// -------------------------------------------------------------------

// ActivationParams

// .CoreML.Specification.ActivationLinear linear = 5;
inline bool ActivationParams::has_linear() const {
  return NonlinearityType_case() == kLinear;
}
inline void ActivationParams::set_has_linear() {
  _oneof_case_[0] = kLinear;
}
inline void ActivationParams::clear_linear() {
  if (has_linear()) {
    delete NonlinearityType_.linear_;
    clear_has_NonlinearityType();
  }
}
inline  const ::CoreML::Specification::ActivationLinear& ActivationParams::linear() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.ActivationParams.linear)
  return has_linear()
      ? *NonlinearityType_.linear_
      : ::CoreML::Specification::ActivationLinear::default_instance();
}
inline ::CoreML::Specification::ActivationLinear* ActivationParams::mutable_linear() {
  if (!has_linear()) {
    clear_NonlinearityType();
    set_has_linear();
    NonlinearityType_.linear_ = new ::CoreML::Specification::ActivationLinear;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.ActivationParams.linear)
  return NonlinearityType_.linear_;
}
inline ::CoreML::Specification::ActivationLinear* ActivationParams::release_linear() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.ActivationParams.linear)
  if (has_linear()) {
    clear_has_NonlinearityType();
    ::CoreML::Specification::ActivationLinear* temp = NonlinearityType_.linear_;
    NonlinearityType_.linear_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ActivationParams::set_allocated_linear(::CoreML::Specification::ActivationLinear* linear) {
  clear_NonlinearityType();
  if (linear) {
    set_has_linear();
    NonlinearityType_.linear_ = linear;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.ActivationParams.linear)
}

// .CoreML.Specification.ActivationReLU ReLU = 10;
inline bool ActivationParams::has_relu() const {
  return NonlinearityType_case() == kReLU;
}
inline void ActivationParams::set_has_relu() {
  _oneof_case_[0] = kReLU;
}
inline void ActivationParams::clear_relu() {
  if (has_relu()) {
    delete NonlinearityType_.relu_;
    clear_has_NonlinearityType();
  }
}
inline  const ::CoreML::Specification::ActivationReLU& ActivationParams::relu() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.ActivationParams.ReLU)
  return has_relu()
      ? *NonlinearityType_.relu_
      : ::CoreML::Specification::ActivationReLU::default_instance();
}
inline ::CoreML::Specification::ActivationReLU* ActivationParams::mutable_relu() {
  if (!has_relu()) {
    clear_NonlinearityType();
    set_has_relu();
    NonlinearityType_.relu_ = new ::CoreML::Specification::ActivationReLU;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.ActivationParams.ReLU)
  return NonlinearityType_.relu_;
}
inline ::CoreML::Specification::ActivationReLU* ActivationParams::release_relu() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.ActivationParams.ReLU)
  if (has_relu()) {
    clear_has_NonlinearityType();
    ::CoreML::Specification::ActivationReLU* temp = NonlinearityType_.relu_;
    NonlinearityType_.relu_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ActivationParams::set_allocated_relu(::CoreML::Specification::ActivationReLU* relu) {
  clear_NonlinearityType();
  if (relu) {
    set_has_relu();
    NonlinearityType_.relu_ = relu;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.ActivationParams.ReLU)
}

// .CoreML.Specification.ActivationLeakyReLU leakyReLU = 15;
inline bool ActivationParams::has_leakyrelu() const {
  return NonlinearityType_case() == kLeakyReLU;
}
inline void ActivationParams::set_has_leakyrelu() {
  _oneof_case_[0] = kLeakyReLU;
}
inline void ActivationParams::clear_leakyrelu() {
  if (has_leakyrelu()) {
    delete NonlinearityType_.leakyrelu_;
    clear_has_NonlinearityType();
  }
}
inline  const ::CoreML::Specification::ActivationLeakyReLU& ActivationParams::leakyrelu() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.ActivationParams.leakyReLU)
  return has_leakyrelu()
      ? *NonlinearityType_.leakyrelu_
      : ::CoreML::Specification::ActivationLeakyReLU::default_instance();
}
inline ::CoreML::Specification::ActivationLeakyReLU* ActivationParams::mutable_leakyrelu() {
  if (!has_leakyrelu()) {
    clear_NonlinearityType();
    set_has_leakyrelu();
    NonlinearityType_.leakyrelu_ = new ::CoreML::Specification::ActivationLeakyReLU;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.ActivationParams.leakyReLU)
  return NonlinearityType_.leakyrelu_;
}
inline ::CoreML::Specification::ActivationLeakyReLU* ActivationParams::release_leakyrelu() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.ActivationParams.leakyReLU)
  if (has_leakyrelu()) {
    clear_has_NonlinearityType();
    ::CoreML::Specification::ActivationLeakyReLU* temp = NonlinearityType_.leakyrelu_;
    NonlinearityType_.leakyrelu_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ActivationParams::set_allocated_leakyrelu(::CoreML::Specification::ActivationLeakyReLU* leakyrelu) {
  clear_NonlinearityType();
  if (leakyrelu) {
    set_has_leakyrelu();
    NonlinearityType_.leakyrelu_ = leakyrelu;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.ActivationParams.leakyReLU)
}

// .CoreML.Specification.ActivationThresholdedReLU thresholdedReLU = 20;
inline bool ActivationParams::has_thresholdedrelu() const {
  return NonlinearityType_case() == kThresholdedReLU;
}
inline void ActivationParams::set_has_thresholdedrelu() {
  _oneof_case_[0] = kThresholdedReLU;
}
inline void ActivationParams::clear_thresholdedrelu() {
  if (has_thresholdedrelu()) {
    delete NonlinearityType_.thresholdedrelu_;
    clear_has_NonlinearityType();
  }
}
inline  const ::CoreML::Specification::ActivationThresholdedReLU& ActivationParams::thresholdedrelu() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.ActivationParams.thresholdedReLU)
  return has_thresholdedrelu()
      ? *NonlinearityType_.thresholdedrelu_
      : ::CoreML::Specification::ActivationThresholdedReLU::default_instance();
}
inline ::CoreML::Specification::ActivationThresholdedReLU* ActivationParams::mutable_thresholdedrelu() {
  if (!has_thresholdedrelu()) {
    clear_NonlinearityType();
    set_has_thresholdedrelu();
    NonlinearityType_.thresholdedrelu_ = new ::CoreML::Specification::ActivationThresholdedReLU;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.ActivationParams.thresholdedReLU)
  return NonlinearityType_.thresholdedrelu_;
}
inline ::CoreML::Specification::ActivationThresholdedReLU* ActivationParams::release_thresholdedrelu() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.ActivationParams.thresholdedReLU)
  if (has_thresholdedrelu()) {
    clear_has_NonlinearityType();
    ::CoreML::Specification::ActivationThresholdedReLU* temp = NonlinearityType_.thresholdedrelu_;
    NonlinearityType_.thresholdedrelu_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ActivationParams::set_allocated_thresholdedrelu(::CoreML::Specification::ActivationThresholdedReLU* thresholdedrelu) {
  clear_NonlinearityType();
  if (thresholdedrelu) {
    set_has_thresholdedrelu();
    NonlinearityType_.thresholdedrelu_ = thresholdedrelu;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.ActivationParams.thresholdedReLU)
}

// .CoreML.Specification.ActivationPReLU PReLU = 25;
inline bool ActivationParams::has_prelu() const {
  return NonlinearityType_case() == kPReLU;
}
inline void ActivationParams::set_has_prelu() {
  _oneof_case_[0] = kPReLU;
}
inline void ActivationParams::clear_prelu() {
  if (has_prelu()) {
    delete NonlinearityType_.prelu_;
    clear_has_NonlinearityType();
  }
}
inline  const ::CoreML::Specification::ActivationPReLU& ActivationParams::prelu() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.ActivationParams.PReLU)
  return has_prelu()
      ? *NonlinearityType_.prelu_
      : ::CoreML::Specification::ActivationPReLU::default_instance();
}
inline ::CoreML::Specification::ActivationPReLU* ActivationParams::mutable_prelu() {
  if (!has_prelu()) {
    clear_NonlinearityType();
    set_has_prelu();
    NonlinearityType_.prelu_ = new ::CoreML::Specification::ActivationPReLU;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.ActivationParams.PReLU)
  return NonlinearityType_.prelu_;
}
inline ::CoreML::Specification::ActivationPReLU* ActivationParams::release_prelu() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.ActivationParams.PReLU)
  if (has_prelu()) {
    clear_has_NonlinearityType();
    ::CoreML::Specification::ActivationPReLU* temp = NonlinearityType_.prelu_;
    NonlinearityType_.prelu_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ActivationParams::set_allocated_prelu(::CoreML::Specification::ActivationPReLU* prelu) {
  clear_NonlinearityType();
  if (prelu) {
    set_has_prelu();
    NonlinearityType_.prelu_ = prelu;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.ActivationParams.PReLU)
}

// .CoreML.Specification.ActivationTanh tanh = 30;
inline bool ActivationParams::has_tanh() const {
  return NonlinearityType_case() == kTanh;
}
inline void ActivationParams::set_has_tanh() {
  _oneof_case_[0] = kTanh;
}
inline void ActivationParams::clear_tanh() {
  if (has_tanh()) {
    delete NonlinearityType_.tanh_;
    clear_has_NonlinearityType();
  }
}
inline  const ::CoreML::Specification::ActivationTanh& ActivationParams::tanh() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.ActivationParams.tanh)
  return has_tanh()
      ? *NonlinearityType_.tanh_
      : ::CoreML::Specification::ActivationTanh::default_instance();
}
inline ::CoreML::Specification::ActivationTanh* ActivationParams::mutable_tanh() {
  if (!has_tanh()) {
    clear_NonlinearityType();
    set_has_tanh();
    NonlinearityType_.tanh_ = new ::CoreML::Specification::ActivationTanh;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.ActivationParams.tanh)
  return NonlinearityType_.tanh_;
}
inline ::CoreML::Specification::ActivationTanh* ActivationParams::release_tanh() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.ActivationParams.tanh)
  if (has_tanh()) {
    clear_has_NonlinearityType();
    ::CoreML::Specification::ActivationTanh* temp = NonlinearityType_.tanh_;
    NonlinearityType_.tanh_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ActivationParams::set_allocated_tanh(::CoreML::Specification::ActivationTanh* tanh) {
  clear_NonlinearityType();
  if (tanh) {
    set_has_tanh();
    NonlinearityType_.tanh_ = tanh;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.ActivationParams.tanh)
}

// .CoreML.Specification.ActivationScaledTanh scaledTanh = 31;
inline bool ActivationParams::has_scaledtanh() const {
  return NonlinearityType_case() == kScaledTanh;
}
inline void ActivationParams::set_has_scaledtanh() {
  _oneof_case_[0] = kScaledTanh;
}
inline void ActivationParams::clear_scaledtanh() {
  if (has_scaledtanh()) {
    delete NonlinearityType_.scaledtanh_;
    clear_has_NonlinearityType();
  }
}
inline  const ::CoreML::Specification::ActivationScaledTanh& ActivationParams::scaledtanh() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.ActivationParams.scaledTanh)
  return has_scaledtanh()
      ? *NonlinearityType_.scaledtanh_
      : ::CoreML::Specification::ActivationScaledTanh::default_instance();
}
inline ::CoreML::Specification::ActivationScaledTanh* ActivationParams::mutable_scaledtanh() {
  if (!has_scaledtanh()) {
    clear_NonlinearityType();
    set_has_scaledtanh();
    NonlinearityType_.scaledtanh_ = new ::CoreML::Specification::ActivationScaledTanh;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.ActivationParams.scaledTanh)
  return NonlinearityType_.scaledtanh_;
}
inline ::CoreML::Specification::ActivationScaledTanh* ActivationParams::release_scaledtanh() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.ActivationParams.scaledTanh)
  if (has_scaledtanh()) {
    clear_has_NonlinearityType();
    ::CoreML::Specification::ActivationScaledTanh* temp = NonlinearityType_.scaledtanh_;
    NonlinearityType_.scaledtanh_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ActivationParams::set_allocated_scaledtanh(::CoreML::Specification::ActivationScaledTanh* scaledtanh) {
  clear_NonlinearityType();
  if (scaledtanh) {
    set_has_scaledtanh();
    NonlinearityType_.scaledtanh_ = scaledtanh;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.ActivationParams.scaledTanh)
}

// .CoreML.Specification.ActivationSigmoid sigmoid = 40;
inline bool ActivationParams::has_sigmoid() const {
  return NonlinearityType_case() == kSigmoid;
}
inline void ActivationParams::set_has_sigmoid() {
  _oneof_case_[0] = kSigmoid;
}
inline void ActivationParams::clear_sigmoid() {
  if (has_sigmoid()) {
    delete NonlinearityType_.sigmoid_;
    clear_has_NonlinearityType();
  }
}
inline  const ::CoreML::Specification::ActivationSigmoid& ActivationParams::sigmoid() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.ActivationParams.sigmoid)
  return has_sigmoid()
      ? *NonlinearityType_.sigmoid_
      : ::CoreML::Specification::ActivationSigmoid::default_instance();
}
inline ::CoreML::Specification::ActivationSigmoid* ActivationParams::mutable_sigmoid() {
  if (!has_sigmoid()) {
    clear_NonlinearityType();
    set_has_sigmoid();
    NonlinearityType_.sigmoid_ = new ::CoreML::Specification::ActivationSigmoid;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.ActivationParams.sigmoid)
  return NonlinearityType_.sigmoid_;
}
inline ::CoreML::Specification::ActivationSigmoid* ActivationParams::release_sigmoid() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.ActivationParams.sigmoid)
  if (has_sigmoid()) {
    clear_has_NonlinearityType();
    ::CoreML::Specification::ActivationSigmoid* temp = NonlinearityType_.sigmoid_;
    NonlinearityType_.sigmoid_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ActivationParams::set_allocated_sigmoid(::CoreML::Specification::ActivationSigmoid* sigmoid) {
  clear_NonlinearityType();
  if (sigmoid) {
    set_has_sigmoid();
    NonlinearityType_.sigmoid_ = sigmoid;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.ActivationParams.sigmoid)
}

// .CoreML.Specification.ActivationSigmoidHard sigmoidHard = 41;
inline bool ActivationParams::has_sigmoidhard() const {
  return NonlinearityType_case() == kSigmoidHard;
}
inline void ActivationParams::set_has_sigmoidhard() {
  _oneof_case_[0] = kSigmoidHard;
}
inline void ActivationParams::clear_sigmoidhard() {
  if (has_sigmoidhard()) {
    delete NonlinearityType_.sigmoidhard_;
    clear_has_NonlinearityType();
  }
}
inline  const ::CoreML::Specification::ActivationSigmoidHard& ActivationParams::sigmoidhard() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.ActivationParams.sigmoidHard)
  return has_sigmoidhard()
      ? *NonlinearityType_.sigmoidhard_
      : ::CoreML::Specification::ActivationSigmoidHard::default_instance();
}
inline ::CoreML::Specification::ActivationSigmoidHard* ActivationParams::mutable_sigmoidhard() {
  if (!has_sigmoidhard()) {
    clear_NonlinearityType();
    set_has_sigmoidhard();
    NonlinearityType_.sigmoidhard_ = new ::CoreML::Specification::ActivationSigmoidHard;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.ActivationParams.sigmoidHard)
  return NonlinearityType_.sigmoidhard_;
}
inline ::CoreML::Specification::ActivationSigmoidHard* ActivationParams::release_sigmoidhard() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.ActivationParams.sigmoidHard)
  if (has_sigmoidhard()) {
    clear_has_NonlinearityType();
    ::CoreML::Specification::ActivationSigmoidHard* temp = NonlinearityType_.sigmoidhard_;
    NonlinearityType_.sigmoidhard_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ActivationParams::set_allocated_sigmoidhard(::CoreML::Specification::ActivationSigmoidHard* sigmoidhard) {
  clear_NonlinearityType();
  if (sigmoidhard) {
    set_has_sigmoidhard();
    NonlinearityType_.sigmoidhard_ = sigmoidhard;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.ActivationParams.sigmoidHard)
}

// .CoreML.Specification.ActivationELU ELU = 50;
inline bool ActivationParams::has_elu() const {
  return NonlinearityType_case() == kELU;
}
inline void ActivationParams::set_has_elu() {
  _oneof_case_[0] = kELU;
}
inline void ActivationParams::clear_elu() {
  if (has_elu()) {
    delete NonlinearityType_.elu_;
    clear_has_NonlinearityType();
  }
}
inline  const ::CoreML::Specification::ActivationELU& ActivationParams::elu() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.ActivationParams.ELU)
  return has_elu()
      ? *NonlinearityType_.elu_
      : ::CoreML::Specification::ActivationELU::default_instance();
}
inline ::CoreML::Specification::ActivationELU* ActivationParams::mutable_elu() {
  if (!has_elu()) {
    clear_NonlinearityType();
    set_has_elu();
    NonlinearityType_.elu_ = new ::CoreML::Specification::ActivationELU;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.ActivationParams.ELU)
  return NonlinearityType_.elu_;
}
inline ::CoreML::Specification::ActivationELU* ActivationParams::release_elu() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.ActivationParams.ELU)
  if (has_elu()) {
    clear_has_NonlinearityType();
    ::CoreML::Specification::ActivationELU* temp = NonlinearityType_.elu_;
    NonlinearityType_.elu_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ActivationParams::set_allocated_elu(::CoreML::Specification::ActivationELU* elu) {
  clear_NonlinearityType();
  if (elu) {
    set_has_elu();
    NonlinearityType_.elu_ = elu;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.ActivationParams.ELU)
}

// .CoreML.Specification.ActivationSoftsign softsign = 60;
inline bool ActivationParams::has_softsign() const {
  return NonlinearityType_case() == kSoftsign;
}
inline void ActivationParams::set_has_softsign() {
  _oneof_case_[0] = kSoftsign;
}
inline void ActivationParams::clear_softsign() {
  if (has_softsign()) {
    delete NonlinearityType_.softsign_;
    clear_has_NonlinearityType();
  }
}
inline  const ::CoreML::Specification::ActivationSoftsign& ActivationParams::softsign() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.ActivationParams.softsign)
  return has_softsign()
      ? *NonlinearityType_.softsign_
      : ::CoreML::Specification::ActivationSoftsign::default_instance();
}
inline ::CoreML::Specification::ActivationSoftsign* ActivationParams::mutable_softsign() {
  if (!has_softsign()) {
    clear_NonlinearityType();
    set_has_softsign();
    NonlinearityType_.softsign_ = new ::CoreML::Specification::ActivationSoftsign;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.ActivationParams.softsign)
  return NonlinearityType_.softsign_;
}
inline ::CoreML::Specification::ActivationSoftsign* ActivationParams::release_softsign() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.ActivationParams.softsign)
  if (has_softsign()) {
    clear_has_NonlinearityType();
    ::CoreML::Specification::ActivationSoftsign* temp = NonlinearityType_.softsign_;
    NonlinearityType_.softsign_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ActivationParams::set_allocated_softsign(::CoreML::Specification::ActivationSoftsign* softsign) {
  clear_NonlinearityType();
  if (softsign) {
    set_has_softsign();
    NonlinearityType_.softsign_ = softsign;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.ActivationParams.softsign)
}

// .CoreML.Specification.ActivationSoftplus softplus = 70;
inline bool ActivationParams::has_softplus() const {
  return NonlinearityType_case() == kSoftplus;
}
inline void ActivationParams::set_has_softplus() {
  _oneof_case_[0] = kSoftplus;
}
inline void ActivationParams::clear_softplus() {
  if (has_softplus()) {
    delete NonlinearityType_.softplus_;
    clear_has_NonlinearityType();
  }
}
inline  const ::CoreML::Specification::ActivationSoftplus& ActivationParams::softplus() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.ActivationParams.softplus)
  return has_softplus()
      ? *NonlinearityType_.softplus_
      : ::CoreML::Specification::ActivationSoftplus::default_instance();
}
inline ::CoreML::Specification::ActivationSoftplus* ActivationParams::mutable_softplus() {
  if (!has_softplus()) {
    clear_NonlinearityType();
    set_has_softplus();
    NonlinearityType_.softplus_ = new ::CoreML::Specification::ActivationSoftplus;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.ActivationParams.softplus)
  return NonlinearityType_.softplus_;
}
inline ::CoreML::Specification::ActivationSoftplus* ActivationParams::release_softplus() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.ActivationParams.softplus)
  if (has_softplus()) {
    clear_has_NonlinearityType();
    ::CoreML::Specification::ActivationSoftplus* temp = NonlinearityType_.softplus_;
    NonlinearityType_.softplus_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ActivationParams::set_allocated_softplus(::CoreML::Specification::ActivationSoftplus* softplus) {
  clear_NonlinearityType();
  if (softplus) {
    set_has_softplus();
    NonlinearityType_.softplus_ = softplus;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.ActivationParams.softplus)
}

// .CoreML.Specification.ActivationParametricSoftplus parametricSoftplus = 71;
inline bool ActivationParams::has_parametricsoftplus() const {
  return NonlinearityType_case() == kParametricSoftplus;
}
inline void ActivationParams::set_has_parametricsoftplus() {
  _oneof_case_[0] = kParametricSoftplus;
}
inline void ActivationParams::clear_parametricsoftplus() {
  if (has_parametricsoftplus()) {
    delete NonlinearityType_.parametricsoftplus_;
    clear_has_NonlinearityType();
  }
}
inline  const ::CoreML::Specification::ActivationParametricSoftplus& ActivationParams::parametricsoftplus() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.ActivationParams.parametricSoftplus)
  return has_parametricsoftplus()
      ? *NonlinearityType_.parametricsoftplus_
      : ::CoreML::Specification::ActivationParametricSoftplus::default_instance();
}
inline ::CoreML::Specification::ActivationParametricSoftplus* ActivationParams::mutable_parametricsoftplus() {
  if (!has_parametricsoftplus()) {
    clear_NonlinearityType();
    set_has_parametricsoftplus();
    NonlinearityType_.parametricsoftplus_ = new ::CoreML::Specification::ActivationParametricSoftplus;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.ActivationParams.parametricSoftplus)
  return NonlinearityType_.parametricsoftplus_;
}
inline ::CoreML::Specification::ActivationParametricSoftplus* ActivationParams::release_parametricsoftplus() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.ActivationParams.parametricSoftplus)
  if (has_parametricsoftplus()) {
    clear_has_NonlinearityType();
    ::CoreML::Specification::ActivationParametricSoftplus* temp = NonlinearityType_.parametricsoftplus_;
    NonlinearityType_.parametricsoftplus_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ActivationParams::set_allocated_parametricsoftplus(::CoreML::Specification::ActivationParametricSoftplus* parametricsoftplus) {
  clear_NonlinearityType();
  if (parametricsoftplus) {
    set_has_parametricsoftplus();
    NonlinearityType_.parametricsoftplus_ = parametricsoftplus;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.ActivationParams.parametricSoftplus)
}

inline bool ActivationParams::has_NonlinearityType() const {
  return NonlinearityType_case() != NONLINEARITYTYPE_NOT_SET;
}
inline void ActivationParams::clear_has_NonlinearityType() {
  _oneof_case_[0] = NONLINEARITYTYPE_NOT_SET;
}
inline ActivationParams::NonlinearityTypeCase ActivationParams::NonlinearityType_case() const {
  return ActivationParams::NonlinearityTypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// NeuralNetworkLayer

// string name = 1;
inline void NeuralNetworkLayer::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& NeuralNetworkLayer::name() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.NeuralNetworkLayer.name)
  return name_.GetNoArena();
}
inline void NeuralNetworkLayer::set_name(const ::std::string& value) {

  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:CoreML.Specification.NeuralNetworkLayer.name)
}
#if LANG_CXX11
inline void NeuralNetworkLayer::set_name(::std::string&& value) {

  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:CoreML.Specification.NeuralNetworkLayer.name)
}
#endif
inline void NeuralNetworkLayer::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);

  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:CoreML.Specification.NeuralNetworkLayer.name)
}
inline void NeuralNetworkLayer::set_name(const char* value, size_t size) {

  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:CoreML.Specification.NeuralNetworkLayer.name)
}
inline ::std::string* NeuralNetworkLayer::mutable_name() {

  // @@protoc_insertion_point(field_mutable:CoreML.Specification.NeuralNetworkLayer.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NeuralNetworkLayer::release_name() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.NeuralNetworkLayer.name)

  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NeuralNetworkLayer::set_allocated_name(::std::string* name) {
  if (name != NULL) {

  } else {

  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.name)
}

// repeated string input = 2;
inline int NeuralNetworkLayer::input_size() const {
  return input_.size();
}
inline void NeuralNetworkLayer::clear_input() {
  input_.Clear();
}
inline const ::std::string& NeuralNetworkLayer::input(int index) const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.NeuralNetworkLayer.input)
  return input_.Get(index);
}
inline ::std::string* NeuralNetworkLayer::mutable_input(int index) {
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.NeuralNetworkLayer.input)
  return input_.Mutable(index);
}
inline void NeuralNetworkLayer::set_input(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:CoreML.Specification.NeuralNetworkLayer.input)
  input_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void NeuralNetworkLayer::set_input(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:CoreML.Specification.NeuralNetworkLayer.input)
  input_.Mutable(index)->assign(std::move(value));
}
#endif
inline void NeuralNetworkLayer::set_input(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  input_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:CoreML.Specification.NeuralNetworkLayer.input)
}
inline void NeuralNetworkLayer::set_input(int index, const char* value, size_t size) {
  input_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:CoreML.Specification.NeuralNetworkLayer.input)
}
inline ::std::string* NeuralNetworkLayer::add_input() {
  // @@protoc_insertion_point(field_add_mutable:CoreML.Specification.NeuralNetworkLayer.input)
  return input_.Add();
}
inline void NeuralNetworkLayer::add_input(const ::std::string& value) {
  input_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:CoreML.Specification.NeuralNetworkLayer.input)
}
#if LANG_CXX11
inline void NeuralNetworkLayer::add_input(::std::string&& value) {
  input_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:CoreML.Specification.NeuralNetworkLayer.input)
}
#endif
inline void NeuralNetworkLayer::add_input(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  input_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:CoreML.Specification.NeuralNetworkLayer.input)
}
inline void NeuralNetworkLayer::add_input(const char* value, size_t size) {
  input_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:CoreML.Specification.NeuralNetworkLayer.input)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
NeuralNetworkLayer::input() const {
  // @@protoc_insertion_point(field_list:CoreML.Specification.NeuralNetworkLayer.input)
  return input_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
NeuralNetworkLayer::mutable_input() {
  // @@protoc_insertion_point(field_mutable_list:CoreML.Specification.NeuralNetworkLayer.input)
  return &input_;
}

// repeated string output = 3;
inline int NeuralNetworkLayer::output_size() const {
  return output_.size();
}
inline void NeuralNetworkLayer::clear_output() {
  output_.Clear();
}
inline const ::std::string& NeuralNetworkLayer::output(int index) const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.NeuralNetworkLayer.output)
  return output_.Get(index);
}
inline ::std::string* NeuralNetworkLayer::mutable_output(int index) {
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.NeuralNetworkLayer.output)
  return output_.Mutable(index);
}
inline void NeuralNetworkLayer::set_output(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:CoreML.Specification.NeuralNetworkLayer.output)
  output_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void NeuralNetworkLayer::set_output(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:CoreML.Specification.NeuralNetworkLayer.output)
  output_.Mutable(index)->assign(std::move(value));
}
#endif
inline void NeuralNetworkLayer::set_output(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  output_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:CoreML.Specification.NeuralNetworkLayer.output)
}
inline void NeuralNetworkLayer::set_output(int index, const char* value, size_t size) {
  output_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:CoreML.Specification.NeuralNetworkLayer.output)
}
inline ::std::string* NeuralNetworkLayer::add_output() {
  // @@protoc_insertion_point(field_add_mutable:CoreML.Specification.NeuralNetworkLayer.output)
  return output_.Add();
}
inline void NeuralNetworkLayer::add_output(const ::std::string& value) {
  output_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:CoreML.Specification.NeuralNetworkLayer.output)
}
#if LANG_CXX11
inline void NeuralNetworkLayer::add_output(::std::string&& value) {
  output_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:CoreML.Specification.NeuralNetworkLayer.output)
}
#endif
inline void NeuralNetworkLayer::add_output(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  output_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:CoreML.Specification.NeuralNetworkLayer.output)
}
inline void NeuralNetworkLayer::add_output(const char* value, size_t size) {
  output_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:CoreML.Specification.NeuralNetworkLayer.output)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
NeuralNetworkLayer::output() const {
  // @@protoc_insertion_point(field_list:CoreML.Specification.NeuralNetworkLayer.output)
  return output_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
NeuralNetworkLayer::mutable_output() {
  // @@protoc_insertion_point(field_mutable_list:CoreML.Specification.NeuralNetworkLayer.output)
  return &output_;
}

// .CoreML.Specification.ConvolutionLayerParams convolution = 100;
inline bool NeuralNetworkLayer::has_convolution() const {
  return layer_case() == kConvolution;
}
inline void NeuralNetworkLayer::set_has_convolution() {
  _oneof_case_[0] = kConvolution;
}
inline void NeuralNetworkLayer::clear_convolution() {
  if (has_convolution()) {
    delete layer_.convolution_;
    clear_has_layer();
  }
}
inline  const ::CoreML::Specification::ConvolutionLayerParams& NeuralNetworkLayer::convolution() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.NeuralNetworkLayer.convolution)
  return has_convolution()
      ? *layer_.convolution_
      : ::CoreML::Specification::ConvolutionLayerParams::default_instance();
}
inline ::CoreML::Specification::ConvolutionLayerParams* NeuralNetworkLayer::mutable_convolution() {
  if (!has_convolution()) {
    clear_layer();
    set_has_convolution();
    layer_.convolution_ = new ::CoreML::Specification::ConvolutionLayerParams;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.NeuralNetworkLayer.convolution)
  return layer_.convolution_;
}
inline ::CoreML::Specification::ConvolutionLayerParams* NeuralNetworkLayer::release_convolution() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.NeuralNetworkLayer.convolution)
  if (has_convolution()) {
    clear_has_layer();
    ::CoreML::Specification::ConvolutionLayerParams* temp = layer_.convolution_;
    layer_.convolution_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void NeuralNetworkLayer::set_allocated_convolution(::CoreML::Specification::ConvolutionLayerParams* convolution) {
  clear_layer();
  if (convolution) {
    set_has_convolution();
    layer_.convolution_ = convolution;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.convolution)
}

// .CoreML.Specification.PoolingLayerParams pooling = 120;
inline bool NeuralNetworkLayer::has_pooling() const {
  return layer_case() == kPooling;
}
inline void NeuralNetworkLayer::set_has_pooling() {
  _oneof_case_[0] = kPooling;
}
inline void NeuralNetworkLayer::clear_pooling() {
  if (has_pooling()) {
    delete layer_.pooling_;
    clear_has_layer();
  }
}
inline  const ::CoreML::Specification::PoolingLayerParams& NeuralNetworkLayer::pooling() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.NeuralNetworkLayer.pooling)
  return has_pooling()
      ? *layer_.pooling_
      : ::CoreML::Specification::PoolingLayerParams::default_instance();
}
inline ::CoreML::Specification::PoolingLayerParams* NeuralNetworkLayer::mutable_pooling() {
  if (!has_pooling()) {
    clear_layer();
    set_has_pooling();
    layer_.pooling_ = new ::CoreML::Specification::PoolingLayerParams;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.NeuralNetworkLayer.pooling)
  return layer_.pooling_;
}
inline ::CoreML::Specification::PoolingLayerParams* NeuralNetworkLayer::release_pooling() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.NeuralNetworkLayer.pooling)
  if (has_pooling()) {
    clear_has_layer();
    ::CoreML::Specification::PoolingLayerParams* temp = layer_.pooling_;
    layer_.pooling_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void NeuralNetworkLayer::set_allocated_pooling(::CoreML::Specification::PoolingLayerParams* pooling) {
  clear_layer();
  if (pooling) {
    set_has_pooling();
    layer_.pooling_ = pooling;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.pooling)
}

// .CoreML.Specification.ActivationParams activation = 130;
inline bool NeuralNetworkLayer::has_activation() const {
  return layer_case() == kActivation;
}
inline void NeuralNetworkLayer::set_has_activation() {
  _oneof_case_[0] = kActivation;
}
inline void NeuralNetworkLayer::clear_activation() {
  if (has_activation()) {
    delete layer_.activation_;
    clear_has_layer();
  }
}
inline  const ::CoreML::Specification::ActivationParams& NeuralNetworkLayer::activation() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.NeuralNetworkLayer.activation)
  return has_activation()
      ? *layer_.activation_
      : ::CoreML::Specification::ActivationParams::default_instance();
}
inline ::CoreML::Specification::ActivationParams* NeuralNetworkLayer::mutable_activation() {
  if (!has_activation()) {
    clear_layer();
    set_has_activation();
    layer_.activation_ = new ::CoreML::Specification::ActivationParams;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.NeuralNetworkLayer.activation)
  return layer_.activation_;
}
inline ::CoreML::Specification::ActivationParams* NeuralNetworkLayer::release_activation() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.NeuralNetworkLayer.activation)
  if (has_activation()) {
    clear_has_layer();
    ::CoreML::Specification::ActivationParams* temp = layer_.activation_;
    layer_.activation_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void NeuralNetworkLayer::set_allocated_activation(::CoreML::Specification::ActivationParams* activation) {
  clear_layer();
  if (activation) {
    set_has_activation();
    layer_.activation_ = activation;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.activation)
}

// .CoreML.Specification.InnerProductLayerParams innerProduct = 140;
inline bool NeuralNetworkLayer::has_innerproduct() const {
  return layer_case() == kInnerProduct;
}
inline void NeuralNetworkLayer::set_has_innerproduct() {
  _oneof_case_[0] = kInnerProduct;
}
inline void NeuralNetworkLayer::clear_innerproduct() {
  if (has_innerproduct()) {
    delete layer_.innerproduct_;
    clear_has_layer();
  }
}
inline  const ::CoreML::Specification::InnerProductLayerParams& NeuralNetworkLayer::innerproduct() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.NeuralNetworkLayer.innerProduct)
  return has_innerproduct()
      ? *layer_.innerproduct_
      : ::CoreML::Specification::InnerProductLayerParams::default_instance();
}
inline ::CoreML::Specification::InnerProductLayerParams* NeuralNetworkLayer::mutable_innerproduct() {
  if (!has_innerproduct()) {
    clear_layer();
    set_has_innerproduct();
    layer_.innerproduct_ = new ::CoreML::Specification::InnerProductLayerParams;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.NeuralNetworkLayer.innerProduct)
  return layer_.innerproduct_;
}
inline ::CoreML::Specification::InnerProductLayerParams* NeuralNetworkLayer::release_innerproduct() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.NeuralNetworkLayer.innerProduct)
  if (has_innerproduct()) {
    clear_has_layer();
    ::CoreML::Specification::InnerProductLayerParams* temp = layer_.innerproduct_;
    layer_.innerproduct_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void NeuralNetworkLayer::set_allocated_innerproduct(::CoreML::Specification::InnerProductLayerParams* innerproduct) {
  clear_layer();
  if (innerproduct) {
    set_has_innerproduct();
    layer_.innerproduct_ = innerproduct;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.innerProduct)
}

// .CoreML.Specification.EmbeddingLayerParams embedding = 150;
inline bool NeuralNetworkLayer::has_embedding() const {
  return layer_case() == kEmbedding;
}
inline void NeuralNetworkLayer::set_has_embedding() {
  _oneof_case_[0] = kEmbedding;
}
inline void NeuralNetworkLayer::clear_embedding() {
  if (has_embedding()) {
    delete layer_.embedding_;
    clear_has_layer();
  }
}
inline  const ::CoreML::Specification::EmbeddingLayerParams& NeuralNetworkLayer::embedding() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.NeuralNetworkLayer.embedding)
  return has_embedding()
      ? *layer_.embedding_
      : ::CoreML::Specification::EmbeddingLayerParams::default_instance();
}
inline ::CoreML::Specification::EmbeddingLayerParams* NeuralNetworkLayer::mutable_embedding() {
  if (!has_embedding()) {
    clear_layer();
    set_has_embedding();
    layer_.embedding_ = new ::CoreML::Specification::EmbeddingLayerParams;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.NeuralNetworkLayer.embedding)
  return layer_.embedding_;
}
inline ::CoreML::Specification::EmbeddingLayerParams* NeuralNetworkLayer::release_embedding() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.NeuralNetworkLayer.embedding)
  if (has_embedding()) {
    clear_has_layer();
    ::CoreML::Specification::EmbeddingLayerParams* temp = layer_.embedding_;
    layer_.embedding_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void NeuralNetworkLayer::set_allocated_embedding(::CoreML::Specification::EmbeddingLayerParams* embedding) {
  clear_layer();
  if (embedding) {
    set_has_embedding();
    layer_.embedding_ = embedding;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.embedding)
}

// .CoreML.Specification.BatchnormLayerParams batchnorm = 160;
inline bool NeuralNetworkLayer::has_batchnorm() const {
  return layer_case() == kBatchnorm;
}
inline void NeuralNetworkLayer::set_has_batchnorm() {
  _oneof_case_[0] = kBatchnorm;
}
inline void NeuralNetworkLayer::clear_batchnorm() {
  if (has_batchnorm()) {
    delete layer_.batchnorm_;
    clear_has_layer();
  }
}
inline  const ::CoreML::Specification::BatchnormLayerParams& NeuralNetworkLayer::batchnorm() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.NeuralNetworkLayer.batchnorm)
  return has_batchnorm()
      ? *layer_.batchnorm_
      : ::CoreML::Specification::BatchnormLayerParams::default_instance();
}
inline ::CoreML::Specification::BatchnormLayerParams* NeuralNetworkLayer::mutable_batchnorm() {
  if (!has_batchnorm()) {
    clear_layer();
    set_has_batchnorm();
    layer_.batchnorm_ = new ::CoreML::Specification::BatchnormLayerParams;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.NeuralNetworkLayer.batchnorm)
  return layer_.batchnorm_;
}
inline ::CoreML::Specification::BatchnormLayerParams* NeuralNetworkLayer::release_batchnorm() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.NeuralNetworkLayer.batchnorm)
  if (has_batchnorm()) {
    clear_has_layer();
    ::CoreML::Specification::BatchnormLayerParams* temp = layer_.batchnorm_;
    layer_.batchnorm_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void NeuralNetworkLayer::set_allocated_batchnorm(::CoreML::Specification::BatchnormLayerParams* batchnorm) {
  clear_layer();
  if (batchnorm) {
    set_has_batchnorm();
    layer_.batchnorm_ = batchnorm;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.batchnorm)
}

// .CoreML.Specification.MeanVarianceNormalizeLayerParams mvn = 165;
inline bool NeuralNetworkLayer::has_mvn() const {
  return layer_case() == kMvn;
}
inline void NeuralNetworkLayer::set_has_mvn() {
  _oneof_case_[0] = kMvn;
}
inline void NeuralNetworkLayer::clear_mvn() {
  if (has_mvn()) {
    delete layer_.mvn_;
    clear_has_layer();
  }
}
inline  const ::CoreML::Specification::MeanVarianceNormalizeLayerParams& NeuralNetworkLayer::mvn() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.NeuralNetworkLayer.mvn)
  return has_mvn()
      ? *layer_.mvn_
      : ::CoreML::Specification::MeanVarianceNormalizeLayerParams::default_instance();
}
inline ::CoreML::Specification::MeanVarianceNormalizeLayerParams* NeuralNetworkLayer::mutable_mvn() {
  if (!has_mvn()) {
    clear_layer();
    set_has_mvn();
    layer_.mvn_ = new ::CoreML::Specification::MeanVarianceNormalizeLayerParams;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.NeuralNetworkLayer.mvn)
  return layer_.mvn_;
}
inline ::CoreML::Specification::MeanVarianceNormalizeLayerParams* NeuralNetworkLayer::release_mvn() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.NeuralNetworkLayer.mvn)
  if (has_mvn()) {
    clear_has_layer();
    ::CoreML::Specification::MeanVarianceNormalizeLayerParams* temp = layer_.mvn_;
    layer_.mvn_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void NeuralNetworkLayer::set_allocated_mvn(::CoreML::Specification::MeanVarianceNormalizeLayerParams* mvn) {
  clear_layer();
  if (mvn) {
    set_has_mvn();
    layer_.mvn_ = mvn;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.mvn)
}

// .CoreML.Specification.L2NormalizeLayerParams l2normalize = 170;
inline bool NeuralNetworkLayer::has_l2normalize() const {
  return layer_case() == kL2Normalize;
}
inline void NeuralNetworkLayer::set_has_l2normalize() {
  _oneof_case_[0] = kL2Normalize;
}
inline void NeuralNetworkLayer::clear_l2normalize() {
  if (has_l2normalize()) {
    delete layer_.l2normalize_;
    clear_has_layer();
  }
}
inline  const ::CoreML::Specification::L2NormalizeLayerParams& NeuralNetworkLayer::l2normalize() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.NeuralNetworkLayer.l2normalize)
  return has_l2normalize()
      ? *layer_.l2normalize_
      : ::CoreML::Specification::L2NormalizeLayerParams::default_instance();
}
inline ::CoreML::Specification::L2NormalizeLayerParams* NeuralNetworkLayer::mutable_l2normalize() {
  if (!has_l2normalize()) {
    clear_layer();
    set_has_l2normalize();
    layer_.l2normalize_ = new ::CoreML::Specification::L2NormalizeLayerParams;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.NeuralNetworkLayer.l2normalize)
  return layer_.l2normalize_;
}
inline ::CoreML::Specification::L2NormalizeLayerParams* NeuralNetworkLayer::release_l2normalize() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.NeuralNetworkLayer.l2normalize)
  if (has_l2normalize()) {
    clear_has_layer();
    ::CoreML::Specification::L2NormalizeLayerParams* temp = layer_.l2normalize_;
    layer_.l2normalize_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void NeuralNetworkLayer::set_allocated_l2normalize(::CoreML::Specification::L2NormalizeLayerParams* l2normalize) {
  clear_layer();
  if (l2normalize) {
    set_has_l2normalize();
    layer_.l2normalize_ = l2normalize;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.l2normalize)
}

// .CoreML.Specification.SoftmaxLayerParams softmax = 175;
inline bool NeuralNetworkLayer::has_softmax() const {
  return layer_case() == kSoftmax;
}
inline void NeuralNetworkLayer::set_has_softmax() {
  _oneof_case_[0] = kSoftmax;
}
inline void NeuralNetworkLayer::clear_softmax() {
  if (has_softmax()) {
    delete layer_.softmax_;
    clear_has_layer();
  }
}
inline  const ::CoreML::Specification::SoftmaxLayerParams& NeuralNetworkLayer::softmax() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.NeuralNetworkLayer.softmax)
  return has_softmax()
      ? *layer_.softmax_
      : ::CoreML::Specification::SoftmaxLayerParams::default_instance();
}
inline ::CoreML::Specification::SoftmaxLayerParams* NeuralNetworkLayer::mutable_softmax() {
  if (!has_softmax()) {
    clear_layer();
    set_has_softmax();
    layer_.softmax_ = new ::CoreML::Specification::SoftmaxLayerParams;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.NeuralNetworkLayer.softmax)
  return layer_.softmax_;
}
inline ::CoreML::Specification::SoftmaxLayerParams* NeuralNetworkLayer::release_softmax() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.NeuralNetworkLayer.softmax)
  if (has_softmax()) {
    clear_has_layer();
    ::CoreML::Specification::SoftmaxLayerParams* temp = layer_.softmax_;
    layer_.softmax_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void NeuralNetworkLayer::set_allocated_softmax(::CoreML::Specification::SoftmaxLayerParams* softmax) {
  clear_layer();
  if (softmax) {
    set_has_softmax();
    layer_.softmax_ = softmax;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.softmax)
}

// .CoreML.Specification.LRNLayerParams lrn = 180;
inline bool NeuralNetworkLayer::has_lrn() const {
  return layer_case() == kLrn;
}
inline void NeuralNetworkLayer::set_has_lrn() {
  _oneof_case_[0] = kLrn;
}
inline void NeuralNetworkLayer::clear_lrn() {
  if (has_lrn()) {
    delete layer_.lrn_;
    clear_has_layer();
  }
}
inline  const ::CoreML::Specification::LRNLayerParams& NeuralNetworkLayer::lrn() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.NeuralNetworkLayer.lrn)
  return has_lrn()
      ? *layer_.lrn_
      : ::CoreML::Specification::LRNLayerParams::default_instance();
}
inline ::CoreML::Specification::LRNLayerParams* NeuralNetworkLayer::mutable_lrn() {
  if (!has_lrn()) {
    clear_layer();
    set_has_lrn();
    layer_.lrn_ = new ::CoreML::Specification::LRNLayerParams;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.NeuralNetworkLayer.lrn)
  return layer_.lrn_;
}
inline ::CoreML::Specification::LRNLayerParams* NeuralNetworkLayer::release_lrn() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.NeuralNetworkLayer.lrn)
  if (has_lrn()) {
    clear_has_layer();
    ::CoreML::Specification::LRNLayerParams* temp = layer_.lrn_;
    layer_.lrn_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void NeuralNetworkLayer::set_allocated_lrn(::CoreML::Specification::LRNLayerParams* lrn) {
  clear_layer();
  if (lrn) {
    set_has_lrn();
    layer_.lrn_ = lrn;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.lrn)
}

// .CoreML.Specification.CropLayerParams crop = 190;
inline bool NeuralNetworkLayer::has_crop() const {
  return layer_case() == kCrop;
}
inline void NeuralNetworkLayer::set_has_crop() {
  _oneof_case_[0] = kCrop;
}
inline void NeuralNetworkLayer::clear_crop() {
  if (has_crop()) {
    delete layer_.crop_;
    clear_has_layer();
  }
}
inline  const ::CoreML::Specification::CropLayerParams& NeuralNetworkLayer::crop() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.NeuralNetworkLayer.crop)
  return has_crop()
      ? *layer_.crop_
      : ::CoreML::Specification::CropLayerParams::default_instance();
}
inline ::CoreML::Specification::CropLayerParams* NeuralNetworkLayer::mutable_crop() {
  if (!has_crop()) {
    clear_layer();
    set_has_crop();
    layer_.crop_ = new ::CoreML::Specification::CropLayerParams;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.NeuralNetworkLayer.crop)
  return layer_.crop_;
}
inline ::CoreML::Specification::CropLayerParams* NeuralNetworkLayer::release_crop() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.NeuralNetworkLayer.crop)
  if (has_crop()) {
    clear_has_layer();
    ::CoreML::Specification::CropLayerParams* temp = layer_.crop_;
    layer_.crop_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void NeuralNetworkLayer::set_allocated_crop(::CoreML::Specification::CropLayerParams* crop) {
  clear_layer();
  if (crop) {
    set_has_crop();
    layer_.crop_ = crop;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.crop)
}

// .CoreML.Specification.PaddingLayerParams padding = 200;
inline bool NeuralNetworkLayer::has_padding() const {
  return layer_case() == kPadding;
}
inline void NeuralNetworkLayer::set_has_padding() {
  _oneof_case_[0] = kPadding;
}
inline void NeuralNetworkLayer::clear_padding() {
  if (has_padding()) {
    delete layer_.padding_;
    clear_has_layer();
  }
}
inline  const ::CoreML::Specification::PaddingLayerParams& NeuralNetworkLayer::padding() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.NeuralNetworkLayer.padding)
  return has_padding()
      ? *layer_.padding_
      : ::CoreML::Specification::PaddingLayerParams::default_instance();
}
inline ::CoreML::Specification::PaddingLayerParams* NeuralNetworkLayer::mutable_padding() {
  if (!has_padding()) {
    clear_layer();
    set_has_padding();
    layer_.padding_ = new ::CoreML::Specification::PaddingLayerParams;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.NeuralNetworkLayer.padding)
  return layer_.padding_;
}
inline ::CoreML::Specification::PaddingLayerParams* NeuralNetworkLayer::release_padding() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.NeuralNetworkLayer.padding)
  if (has_padding()) {
    clear_has_layer();
    ::CoreML::Specification::PaddingLayerParams* temp = layer_.padding_;
    layer_.padding_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void NeuralNetworkLayer::set_allocated_padding(::CoreML::Specification::PaddingLayerParams* padding) {
  clear_layer();
  if (padding) {
    set_has_padding();
    layer_.padding_ = padding;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.padding)
}

// .CoreML.Specification.UpsampleLayerParams upsample = 210;
inline bool NeuralNetworkLayer::has_upsample() const {
  return layer_case() == kUpsample;
}
inline void NeuralNetworkLayer::set_has_upsample() {
  _oneof_case_[0] = kUpsample;
}
inline void NeuralNetworkLayer::clear_upsample() {
  if (has_upsample()) {
    delete layer_.upsample_;
    clear_has_layer();
  }
}
inline  const ::CoreML::Specification::UpsampleLayerParams& NeuralNetworkLayer::upsample() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.NeuralNetworkLayer.upsample)
  return has_upsample()
      ? *layer_.upsample_
      : ::CoreML::Specification::UpsampleLayerParams::default_instance();
}
inline ::CoreML::Specification::UpsampleLayerParams* NeuralNetworkLayer::mutable_upsample() {
  if (!has_upsample()) {
    clear_layer();
    set_has_upsample();
    layer_.upsample_ = new ::CoreML::Specification::UpsampleLayerParams;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.NeuralNetworkLayer.upsample)
  return layer_.upsample_;
}
inline ::CoreML::Specification::UpsampleLayerParams* NeuralNetworkLayer::release_upsample() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.NeuralNetworkLayer.upsample)
  if (has_upsample()) {
    clear_has_layer();
    ::CoreML::Specification::UpsampleLayerParams* temp = layer_.upsample_;
    layer_.upsample_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void NeuralNetworkLayer::set_allocated_upsample(::CoreML::Specification::UpsampleLayerParams* upsample) {
  clear_layer();
  if (upsample) {
    set_has_upsample();
    layer_.upsample_ = upsample;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.upsample)
}

// .CoreML.Specification.ResizeBilinearLayerParams resizeBilinear = 211;
inline bool NeuralNetworkLayer::has_resizebilinear() const {
  return layer_case() == kResizeBilinear;
}
inline void NeuralNetworkLayer::set_has_resizebilinear() {
  _oneof_case_[0] = kResizeBilinear;
}
inline void NeuralNetworkLayer::clear_resizebilinear() {
  if (has_resizebilinear()) {
    delete layer_.resizebilinear_;
    clear_has_layer();
  }
}
inline  const ::CoreML::Specification::ResizeBilinearLayerParams& NeuralNetworkLayer::resizebilinear() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.NeuralNetworkLayer.resizeBilinear)
  return has_resizebilinear()
      ? *layer_.resizebilinear_
      : ::CoreML::Specification::ResizeBilinearLayerParams::default_instance();
}
inline ::CoreML::Specification::ResizeBilinearLayerParams* NeuralNetworkLayer::mutable_resizebilinear() {
  if (!has_resizebilinear()) {
    clear_layer();
    set_has_resizebilinear();
    layer_.resizebilinear_ = new ::CoreML::Specification::ResizeBilinearLayerParams;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.NeuralNetworkLayer.resizeBilinear)
  return layer_.resizebilinear_;
}
inline ::CoreML::Specification::ResizeBilinearLayerParams* NeuralNetworkLayer::release_resizebilinear() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.NeuralNetworkLayer.resizeBilinear)
  if (has_resizebilinear()) {
    clear_has_layer();
    ::CoreML::Specification::ResizeBilinearLayerParams* temp = layer_.resizebilinear_;
    layer_.resizebilinear_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void NeuralNetworkLayer::set_allocated_resizebilinear(::CoreML::Specification::ResizeBilinearLayerParams* resizebilinear) {
  clear_layer();
  if (resizebilinear) {
    set_has_resizebilinear();
    layer_.resizebilinear_ = resizebilinear;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.resizeBilinear)
}

// .CoreML.Specification.CropResizeLayerParams cropResize = 212;
inline bool NeuralNetworkLayer::has_cropresize() const {
  return layer_case() == kCropResize;
}
inline void NeuralNetworkLayer::set_has_cropresize() {
  _oneof_case_[0] = kCropResize;
}
inline void NeuralNetworkLayer::clear_cropresize() {
  if (has_cropresize()) {
    delete layer_.cropresize_;
    clear_has_layer();
  }
}
inline  const ::CoreML::Specification::CropResizeLayerParams& NeuralNetworkLayer::cropresize() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.NeuralNetworkLayer.cropResize)
  return has_cropresize()
      ? *layer_.cropresize_
      : ::CoreML::Specification::CropResizeLayerParams::default_instance();
}
inline ::CoreML::Specification::CropResizeLayerParams* NeuralNetworkLayer::mutable_cropresize() {
  if (!has_cropresize()) {
    clear_layer();
    set_has_cropresize();
    layer_.cropresize_ = new ::CoreML::Specification::CropResizeLayerParams;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.NeuralNetworkLayer.cropResize)
  return layer_.cropresize_;
}
inline ::CoreML::Specification::CropResizeLayerParams* NeuralNetworkLayer::release_cropresize() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.NeuralNetworkLayer.cropResize)
  if (has_cropresize()) {
    clear_has_layer();
    ::CoreML::Specification::CropResizeLayerParams* temp = layer_.cropresize_;
    layer_.cropresize_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void NeuralNetworkLayer::set_allocated_cropresize(::CoreML::Specification::CropResizeLayerParams* cropresize) {
  clear_layer();
  if (cropresize) {
    set_has_cropresize();
    layer_.cropresize_ = cropresize;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.cropResize)
}

// .CoreML.Specification.UnaryFunctionLayerParams unary = 220;
inline bool NeuralNetworkLayer::has_unary() const {
  return layer_case() == kUnary;
}
inline void NeuralNetworkLayer::set_has_unary() {
  _oneof_case_[0] = kUnary;
}
inline void NeuralNetworkLayer::clear_unary() {
  if (has_unary()) {
    delete layer_.unary_;
    clear_has_layer();
  }
}
inline  const ::CoreML::Specification::UnaryFunctionLayerParams& NeuralNetworkLayer::unary() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.NeuralNetworkLayer.unary)
  return has_unary()
      ? *layer_.unary_
      : ::CoreML::Specification::UnaryFunctionLayerParams::default_instance();
}
inline ::CoreML::Specification::UnaryFunctionLayerParams* NeuralNetworkLayer::mutable_unary() {
  if (!has_unary()) {
    clear_layer();
    set_has_unary();
    layer_.unary_ = new ::CoreML::Specification::UnaryFunctionLayerParams;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.NeuralNetworkLayer.unary)
  return layer_.unary_;
}
inline ::CoreML::Specification::UnaryFunctionLayerParams* NeuralNetworkLayer::release_unary() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.NeuralNetworkLayer.unary)
  if (has_unary()) {
    clear_has_layer();
    ::CoreML::Specification::UnaryFunctionLayerParams* temp = layer_.unary_;
    layer_.unary_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void NeuralNetworkLayer::set_allocated_unary(::CoreML::Specification::UnaryFunctionLayerParams* unary) {
  clear_layer();
  if (unary) {
    set_has_unary();
    layer_.unary_ = unary;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.unary)
}

// .CoreML.Specification.AddLayerParams add = 230;
inline bool NeuralNetworkLayer::has_add() const {
  return layer_case() == kAdd;
}
inline void NeuralNetworkLayer::set_has_add() {
  _oneof_case_[0] = kAdd;
}
inline void NeuralNetworkLayer::clear_add() {
  if (has_add()) {
    delete layer_.add_;
    clear_has_layer();
  }
}
inline  const ::CoreML::Specification::AddLayerParams& NeuralNetworkLayer::add() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.NeuralNetworkLayer.add)
  return has_add()
      ? *layer_.add_
      : ::CoreML::Specification::AddLayerParams::default_instance();
}
inline ::CoreML::Specification::AddLayerParams* NeuralNetworkLayer::mutable_add() {
  if (!has_add()) {
    clear_layer();
    set_has_add();
    layer_.add_ = new ::CoreML::Specification::AddLayerParams;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.NeuralNetworkLayer.add)
  return layer_.add_;
}
inline ::CoreML::Specification::AddLayerParams* NeuralNetworkLayer::release_add() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.NeuralNetworkLayer.add)
  if (has_add()) {
    clear_has_layer();
    ::CoreML::Specification::AddLayerParams* temp = layer_.add_;
    layer_.add_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void NeuralNetworkLayer::set_allocated_add(::CoreML::Specification::AddLayerParams* add) {
  clear_layer();
  if (add) {
    set_has_add();
    layer_.add_ = add;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.add)
}

// .CoreML.Specification.MultiplyLayerParams multiply = 231;
inline bool NeuralNetworkLayer::has_multiply() const {
  return layer_case() == kMultiply;
}
inline void NeuralNetworkLayer::set_has_multiply() {
  _oneof_case_[0] = kMultiply;
}
inline void NeuralNetworkLayer::clear_multiply() {
  if (has_multiply()) {
    delete layer_.multiply_;
    clear_has_layer();
  }
}
inline  const ::CoreML::Specification::MultiplyLayerParams& NeuralNetworkLayer::multiply() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.NeuralNetworkLayer.multiply)
  return has_multiply()
      ? *layer_.multiply_
      : ::CoreML::Specification::MultiplyLayerParams::default_instance();
}
inline ::CoreML::Specification::MultiplyLayerParams* NeuralNetworkLayer::mutable_multiply() {
  if (!has_multiply()) {
    clear_layer();
    set_has_multiply();
    layer_.multiply_ = new ::CoreML::Specification::MultiplyLayerParams;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.NeuralNetworkLayer.multiply)
  return layer_.multiply_;
}
inline ::CoreML::Specification::MultiplyLayerParams* NeuralNetworkLayer::release_multiply() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.NeuralNetworkLayer.multiply)
  if (has_multiply()) {
    clear_has_layer();
    ::CoreML::Specification::MultiplyLayerParams* temp = layer_.multiply_;
    layer_.multiply_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void NeuralNetworkLayer::set_allocated_multiply(::CoreML::Specification::MultiplyLayerParams* multiply) {
  clear_layer();
  if (multiply) {
    set_has_multiply();
    layer_.multiply_ = multiply;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.multiply)
}

// .CoreML.Specification.AverageLayerParams average = 240;
inline bool NeuralNetworkLayer::has_average() const {
  return layer_case() == kAverage;
}
inline void NeuralNetworkLayer::set_has_average() {
  _oneof_case_[0] = kAverage;
}
inline void NeuralNetworkLayer::clear_average() {
  if (has_average()) {
    delete layer_.average_;
    clear_has_layer();
  }
}
inline  const ::CoreML::Specification::AverageLayerParams& NeuralNetworkLayer::average() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.NeuralNetworkLayer.average)
  return has_average()
      ? *layer_.average_
      : ::CoreML::Specification::AverageLayerParams::default_instance();
}
inline ::CoreML::Specification::AverageLayerParams* NeuralNetworkLayer::mutable_average() {
  if (!has_average()) {
    clear_layer();
    set_has_average();
    layer_.average_ = new ::CoreML::Specification::AverageLayerParams;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.NeuralNetworkLayer.average)
  return layer_.average_;
}
inline ::CoreML::Specification::AverageLayerParams* NeuralNetworkLayer::release_average() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.NeuralNetworkLayer.average)
  if (has_average()) {
    clear_has_layer();
    ::CoreML::Specification::AverageLayerParams* temp = layer_.average_;
    layer_.average_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void NeuralNetworkLayer::set_allocated_average(::CoreML::Specification::AverageLayerParams* average) {
  clear_layer();
  if (average) {
    set_has_average();
    layer_.average_ = average;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.average)
}

// .CoreML.Specification.ScaleLayerParams scale = 245;
inline bool NeuralNetworkLayer::has_scale() const {
  return layer_case() == kScale;
}
inline void NeuralNetworkLayer::set_has_scale() {
  _oneof_case_[0] = kScale;
}
inline void NeuralNetworkLayer::clear_scale() {
  if (has_scale()) {
    delete layer_.scale_;
    clear_has_layer();
  }
}
inline  const ::CoreML::Specification::ScaleLayerParams& NeuralNetworkLayer::scale() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.NeuralNetworkLayer.scale)
  return has_scale()
      ? *layer_.scale_
      : ::CoreML::Specification::ScaleLayerParams::default_instance();
}
inline ::CoreML::Specification::ScaleLayerParams* NeuralNetworkLayer::mutable_scale() {
  if (!has_scale()) {
    clear_layer();
    set_has_scale();
    layer_.scale_ = new ::CoreML::Specification::ScaleLayerParams;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.NeuralNetworkLayer.scale)
  return layer_.scale_;
}
inline ::CoreML::Specification::ScaleLayerParams* NeuralNetworkLayer::release_scale() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.NeuralNetworkLayer.scale)
  if (has_scale()) {
    clear_has_layer();
    ::CoreML::Specification::ScaleLayerParams* temp = layer_.scale_;
    layer_.scale_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void NeuralNetworkLayer::set_allocated_scale(::CoreML::Specification::ScaleLayerParams* scale) {
  clear_layer();
  if (scale) {
    set_has_scale();
    layer_.scale_ = scale;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.scale)
}

// .CoreML.Specification.BiasLayerParams bias = 250;
inline bool NeuralNetworkLayer::has_bias() const {
  return layer_case() == kBias;
}
inline void NeuralNetworkLayer::set_has_bias() {
  _oneof_case_[0] = kBias;
}
inline void NeuralNetworkLayer::clear_bias() {
  if (has_bias()) {
    delete layer_.bias_;
    clear_has_layer();
  }
}
inline  const ::CoreML::Specification::BiasLayerParams& NeuralNetworkLayer::bias() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.NeuralNetworkLayer.bias)
  return has_bias()
      ? *layer_.bias_
      : ::CoreML::Specification::BiasLayerParams::default_instance();
}
inline ::CoreML::Specification::BiasLayerParams* NeuralNetworkLayer::mutable_bias() {
  if (!has_bias()) {
    clear_layer();
    set_has_bias();
    layer_.bias_ = new ::CoreML::Specification::BiasLayerParams;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.NeuralNetworkLayer.bias)
  return layer_.bias_;
}
inline ::CoreML::Specification::BiasLayerParams* NeuralNetworkLayer::release_bias() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.NeuralNetworkLayer.bias)
  if (has_bias()) {
    clear_has_layer();
    ::CoreML::Specification::BiasLayerParams* temp = layer_.bias_;
    layer_.bias_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void NeuralNetworkLayer::set_allocated_bias(::CoreML::Specification::BiasLayerParams* bias) {
  clear_layer();
  if (bias) {
    set_has_bias();
    layer_.bias_ = bias;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.bias)
}

// .CoreML.Specification.MaxLayerParams max = 260;
inline bool NeuralNetworkLayer::has_max() const {
  return layer_case() == kMax;
}
inline void NeuralNetworkLayer::set_has_max() {
  _oneof_case_[0] = kMax;
}
inline void NeuralNetworkLayer::clear_max() {
  if (has_max()) {
    delete layer_.max_;
    clear_has_layer();
  }
}
inline  const ::CoreML::Specification::MaxLayerParams& NeuralNetworkLayer::max() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.NeuralNetworkLayer.max)
  return has_max()
      ? *layer_.max_
      : ::CoreML::Specification::MaxLayerParams::default_instance();
}
inline ::CoreML::Specification::MaxLayerParams* NeuralNetworkLayer::mutable_max() {
  if (!has_max()) {
    clear_layer();
    set_has_max();
    layer_.max_ = new ::CoreML::Specification::MaxLayerParams;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.NeuralNetworkLayer.max)
  return layer_.max_;
}
inline ::CoreML::Specification::MaxLayerParams* NeuralNetworkLayer::release_max() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.NeuralNetworkLayer.max)
  if (has_max()) {
    clear_has_layer();
    ::CoreML::Specification::MaxLayerParams* temp = layer_.max_;
    layer_.max_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void NeuralNetworkLayer::set_allocated_max(::CoreML::Specification::MaxLayerParams* max) {
  clear_layer();
  if (max) {
    set_has_max();
    layer_.max_ = max;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.max)
}

// .CoreML.Specification.MinLayerParams min = 261;
inline bool NeuralNetworkLayer::has_min() const {
  return layer_case() == kMin;
}
inline void NeuralNetworkLayer::set_has_min() {
  _oneof_case_[0] = kMin;
}
inline void NeuralNetworkLayer::clear_min() {
  if (has_min()) {
    delete layer_.min_;
    clear_has_layer();
  }
}
inline  const ::CoreML::Specification::MinLayerParams& NeuralNetworkLayer::min() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.NeuralNetworkLayer.min)
  return has_min()
      ? *layer_.min_
      : ::CoreML::Specification::MinLayerParams::default_instance();
}
inline ::CoreML::Specification::MinLayerParams* NeuralNetworkLayer::mutable_min() {
  if (!has_min()) {
    clear_layer();
    set_has_min();
    layer_.min_ = new ::CoreML::Specification::MinLayerParams;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.NeuralNetworkLayer.min)
  return layer_.min_;
}
inline ::CoreML::Specification::MinLayerParams* NeuralNetworkLayer::release_min() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.NeuralNetworkLayer.min)
  if (has_min()) {
    clear_has_layer();
    ::CoreML::Specification::MinLayerParams* temp = layer_.min_;
    layer_.min_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void NeuralNetworkLayer::set_allocated_min(::CoreML::Specification::MinLayerParams* min) {
  clear_layer();
  if (min) {
    set_has_min();
    layer_.min_ = min;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.min)
}

// .CoreML.Specification.DotProductLayerParams dot = 270;
inline bool NeuralNetworkLayer::has_dot() const {
  return layer_case() == kDot;
}
inline void NeuralNetworkLayer::set_has_dot() {
  _oneof_case_[0] = kDot;
}
inline void NeuralNetworkLayer::clear_dot() {
  if (has_dot()) {
    delete layer_.dot_;
    clear_has_layer();
  }
}
inline  const ::CoreML::Specification::DotProductLayerParams& NeuralNetworkLayer::dot() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.NeuralNetworkLayer.dot)
  return has_dot()
      ? *layer_.dot_
      : ::CoreML::Specification::DotProductLayerParams::default_instance();
}
inline ::CoreML::Specification::DotProductLayerParams* NeuralNetworkLayer::mutable_dot() {
  if (!has_dot()) {
    clear_layer();
    set_has_dot();
    layer_.dot_ = new ::CoreML::Specification::DotProductLayerParams;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.NeuralNetworkLayer.dot)
  return layer_.dot_;
}
inline ::CoreML::Specification::DotProductLayerParams* NeuralNetworkLayer::release_dot() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.NeuralNetworkLayer.dot)
  if (has_dot()) {
    clear_has_layer();
    ::CoreML::Specification::DotProductLayerParams* temp = layer_.dot_;
    layer_.dot_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void NeuralNetworkLayer::set_allocated_dot(::CoreML::Specification::DotProductLayerParams* dot) {
  clear_layer();
  if (dot) {
    set_has_dot();
    layer_.dot_ = dot;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.dot)
}

// .CoreML.Specification.ReduceLayerParams reduce = 280;
inline bool NeuralNetworkLayer::has_reduce() const {
  return layer_case() == kReduce;
}
inline void NeuralNetworkLayer::set_has_reduce() {
  _oneof_case_[0] = kReduce;
}
inline void NeuralNetworkLayer::clear_reduce() {
  if (has_reduce()) {
    delete layer_.reduce_;
    clear_has_layer();
  }
}
inline  const ::CoreML::Specification::ReduceLayerParams& NeuralNetworkLayer::reduce() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.NeuralNetworkLayer.reduce)
  return has_reduce()
      ? *layer_.reduce_
      : ::CoreML::Specification::ReduceLayerParams::default_instance();
}
inline ::CoreML::Specification::ReduceLayerParams* NeuralNetworkLayer::mutable_reduce() {
  if (!has_reduce()) {
    clear_layer();
    set_has_reduce();
    layer_.reduce_ = new ::CoreML::Specification::ReduceLayerParams;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.NeuralNetworkLayer.reduce)
  return layer_.reduce_;
}
inline ::CoreML::Specification::ReduceLayerParams* NeuralNetworkLayer::release_reduce() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.NeuralNetworkLayer.reduce)
  if (has_reduce()) {
    clear_has_layer();
    ::CoreML::Specification::ReduceLayerParams* temp = layer_.reduce_;
    layer_.reduce_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void NeuralNetworkLayer::set_allocated_reduce(::CoreML::Specification::ReduceLayerParams* reduce) {
  clear_layer();
  if (reduce) {
    set_has_reduce();
    layer_.reduce_ = reduce;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.reduce)
}

// .CoreML.Specification.LoadConstantLayerParams loadConstant = 290;
inline bool NeuralNetworkLayer::has_loadconstant() const {
  return layer_case() == kLoadConstant;
}
inline void NeuralNetworkLayer::set_has_loadconstant() {
  _oneof_case_[0] = kLoadConstant;
}
inline void NeuralNetworkLayer::clear_loadconstant() {
  if (has_loadconstant()) {
    delete layer_.loadconstant_;
    clear_has_layer();
  }
}
inline  const ::CoreML::Specification::LoadConstantLayerParams& NeuralNetworkLayer::loadconstant() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.NeuralNetworkLayer.loadConstant)
  return has_loadconstant()
      ? *layer_.loadconstant_
      : ::CoreML::Specification::LoadConstantLayerParams::default_instance();
}
inline ::CoreML::Specification::LoadConstantLayerParams* NeuralNetworkLayer::mutable_loadconstant() {
  if (!has_loadconstant()) {
    clear_layer();
    set_has_loadconstant();
    layer_.loadconstant_ = new ::CoreML::Specification::LoadConstantLayerParams;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.NeuralNetworkLayer.loadConstant)
  return layer_.loadconstant_;
}
inline ::CoreML::Specification::LoadConstantLayerParams* NeuralNetworkLayer::release_loadconstant() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.NeuralNetworkLayer.loadConstant)
  if (has_loadconstant()) {
    clear_has_layer();
    ::CoreML::Specification::LoadConstantLayerParams* temp = layer_.loadconstant_;
    layer_.loadconstant_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void NeuralNetworkLayer::set_allocated_loadconstant(::CoreML::Specification::LoadConstantLayerParams* loadconstant) {
  clear_layer();
  if (loadconstant) {
    set_has_loadconstant();
    layer_.loadconstant_ = loadconstant;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.loadConstant)
}

// .CoreML.Specification.ReshapeLayerParams reshape = 300;
inline bool NeuralNetworkLayer::has_reshape() const {
  return layer_case() == kReshape;
}
inline void NeuralNetworkLayer::set_has_reshape() {
  _oneof_case_[0] = kReshape;
}
inline void NeuralNetworkLayer::clear_reshape() {
  if (has_reshape()) {
    delete layer_.reshape_;
    clear_has_layer();
  }
}
inline  const ::CoreML::Specification::ReshapeLayerParams& NeuralNetworkLayer::reshape() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.NeuralNetworkLayer.reshape)
  return has_reshape()
      ? *layer_.reshape_
      : ::CoreML::Specification::ReshapeLayerParams::default_instance();
}
inline ::CoreML::Specification::ReshapeLayerParams* NeuralNetworkLayer::mutable_reshape() {
  if (!has_reshape()) {
    clear_layer();
    set_has_reshape();
    layer_.reshape_ = new ::CoreML::Specification::ReshapeLayerParams;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.NeuralNetworkLayer.reshape)
  return layer_.reshape_;
}
inline ::CoreML::Specification::ReshapeLayerParams* NeuralNetworkLayer::release_reshape() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.NeuralNetworkLayer.reshape)
  if (has_reshape()) {
    clear_has_layer();
    ::CoreML::Specification::ReshapeLayerParams* temp = layer_.reshape_;
    layer_.reshape_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void NeuralNetworkLayer::set_allocated_reshape(::CoreML::Specification::ReshapeLayerParams* reshape) {
  clear_layer();
  if (reshape) {
    set_has_reshape();
    layer_.reshape_ = reshape;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.reshape)
}

// .CoreML.Specification.FlattenLayerParams flatten = 301;
inline bool NeuralNetworkLayer::has_flatten() const {
  return layer_case() == kFlatten;
}
inline void NeuralNetworkLayer::set_has_flatten() {
  _oneof_case_[0] = kFlatten;
}
inline void NeuralNetworkLayer::clear_flatten() {
  if (has_flatten()) {
    delete layer_.flatten_;
    clear_has_layer();
  }
}
inline  const ::CoreML::Specification::FlattenLayerParams& NeuralNetworkLayer::flatten() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.NeuralNetworkLayer.flatten)
  return has_flatten()
      ? *layer_.flatten_
      : ::CoreML::Specification::FlattenLayerParams::default_instance();
}
inline ::CoreML::Specification::FlattenLayerParams* NeuralNetworkLayer::mutable_flatten() {
  if (!has_flatten()) {
    clear_layer();
    set_has_flatten();
    layer_.flatten_ = new ::CoreML::Specification::FlattenLayerParams;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.NeuralNetworkLayer.flatten)
  return layer_.flatten_;
}
inline ::CoreML::Specification::FlattenLayerParams* NeuralNetworkLayer::release_flatten() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.NeuralNetworkLayer.flatten)
  if (has_flatten()) {
    clear_has_layer();
    ::CoreML::Specification::FlattenLayerParams* temp = layer_.flatten_;
    layer_.flatten_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void NeuralNetworkLayer::set_allocated_flatten(::CoreML::Specification::FlattenLayerParams* flatten) {
  clear_layer();
  if (flatten) {
    set_has_flatten();
    layer_.flatten_ = flatten;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.flatten)
}

// .CoreML.Specification.PermuteLayerParams permute = 310;
inline bool NeuralNetworkLayer::has_permute() const {
  return layer_case() == kPermute;
}
inline void NeuralNetworkLayer::set_has_permute() {
  _oneof_case_[0] = kPermute;
}
inline void NeuralNetworkLayer::clear_permute() {
  if (has_permute()) {
    delete layer_.permute_;
    clear_has_layer();
  }
}
inline  const ::CoreML::Specification::PermuteLayerParams& NeuralNetworkLayer::permute() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.NeuralNetworkLayer.permute)
  return has_permute()
      ? *layer_.permute_
      : ::CoreML::Specification::PermuteLayerParams::default_instance();
}
inline ::CoreML::Specification::PermuteLayerParams* NeuralNetworkLayer::mutable_permute() {
  if (!has_permute()) {
    clear_layer();
    set_has_permute();
    layer_.permute_ = new ::CoreML::Specification::PermuteLayerParams;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.NeuralNetworkLayer.permute)
  return layer_.permute_;
}
inline ::CoreML::Specification::PermuteLayerParams* NeuralNetworkLayer::release_permute() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.NeuralNetworkLayer.permute)
  if (has_permute()) {
    clear_has_layer();
    ::CoreML::Specification::PermuteLayerParams* temp = layer_.permute_;
    layer_.permute_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void NeuralNetworkLayer::set_allocated_permute(::CoreML::Specification::PermuteLayerParams* permute) {
  clear_layer();
  if (permute) {
    set_has_permute();
    layer_.permute_ = permute;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.permute)
}

// .CoreML.Specification.ConcatLayerParams concat = 320;
inline bool NeuralNetworkLayer::has_concat() const {
  return layer_case() == kConcat;
}
inline void NeuralNetworkLayer::set_has_concat() {
  _oneof_case_[0] = kConcat;
}
inline void NeuralNetworkLayer::clear_concat() {
  if (has_concat()) {
    delete layer_.concat_;
    clear_has_layer();
  }
}
inline  const ::CoreML::Specification::ConcatLayerParams& NeuralNetworkLayer::concat() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.NeuralNetworkLayer.concat)
  return has_concat()
      ? *layer_.concat_
      : ::CoreML::Specification::ConcatLayerParams::default_instance();
}
inline ::CoreML::Specification::ConcatLayerParams* NeuralNetworkLayer::mutable_concat() {
  if (!has_concat()) {
    clear_layer();
    set_has_concat();
    layer_.concat_ = new ::CoreML::Specification::ConcatLayerParams;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.NeuralNetworkLayer.concat)
  return layer_.concat_;
}
inline ::CoreML::Specification::ConcatLayerParams* NeuralNetworkLayer::release_concat() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.NeuralNetworkLayer.concat)
  if (has_concat()) {
    clear_has_layer();
    ::CoreML::Specification::ConcatLayerParams* temp = layer_.concat_;
    layer_.concat_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void NeuralNetworkLayer::set_allocated_concat(::CoreML::Specification::ConcatLayerParams* concat) {
  clear_layer();
  if (concat) {
    set_has_concat();
    layer_.concat_ = concat;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.concat)
}

// .CoreML.Specification.SplitLayerParams split = 330;
inline bool NeuralNetworkLayer::has_split() const {
  return layer_case() == kSplit;
}
inline void NeuralNetworkLayer::set_has_split() {
  _oneof_case_[0] = kSplit;
}
inline void NeuralNetworkLayer::clear_split() {
  if (has_split()) {
    delete layer_.split_;
    clear_has_layer();
  }
}
inline  const ::CoreML::Specification::SplitLayerParams& NeuralNetworkLayer::split() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.NeuralNetworkLayer.split)
  return has_split()
      ? *layer_.split_
      : ::CoreML::Specification::SplitLayerParams::default_instance();
}
inline ::CoreML::Specification::SplitLayerParams* NeuralNetworkLayer::mutable_split() {
  if (!has_split()) {
    clear_layer();
    set_has_split();
    layer_.split_ = new ::CoreML::Specification::SplitLayerParams;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.NeuralNetworkLayer.split)
  return layer_.split_;
}
inline ::CoreML::Specification::SplitLayerParams* NeuralNetworkLayer::release_split() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.NeuralNetworkLayer.split)
  if (has_split()) {
    clear_has_layer();
    ::CoreML::Specification::SplitLayerParams* temp = layer_.split_;
    layer_.split_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void NeuralNetworkLayer::set_allocated_split(::CoreML::Specification::SplitLayerParams* split) {
  clear_layer();
  if (split) {
    set_has_split();
    layer_.split_ = split;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.split)
}

// .CoreML.Specification.SequenceRepeatLayerParams sequenceRepeat = 340;
inline bool NeuralNetworkLayer::has_sequencerepeat() const {
  return layer_case() == kSequenceRepeat;
}
inline void NeuralNetworkLayer::set_has_sequencerepeat() {
  _oneof_case_[0] = kSequenceRepeat;
}
inline void NeuralNetworkLayer::clear_sequencerepeat() {
  if (has_sequencerepeat()) {
    delete layer_.sequencerepeat_;
    clear_has_layer();
  }
}
inline  const ::CoreML::Specification::SequenceRepeatLayerParams& NeuralNetworkLayer::sequencerepeat() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.NeuralNetworkLayer.sequenceRepeat)
  return has_sequencerepeat()
      ? *layer_.sequencerepeat_
      : ::CoreML::Specification::SequenceRepeatLayerParams::default_instance();
}
inline ::CoreML::Specification::SequenceRepeatLayerParams* NeuralNetworkLayer::mutable_sequencerepeat() {
  if (!has_sequencerepeat()) {
    clear_layer();
    set_has_sequencerepeat();
    layer_.sequencerepeat_ = new ::CoreML::Specification::SequenceRepeatLayerParams;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.NeuralNetworkLayer.sequenceRepeat)
  return layer_.sequencerepeat_;
}
inline ::CoreML::Specification::SequenceRepeatLayerParams* NeuralNetworkLayer::release_sequencerepeat() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.NeuralNetworkLayer.sequenceRepeat)
  if (has_sequencerepeat()) {
    clear_has_layer();
    ::CoreML::Specification::SequenceRepeatLayerParams* temp = layer_.sequencerepeat_;
    layer_.sequencerepeat_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void NeuralNetworkLayer::set_allocated_sequencerepeat(::CoreML::Specification::SequenceRepeatLayerParams* sequencerepeat) {
  clear_layer();
  if (sequencerepeat) {
    set_has_sequencerepeat();
    layer_.sequencerepeat_ = sequencerepeat;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.sequenceRepeat)
}

// .CoreML.Specification.ReorganizeDataLayerParams reorganizeData = 345;
inline bool NeuralNetworkLayer::has_reorganizedata() const {
  return layer_case() == kReorganizeData;
}
inline void NeuralNetworkLayer::set_has_reorganizedata() {
  _oneof_case_[0] = kReorganizeData;
}
inline void NeuralNetworkLayer::clear_reorganizedata() {
  if (has_reorganizedata()) {
    delete layer_.reorganizedata_;
    clear_has_layer();
  }
}
inline  const ::CoreML::Specification::ReorganizeDataLayerParams& NeuralNetworkLayer::reorganizedata() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.NeuralNetworkLayer.reorganizeData)
  return has_reorganizedata()
      ? *layer_.reorganizedata_
      : ::CoreML::Specification::ReorganizeDataLayerParams::default_instance();
}
inline ::CoreML::Specification::ReorganizeDataLayerParams* NeuralNetworkLayer::mutable_reorganizedata() {
  if (!has_reorganizedata()) {
    clear_layer();
    set_has_reorganizedata();
    layer_.reorganizedata_ = new ::CoreML::Specification::ReorganizeDataLayerParams;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.NeuralNetworkLayer.reorganizeData)
  return layer_.reorganizedata_;
}
inline ::CoreML::Specification::ReorganizeDataLayerParams* NeuralNetworkLayer::release_reorganizedata() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.NeuralNetworkLayer.reorganizeData)
  if (has_reorganizedata()) {
    clear_has_layer();
    ::CoreML::Specification::ReorganizeDataLayerParams* temp = layer_.reorganizedata_;
    layer_.reorganizedata_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void NeuralNetworkLayer::set_allocated_reorganizedata(::CoreML::Specification::ReorganizeDataLayerParams* reorganizedata) {
  clear_layer();
  if (reorganizedata) {
    set_has_reorganizedata();
    layer_.reorganizedata_ = reorganizedata;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.reorganizeData)
}

// .CoreML.Specification.SliceLayerParams slice = 350;
inline bool NeuralNetworkLayer::has_slice() const {
  return layer_case() == kSlice;
}
inline void NeuralNetworkLayer::set_has_slice() {
  _oneof_case_[0] = kSlice;
}
inline void NeuralNetworkLayer::clear_slice() {
  if (has_slice()) {
    delete layer_.slice_;
    clear_has_layer();
  }
}
inline  const ::CoreML::Specification::SliceLayerParams& NeuralNetworkLayer::slice() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.NeuralNetworkLayer.slice)
  return has_slice()
      ? *layer_.slice_
      : ::CoreML::Specification::SliceLayerParams::default_instance();
}
inline ::CoreML::Specification::SliceLayerParams* NeuralNetworkLayer::mutable_slice() {
  if (!has_slice()) {
    clear_layer();
    set_has_slice();
    layer_.slice_ = new ::CoreML::Specification::SliceLayerParams;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.NeuralNetworkLayer.slice)
  return layer_.slice_;
}
inline ::CoreML::Specification::SliceLayerParams* NeuralNetworkLayer::release_slice() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.NeuralNetworkLayer.slice)
  if (has_slice()) {
    clear_has_layer();
    ::CoreML::Specification::SliceLayerParams* temp = layer_.slice_;
    layer_.slice_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void NeuralNetworkLayer::set_allocated_slice(::CoreML::Specification::SliceLayerParams* slice) {
  clear_layer();
  if (slice) {
    set_has_slice();
    layer_.slice_ = slice;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.slice)
}

// .CoreML.Specification.SimpleRecurrentLayerParams simpleRecurrent = 400;
inline bool NeuralNetworkLayer::has_simplerecurrent() const {
  return layer_case() == kSimpleRecurrent;
}
inline void NeuralNetworkLayer::set_has_simplerecurrent() {
  _oneof_case_[0] = kSimpleRecurrent;
}
inline void NeuralNetworkLayer::clear_simplerecurrent() {
  if (has_simplerecurrent()) {
    delete layer_.simplerecurrent_;
    clear_has_layer();
  }
}
inline  const ::CoreML::Specification::SimpleRecurrentLayerParams& NeuralNetworkLayer::simplerecurrent() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.NeuralNetworkLayer.simpleRecurrent)
  return has_simplerecurrent()
      ? *layer_.simplerecurrent_
      : ::CoreML::Specification::SimpleRecurrentLayerParams::default_instance();
}
inline ::CoreML::Specification::SimpleRecurrentLayerParams* NeuralNetworkLayer::mutable_simplerecurrent() {
  if (!has_simplerecurrent()) {
    clear_layer();
    set_has_simplerecurrent();
    layer_.simplerecurrent_ = new ::CoreML::Specification::SimpleRecurrentLayerParams;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.NeuralNetworkLayer.simpleRecurrent)
  return layer_.simplerecurrent_;
}
inline ::CoreML::Specification::SimpleRecurrentLayerParams* NeuralNetworkLayer::release_simplerecurrent() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.NeuralNetworkLayer.simpleRecurrent)
  if (has_simplerecurrent()) {
    clear_has_layer();
    ::CoreML::Specification::SimpleRecurrentLayerParams* temp = layer_.simplerecurrent_;
    layer_.simplerecurrent_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void NeuralNetworkLayer::set_allocated_simplerecurrent(::CoreML::Specification::SimpleRecurrentLayerParams* simplerecurrent) {
  clear_layer();
  if (simplerecurrent) {
    set_has_simplerecurrent();
    layer_.simplerecurrent_ = simplerecurrent;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.simpleRecurrent)
}

// .CoreML.Specification.GRULayerParams gru = 410;
inline bool NeuralNetworkLayer::has_gru() const {
  return layer_case() == kGru;
}
inline void NeuralNetworkLayer::set_has_gru() {
  _oneof_case_[0] = kGru;
}
inline void NeuralNetworkLayer::clear_gru() {
  if (has_gru()) {
    delete layer_.gru_;
    clear_has_layer();
  }
}
inline  const ::CoreML::Specification::GRULayerParams& NeuralNetworkLayer::gru() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.NeuralNetworkLayer.gru)
  return has_gru()
      ? *layer_.gru_
      : ::CoreML::Specification::GRULayerParams::default_instance();
}
inline ::CoreML::Specification::GRULayerParams* NeuralNetworkLayer::mutable_gru() {
  if (!has_gru()) {
    clear_layer();
    set_has_gru();
    layer_.gru_ = new ::CoreML::Specification::GRULayerParams;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.NeuralNetworkLayer.gru)
  return layer_.gru_;
}
inline ::CoreML::Specification::GRULayerParams* NeuralNetworkLayer::release_gru() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.NeuralNetworkLayer.gru)
  if (has_gru()) {
    clear_has_layer();
    ::CoreML::Specification::GRULayerParams* temp = layer_.gru_;
    layer_.gru_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void NeuralNetworkLayer::set_allocated_gru(::CoreML::Specification::GRULayerParams* gru) {
  clear_layer();
  if (gru) {
    set_has_gru();
    layer_.gru_ = gru;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.gru)
}

// .CoreML.Specification.UniDirectionalLSTMLayerParams uniDirectionalLSTM = 420;
inline bool NeuralNetworkLayer::has_unidirectionallstm() const {
  return layer_case() == kUniDirectionalLSTM;
}
inline void NeuralNetworkLayer::set_has_unidirectionallstm() {
  _oneof_case_[0] = kUniDirectionalLSTM;
}
inline void NeuralNetworkLayer::clear_unidirectionallstm() {
  if (has_unidirectionallstm()) {
    delete layer_.unidirectionallstm_;
    clear_has_layer();
  }
}
inline  const ::CoreML::Specification::UniDirectionalLSTMLayerParams& NeuralNetworkLayer::unidirectionallstm() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.NeuralNetworkLayer.uniDirectionalLSTM)
  return has_unidirectionallstm()
      ? *layer_.unidirectionallstm_
      : ::CoreML::Specification::UniDirectionalLSTMLayerParams::default_instance();
}
inline ::CoreML::Specification::UniDirectionalLSTMLayerParams* NeuralNetworkLayer::mutable_unidirectionallstm() {
  if (!has_unidirectionallstm()) {
    clear_layer();
    set_has_unidirectionallstm();
    layer_.unidirectionallstm_ = new ::CoreML::Specification::UniDirectionalLSTMLayerParams;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.NeuralNetworkLayer.uniDirectionalLSTM)
  return layer_.unidirectionallstm_;
}
inline ::CoreML::Specification::UniDirectionalLSTMLayerParams* NeuralNetworkLayer::release_unidirectionallstm() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.NeuralNetworkLayer.uniDirectionalLSTM)
  if (has_unidirectionallstm()) {
    clear_has_layer();
    ::CoreML::Specification::UniDirectionalLSTMLayerParams* temp = layer_.unidirectionallstm_;
    layer_.unidirectionallstm_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void NeuralNetworkLayer::set_allocated_unidirectionallstm(::CoreML::Specification::UniDirectionalLSTMLayerParams* unidirectionallstm) {
  clear_layer();
  if (unidirectionallstm) {
    set_has_unidirectionallstm();
    layer_.unidirectionallstm_ = unidirectionallstm;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.uniDirectionalLSTM)
}

// .CoreML.Specification.BiDirectionalLSTMLayerParams biDirectionalLSTM = 430;
inline bool NeuralNetworkLayer::has_bidirectionallstm() const {
  return layer_case() == kBiDirectionalLSTM;
}
inline void NeuralNetworkLayer::set_has_bidirectionallstm() {
  _oneof_case_[0] = kBiDirectionalLSTM;
}
inline void NeuralNetworkLayer::clear_bidirectionallstm() {
  if (has_bidirectionallstm()) {
    delete layer_.bidirectionallstm_;
    clear_has_layer();
  }
}
inline  const ::CoreML::Specification::BiDirectionalLSTMLayerParams& NeuralNetworkLayer::bidirectionallstm() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.NeuralNetworkLayer.biDirectionalLSTM)
  return has_bidirectionallstm()
      ? *layer_.bidirectionallstm_
      : ::CoreML::Specification::BiDirectionalLSTMLayerParams::default_instance();
}
inline ::CoreML::Specification::BiDirectionalLSTMLayerParams* NeuralNetworkLayer::mutable_bidirectionallstm() {
  if (!has_bidirectionallstm()) {
    clear_layer();
    set_has_bidirectionallstm();
    layer_.bidirectionallstm_ = new ::CoreML::Specification::BiDirectionalLSTMLayerParams;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.NeuralNetworkLayer.biDirectionalLSTM)
  return layer_.bidirectionallstm_;
}
inline ::CoreML::Specification::BiDirectionalLSTMLayerParams* NeuralNetworkLayer::release_bidirectionallstm() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.NeuralNetworkLayer.biDirectionalLSTM)
  if (has_bidirectionallstm()) {
    clear_has_layer();
    ::CoreML::Specification::BiDirectionalLSTMLayerParams* temp = layer_.bidirectionallstm_;
    layer_.bidirectionallstm_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void NeuralNetworkLayer::set_allocated_bidirectionallstm(::CoreML::Specification::BiDirectionalLSTMLayerParams* bidirectionallstm) {
  clear_layer();
  if (bidirectionallstm) {
    set_has_bidirectionallstm();
    layer_.bidirectionallstm_ = bidirectionallstm;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.biDirectionalLSTM)
}

// .CoreML.Specification.CustomLayerParams custom = 500;
inline bool NeuralNetworkLayer::has_custom() const {
  return layer_case() == kCustom;
}
inline void NeuralNetworkLayer::set_has_custom() {
  _oneof_case_[0] = kCustom;
}
inline void NeuralNetworkLayer::clear_custom() {
  if (has_custom()) {
    delete layer_.custom_;
    clear_has_layer();
  }
}
inline  const ::CoreML::Specification::CustomLayerParams& NeuralNetworkLayer::custom() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.NeuralNetworkLayer.custom)
  return has_custom()
      ? *layer_.custom_
      : ::CoreML::Specification::CustomLayerParams::default_instance();
}
inline ::CoreML::Specification::CustomLayerParams* NeuralNetworkLayer::mutable_custom() {
  if (!has_custom()) {
    clear_layer();
    set_has_custom();
    layer_.custom_ = new ::CoreML::Specification::CustomLayerParams;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.NeuralNetworkLayer.custom)
  return layer_.custom_;
}
inline ::CoreML::Specification::CustomLayerParams* NeuralNetworkLayer::release_custom() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.NeuralNetworkLayer.custom)
  if (has_custom()) {
    clear_has_layer();
    ::CoreML::Specification::CustomLayerParams* temp = layer_.custom_;
    layer_.custom_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void NeuralNetworkLayer::set_allocated_custom(::CoreML::Specification::CustomLayerParams* custom) {
  clear_layer();
  if (custom) {
    set_has_custom();
    layer_.custom_ = custom;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkLayer.custom)
}

inline bool NeuralNetworkLayer::has_layer() const {
  return layer_case() != LAYER_NOT_SET;
}
inline void NeuralNetworkLayer::clear_has_layer() {
  _oneof_case_[0] = LAYER_NOT_SET;
}
inline NeuralNetworkLayer::LayerCase NeuralNetworkLayer::layer_case() const {
  return NeuralNetworkLayer::LayerCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// BorderAmounts_EdgeSizes

// uint64 startEdgeSize = 1;
inline void BorderAmounts_EdgeSizes::clear_startedgesize() {
  startedgesize_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 BorderAmounts_EdgeSizes::startedgesize() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.BorderAmounts.EdgeSizes.startEdgeSize)
  return startedgesize_;
}
inline void BorderAmounts_EdgeSizes::set_startedgesize(::google::protobuf::uint64 value) {

  startedgesize_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.BorderAmounts.EdgeSizes.startEdgeSize)
}

// uint64 endEdgeSize = 2;
inline void BorderAmounts_EdgeSizes::clear_endedgesize() {
  endedgesize_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 BorderAmounts_EdgeSizes::endedgesize() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.BorderAmounts.EdgeSizes.endEdgeSize)
  return endedgesize_;
}
inline void BorderAmounts_EdgeSizes::set_endedgesize(::google::protobuf::uint64 value) {

  endedgesize_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.BorderAmounts.EdgeSizes.endEdgeSize)
}

// -------------------------------------------------------------------

// BorderAmounts

// repeated .CoreML.Specification.BorderAmounts.EdgeSizes borderAmounts = 10;
inline int BorderAmounts::borderamounts_size() const {
  return borderamounts_.size();
}
inline void BorderAmounts::clear_borderamounts() {
  borderamounts_.Clear();
}
inline const ::CoreML::Specification::BorderAmounts_EdgeSizes& BorderAmounts::borderamounts(int index) const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.BorderAmounts.borderAmounts)
  return borderamounts_.Get(index);
}
inline ::CoreML::Specification::BorderAmounts_EdgeSizes* BorderAmounts::mutable_borderamounts(int index) {
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.BorderAmounts.borderAmounts)
  return borderamounts_.Mutable(index);
}
inline ::CoreML::Specification::BorderAmounts_EdgeSizes* BorderAmounts::add_borderamounts() {
  // @@protoc_insertion_point(field_add:CoreML.Specification.BorderAmounts.borderAmounts)
  return borderamounts_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::BorderAmounts_EdgeSizes >*
BorderAmounts::mutable_borderamounts() {
  // @@protoc_insertion_point(field_mutable_list:CoreML.Specification.BorderAmounts.borderAmounts)
  return &borderamounts_;
}
inline const ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::BorderAmounts_EdgeSizes >&
BorderAmounts::borderamounts() const {
  // @@protoc_insertion_point(field_list:CoreML.Specification.BorderAmounts.borderAmounts)
  return borderamounts_;
}

// -------------------------------------------------------------------

// ValidPadding

// .CoreML.Specification.BorderAmounts paddingAmounts = 1;
inline bool ValidPadding::has_paddingamounts() const {
  return this != internal_default_instance() && paddingamounts_ != NULL;
}
inline void ValidPadding::clear_paddingamounts() {
  if (GetArenaNoVirtual() == NULL && paddingamounts_ != NULL) delete paddingamounts_;
  paddingamounts_ = NULL;
}
inline const ::CoreML::Specification::BorderAmounts& ValidPadding::paddingamounts() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.ValidPadding.paddingAmounts)
  return paddingamounts_ != NULL ? *paddingamounts_
                         : *::CoreML::Specification::BorderAmounts::internal_default_instance();
}
inline ::CoreML::Specification::BorderAmounts* ValidPadding::mutable_paddingamounts() {

  if (paddingamounts_ == NULL) {
    paddingamounts_ = new ::CoreML::Specification::BorderAmounts;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.ValidPadding.paddingAmounts)
  return paddingamounts_;
}
inline ::CoreML::Specification::BorderAmounts* ValidPadding::release_paddingamounts() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.ValidPadding.paddingAmounts)

  ::CoreML::Specification::BorderAmounts* temp = paddingamounts_;
  paddingamounts_ = NULL;
  return temp;
}
inline void ValidPadding::set_allocated_paddingamounts(::CoreML::Specification::BorderAmounts* paddingamounts) {
  delete paddingamounts_;
  paddingamounts_ = paddingamounts;
  if (paddingamounts) {

  } else {

  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.ValidPadding.paddingAmounts)
}

// -------------------------------------------------------------------

// SamePadding

// .CoreML.Specification.SamePadding.SamePaddingMode asymmetryMode = 1;
inline void SamePadding::clear_asymmetrymode() {
  asymmetrymode_ = 0;
}
inline ::CoreML::Specification::SamePadding_SamePaddingMode SamePadding::asymmetrymode() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.SamePadding.asymmetryMode)
  return static_cast< ::CoreML::Specification::SamePadding_SamePaddingMode >(asymmetrymode_);
}
inline void SamePadding::set_asymmetrymode(::CoreML::Specification::SamePadding_SamePaddingMode value) {

  asymmetrymode_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.SamePadding.asymmetryMode)
}

// -------------------------------------------------------------------

// SamplingMode

// .CoreML.Specification.SamplingMode.Method samplingMethod = 1;
inline void SamplingMode::clear_samplingmethod() {
  samplingmethod_ = 0;
}
inline ::CoreML::Specification::SamplingMode_Method SamplingMode::samplingmethod() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.SamplingMode.samplingMethod)
  return static_cast< ::CoreML::Specification::SamplingMode_Method >(samplingmethod_);
}
inline void SamplingMode::set_samplingmethod(::CoreML::Specification::SamplingMode_Method value) {

  samplingmethod_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.SamplingMode.samplingMethod)
}

// -------------------------------------------------------------------

// BoxCoordinatesMode

// .CoreML.Specification.BoxCoordinatesMode.Coordinates boxMode = 1;
inline void BoxCoordinatesMode::clear_boxmode() {
  boxmode_ = 0;
}
inline ::CoreML::Specification::BoxCoordinatesMode_Coordinates BoxCoordinatesMode::boxmode() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.BoxCoordinatesMode.boxMode)
  return static_cast< ::CoreML::Specification::BoxCoordinatesMode_Coordinates >(boxmode_);
}
inline void BoxCoordinatesMode::set_boxmode(::CoreML::Specification::BoxCoordinatesMode_Coordinates value) {

  boxmode_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.BoxCoordinatesMode.boxMode)
}

// -------------------------------------------------------------------

// WeightParams

// repeated float floatValue = 1;
inline int WeightParams::floatvalue_size() const {
  return floatvalue_.size();
}
inline void WeightParams::clear_floatvalue() {
  floatvalue_.Clear();
}
inline float WeightParams::floatvalue(int index) const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.WeightParams.floatValue)
  return floatvalue_.Get(index);
}
inline void WeightParams::set_floatvalue(int index, float value) {
  floatvalue_.Set(index, value);
  // @@protoc_insertion_point(field_set:CoreML.Specification.WeightParams.floatValue)
}
inline void WeightParams::add_floatvalue(float value) {
  floatvalue_.Add(value);
  // @@protoc_insertion_point(field_add:CoreML.Specification.WeightParams.floatValue)
}
inline const ::google::protobuf::RepeatedField< float >&
WeightParams::floatvalue() const {
  // @@protoc_insertion_point(field_list:CoreML.Specification.WeightParams.floatValue)
  return floatvalue_;
}
inline ::google::protobuf::RepeatedField< float >*
WeightParams::mutable_floatvalue() {
  // @@protoc_insertion_point(field_mutable_list:CoreML.Specification.WeightParams.floatValue)
  return &floatvalue_;
}

// bytes float16Value = 2;
inline void WeightParams::clear_float16value() {
  float16value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& WeightParams::float16value() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.WeightParams.float16Value)
  return float16value_.GetNoArena();
}
inline void WeightParams::set_float16value(const ::std::string& value) {

  float16value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:CoreML.Specification.WeightParams.float16Value)
}
#if LANG_CXX11
inline void WeightParams::set_float16value(::std::string&& value) {

  float16value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:CoreML.Specification.WeightParams.float16Value)
}
#endif
inline void WeightParams::set_float16value(const char* value) {
  GOOGLE_DCHECK(value != NULL);

  float16value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:CoreML.Specification.WeightParams.float16Value)
}
inline void WeightParams::set_float16value(const void* value, size_t size) {

  float16value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:CoreML.Specification.WeightParams.float16Value)
}
inline ::std::string* WeightParams::mutable_float16value() {

  // @@protoc_insertion_point(field_mutable:CoreML.Specification.WeightParams.float16Value)
  return float16value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* WeightParams::release_float16value() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.WeightParams.float16Value)

  return float16value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void WeightParams::set_allocated_float16value(::std::string* float16value) {
  if (float16value != NULL) {

  } else {

  }
  float16value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), float16value);
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.WeightParams.float16Value)
}

// bytes rawValue = 30;
inline void WeightParams::clear_rawvalue() {
  rawvalue_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& WeightParams::rawvalue() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.WeightParams.rawValue)
  return rawvalue_.GetNoArena();
}
inline void WeightParams::set_rawvalue(const ::std::string& value) {

  rawvalue_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:CoreML.Specification.WeightParams.rawValue)
}
#if LANG_CXX11
inline void WeightParams::set_rawvalue(::std::string&& value) {

  rawvalue_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:CoreML.Specification.WeightParams.rawValue)
}
#endif
inline void WeightParams::set_rawvalue(const char* value) {
  GOOGLE_DCHECK(value != NULL);

  rawvalue_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:CoreML.Specification.WeightParams.rawValue)
}
inline void WeightParams::set_rawvalue(const void* value, size_t size) {

  rawvalue_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:CoreML.Specification.WeightParams.rawValue)
}
inline ::std::string* WeightParams::mutable_rawvalue() {

  // @@protoc_insertion_point(field_mutable:CoreML.Specification.WeightParams.rawValue)
  return rawvalue_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* WeightParams::release_rawvalue() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.WeightParams.rawValue)

  return rawvalue_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void WeightParams::set_allocated_rawvalue(::std::string* rawvalue) {
  if (rawvalue != NULL) {

  } else {

  }
  rawvalue_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), rawvalue);
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.WeightParams.rawValue)
}

// .CoreML.Specification.QuantizationParams quantization = 40;
inline bool WeightParams::has_quantization() const {
  return this != internal_default_instance() && quantization_ != NULL;
}
inline void WeightParams::clear_quantization() {
  if (GetArenaNoVirtual() == NULL && quantization_ != NULL) delete quantization_;
  quantization_ = NULL;
}
inline const ::CoreML::Specification::QuantizationParams& WeightParams::quantization() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.WeightParams.quantization)
  return quantization_ != NULL ? *quantization_
                         : *::CoreML::Specification::QuantizationParams::internal_default_instance();
}
inline ::CoreML::Specification::QuantizationParams* WeightParams::mutable_quantization() {

  if (quantization_ == NULL) {
    quantization_ = new ::CoreML::Specification::QuantizationParams;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.WeightParams.quantization)
  return quantization_;
}
inline ::CoreML::Specification::QuantizationParams* WeightParams::release_quantization() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.WeightParams.quantization)

  ::CoreML::Specification::QuantizationParams* temp = quantization_;
  quantization_ = NULL;
  return temp;
}
inline void WeightParams::set_allocated_quantization(::CoreML::Specification::QuantizationParams* quantization) {
  delete quantization_;
  quantization_ = quantization;
  if (quantization) {

  } else {

  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.WeightParams.quantization)
}

// -------------------------------------------------------------------

// QuantizationParams

// uint64 numberOfBits = 1;
inline void QuantizationParams::clear_numberofbits() {
  numberofbits_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 QuantizationParams::numberofbits() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.QuantizationParams.numberOfBits)
  return numberofbits_;
}
inline void QuantizationParams::set_numberofbits(::google::protobuf::uint64 value) {

  numberofbits_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.QuantizationParams.numberOfBits)
}

// .CoreML.Specification.LinearQuantizationParams linearQuantization = 101;
inline bool QuantizationParams::has_linearquantization() const {
  return QuantizationType_case() == kLinearQuantization;
}
inline void QuantizationParams::set_has_linearquantization() {
  _oneof_case_[0] = kLinearQuantization;
}
inline void QuantizationParams::clear_linearquantization() {
  if (has_linearquantization()) {
    delete QuantizationType_.linearquantization_;
    clear_has_QuantizationType();
  }
}
inline  const ::CoreML::Specification::LinearQuantizationParams& QuantizationParams::linearquantization() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.QuantizationParams.linearQuantization)
  return has_linearquantization()
      ? *QuantizationType_.linearquantization_
      : ::CoreML::Specification::LinearQuantizationParams::default_instance();
}
inline ::CoreML::Specification::LinearQuantizationParams* QuantizationParams::mutable_linearquantization() {
  if (!has_linearquantization()) {
    clear_QuantizationType();
    set_has_linearquantization();
    QuantizationType_.linearquantization_ = new ::CoreML::Specification::LinearQuantizationParams;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.QuantizationParams.linearQuantization)
  return QuantizationType_.linearquantization_;
}
inline ::CoreML::Specification::LinearQuantizationParams* QuantizationParams::release_linearquantization() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.QuantizationParams.linearQuantization)
  if (has_linearquantization()) {
    clear_has_QuantizationType();
    ::CoreML::Specification::LinearQuantizationParams* temp = QuantizationType_.linearquantization_;
    QuantizationType_.linearquantization_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void QuantizationParams::set_allocated_linearquantization(::CoreML::Specification::LinearQuantizationParams* linearquantization) {
  clear_QuantizationType();
  if (linearquantization) {
    set_has_linearquantization();
    QuantizationType_.linearquantization_ = linearquantization;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.QuantizationParams.linearQuantization)
}

// .CoreML.Specification.LookUpTableQuantizationParams lookupTableQuantization = 102;
inline bool QuantizationParams::has_lookuptablequantization() const {
  return QuantizationType_case() == kLookupTableQuantization;
}
inline void QuantizationParams::set_has_lookuptablequantization() {
  _oneof_case_[0] = kLookupTableQuantization;
}
inline void QuantizationParams::clear_lookuptablequantization() {
  if (has_lookuptablequantization()) {
    delete QuantizationType_.lookuptablequantization_;
    clear_has_QuantizationType();
  }
}
inline  const ::CoreML::Specification::LookUpTableQuantizationParams& QuantizationParams::lookuptablequantization() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.QuantizationParams.lookupTableQuantization)
  return has_lookuptablequantization()
      ? *QuantizationType_.lookuptablequantization_
      : ::CoreML::Specification::LookUpTableQuantizationParams::default_instance();
}
inline ::CoreML::Specification::LookUpTableQuantizationParams* QuantizationParams::mutable_lookuptablequantization() {
  if (!has_lookuptablequantization()) {
    clear_QuantizationType();
    set_has_lookuptablequantization();
    QuantizationType_.lookuptablequantization_ = new ::CoreML::Specification::LookUpTableQuantizationParams;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.QuantizationParams.lookupTableQuantization)
  return QuantizationType_.lookuptablequantization_;
}
inline ::CoreML::Specification::LookUpTableQuantizationParams* QuantizationParams::release_lookuptablequantization() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.QuantizationParams.lookupTableQuantization)
  if (has_lookuptablequantization()) {
    clear_has_QuantizationType();
    ::CoreML::Specification::LookUpTableQuantizationParams* temp = QuantizationType_.lookuptablequantization_;
    QuantizationType_.lookuptablequantization_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void QuantizationParams::set_allocated_lookuptablequantization(::CoreML::Specification::LookUpTableQuantizationParams* lookuptablequantization) {
  clear_QuantizationType();
  if (lookuptablequantization) {
    set_has_lookuptablequantization();
    QuantizationType_.lookuptablequantization_ = lookuptablequantization;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.QuantizationParams.lookupTableQuantization)
}

inline bool QuantizationParams::has_QuantizationType() const {
  return QuantizationType_case() != QUANTIZATIONTYPE_NOT_SET;
}
inline void QuantizationParams::clear_has_QuantizationType() {
  _oneof_case_[0] = QUANTIZATIONTYPE_NOT_SET;
}
inline QuantizationParams::QuantizationTypeCase QuantizationParams::QuantizationType_case() const {
  return QuantizationParams::QuantizationTypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// LinearQuantizationParams

// repeated float scale = 1;
inline int LinearQuantizationParams::scale_size() const {
  return scale_.size();
}
inline void LinearQuantizationParams::clear_scale() {
  scale_.Clear();
}
inline float LinearQuantizationParams::scale(int index) const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.LinearQuantizationParams.scale)
  return scale_.Get(index);
}
inline void LinearQuantizationParams::set_scale(int index, float value) {
  scale_.Set(index, value);
  // @@protoc_insertion_point(field_set:CoreML.Specification.LinearQuantizationParams.scale)
}
inline void LinearQuantizationParams::add_scale(float value) {
  scale_.Add(value);
  // @@protoc_insertion_point(field_add:CoreML.Specification.LinearQuantizationParams.scale)
}
inline const ::google::protobuf::RepeatedField< float >&
LinearQuantizationParams::scale() const {
  // @@protoc_insertion_point(field_list:CoreML.Specification.LinearQuantizationParams.scale)
  return scale_;
}
inline ::google::protobuf::RepeatedField< float >*
LinearQuantizationParams::mutable_scale() {
  // @@protoc_insertion_point(field_mutable_list:CoreML.Specification.LinearQuantizationParams.scale)
  return &scale_;
}

// repeated float bias = 2;
inline int LinearQuantizationParams::bias_size() const {
  return bias_.size();
}
inline void LinearQuantizationParams::clear_bias() {
  bias_.Clear();
}
inline float LinearQuantizationParams::bias(int index) const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.LinearQuantizationParams.bias)
  return bias_.Get(index);
}
inline void LinearQuantizationParams::set_bias(int index, float value) {
  bias_.Set(index, value);
  // @@protoc_insertion_point(field_set:CoreML.Specification.LinearQuantizationParams.bias)
}
inline void LinearQuantizationParams::add_bias(float value) {
  bias_.Add(value);
  // @@protoc_insertion_point(field_add:CoreML.Specification.LinearQuantizationParams.bias)
}
inline const ::google::protobuf::RepeatedField< float >&
LinearQuantizationParams::bias() const {
  // @@protoc_insertion_point(field_list:CoreML.Specification.LinearQuantizationParams.bias)
  return bias_;
}
inline ::google::protobuf::RepeatedField< float >*
LinearQuantizationParams::mutable_bias() {
  // @@protoc_insertion_point(field_mutable_list:CoreML.Specification.LinearQuantizationParams.bias)
  return &bias_;
}

// -------------------------------------------------------------------

// LookUpTableQuantizationParams

// repeated float floatValue = 1;
inline int LookUpTableQuantizationParams::floatvalue_size() const {
  return floatvalue_.size();
}
inline void LookUpTableQuantizationParams::clear_floatvalue() {
  floatvalue_.Clear();
}
inline float LookUpTableQuantizationParams::floatvalue(int index) const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.LookUpTableQuantizationParams.floatValue)
  return floatvalue_.Get(index);
}
inline void LookUpTableQuantizationParams::set_floatvalue(int index, float value) {
  floatvalue_.Set(index, value);
  // @@protoc_insertion_point(field_set:CoreML.Specification.LookUpTableQuantizationParams.floatValue)
}
inline void LookUpTableQuantizationParams::add_floatvalue(float value) {
  floatvalue_.Add(value);
  // @@protoc_insertion_point(field_add:CoreML.Specification.LookUpTableQuantizationParams.floatValue)
}
inline const ::google::protobuf::RepeatedField< float >&
LookUpTableQuantizationParams::floatvalue() const {
  // @@protoc_insertion_point(field_list:CoreML.Specification.LookUpTableQuantizationParams.floatValue)
  return floatvalue_;
}
inline ::google::protobuf::RepeatedField< float >*
LookUpTableQuantizationParams::mutable_floatvalue() {
  // @@protoc_insertion_point(field_mutable_list:CoreML.Specification.LookUpTableQuantizationParams.floatValue)
  return &floatvalue_;
}

// -------------------------------------------------------------------

// ConvolutionLayerParams

// uint64 outputChannels = 1;
inline void ConvolutionLayerParams::clear_outputchannels() {
  outputchannels_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 ConvolutionLayerParams::outputchannels() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.ConvolutionLayerParams.outputChannels)
  return outputchannels_;
}
inline void ConvolutionLayerParams::set_outputchannels(::google::protobuf::uint64 value) {

  outputchannels_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.ConvolutionLayerParams.outputChannels)
}

// uint64 kernelChannels = 2;
inline void ConvolutionLayerParams::clear_kernelchannels() {
  kernelchannels_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 ConvolutionLayerParams::kernelchannels() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.ConvolutionLayerParams.kernelChannels)
  return kernelchannels_;
}
inline void ConvolutionLayerParams::set_kernelchannels(::google::protobuf::uint64 value) {

  kernelchannels_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.ConvolutionLayerParams.kernelChannels)
}

// uint64 nGroups = 10;
inline void ConvolutionLayerParams::clear_ngroups() {
  ngroups_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 ConvolutionLayerParams::ngroups() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.ConvolutionLayerParams.nGroups)
  return ngroups_;
}
inline void ConvolutionLayerParams::set_ngroups(::google::protobuf::uint64 value) {

  ngroups_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.ConvolutionLayerParams.nGroups)
}

// repeated uint64 kernelSize = 20;
inline int ConvolutionLayerParams::kernelsize_size() const {
  return kernelsize_.size();
}
inline void ConvolutionLayerParams::clear_kernelsize() {
  kernelsize_.Clear();
}
inline ::google::protobuf::uint64 ConvolutionLayerParams::kernelsize(int index) const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.ConvolutionLayerParams.kernelSize)
  return kernelsize_.Get(index);
}
inline void ConvolutionLayerParams::set_kernelsize(int index, ::google::protobuf::uint64 value) {
  kernelsize_.Set(index, value);
  // @@protoc_insertion_point(field_set:CoreML.Specification.ConvolutionLayerParams.kernelSize)
}
inline void ConvolutionLayerParams::add_kernelsize(::google::protobuf::uint64 value) {
  kernelsize_.Add(value);
  // @@protoc_insertion_point(field_add:CoreML.Specification.ConvolutionLayerParams.kernelSize)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
ConvolutionLayerParams::kernelsize() const {
  // @@protoc_insertion_point(field_list:CoreML.Specification.ConvolutionLayerParams.kernelSize)
  return kernelsize_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
ConvolutionLayerParams::mutable_kernelsize() {
  // @@protoc_insertion_point(field_mutable_list:CoreML.Specification.ConvolutionLayerParams.kernelSize)
  return &kernelsize_;
}

// repeated uint64 stride = 30;
inline int ConvolutionLayerParams::stride_size() const {
  return stride_.size();
}
inline void ConvolutionLayerParams::clear_stride() {
  stride_.Clear();
}
inline ::google::protobuf::uint64 ConvolutionLayerParams::stride(int index) const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.ConvolutionLayerParams.stride)
  return stride_.Get(index);
}
inline void ConvolutionLayerParams::set_stride(int index, ::google::protobuf::uint64 value) {
  stride_.Set(index, value);
  // @@protoc_insertion_point(field_set:CoreML.Specification.ConvolutionLayerParams.stride)
}
inline void ConvolutionLayerParams::add_stride(::google::protobuf::uint64 value) {
  stride_.Add(value);
  // @@protoc_insertion_point(field_add:CoreML.Specification.ConvolutionLayerParams.stride)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
ConvolutionLayerParams::stride() const {
  // @@protoc_insertion_point(field_list:CoreML.Specification.ConvolutionLayerParams.stride)
  return stride_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
ConvolutionLayerParams::mutable_stride() {
  // @@protoc_insertion_point(field_mutable_list:CoreML.Specification.ConvolutionLayerParams.stride)
  return &stride_;
}

// repeated uint64 dilationFactor = 40;
inline int ConvolutionLayerParams::dilationfactor_size() const {
  return dilationfactor_.size();
}
inline void ConvolutionLayerParams::clear_dilationfactor() {
  dilationfactor_.Clear();
}
inline ::google::protobuf::uint64 ConvolutionLayerParams::dilationfactor(int index) const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.ConvolutionLayerParams.dilationFactor)
  return dilationfactor_.Get(index);
}
inline void ConvolutionLayerParams::set_dilationfactor(int index, ::google::protobuf::uint64 value) {
  dilationfactor_.Set(index, value);
  // @@protoc_insertion_point(field_set:CoreML.Specification.ConvolutionLayerParams.dilationFactor)
}
inline void ConvolutionLayerParams::add_dilationfactor(::google::protobuf::uint64 value) {
  dilationfactor_.Add(value);
  // @@protoc_insertion_point(field_add:CoreML.Specification.ConvolutionLayerParams.dilationFactor)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
ConvolutionLayerParams::dilationfactor() const {
  // @@protoc_insertion_point(field_list:CoreML.Specification.ConvolutionLayerParams.dilationFactor)
  return dilationfactor_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
ConvolutionLayerParams::mutable_dilationfactor() {
  // @@protoc_insertion_point(field_mutable_list:CoreML.Specification.ConvolutionLayerParams.dilationFactor)
  return &dilationfactor_;
}

// .CoreML.Specification.ValidPadding valid = 50;
inline bool ConvolutionLayerParams::has_valid() const {
  return ConvolutionPaddingType_case() == kValid;
}
inline void ConvolutionLayerParams::set_has_valid() {
  _oneof_case_[0] = kValid;
}
inline void ConvolutionLayerParams::clear_valid() {
  if (has_valid()) {
    delete ConvolutionPaddingType_.valid_;
    clear_has_ConvolutionPaddingType();
  }
}
inline  const ::CoreML::Specification::ValidPadding& ConvolutionLayerParams::valid() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.ConvolutionLayerParams.valid)
  return has_valid()
      ? *ConvolutionPaddingType_.valid_
      : ::CoreML::Specification::ValidPadding::default_instance();
}
inline ::CoreML::Specification::ValidPadding* ConvolutionLayerParams::mutable_valid() {
  if (!has_valid()) {
    clear_ConvolutionPaddingType();
    set_has_valid();
    ConvolutionPaddingType_.valid_ = new ::CoreML::Specification::ValidPadding;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.ConvolutionLayerParams.valid)
  return ConvolutionPaddingType_.valid_;
}
inline ::CoreML::Specification::ValidPadding* ConvolutionLayerParams::release_valid() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.ConvolutionLayerParams.valid)
  if (has_valid()) {
    clear_has_ConvolutionPaddingType();
    ::CoreML::Specification::ValidPadding* temp = ConvolutionPaddingType_.valid_;
    ConvolutionPaddingType_.valid_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ConvolutionLayerParams::set_allocated_valid(::CoreML::Specification::ValidPadding* valid) {
  clear_ConvolutionPaddingType();
  if (valid) {
    set_has_valid();
    ConvolutionPaddingType_.valid_ = valid;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.ConvolutionLayerParams.valid)
}

// .CoreML.Specification.SamePadding same = 51;
inline bool ConvolutionLayerParams::has_same() const {
  return ConvolutionPaddingType_case() == kSame;
}
inline void ConvolutionLayerParams::set_has_same() {
  _oneof_case_[0] = kSame;
}
inline void ConvolutionLayerParams::clear_same() {
  if (has_same()) {
    delete ConvolutionPaddingType_.same_;
    clear_has_ConvolutionPaddingType();
  }
}
inline  const ::CoreML::Specification::SamePadding& ConvolutionLayerParams::same() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.ConvolutionLayerParams.same)
  return has_same()
      ? *ConvolutionPaddingType_.same_
      : ::CoreML::Specification::SamePadding::default_instance();
}
inline ::CoreML::Specification::SamePadding* ConvolutionLayerParams::mutable_same() {
  if (!has_same()) {
    clear_ConvolutionPaddingType();
    set_has_same();
    ConvolutionPaddingType_.same_ = new ::CoreML::Specification::SamePadding;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.ConvolutionLayerParams.same)
  return ConvolutionPaddingType_.same_;
}
inline ::CoreML::Specification::SamePadding* ConvolutionLayerParams::release_same() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.ConvolutionLayerParams.same)
  if (has_same()) {
    clear_has_ConvolutionPaddingType();
    ::CoreML::Specification::SamePadding* temp = ConvolutionPaddingType_.same_;
    ConvolutionPaddingType_.same_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ConvolutionLayerParams::set_allocated_same(::CoreML::Specification::SamePadding* same) {
  clear_ConvolutionPaddingType();
  if (same) {
    set_has_same();
    ConvolutionPaddingType_.same_ = same;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.ConvolutionLayerParams.same)
}

// bool isDeconvolution = 60;
inline void ConvolutionLayerParams::clear_isdeconvolution() {
  isdeconvolution_ = false;
}
inline bool ConvolutionLayerParams::isdeconvolution() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.ConvolutionLayerParams.isDeconvolution)
  return isdeconvolution_;
}
inline void ConvolutionLayerParams::set_isdeconvolution(bool value) {

  isdeconvolution_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.ConvolutionLayerParams.isDeconvolution)
}

// bool hasBias = 70;
inline void ConvolutionLayerParams::clear_hasbias() {
  hasbias_ = false;
}
inline bool ConvolutionLayerParams::hasbias() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.ConvolutionLayerParams.hasBias)
  return hasbias_;
}
inline void ConvolutionLayerParams::set_hasbias(bool value) {

  hasbias_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.ConvolutionLayerParams.hasBias)
}

// .CoreML.Specification.WeightParams weights = 90;
inline bool ConvolutionLayerParams::has_weights() const {
  return this != internal_default_instance() && weights_ != NULL;
}
inline void ConvolutionLayerParams::clear_weights() {
  if (GetArenaNoVirtual() == NULL && weights_ != NULL) delete weights_;
  weights_ = NULL;
}
inline const ::CoreML::Specification::WeightParams& ConvolutionLayerParams::weights() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.ConvolutionLayerParams.weights)
  return weights_ != NULL ? *weights_
                         : *::CoreML::Specification::WeightParams::internal_default_instance();
}
inline ::CoreML::Specification::WeightParams* ConvolutionLayerParams::mutable_weights() {

  if (weights_ == NULL) {
    weights_ = new ::CoreML::Specification::WeightParams;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.ConvolutionLayerParams.weights)
  return weights_;
}
inline ::CoreML::Specification::WeightParams* ConvolutionLayerParams::release_weights() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.ConvolutionLayerParams.weights)

  ::CoreML::Specification::WeightParams* temp = weights_;
  weights_ = NULL;
  return temp;
}
inline void ConvolutionLayerParams::set_allocated_weights(::CoreML::Specification::WeightParams* weights) {
  delete weights_;
  weights_ = weights;
  if (weights) {

  } else {

  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.ConvolutionLayerParams.weights)
}

// .CoreML.Specification.WeightParams bias = 91;
inline bool ConvolutionLayerParams::has_bias() const {
  return this != internal_default_instance() && bias_ != NULL;
}
inline void ConvolutionLayerParams::clear_bias() {
  if (GetArenaNoVirtual() == NULL && bias_ != NULL) delete bias_;
  bias_ = NULL;
}
inline const ::CoreML::Specification::WeightParams& ConvolutionLayerParams::bias() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.ConvolutionLayerParams.bias)
  return bias_ != NULL ? *bias_
                         : *::CoreML::Specification::WeightParams::internal_default_instance();
}
inline ::CoreML::Specification::WeightParams* ConvolutionLayerParams::mutable_bias() {

  if (bias_ == NULL) {
    bias_ = new ::CoreML::Specification::WeightParams;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.ConvolutionLayerParams.bias)
  return bias_;
}
inline ::CoreML::Specification::WeightParams* ConvolutionLayerParams::release_bias() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.ConvolutionLayerParams.bias)

  ::CoreML::Specification::WeightParams* temp = bias_;
  bias_ = NULL;
  return temp;
}
inline void ConvolutionLayerParams::set_allocated_bias(::CoreML::Specification::WeightParams* bias) {
  delete bias_;
  bias_ = bias;
  if (bias) {

  } else {

  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.ConvolutionLayerParams.bias)
}

// repeated uint64 outputShape = 100;
inline int ConvolutionLayerParams::outputshape_size() const {
  return outputshape_.size();
}
inline void ConvolutionLayerParams::clear_outputshape() {
  outputshape_.Clear();
}
inline ::google::protobuf::uint64 ConvolutionLayerParams::outputshape(int index) const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.ConvolutionLayerParams.outputShape)
  return outputshape_.Get(index);
}
inline void ConvolutionLayerParams::set_outputshape(int index, ::google::protobuf::uint64 value) {
  outputshape_.Set(index, value);
  // @@protoc_insertion_point(field_set:CoreML.Specification.ConvolutionLayerParams.outputShape)
}
inline void ConvolutionLayerParams::add_outputshape(::google::protobuf::uint64 value) {
  outputshape_.Add(value);
  // @@protoc_insertion_point(field_add:CoreML.Specification.ConvolutionLayerParams.outputShape)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
ConvolutionLayerParams::outputshape() const {
  // @@protoc_insertion_point(field_list:CoreML.Specification.ConvolutionLayerParams.outputShape)
  return outputshape_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
ConvolutionLayerParams::mutable_outputshape() {
  // @@protoc_insertion_point(field_mutable_list:CoreML.Specification.ConvolutionLayerParams.outputShape)
  return &outputshape_;
}

inline bool ConvolutionLayerParams::has_ConvolutionPaddingType() const {
  return ConvolutionPaddingType_case() != CONVOLUTIONPADDINGTYPE_NOT_SET;
}
inline void ConvolutionLayerParams::clear_has_ConvolutionPaddingType() {
  _oneof_case_[0] = CONVOLUTIONPADDINGTYPE_NOT_SET;
}
inline ConvolutionLayerParams::ConvolutionPaddingTypeCase ConvolutionLayerParams::ConvolutionPaddingType_case() const {
  return ConvolutionLayerParams::ConvolutionPaddingTypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// InnerProductLayerParams

// uint64 inputChannels = 1;
inline void InnerProductLayerParams::clear_inputchannels() {
  inputchannels_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 InnerProductLayerParams::inputchannels() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.InnerProductLayerParams.inputChannels)
  return inputchannels_;
}
inline void InnerProductLayerParams::set_inputchannels(::google::protobuf::uint64 value) {

  inputchannels_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.InnerProductLayerParams.inputChannels)
}

// uint64 outputChannels = 2;
inline void InnerProductLayerParams::clear_outputchannels() {
  outputchannels_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 InnerProductLayerParams::outputchannels() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.InnerProductLayerParams.outputChannels)
  return outputchannels_;
}
inline void InnerProductLayerParams::set_outputchannels(::google::protobuf::uint64 value) {

  outputchannels_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.InnerProductLayerParams.outputChannels)
}

// bool hasBias = 10;
inline void InnerProductLayerParams::clear_hasbias() {
  hasbias_ = false;
}
inline bool InnerProductLayerParams::hasbias() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.InnerProductLayerParams.hasBias)
  return hasbias_;
}
inline void InnerProductLayerParams::set_hasbias(bool value) {

  hasbias_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.InnerProductLayerParams.hasBias)
}

// .CoreML.Specification.WeightParams weights = 20;
inline bool InnerProductLayerParams::has_weights() const {
  return this != internal_default_instance() && weights_ != NULL;
}
inline void InnerProductLayerParams::clear_weights() {
  if (GetArenaNoVirtual() == NULL && weights_ != NULL) delete weights_;
  weights_ = NULL;
}
inline const ::CoreML::Specification::WeightParams& InnerProductLayerParams::weights() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.InnerProductLayerParams.weights)
  return weights_ != NULL ? *weights_
                         : *::CoreML::Specification::WeightParams::internal_default_instance();
}
inline ::CoreML::Specification::WeightParams* InnerProductLayerParams::mutable_weights() {

  if (weights_ == NULL) {
    weights_ = new ::CoreML::Specification::WeightParams;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.InnerProductLayerParams.weights)
  return weights_;
}
inline ::CoreML::Specification::WeightParams* InnerProductLayerParams::release_weights() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.InnerProductLayerParams.weights)

  ::CoreML::Specification::WeightParams* temp = weights_;
  weights_ = NULL;
  return temp;
}
inline void InnerProductLayerParams::set_allocated_weights(::CoreML::Specification::WeightParams* weights) {
  delete weights_;
  weights_ = weights;
  if (weights) {

  } else {

  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.InnerProductLayerParams.weights)
}

// .CoreML.Specification.WeightParams bias = 21;
inline bool InnerProductLayerParams::has_bias() const {
  return this != internal_default_instance() && bias_ != NULL;
}
inline void InnerProductLayerParams::clear_bias() {
  if (GetArenaNoVirtual() == NULL && bias_ != NULL) delete bias_;
  bias_ = NULL;
}
inline const ::CoreML::Specification::WeightParams& InnerProductLayerParams::bias() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.InnerProductLayerParams.bias)
  return bias_ != NULL ? *bias_
                         : *::CoreML::Specification::WeightParams::internal_default_instance();
}
inline ::CoreML::Specification::WeightParams* InnerProductLayerParams::mutable_bias() {

  if (bias_ == NULL) {
    bias_ = new ::CoreML::Specification::WeightParams;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.InnerProductLayerParams.bias)
  return bias_;
}
inline ::CoreML::Specification::WeightParams* InnerProductLayerParams::release_bias() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.InnerProductLayerParams.bias)

  ::CoreML::Specification::WeightParams* temp = bias_;
  bias_ = NULL;
  return temp;
}
inline void InnerProductLayerParams::set_allocated_bias(::CoreML::Specification::WeightParams* bias) {
  delete bias_;
  bias_ = bias;
  if (bias) {

  } else {

  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.InnerProductLayerParams.bias)
}

// -------------------------------------------------------------------

// EmbeddingLayerParams

// uint64 inputDim = 1;
inline void EmbeddingLayerParams::clear_inputdim() {
  inputdim_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 EmbeddingLayerParams::inputdim() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.EmbeddingLayerParams.inputDim)
  return inputdim_;
}
inline void EmbeddingLayerParams::set_inputdim(::google::protobuf::uint64 value) {

  inputdim_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.EmbeddingLayerParams.inputDim)
}

// uint64 outputChannels = 2;
inline void EmbeddingLayerParams::clear_outputchannels() {
  outputchannels_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 EmbeddingLayerParams::outputchannels() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.EmbeddingLayerParams.outputChannels)
  return outputchannels_;
}
inline void EmbeddingLayerParams::set_outputchannels(::google::protobuf::uint64 value) {

  outputchannels_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.EmbeddingLayerParams.outputChannels)
}

// bool hasBias = 10;
inline void EmbeddingLayerParams::clear_hasbias() {
  hasbias_ = false;
}
inline bool EmbeddingLayerParams::hasbias() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.EmbeddingLayerParams.hasBias)
  return hasbias_;
}
inline void EmbeddingLayerParams::set_hasbias(bool value) {

  hasbias_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.EmbeddingLayerParams.hasBias)
}

// .CoreML.Specification.WeightParams weights = 20;
inline bool EmbeddingLayerParams::has_weights() const {
  return this != internal_default_instance() && weights_ != NULL;
}
inline void EmbeddingLayerParams::clear_weights() {
  if (GetArenaNoVirtual() == NULL && weights_ != NULL) delete weights_;
  weights_ = NULL;
}
inline const ::CoreML::Specification::WeightParams& EmbeddingLayerParams::weights() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.EmbeddingLayerParams.weights)
  return weights_ != NULL ? *weights_
                         : *::CoreML::Specification::WeightParams::internal_default_instance();
}
inline ::CoreML::Specification::WeightParams* EmbeddingLayerParams::mutable_weights() {

  if (weights_ == NULL) {
    weights_ = new ::CoreML::Specification::WeightParams;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.EmbeddingLayerParams.weights)
  return weights_;
}
inline ::CoreML::Specification::WeightParams* EmbeddingLayerParams::release_weights() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.EmbeddingLayerParams.weights)

  ::CoreML::Specification::WeightParams* temp = weights_;
  weights_ = NULL;
  return temp;
}
inline void EmbeddingLayerParams::set_allocated_weights(::CoreML::Specification::WeightParams* weights) {
  delete weights_;
  weights_ = weights;
  if (weights) {

  } else {

  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.EmbeddingLayerParams.weights)
}

// .CoreML.Specification.WeightParams bias = 21;
inline bool EmbeddingLayerParams::has_bias() const {
  return this != internal_default_instance() && bias_ != NULL;
}
inline void EmbeddingLayerParams::clear_bias() {
  if (GetArenaNoVirtual() == NULL && bias_ != NULL) delete bias_;
  bias_ = NULL;
}
inline const ::CoreML::Specification::WeightParams& EmbeddingLayerParams::bias() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.EmbeddingLayerParams.bias)
  return bias_ != NULL ? *bias_
                         : *::CoreML::Specification::WeightParams::internal_default_instance();
}
inline ::CoreML::Specification::WeightParams* EmbeddingLayerParams::mutable_bias() {

  if (bias_ == NULL) {
    bias_ = new ::CoreML::Specification::WeightParams;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.EmbeddingLayerParams.bias)
  return bias_;
}
inline ::CoreML::Specification::WeightParams* EmbeddingLayerParams::release_bias() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.EmbeddingLayerParams.bias)

  ::CoreML::Specification::WeightParams* temp = bias_;
  bias_ = NULL;
  return temp;
}
inline void EmbeddingLayerParams::set_allocated_bias(::CoreML::Specification::WeightParams* bias) {
  delete bias_;
  bias_ = bias;
  if (bias) {

  } else {

  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.EmbeddingLayerParams.bias)
}

// -------------------------------------------------------------------

// BatchnormLayerParams

// uint64 channels = 1;
inline void BatchnormLayerParams::clear_channels() {
  channels_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 BatchnormLayerParams::channels() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.BatchnormLayerParams.channels)
  return channels_;
}
inline void BatchnormLayerParams::set_channels(::google::protobuf::uint64 value) {

  channels_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.BatchnormLayerParams.channels)
}

// bool computeMeanVar = 5;
inline void BatchnormLayerParams::clear_computemeanvar() {
  computemeanvar_ = false;
}
inline bool BatchnormLayerParams::computemeanvar() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.BatchnormLayerParams.computeMeanVar)
  return computemeanvar_;
}
inline void BatchnormLayerParams::set_computemeanvar(bool value) {

  computemeanvar_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.BatchnormLayerParams.computeMeanVar)
}

// bool instanceNormalization = 6;
inline void BatchnormLayerParams::clear_instancenormalization() {
  instancenormalization_ = false;
}
inline bool BatchnormLayerParams::instancenormalization() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.BatchnormLayerParams.instanceNormalization)
  return instancenormalization_;
}
inline void BatchnormLayerParams::set_instancenormalization(bool value) {

  instancenormalization_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.BatchnormLayerParams.instanceNormalization)
}

// float epsilon = 10;
inline void BatchnormLayerParams::clear_epsilon() {
  epsilon_ = 0;
}
inline float BatchnormLayerParams::epsilon() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.BatchnormLayerParams.epsilon)
  return epsilon_;
}
inline void BatchnormLayerParams::set_epsilon(float value) {

  epsilon_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.BatchnormLayerParams.epsilon)
}

// .CoreML.Specification.WeightParams gamma = 15;
inline bool BatchnormLayerParams::has_gamma() const {
  return this != internal_default_instance() && gamma_ != NULL;
}
inline void BatchnormLayerParams::clear_gamma() {
  if (GetArenaNoVirtual() == NULL && gamma_ != NULL) delete gamma_;
  gamma_ = NULL;
}
inline const ::CoreML::Specification::WeightParams& BatchnormLayerParams::gamma() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.BatchnormLayerParams.gamma)
  return gamma_ != NULL ? *gamma_
                         : *::CoreML::Specification::WeightParams::internal_default_instance();
}
inline ::CoreML::Specification::WeightParams* BatchnormLayerParams::mutable_gamma() {

  if (gamma_ == NULL) {
    gamma_ = new ::CoreML::Specification::WeightParams;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.BatchnormLayerParams.gamma)
  return gamma_;
}
inline ::CoreML::Specification::WeightParams* BatchnormLayerParams::release_gamma() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.BatchnormLayerParams.gamma)

  ::CoreML::Specification::WeightParams* temp = gamma_;
  gamma_ = NULL;
  return temp;
}
inline void BatchnormLayerParams::set_allocated_gamma(::CoreML::Specification::WeightParams* gamma) {
  delete gamma_;
  gamma_ = gamma;
  if (gamma) {

  } else {

  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.BatchnormLayerParams.gamma)
}

// .CoreML.Specification.WeightParams beta = 16;
inline bool BatchnormLayerParams::has_beta() const {
  return this != internal_default_instance() && beta_ != NULL;
}
inline void BatchnormLayerParams::clear_beta() {
  if (GetArenaNoVirtual() == NULL && beta_ != NULL) delete beta_;
  beta_ = NULL;
}
inline const ::CoreML::Specification::WeightParams& BatchnormLayerParams::beta() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.BatchnormLayerParams.beta)
  return beta_ != NULL ? *beta_
                         : *::CoreML::Specification::WeightParams::internal_default_instance();
}
inline ::CoreML::Specification::WeightParams* BatchnormLayerParams::mutable_beta() {

  if (beta_ == NULL) {
    beta_ = new ::CoreML::Specification::WeightParams;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.BatchnormLayerParams.beta)
  return beta_;
}
inline ::CoreML::Specification::WeightParams* BatchnormLayerParams::release_beta() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.BatchnormLayerParams.beta)

  ::CoreML::Specification::WeightParams* temp = beta_;
  beta_ = NULL;
  return temp;
}
inline void BatchnormLayerParams::set_allocated_beta(::CoreML::Specification::WeightParams* beta) {
  delete beta_;
  beta_ = beta;
  if (beta) {

  } else {

  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.BatchnormLayerParams.beta)
}

// .CoreML.Specification.WeightParams mean = 17;
inline bool BatchnormLayerParams::has_mean() const {
  return this != internal_default_instance() && mean_ != NULL;
}
inline void BatchnormLayerParams::clear_mean() {
  if (GetArenaNoVirtual() == NULL && mean_ != NULL) delete mean_;
  mean_ = NULL;
}
inline const ::CoreML::Specification::WeightParams& BatchnormLayerParams::mean() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.BatchnormLayerParams.mean)
  return mean_ != NULL ? *mean_
                         : *::CoreML::Specification::WeightParams::internal_default_instance();
}
inline ::CoreML::Specification::WeightParams* BatchnormLayerParams::mutable_mean() {

  if (mean_ == NULL) {
    mean_ = new ::CoreML::Specification::WeightParams;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.BatchnormLayerParams.mean)
  return mean_;
}
inline ::CoreML::Specification::WeightParams* BatchnormLayerParams::release_mean() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.BatchnormLayerParams.mean)

  ::CoreML::Specification::WeightParams* temp = mean_;
  mean_ = NULL;
  return temp;
}
inline void BatchnormLayerParams::set_allocated_mean(::CoreML::Specification::WeightParams* mean) {
  delete mean_;
  mean_ = mean;
  if (mean) {

  } else {

  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.BatchnormLayerParams.mean)
}

// .CoreML.Specification.WeightParams variance = 18;
inline bool BatchnormLayerParams::has_variance() const {
  return this != internal_default_instance() && variance_ != NULL;
}
inline void BatchnormLayerParams::clear_variance() {
  if (GetArenaNoVirtual() == NULL && variance_ != NULL) delete variance_;
  variance_ = NULL;
}
inline const ::CoreML::Specification::WeightParams& BatchnormLayerParams::variance() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.BatchnormLayerParams.variance)
  return variance_ != NULL ? *variance_
                         : *::CoreML::Specification::WeightParams::internal_default_instance();
}
inline ::CoreML::Specification::WeightParams* BatchnormLayerParams::mutable_variance() {

  if (variance_ == NULL) {
    variance_ = new ::CoreML::Specification::WeightParams;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.BatchnormLayerParams.variance)
  return variance_;
}
inline ::CoreML::Specification::WeightParams* BatchnormLayerParams::release_variance() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.BatchnormLayerParams.variance)

  ::CoreML::Specification::WeightParams* temp = variance_;
  variance_ = NULL;
  return temp;
}
inline void BatchnormLayerParams::set_allocated_variance(::CoreML::Specification::WeightParams* variance) {
  delete variance_;
  variance_ = variance;
  if (variance) {

  } else {

  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.BatchnormLayerParams.variance)
}

// -------------------------------------------------------------------

// PoolingLayerParams_ValidCompletePadding

// repeated uint64 paddingAmounts = 10;
inline int PoolingLayerParams_ValidCompletePadding::paddingamounts_size() const {
  return paddingamounts_.size();
}
inline void PoolingLayerParams_ValidCompletePadding::clear_paddingamounts() {
  paddingamounts_.Clear();
}
inline ::google::protobuf::uint64 PoolingLayerParams_ValidCompletePadding::paddingamounts(int index) const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.PoolingLayerParams.ValidCompletePadding.paddingAmounts)
  return paddingamounts_.Get(index);
}
inline void PoolingLayerParams_ValidCompletePadding::set_paddingamounts(int index, ::google::protobuf::uint64 value) {
  paddingamounts_.Set(index, value);
  // @@protoc_insertion_point(field_set:CoreML.Specification.PoolingLayerParams.ValidCompletePadding.paddingAmounts)
}
inline void PoolingLayerParams_ValidCompletePadding::add_paddingamounts(::google::protobuf::uint64 value) {
  paddingamounts_.Add(value);
  // @@protoc_insertion_point(field_add:CoreML.Specification.PoolingLayerParams.ValidCompletePadding.paddingAmounts)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
PoolingLayerParams_ValidCompletePadding::paddingamounts() const {
  // @@protoc_insertion_point(field_list:CoreML.Specification.PoolingLayerParams.ValidCompletePadding.paddingAmounts)
  return paddingamounts_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
PoolingLayerParams_ValidCompletePadding::mutable_paddingamounts() {
  // @@protoc_insertion_point(field_mutable_list:CoreML.Specification.PoolingLayerParams.ValidCompletePadding.paddingAmounts)
  return &paddingamounts_;
}

// -------------------------------------------------------------------

// PoolingLayerParams

// .CoreML.Specification.PoolingLayerParams.PoolingType type = 1;
inline void PoolingLayerParams::clear_type() {
  type_ = 0;
}
inline ::CoreML::Specification::PoolingLayerParams_PoolingType PoolingLayerParams::type() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.PoolingLayerParams.type)
  return static_cast< ::CoreML::Specification::PoolingLayerParams_PoolingType >(type_);
}
inline void PoolingLayerParams::set_type(::CoreML::Specification::PoolingLayerParams_PoolingType value) {

  type_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.PoolingLayerParams.type)
}

// repeated uint64 kernelSize = 10;
inline int PoolingLayerParams::kernelsize_size() const {
  return kernelsize_.size();
}
inline void PoolingLayerParams::clear_kernelsize() {
  kernelsize_.Clear();
}
inline ::google::protobuf::uint64 PoolingLayerParams::kernelsize(int index) const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.PoolingLayerParams.kernelSize)
  return kernelsize_.Get(index);
}
inline void PoolingLayerParams::set_kernelsize(int index, ::google::protobuf::uint64 value) {
  kernelsize_.Set(index, value);
  // @@protoc_insertion_point(field_set:CoreML.Specification.PoolingLayerParams.kernelSize)
}
inline void PoolingLayerParams::add_kernelsize(::google::protobuf::uint64 value) {
  kernelsize_.Add(value);
  // @@protoc_insertion_point(field_add:CoreML.Specification.PoolingLayerParams.kernelSize)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
PoolingLayerParams::kernelsize() const {
  // @@protoc_insertion_point(field_list:CoreML.Specification.PoolingLayerParams.kernelSize)
  return kernelsize_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
PoolingLayerParams::mutable_kernelsize() {
  // @@protoc_insertion_point(field_mutable_list:CoreML.Specification.PoolingLayerParams.kernelSize)
  return &kernelsize_;
}

// repeated uint64 stride = 20;
inline int PoolingLayerParams::stride_size() const {
  return stride_.size();
}
inline void PoolingLayerParams::clear_stride() {
  stride_.Clear();
}
inline ::google::protobuf::uint64 PoolingLayerParams::stride(int index) const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.PoolingLayerParams.stride)
  return stride_.Get(index);
}
inline void PoolingLayerParams::set_stride(int index, ::google::protobuf::uint64 value) {
  stride_.Set(index, value);
  // @@protoc_insertion_point(field_set:CoreML.Specification.PoolingLayerParams.stride)
}
inline void PoolingLayerParams::add_stride(::google::protobuf::uint64 value) {
  stride_.Add(value);
  // @@protoc_insertion_point(field_add:CoreML.Specification.PoolingLayerParams.stride)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
PoolingLayerParams::stride() const {
  // @@protoc_insertion_point(field_list:CoreML.Specification.PoolingLayerParams.stride)
  return stride_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
PoolingLayerParams::mutable_stride() {
  // @@protoc_insertion_point(field_mutable_list:CoreML.Specification.PoolingLayerParams.stride)
  return &stride_;
}

// .CoreML.Specification.ValidPadding valid = 30;
inline bool PoolingLayerParams::has_valid() const {
  return PoolingPaddingType_case() == kValid;
}
inline void PoolingLayerParams::set_has_valid() {
  _oneof_case_[0] = kValid;
}
inline void PoolingLayerParams::clear_valid() {
  if (has_valid()) {
    delete PoolingPaddingType_.valid_;
    clear_has_PoolingPaddingType();
  }
}
inline  const ::CoreML::Specification::ValidPadding& PoolingLayerParams::valid() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.PoolingLayerParams.valid)
  return has_valid()
      ? *PoolingPaddingType_.valid_
      : ::CoreML::Specification::ValidPadding::default_instance();
}
inline ::CoreML::Specification::ValidPadding* PoolingLayerParams::mutable_valid() {
  if (!has_valid()) {
    clear_PoolingPaddingType();
    set_has_valid();
    PoolingPaddingType_.valid_ = new ::CoreML::Specification::ValidPadding;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.PoolingLayerParams.valid)
  return PoolingPaddingType_.valid_;
}
inline ::CoreML::Specification::ValidPadding* PoolingLayerParams::release_valid() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.PoolingLayerParams.valid)
  if (has_valid()) {
    clear_has_PoolingPaddingType();
    ::CoreML::Specification::ValidPadding* temp = PoolingPaddingType_.valid_;
    PoolingPaddingType_.valid_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void PoolingLayerParams::set_allocated_valid(::CoreML::Specification::ValidPadding* valid) {
  clear_PoolingPaddingType();
  if (valid) {
    set_has_valid();
    PoolingPaddingType_.valid_ = valid;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.PoolingLayerParams.valid)
}

// .CoreML.Specification.SamePadding same = 31;
inline bool PoolingLayerParams::has_same() const {
  return PoolingPaddingType_case() == kSame;
}
inline void PoolingLayerParams::set_has_same() {
  _oneof_case_[0] = kSame;
}
inline void PoolingLayerParams::clear_same() {
  if (has_same()) {
    delete PoolingPaddingType_.same_;
    clear_has_PoolingPaddingType();
  }
}
inline  const ::CoreML::Specification::SamePadding& PoolingLayerParams::same() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.PoolingLayerParams.same)
  return has_same()
      ? *PoolingPaddingType_.same_
      : ::CoreML::Specification::SamePadding::default_instance();
}
inline ::CoreML::Specification::SamePadding* PoolingLayerParams::mutable_same() {
  if (!has_same()) {
    clear_PoolingPaddingType();
    set_has_same();
    PoolingPaddingType_.same_ = new ::CoreML::Specification::SamePadding;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.PoolingLayerParams.same)
  return PoolingPaddingType_.same_;
}
inline ::CoreML::Specification::SamePadding* PoolingLayerParams::release_same() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.PoolingLayerParams.same)
  if (has_same()) {
    clear_has_PoolingPaddingType();
    ::CoreML::Specification::SamePadding* temp = PoolingPaddingType_.same_;
    PoolingPaddingType_.same_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void PoolingLayerParams::set_allocated_same(::CoreML::Specification::SamePadding* same) {
  clear_PoolingPaddingType();
  if (same) {
    set_has_same();
    PoolingPaddingType_.same_ = same;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.PoolingLayerParams.same)
}

// .CoreML.Specification.PoolingLayerParams.ValidCompletePadding includeLastPixel = 32;
inline bool PoolingLayerParams::has_includelastpixel() const {
  return PoolingPaddingType_case() == kIncludeLastPixel;
}
inline void PoolingLayerParams::set_has_includelastpixel() {
  _oneof_case_[0] = kIncludeLastPixel;
}
inline void PoolingLayerParams::clear_includelastpixel() {
  if (has_includelastpixel()) {
    delete PoolingPaddingType_.includelastpixel_;
    clear_has_PoolingPaddingType();
  }
}
inline  const ::CoreML::Specification::PoolingLayerParams_ValidCompletePadding& PoolingLayerParams::includelastpixel() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.PoolingLayerParams.includeLastPixel)
  return has_includelastpixel()
      ? *PoolingPaddingType_.includelastpixel_
      : ::CoreML::Specification::PoolingLayerParams_ValidCompletePadding::default_instance();
}
inline ::CoreML::Specification::PoolingLayerParams_ValidCompletePadding* PoolingLayerParams::mutable_includelastpixel() {
  if (!has_includelastpixel()) {
    clear_PoolingPaddingType();
    set_has_includelastpixel();
    PoolingPaddingType_.includelastpixel_ = new ::CoreML::Specification::PoolingLayerParams_ValidCompletePadding;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.PoolingLayerParams.includeLastPixel)
  return PoolingPaddingType_.includelastpixel_;
}
inline ::CoreML::Specification::PoolingLayerParams_ValidCompletePadding* PoolingLayerParams::release_includelastpixel() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.PoolingLayerParams.includeLastPixel)
  if (has_includelastpixel()) {
    clear_has_PoolingPaddingType();
    ::CoreML::Specification::PoolingLayerParams_ValidCompletePadding* temp = PoolingPaddingType_.includelastpixel_;
    PoolingPaddingType_.includelastpixel_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void PoolingLayerParams::set_allocated_includelastpixel(::CoreML::Specification::PoolingLayerParams_ValidCompletePadding* includelastpixel) {
  clear_PoolingPaddingType();
  if (includelastpixel) {
    set_has_includelastpixel();
    PoolingPaddingType_.includelastpixel_ = includelastpixel;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.PoolingLayerParams.includeLastPixel)
}

// bool avgPoolExcludePadding = 50;
inline void PoolingLayerParams::clear_avgpoolexcludepadding() {
  avgpoolexcludepadding_ = false;
}
inline bool PoolingLayerParams::avgpoolexcludepadding() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.PoolingLayerParams.avgPoolExcludePadding)
  return avgpoolexcludepadding_;
}
inline void PoolingLayerParams::set_avgpoolexcludepadding(bool value) {

  avgpoolexcludepadding_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.PoolingLayerParams.avgPoolExcludePadding)
}

// bool globalPooling = 60;
inline void PoolingLayerParams::clear_globalpooling() {
  globalpooling_ = false;
}
inline bool PoolingLayerParams::globalpooling() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.PoolingLayerParams.globalPooling)
  return globalpooling_;
}
inline void PoolingLayerParams::set_globalpooling(bool value) {

  globalpooling_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.PoolingLayerParams.globalPooling)
}

inline bool PoolingLayerParams::has_PoolingPaddingType() const {
  return PoolingPaddingType_case() != POOLINGPADDINGTYPE_NOT_SET;
}
inline void PoolingLayerParams::clear_has_PoolingPaddingType() {
  _oneof_case_[0] = POOLINGPADDINGTYPE_NOT_SET;
}
inline PoolingLayerParams::PoolingPaddingTypeCase PoolingLayerParams::PoolingPaddingType_case() const {
  return PoolingLayerParams::PoolingPaddingTypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// PaddingLayerParams_PaddingConstant

// float value = 1;
inline void PaddingLayerParams_PaddingConstant::clear_value() {
  value_ = 0;
}
inline float PaddingLayerParams_PaddingConstant::value() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.PaddingLayerParams.PaddingConstant.value)
  return value_;
}
inline void PaddingLayerParams_PaddingConstant::set_value(float value) {

  value_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.PaddingLayerParams.PaddingConstant.value)
}

// -------------------------------------------------------------------

// PaddingLayerParams_PaddingReflection

// -------------------------------------------------------------------

// PaddingLayerParams_PaddingReplication

// -------------------------------------------------------------------

// PaddingLayerParams

// .CoreML.Specification.PaddingLayerParams.PaddingConstant constant = 1;
inline bool PaddingLayerParams::has_constant() const {
  return PaddingType_case() == kConstant;
}
inline void PaddingLayerParams::set_has_constant() {
  _oneof_case_[0] = kConstant;
}
inline void PaddingLayerParams::clear_constant() {
  if (has_constant()) {
    delete PaddingType_.constant_;
    clear_has_PaddingType();
  }
}
inline  const ::CoreML::Specification::PaddingLayerParams_PaddingConstant& PaddingLayerParams::constant() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.PaddingLayerParams.constant)
  return has_constant()
      ? *PaddingType_.constant_
      : ::CoreML::Specification::PaddingLayerParams_PaddingConstant::default_instance();
}
inline ::CoreML::Specification::PaddingLayerParams_PaddingConstant* PaddingLayerParams::mutable_constant() {
  if (!has_constant()) {
    clear_PaddingType();
    set_has_constant();
    PaddingType_.constant_ = new ::CoreML::Specification::PaddingLayerParams_PaddingConstant;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.PaddingLayerParams.constant)
  return PaddingType_.constant_;
}
inline ::CoreML::Specification::PaddingLayerParams_PaddingConstant* PaddingLayerParams::release_constant() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.PaddingLayerParams.constant)
  if (has_constant()) {
    clear_has_PaddingType();
    ::CoreML::Specification::PaddingLayerParams_PaddingConstant* temp = PaddingType_.constant_;
    PaddingType_.constant_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void PaddingLayerParams::set_allocated_constant(::CoreML::Specification::PaddingLayerParams_PaddingConstant* constant) {
  clear_PaddingType();
  if (constant) {
    set_has_constant();
    PaddingType_.constant_ = constant;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.PaddingLayerParams.constant)
}

// .CoreML.Specification.PaddingLayerParams.PaddingReflection reflection = 2;
inline bool PaddingLayerParams::has_reflection() const {
  return PaddingType_case() == kReflection;
}
inline void PaddingLayerParams::set_has_reflection() {
  _oneof_case_[0] = kReflection;
}
inline void PaddingLayerParams::clear_reflection() {
  if (has_reflection()) {
    delete PaddingType_.reflection_;
    clear_has_PaddingType();
  }
}
inline  const ::CoreML::Specification::PaddingLayerParams_PaddingReflection& PaddingLayerParams::reflection() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.PaddingLayerParams.reflection)
  return has_reflection()
      ? *PaddingType_.reflection_
      : ::CoreML::Specification::PaddingLayerParams_PaddingReflection::default_instance();
}
inline ::CoreML::Specification::PaddingLayerParams_PaddingReflection* PaddingLayerParams::mutable_reflection() {
  if (!has_reflection()) {
    clear_PaddingType();
    set_has_reflection();
    PaddingType_.reflection_ = new ::CoreML::Specification::PaddingLayerParams_PaddingReflection;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.PaddingLayerParams.reflection)
  return PaddingType_.reflection_;
}
inline ::CoreML::Specification::PaddingLayerParams_PaddingReflection* PaddingLayerParams::release_reflection() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.PaddingLayerParams.reflection)
  if (has_reflection()) {
    clear_has_PaddingType();
    ::CoreML::Specification::PaddingLayerParams_PaddingReflection* temp = PaddingType_.reflection_;
    PaddingType_.reflection_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void PaddingLayerParams::set_allocated_reflection(::CoreML::Specification::PaddingLayerParams_PaddingReflection* reflection) {
  clear_PaddingType();
  if (reflection) {
    set_has_reflection();
    PaddingType_.reflection_ = reflection;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.PaddingLayerParams.reflection)
}

// .CoreML.Specification.PaddingLayerParams.PaddingReplication replication = 3;
inline bool PaddingLayerParams::has_replication() const {
  return PaddingType_case() == kReplication;
}
inline void PaddingLayerParams::set_has_replication() {
  _oneof_case_[0] = kReplication;
}
inline void PaddingLayerParams::clear_replication() {
  if (has_replication()) {
    delete PaddingType_.replication_;
    clear_has_PaddingType();
  }
}
inline  const ::CoreML::Specification::PaddingLayerParams_PaddingReplication& PaddingLayerParams::replication() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.PaddingLayerParams.replication)
  return has_replication()
      ? *PaddingType_.replication_
      : ::CoreML::Specification::PaddingLayerParams_PaddingReplication::default_instance();
}
inline ::CoreML::Specification::PaddingLayerParams_PaddingReplication* PaddingLayerParams::mutable_replication() {
  if (!has_replication()) {
    clear_PaddingType();
    set_has_replication();
    PaddingType_.replication_ = new ::CoreML::Specification::PaddingLayerParams_PaddingReplication;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.PaddingLayerParams.replication)
  return PaddingType_.replication_;
}
inline ::CoreML::Specification::PaddingLayerParams_PaddingReplication* PaddingLayerParams::release_replication() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.PaddingLayerParams.replication)
  if (has_replication()) {
    clear_has_PaddingType();
    ::CoreML::Specification::PaddingLayerParams_PaddingReplication* temp = PaddingType_.replication_;
    PaddingType_.replication_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void PaddingLayerParams::set_allocated_replication(::CoreML::Specification::PaddingLayerParams_PaddingReplication* replication) {
  clear_PaddingType();
  if (replication) {
    set_has_replication();
    PaddingType_.replication_ = replication;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.PaddingLayerParams.replication)
}

// .CoreML.Specification.BorderAmounts paddingAmounts = 10;
inline bool PaddingLayerParams::has_paddingamounts() const {
  return this != internal_default_instance() && paddingamounts_ != NULL;
}
inline void PaddingLayerParams::clear_paddingamounts() {
  if (GetArenaNoVirtual() == NULL && paddingamounts_ != NULL) delete paddingamounts_;
  paddingamounts_ = NULL;
}
inline const ::CoreML::Specification::BorderAmounts& PaddingLayerParams::paddingamounts() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.PaddingLayerParams.paddingAmounts)
  return paddingamounts_ != NULL ? *paddingamounts_
                         : *::CoreML::Specification::BorderAmounts::internal_default_instance();
}
inline ::CoreML::Specification::BorderAmounts* PaddingLayerParams::mutable_paddingamounts() {

  if (paddingamounts_ == NULL) {
    paddingamounts_ = new ::CoreML::Specification::BorderAmounts;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.PaddingLayerParams.paddingAmounts)
  return paddingamounts_;
}
inline ::CoreML::Specification::BorderAmounts* PaddingLayerParams::release_paddingamounts() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.PaddingLayerParams.paddingAmounts)

  ::CoreML::Specification::BorderAmounts* temp = paddingamounts_;
  paddingamounts_ = NULL;
  return temp;
}
inline void PaddingLayerParams::set_allocated_paddingamounts(::CoreML::Specification::BorderAmounts* paddingamounts) {
  delete paddingamounts_;
  paddingamounts_ = paddingamounts;
  if (paddingamounts) {

  } else {

  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.PaddingLayerParams.paddingAmounts)
}

inline bool PaddingLayerParams::has_PaddingType() const {
  return PaddingType_case() != PADDINGTYPE_NOT_SET;
}
inline void PaddingLayerParams::clear_has_PaddingType() {
  _oneof_case_[0] = PADDINGTYPE_NOT_SET;
}
inline PaddingLayerParams::PaddingTypeCase PaddingLayerParams::PaddingType_case() const {
  return PaddingLayerParams::PaddingTypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ConcatLayerParams

// bool sequenceConcat = 100;
inline void ConcatLayerParams::clear_sequenceconcat() {
  sequenceconcat_ = false;
}
inline bool ConcatLayerParams::sequenceconcat() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.ConcatLayerParams.sequenceConcat)
  return sequenceconcat_;
}
inline void ConcatLayerParams::set_sequenceconcat(bool value) {

  sequenceconcat_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.ConcatLayerParams.sequenceConcat)
}

// -------------------------------------------------------------------

// LRNLayerParams

// float alpha = 1;
inline void LRNLayerParams::clear_alpha() {
  alpha_ = 0;
}
inline float LRNLayerParams::alpha() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.LRNLayerParams.alpha)
  return alpha_;
}
inline void LRNLayerParams::set_alpha(float value) {

  alpha_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.LRNLayerParams.alpha)
}

// float beta = 2;
inline void LRNLayerParams::clear_beta() {
  beta_ = 0;
}
inline float LRNLayerParams::beta() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.LRNLayerParams.beta)
  return beta_;
}
inline void LRNLayerParams::set_beta(float value) {

  beta_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.LRNLayerParams.beta)
}

// uint64 localSize = 3;
inline void LRNLayerParams::clear_localsize() {
  localsize_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 LRNLayerParams::localsize() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.LRNLayerParams.localSize)
  return localsize_;
}
inline void LRNLayerParams::set_localsize(::google::protobuf::uint64 value) {

  localsize_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.LRNLayerParams.localSize)
}

// float k = 4;
inline void LRNLayerParams::clear_k() {
  k_ = 0;
}
inline float LRNLayerParams::k() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.LRNLayerParams.k)
  return k_;
}
inline void LRNLayerParams::set_k(float value) {

  k_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.LRNLayerParams.k)
}

// -------------------------------------------------------------------

// SoftmaxLayerParams

// -------------------------------------------------------------------

// SplitLayerParams

// uint64 nOutputs = 1;
inline void SplitLayerParams::clear_noutputs() {
  noutputs_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 SplitLayerParams::noutputs() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.SplitLayerParams.nOutputs)
  return noutputs_;
}
inline void SplitLayerParams::set_noutputs(::google::protobuf::uint64 value) {

  noutputs_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.SplitLayerParams.nOutputs)
}

// -------------------------------------------------------------------

// AddLayerParams

// float alpha = 1;
inline void AddLayerParams::clear_alpha() {
  alpha_ = 0;
}
inline float AddLayerParams::alpha() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.AddLayerParams.alpha)
  return alpha_;
}
inline void AddLayerParams::set_alpha(float value) {

  alpha_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.AddLayerParams.alpha)
}

// -------------------------------------------------------------------

// MultiplyLayerParams

// float alpha = 1;
inline void MultiplyLayerParams::clear_alpha() {
  alpha_ = 0;
}
inline float MultiplyLayerParams::alpha() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.MultiplyLayerParams.alpha)
  return alpha_;
}
inline void MultiplyLayerParams::set_alpha(float value) {

  alpha_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.MultiplyLayerParams.alpha)
}

// -------------------------------------------------------------------

// UnaryFunctionLayerParams

// .CoreML.Specification.UnaryFunctionLayerParams.Operation type = 1;
inline void UnaryFunctionLayerParams::clear_type() {
  type_ = 0;
}
inline ::CoreML::Specification::UnaryFunctionLayerParams_Operation UnaryFunctionLayerParams::type() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.UnaryFunctionLayerParams.type)
  return static_cast< ::CoreML::Specification::UnaryFunctionLayerParams_Operation >(type_);
}
inline void UnaryFunctionLayerParams::set_type(::CoreML::Specification::UnaryFunctionLayerParams_Operation value) {

  type_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.UnaryFunctionLayerParams.type)
}

// float alpha = 2;
inline void UnaryFunctionLayerParams::clear_alpha() {
  alpha_ = 0;
}
inline float UnaryFunctionLayerParams::alpha() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.UnaryFunctionLayerParams.alpha)
  return alpha_;
}
inline void UnaryFunctionLayerParams::set_alpha(float value) {

  alpha_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.UnaryFunctionLayerParams.alpha)
}

// float epsilon = 3;
inline void UnaryFunctionLayerParams::clear_epsilon() {
  epsilon_ = 0;
}
inline float UnaryFunctionLayerParams::epsilon() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.UnaryFunctionLayerParams.epsilon)
  return epsilon_;
}
inline void UnaryFunctionLayerParams::set_epsilon(float value) {

  epsilon_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.UnaryFunctionLayerParams.epsilon)
}

// float shift = 4;
inline void UnaryFunctionLayerParams::clear_shift() {
  shift_ = 0;
}
inline float UnaryFunctionLayerParams::shift() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.UnaryFunctionLayerParams.shift)
  return shift_;
}
inline void UnaryFunctionLayerParams::set_shift(float value) {

  shift_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.UnaryFunctionLayerParams.shift)
}

// float scale = 5;
inline void UnaryFunctionLayerParams::clear_scale() {
  scale_ = 0;
}
inline float UnaryFunctionLayerParams::scale() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.UnaryFunctionLayerParams.scale)
  return scale_;
}
inline void UnaryFunctionLayerParams::set_scale(float value) {

  scale_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.UnaryFunctionLayerParams.scale)
}

// -------------------------------------------------------------------

// UpsampleLayerParams

// repeated uint64 scalingFactor = 1;
inline int UpsampleLayerParams::scalingfactor_size() const {
  return scalingfactor_.size();
}
inline void UpsampleLayerParams::clear_scalingfactor() {
  scalingfactor_.Clear();
}
inline ::google::protobuf::uint64 UpsampleLayerParams::scalingfactor(int index) const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.UpsampleLayerParams.scalingFactor)
  return scalingfactor_.Get(index);
}
inline void UpsampleLayerParams::set_scalingfactor(int index, ::google::protobuf::uint64 value) {
  scalingfactor_.Set(index, value);
  // @@protoc_insertion_point(field_set:CoreML.Specification.UpsampleLayerParams.scalingFactor)
}
inline void UpsampleLayerParams::add_scalingfactor(::google::protobuf::uint64 value) {
  scalingfactor_.Add(value);
  // @@protoc_insertion_point(field_add:CoreML.Specification.UpsampleLayerParams.scalingFactor)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
UpsampleLayerParams::scalingfactor() const {
  // @@protoc_insertion_point(field_list:CoreML.Specification.UpsampleLayerParams.scalingFactor)
  return scalingfactor_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
UpsampleLayerParams::mutable_scalingfactor() {
  // @@protoc_insertion_point(field_mutable_list:CoreML.Specification.UpsampleLayerParams.scalingFactor)
  return &scalingfactor_;
}

// .CoreML.Specification.UpsampleLayerParams.InterpolationMode mode = 5;
inline void UpsampleLayerParams::clear_mode() {
  mode_ = 0;
}
inline ::CoreML::Specification::UpsampleLayerParams_InterpolationMode UpsampleLayerParams::mode() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.UpsampleLayerParams.mode)
  return static_cast< ::CoreML::Specification::UpsampleLayerParams_InterpolationMode >(mode_);
}
inline void UpsampleLayerParams::set_mode(::CoreML::Specification::UpsampleLayerParams_InterpolationMode value) {

  mode_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.UpsampleLayerParams.mode)
}

// -------------------------------------------------------------------

// ResizeBilinearLayerParams

// repeated uint64 targetSize = 1;
inline int ResizeBilinearLayerParams::targetsize_size() const {
  return targetsize_.size();
}
inline void ResizeBilinearLayerParams::clear_targetsize() {
  targetsize_.Clear();
}
inline ::google::protobuf::uint64 ResizeBilinearLayerParams::targetsize(int index) const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.ResizeBilinearLayerParams.targetSize)
  return targetsize_.Get(index);
}
inline void ResizeBilinearLayerParams::set_targetsize(int index, ::google::protobuf::uint64 value) {
  targetsize_.Set(index, value);
  // @@protoc_insertion_point(field_set:CoreML.Specification.ResizeBilinearLayerParams.targetSize)
}
inline void ResizeBilinearLayerParams::add_targetsize(::google::protobuf::uint64 value) {
  targetsize_.Add(value);
  // @@protoc_insertion_point(field_add:CoreML.Specification.ResizeBilinearLayerParams.targetSize)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
ResizeBilinearLayerParams::targetsize() const {
  // @@protoc_insertion_point(field_list:CoreML.Specification.ResizeBilinearLayerParams.targetSize)
  return targetsize_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
ResizeBilinearLayerParams::mutable_targetsize() {
  // @@protoc_insertion_point(field_mutable_list:CoreML.Specification.ResizeBilinearLayerParams.targetSize)
  return &targetsize_;
}

// .CoreML.Specification.SamplingMode mode = 2;
inline bool ResizeBilinearLayerParams::has_mode() const {
  return this != internal_default_instance() && mode_ != NULL;
}
inline void ResizeBilinearLayerParams::clear_mode() {
  if (GetArenaNoVirtual() == NULL && mode_ != NULL) delete mode_;
  mode_ = NULL;
}
inline const ::CoreML::Specification::SamplingMode& ResizeBilinearLayerParams::mode() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.ResizeBilinearLayerParams.mode)
  return mode_ != NULL ? *mode_
                         : *::CoreML::Specification::SamplingMode::internal_default_instance();
}
inline ::CoreML::Specification::SamplingMode* ResizeBilinearLayerParams::mutable_mode() {

  if (mode_ == NULL) {
    mode_ = new ::CoreML::Specification::SamplingMode;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.ResizeBilinearLayerParams.mode)
  return mode_;
}
inline ::CoreML::Specification::SamplingMode* ResizeBilinearLayerParams::release_mode() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.ResizeBilinearLayerParams.mode)

  ::CoreML::Specification::SamplingMode* temp = mode_;
  mode_ = NULL;
  return temp;
}
inline void ResizeBilinearLayerParams::set_allocated_mode(::CoreML::Specification::SamplingMode* mode) {
  delete mode_;
  mode_ = mode;
  if (mode) {

  } else {

  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.ResizeBilinearLayerParams.mode)
}

// -------------------------------------------------------------------

// CropResizeLayerParams

// repeated uint64 targetSize = 1;
inline int CropResizeLayerParams::targetsize_size() const {
  return targetsize_.size();
}
inline void CropResizeLayerParams::clear_targetsize() {
  targetsize_.Clear();
}
inline ::google::protobuf::uint64 CropResizeLayerParams::targetsize(int index) const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.CropResizeLayerParams.targetSize)
  return targetsize_.Get(index);
}
inline void CropResizeLayerParams::set_targetsize(int index, ::google::protobuf::uint64 value) {
  targetsize_.Set(index, value);
  // @@protoc_insertion_point(field_set:CoreML.Specification.CropResizeLayerParams.targetSize)
}
inline void CropResizeLayerParams::add_targetsize(::google::protobuf::uint64 value) {
  targetsize_.Add(value);
  // @@protoc_insertion_point(field_add:CoreML.Specification.CropResizeLayerParams.targetSize)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
CropResizeLayerParams::targetsize() const {
  // @@protoc_insertion_point(field_list:CoreML.Specification.CropResizeLayerParams.targetSize)
  return targetsize_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
CropResizeLayerParams::mutable_targetsize() {
  // @@protoc_insertion_point(field_mutable_list:CoreML.Specification.CropResizeLayerParams.targetSize)
  return &targetsize_;
}

// bool normalizedCoordinates = 2;
inline void CropResizeLayerParams::clear_normalizedcoordinates() {
  normalizedcoordinates_ = false;
}
inline bool CropResizeLayerParams::normalizedcoordinates() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.CropResizeLayerParams.normalizedCoordinates)
  return normalizedcoordinates_;
}
inline void CropResizeLayerParams::set_normalizedcoordinates(bool value) {

  normalizedcoordinates_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.CropResizeLayerParams.normalizedCoordinates)
}

// .CoreML.Specification.SamplingMode mode = 3;
inline bool CropResizeLayerParams::has_mode() const {
  return this != internal_default_instance() && mode_ != NULL;
}
inline void CropResizeLayerParams::clear_mode() {
  if (GetArenaNoVirtual() == NULL && mode_ != NULL) delete mode_;
  mode_ = NULL;
}
inline const ::CoreML::Specification::SamplingMode& CropResizeLayerParams::mode() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.CropResizeLayerParams.mode)
  return mode_ != NULL ? *mode_
                         : *::CoreML::Specification::SamplingMode::internal_default_instance();
}
inline ::CoreML::Specification::SamplingMode* CropResizeLayerParams::mutable_mode() {

  if (mode_ == NULL) {
    mode_ = new ::CoreML::Specification::SamplingMode;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.CropResizeLayerParams.mode)
  return mode_;
}
inline ::CoreML::Specification::SamplingMode* CropResizeLayerParams::release_mode() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.CropResizeLayerParams.mode)

  ::CoreML::Specification::SamplingMode* temp = mode_;
  mode_ = NULL;
  return temp;
}
inline void CropResizeLayerParams::set_allocated_mode(::CoreML::Specification::SamplingMode* mode) {
  delete mode_;
  mode_ = mode;
  if (mode) {

  } else {

  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.CropResizeLayerParams.mode)
}

// .CoreML.Specification.BoxCoordinatesMode boxIndicesMode = 4;
inline bool CropResizeLayerParams::has_boxindicesmode() const {
  return this != internal_default_instance() && boxindicesmode_ != NULL;
}
inline void CropResizeLayerParams::clear_boxindicesmode() {
  if (GetArenaNoVirtual() == NULL && boxindicesmode_ != NULL) delete boxindicesmode_;
  boxindicesmode_ = NULL;
}
inline const ::CoreML::Specification::BoxCoordinatesMode& CropResizeLayerParams::boxindicesmode() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.CropResizeLayerParams.boxIndicesMode)
  return boxindicesmode_ != NULL ? *boxindicesmode_
                         : *::CoreML::Specification::BoxCoordinatesMode::internal_default_instance();
}
inline ::CoreML::Specification::BoxCoordinatesMode* CropResizeLayerParams::mutable_boxindicesmode() {

  if (boxindicesmode_ == NULL) {
    boxindicesmode_ = new ::CoreML::Specification::BoxCoordinatesMode;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.CropResizeLayerParams.boxIndicesMode)
  return boxindicesmode_;
}
inline ::CoreML::Specification::BoxCoordinatesMode* CropResizeLayerParams::release_boxindicesmode() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.CropResizeLayerParams.boxIndicesMode)

  ::CoreML::Specification::BoxCoordinatesMode* temp = boxindicesmode_;
  boxindicesmode_ = NULL;
  return temp;
}
inline void CropResizeLayerParams::set_allocated_boxindicesmode(::CoreML::Specification::BoxCoordinatesMode* boxindicesmode) {
  delete boxindicesmode_;
  boxindicesmode_ = boxindicesmode;
  if (boxindicesmode) {

  } else {

  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.CropResizeLayerParams.boxIndicesMode)
}

// float spatialScale = 5;
inline void CropResizeLayerParams::clear_spatialscale() {
  spatialscale_ = 0;
}
inline float CropResizeLayerParams::spatialscale() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.CropResizeLayerParams.spatialScale)
  return spatialscale_;
}
inline void CropResizeLayerParams::set_spatialscale(float value) {

  spatialscale_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.CropResizeLayerParams.spatialScale)
}

// -------------------------------------------------------------------

// BiasLayerParams

// repeated uint64 shape = 1;
inline int BiasLayerParams::shape_size() const {
  return shape_.size();
}
inline void BiasLayerParams::clear_shape() {
  shape_.Clear();
}
inline ::google::protobuf::uint64 BiasLayerParams::shape(int index) const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.BiasLayerParams.shape)
  return shape_.Get(index);
}
inline void BiasLayerParams::set_shape(int index, ::google::protobuf::uint64 value) {
  shape_.Set(index, value);
  // @@protoc_insertion_point(field_set:CoreML.Specification.BiasLayerParams.shape)
}
inline void BiasLayerParams::add_shape(::google::protobuf::uint64 value) {
  shape_.Add(value);
  // @@protoc_insertion_point(field_add:CoreML.Specification.BiasLayerParams.shape)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
BiasLayerParams::shape() const {
  // @@protoc_insertion_point(field_list:CoreML.Specification.BiasLayerParams.shape)
  return shape_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
BiasLayerParams::mutable_shape() {
  // @@protoc_insertion_point(field_mutable_list:CoreML.Specification.BiasLayerParams.shape)
  return &shape_;
}

// .CoreML.Specification.WeightParams bias = 2;
inline bool BiasLayerParams::has_bias() const {
  return this != internal_default_instance() && bias_ != NULL;
}
inline void BiasLayerParams::clear_bias() {
  if (GetArenaNoVirtual() == NULL && bias_ != NULL) delete bias_;
  bias_ = NULL;
}
inline const ::CoreML::Specification::WeightParams& BiasLayerParams::bias() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.BiasLayerParams.bias)
  return bias_ != NULL ? *bias_
                         : *::CoreML::Specification::WeightParams::internal_default_instance();
}
inline ::CoreML::Specification::WeightParams* BiasLayerParams::mutable_bias() {

  if (bias_ == NULL) {
    bias_ = new ::CoreML::Specification::WeightParams;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.BiasLayerParams.bias)
  return bias_;
}
inline ::CoreML::Specification::WeightParams* BiasLayerParams::release_bias() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.BiasLayerParams.bias)

  ::CoreML::Specification::WeightParams* temp = bias_;
  bias_ = NULL;
  return temp;
}
inline void BiasLayerParams::set_allocated_bias(::CoreML::Specification::WeightParams* bias) {
  delete bias_;
  bias_ = bias;
  if (bias) {

  } else {

  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.BiasLayerParams.bias)
}

// -------------------------------------------------------------------

// ScaleLayerParams

// repeated uint64 shapeScale = 1;
inline int ScaleLayerParams::shapescale_size() const {
  return shapescale_.size();
}
inline void ScaleLayerParams::clear_shapescale() {
  shapescale_.Clear();
}
inline ::google::protobuf::uint64 ScaleLayerParams::shapescale(int index) const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.ScaleLayerParams.shapeScale)
  return shapescale_.Get(index);
}
inline void ScaleLayerParams::set_shapescale(int index, ::google::protobuf::uint64 value) {
  shapescale_.Set(index, value);
  // @@protoc_insertion_point(field_set:CoreML.Specification.ScaleLayerParams.shapeScale)
}
inline void ScaleLayerParams::add_shapescale(::google::protobuf::uint64 value) {
  shapescale_.Add(value);
  // @@protoc_insertion_point(field_add:CoreML.Specification.ScaleLayerParams.shapeScale)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
ScaleLayerParams::shapescale() const {
  // @@protoc_insertion_point(field_list:CoreML.Specification.ScaleLayerParams.shapeScale)
  return shapescale_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
ScaleLayerParams::mutable_shapescale() {
  // @@protoc_insertion_point(field_mutable_list:CoreML.Specification.ScaleLayerParams.shapeScale)
  return &shapescale_;
}

// .CoreML.Specification.WeightParams scale = 2;
inline bool ScaleLayerParams::has_scale() const {
  return this != internal_default_instance() && scale_ != NULL;
}
inline void ScaleLayerParams::clear_scale() {
  if (GetArenaNoVirtual() == NULL && scale_ != NULL) delete scale_;
  scale_ = NULL;
}
inline const ::CoreML::Specification::WeightParams& ScaleLayerParams::scale() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.ScaleLayerParams.scale)
  return scale_ != NULL ? *scale_
                         : *::CoreML::Specification::WeightParams::internal_default_instance();
}
inline ::CoreML::Specification::WeightParams* ScaleLayerParams::mutable_scale() {

  if (scale_ == NULL) {
    scale_ = new ::CoreML::Specification::WeightParams;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.ScaleLayerParams.scale)
  return scale_;
}
inline ::CoreML::Specification::WeightParams* ScaleLayerParams::release_scale() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.ScaleLayerParams.scale)

  ::CoreML::Specification::WeightParams* temp = scale_;
  scale_ = NULL;
  return temp;
}
inline void ScaleLayerParams::set_allocated_scale(::CoreML::Specification::WeightParams* scale) {
  delete scale_;
  scale_ = scale;
  if (scale) {

  } else {

  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.ScaleLayerParams.scale)
}

// bool hasBias = 3;
inline void ScaleLayerParams::clear_hasbias() {
  hasbias_ = false;
}
inline bool ScaleLayerParams::hasbias() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.ScaleLayerParams.hasBias)
  return hasbias_;
}
inline void ScaleLayerParams::set_hasbias(bool value) {

  hasbias_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.ScaleLayerParams.hasBias)
}

// repeated uint64 shapeBias = 4;
inline int ScaleLayerParams::shapebias_size() const {
  return shapebias_.size();
}
inline void ScaleLayerParams::clear_shapebias() {
  shapebias_.Clear();
}
inline ::google::protobuf::uint64 ScaleLayerParams::shapebias(int index) const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.ScaleLayerParams.shapeBias)
  return shapebias_.Get(index);
}
inline void ScaleLayerParams::set_shapebias(int index, ::google::protobuf::uint64 value) {
  shapebias_.Set(index, value);
  // @@protoc_insertion_point(field_set:CoreML.Specification.ScaleLayerParams.shapeBias)
}
inline void ScaleLayerParams::add_shapebias(::google::protobuf::uint64 value) {
  shapebias_.Add(value);
  // @@protoc_insertion_point(field_add:CoreML.Specification.ScaleLayerParams.shapeBias)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
ScaleLayerParams::shapebias() const {
  // @@protoc_insertion_point(field_list:CoreML.Specification.ScaleLayerParams.shapeBias)
  return shapebias_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
ScaleLayerParams::mutable_shapebias() {
  // @@protoc_insertion_point(field_mutable_list:CoreML.Specification.ScaleLayerParams.shapeBias)
  return &shapebias_;
}

// .CoreML.Specification.WeightParams bias = 5;
inline bool ScaleLayerParams::has_bias() const {
  return this != internal_default_instance() && bias_ != NULL;
}
inline void ScaleLayerParams::clear_bias() {
  if (GetArenaNoVirtual() == NULL && bias_ != NULL) delete bias_;
  bias_ = NULL;
}
inline const ::CoreML::Specification::WeightParams& ScaleLayerParams::bias() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.ScaleLayerParams.bias)
  return bias_ != NULL ? *bias_
                         : *::CoreML::Specification::WeightParams::internal_default_instance();
}
inline ::CoreML::Specification::WeightParams* ScaleLayerParams::mutable_bias() {

  if (bias_ == NULL) {
    bias_ = new ::CoreML::Specification::WeightParams;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.ScaleLayerParams.bias)
  return bias_;
}
inline ::CoreML::Specification::WeightParams* ScaleLayerParams::release_bias() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.ScaleLayerParams.bias)

  ::CoreML::Specification::WeightParams* temp = bias_;
  bias_ = NULL;
  return temp;
}
inline void ScaleLayerParams::set_allocated_bias(::CoreML::Specification::WeightParams* bias) {
  delete bias_;
  bias_ = bias;
  if (bias) {

  } else {

  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.ScaleLayerParams.bias)
}

// -------------------------------------------------------------------

// LoadConstantLayerParams

// repeated uint64 shape = 1;
inline int LoadConstantLayerParams::shape_size() const {
  return shape_.size();
}
inline void LoadConstantLayerParams::clear_shape() {
  shape_.Clear();
}
inline ::google::protobuf::uint64 LoadConstantLayerParams::shape(int index) const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.LoadConstantLayerParams.shape)
  return shape_.Get(index);
}
inline void LoadConstantLayerParams::set_shape(int index, ::google::protobuf::uint64 value) {
  shape_.Set(index, value);
  // @@protoc_insertion_point(field_set:CoreML.Specification.LoadConstantLayerParams.shape)
}
inline void LoadConstantLayerParams::add_shape(::google::protobuf::uint64 value) {
  shape_.Add(value);
  // @@protoc_insertion_point(field_add:CoreML.Specification.LoadConstantLayerParams.shape)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
LoadConstantLayerParams::shape() const {
  // @@protoc_insertion_point(field_list:CoreML.Specification.LoadConstantLayerParams.shape)
  return shape_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
LoadConstantLayerParams::mutable_shape() {
  // @@protoc_insertion_point(field_mutable_list:CoreML.Specification.LoadConstantLayerParams.shape)
  return &shape_;
}

// .CoreML.Specification.WeightParams data = 2;
inline bool LoadConstantLayerParams::has_data() const {
  return this != internal_default_instance() && data_ != NULL;
}
inline void LoadConstantLayerParams::clear_data() {
  if (GetArenaNoVirtual() == NULL && data_ != NULL) delete data_;
  data_ = NULL;
}
inline const ::CoreML::Specification::WeightParams& LoadConstantLayerParams::data() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.LoadConstantLayerParams.data)
  return data_ != NULL ? *data_
                         : *::CoreML::Specification::WeightParams::internal_default_instance();
}
inline ::CoreML::Specification::WeightParams* LoadConstantLayerParams::mutable_data() {

  if (data_ == NULL) {
    data_ = new ::CoreML::Specification::WeightParams;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.LoadConstantLayerParams.data)
  return data_;
}
inline ::CoreML::Specification::WeightParams* LoadConstantLayerParams::release_data() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.LoadConstantLayerParams.data)

  ::CoreML::Specification::WeightParams* temp = data_;
  data_ = NULL;
  return temp;
}
inline void LoadConstantLayerParams::set_allocated_data(::CoreML::Specification::WeightParams* data) {
  delete data_;
  data_ = data;
  if (data) {

  } else {

  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.LoadConstantLayerParams.data)
}

// -------------------------------------------------------------------

// L2NormalizeLayerParams

// float epsilon = 1;
inline void L2NormalizeLayerParams::clear_epsilon() {
  epsilon_ = 0;
}
inline float L2NormalizeLayerParams::epsilon() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.L2NormalizeLayerParams.epsilon)
  return epsilon_;
}
inline void L2NormalizeLayerParams::set_epsilon(float value) {

  epsilon_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.L2NormalizeLayerParams.epsilon)
}

// -------------------------------------------------------------------

// FlattenLayerParams

// .CoreML.Specification.FlattenLayerParams.FlattenOrder mode = 1;
inline void FlattenLayerParams::clear_mode() {
  mode_ = 0;
}
inline ::CoreML::Specification::FlattenLayerParams_FlattenOrder FlattenLayerParams::mode() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.FlattenLayerParams.mode)
  return static_cast< ::CoreML::Specification::FlattenLayerParams_FlattenOrder >(mode_);
}
inline void FlattenLayerParams::set_mode(::CoreML::Specification::FlattenLayerParams_FlattenOrder value) {

  mode_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.FlattenLayerParams.mode)
}

// -------------------------------------------------------------------

// ReshapeLayerParams

// repeated int64 targetShape = 1;
inline int ReshapeLayerParams::targetshape_size() const {
  return targetshape_.size();
}
inline void ReshapeLayerParams::clear_targetshape() {
  targetshape_.Clear();
}
inline ::google::protobuf::int64 ReshapeLayerParams::targetshape(int index) const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.ReshapeLayerParams.targetShape)
  return targetshape_.Get(index);
}
inline void ReshapeLayerParams::set_targetshape(int index, ::google::protobuf::int64 value) {
  targetshape_.Set(index, value);
  // @@protoc_insertion_point(field_set:CoreML.Specification.ReshapeLayerParams.targetShape)
}
inline void ReshapeLayerParams::add_targetshape(::google::protobuf::int64 value) {
  targetshape_.Add(value);
  // @@protoc_insertion_point(field_add:CoreML.Specification.ReshapeLayerParams.targetShape)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
ReshapeLayerParams::targetshape() const {
  // @@protoc_insertion_point(field_list:CoreML.Specification.ReshapeLayerParams.targetShape)
  return targetshape_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
ReshapeLayerParams::mutable_targetshape() {
  // @@protoc_insertion_point(field_mutable_list:CoreML.Specification.ReshapeLayerParams.targetShape)
  return &targetshape_;
}

// .CoreML.Specification.ReshapeLayerParams.ReshapeOrder mode = 2;
inline void ReshapeLayerParams::clear_mode() {
  mode_ = 0;
}
inline ::CoreML::Specification::ReshapeLayerParams_ReshapeOrder ReshapeLayerParams::mode() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.ReshapeLayerParams.mode)
  return static_cast< ::CoreML::Specification::ReshapeLayerParams_ReshapeOrder >(mode_);
}
inline void ReshapeLayerParams::set_mode(::CoreML::Specification::ReshapeLayerParams_ReshapeOrder value) {

  mode_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.ReshapeLayerParams.mode)
}

// -------------------------------------------------------------------

// PermuteLayerParams

// repeated uint64 axis = 1;
inline int PermuteLayerParams::axis_size() const {
  return axis_.size();
}
inline void PermuteLayerParams::clear_axis() {
  axis_.Clear();
}
inline ::google::protobuf::uint64 PermuteLayerParams::axis(int index) const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.PermuteLayerParams.axis)
  return axis_.Get(index);
}
inline void PermuteLayerParams::set_axis(int index, ::google::protobuf::uint64 value) {
  axis_.Set(index, value);
  // @@protoc_insertion_point(field_set:CoreML.Specification.PermuteLayerParams.axis)
}
inline void PermuteLayerParams::add_axis(::google::protobuf::uint64 value) {
  axis_.Add(value);
  // @@protoc_insertion_point(field_add:CoreML.Specification.PermuteLayerParams.axis)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
PermuteLayerParams::axis() const {
  // @@protoc_insertion_point(field_list:CoreML.Specification.PermuteLayerParams.axis)
  return axis_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
PermuteLayerParams::mutable_axis() {
  // @@protoc_insertion_point(field_mutable_list:CoreML.Specification.PermuteLayerParams.axis)
  return &axis_;
}

// -------------------------------------------------------------------

// ReorganizeDataLayerParams

// .CoreML.Specification.ReorganizeDataLayerParams.ReorganizationType mode = 1;
inline void ReorganizeDataLayerParams::clear_mode() {
  mode_ = 0;
}
inline ::CoreML::Specification::ReorganizeDataLayerParams_ReorganizationType ReorganizeDataLayerParams::mode() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.ReorganizeDataLayerParams.mode)
  return static_cast< ::CoreML::Specification::ReorganizeDataLayerParams_ReorganizationType >(mode_);
}
inline void ReorganizeDataLayerParams::set_mode(::CoreML::Specification::ReorganizeDataLayerParams_ReorganizationType value) {

  mode_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.ReorganizeDataLayerParams.mode)
}

// uint64 blockSize = 2;
inline void ReorganizeDataLayerParams::clear_blocksize() {
  blocksize_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 ReorganizeDataLayerParams::blocksize() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.ReorganizeDataLayerParams.blockSize)
  return blocksize_;
}
inline void ReorganizeDataLayerParams::set_blocksize(::google::protobuf::uint64 value) {

  blocksize_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.ReorganizeDataLayerParams.blockSize)
}

// -------------------------------------------------------------------

// SliceLayerParams

// int64 startIndex = 1;
inline void SliceLayerParams::clear_startindex() {
  startindex_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 SliceLayerParams::startindex() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.SliceLayerParams.startIndex)
  return startindex_;
}
inline void SliceLayerParams::set_startindex(::google::protobuf::int64 value) {

  startindex_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.SliceLayerParams.startIndex)
}

// int64 endIndex = 2;
inline void SliceLayerParams::clear_endindex() {
  endindex_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 SliceLayerParams::endindex() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.SliceLayerParams.endIndex)
  return endindex_;
}
inline void SliceLayerParams::set_endindex(::google::protobuf::int64 value) {

  endindex_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.SliceLayerParams.endIndex)
}

// uint64 stride = 3;
inline void SliceLayerParams::clear_stride() {
  stride_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 SliceLayerParams::stride() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.SliceLayerParams.stride)
  return stride_;
}
inline void SliceLayerParams::set_stride(::google::protobuf::uint64 value) {

  stride_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.SliceLayerParams.stride)
}

// .CoreML.Specification.SliceLayerParams.SliceAxis axis = 4;
inline void SliceLayerParams::clear_axis() {
  axis_ = 0;
}
inline ::CoreML::Specification::SliceLayerParams_SliceAxis SliceLayerParams::axis() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.SliceLayerParams.axis)
  return static_cast< ::CoreML::Specification::SliceLayerParams_SliceAxis >(axis_);
}
inline void SliceLayerParams::set_axis(::CoreML::Specification::SliceLayerParams_SliceAxis value) {

  axis_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.SliceLayerParams.axis)
}

// -------------------------------------------------------------------

// ReduceLayerParams

// .CoreML.Specification.ReduceLayerParams.ReduceOperation mode = 1;
inline void ReduceLayerParams::clear_mode() {
  mode_ = 0;
}
inline ::CoreML::Specification::ReduceLayerParams_ReduceOperation ReduceLayerParams::mode() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.ReduceLayerParams.mode)
  return static_cast< ::CoreML::Specification::ReduceLayerParams_ReduceOperation >(mode_);
}
inline void ReduceLayerParams::set_mode(::CoreML::Specification::ReduceLayerParams_ReduceOperation value) {

  mode_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.ReduceLayerParams.mode)
}

// float epsilon = 2;
inline void ReduceLayerParams::clear_epsilon() {
  epsilon_ = 0;
}
inline float ReduceLayerParams::epsilon() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.ReduceLayerParams.epsilon)
  return epsilon_;
}
inline void ReduceLayerParams::set_epsilon(float value) {

  epsilon_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.ReduceLayerParams.epsilon)
}

// .CoreML.Specification.ReduceLayerParams.ReduceAxis axis = 3;
inline void ReduceLayerParams::clear_axis() {
  axis_ = 0;
}
inline ::CoreML::Specification::ReduceLayerParams_ReduceAxis ReduceLayerParams::axis() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.ReduceLayerParams.axis)
  return static_cast< ::CoreML::Specification::ReduceLayerParams_ReduceAxis >(axis_);
}
inline void ReduceLayerParams::set_axis(::CoreML::Specification::ReduceLayerParams_ReduceAxis value) {

  axis_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.ReduceLayerParams.axis)
}

// -------------------------------------------------------------------

// CropLayerParams

// .CoreML.Specification.BorderAmounts cropAmounts = 1;
inline bool CropLayerParams::has_cropamounts() const {
  return this != internal_default_instance() && cropamounts_ != NULL;
}
inline void CropLayerParams::clear_cropamounts() {
  if (GetArenaNoVirtual() == NULL && cropamounts_ != NULL) delete cropamounts_;
  cropamounts_ = NULL;
}
inline const ::CoreML::Specification::BorderAmounts& CropLayerParams::cropamounts() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.CropLayerParams.cropAmounts)
  return cropamounts_ != NULL ? *cropamounts_
                         : *::CoreML::Specification::BorderAmounts::internal_default_instance();
}
inline ::CoreML::Specification::BorderAmounts* CropLayerParams::mutable_cropamounts() {

  if (cropamounts_ == NULL) {
    cropamounts_ = new ::CoreML::Specification::BorderAmounts;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.CropLayerParams.cropAmounts)
  return cropamounts_;
}
inline ::CoreML::Specification::BorderAmounts* CropLayerParams::release_cropamounts() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.CropLayerParams.cropAmounts)

  ::CoreML::Specification::BorderAmounts* temp = cropamounts_;
  cropamounts_ = NULL;
  return temp;
}
inline void CropLayerParams::set_allocated_cropamounts(::CoreML::Specification::BorderAmounts* cropamounts) {
  delete cropamounts_;
  cropamounts_ = cropamounts;
  if (cropamounts) {

  } else {

  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.CropLayerParams.cropAmounts)
}

// repeated uint64 offset = 5;
inline int CropLayerParams::offset_size() const {
  return offset_.size();
}
inline void CropLayerParams::clear_offset() {
  offset_.Clear();
}
inline ::google::protobuf::uint64 CropLayerParams::offset(int index) const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.CropLayerParams.offset)
  return offset_.Get(index);
}
inline void CropLayerParams::set_offset(int index, ::google::protobuf::uint64 value) {
  offset_.Set(index, value);
  // @@protoc_insertion_point(field_set:CoreML.Specification.CropLayerParams.offset)
}
inline void CropLayerParams::add_offset(::google::protobuf::uint64 value) {
  offset_.Add(value);
  // @@protoc_insertion_point(field_add:CoreML.Specification.CropLayerParams.offset)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
CropLayerParams::offset() const {
  // @@protoc_insertion_point(field_list:CoreML.Specification.CropLayerParams.offset)
  return offset_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
CropLayerParams::mutable_offset() {
  // @@protoc_insertion_point(field_mutable_list:CoreML.Specification.CropLayerParams.offset)
  return &offset_;
}

// -------------------------------------------------------------------

// AverageLayerParams

// -------------------------------------------------------------------

// MaxLayerParams

// -------------------------------------------------------------------

// MinLayerParams

// -------------------------------------------------------------------

// DotProductLayerParams

// bool cosineSimilarity = 1;
inline void DotProductLayerParams::clear_cosinesimilarity() {
  cosinesimilarity_ = false;
}
inline bool DotProductLayerParams::cosinesimilarity() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.DotProductLayerParams.cosineSimilarity)
  return cosinesimilarity_;
}
inline void DotProductLayerParams::set_cosinesimilarity(bool value) {

  cosinesimilarity_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.DotProductLayerParams.cosineSimilarity)
}

// -------------------------------------------------------------------

// MeanVarianceNormalizeLayerParams

// bool acrossChannels = 1;
inline void MeanVarianceNormalizeLayerParams::clear_acrosschannels() {
  acrosschannels_ = false;
}
inline bool MeanVarianceNormalizeLayerParams::acrosschannels() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.MeanVarianceNormalizeLayerParams.acrossChannels)
  return acrosschannels_;
}
inline void MeanVarianceNormalizeLayerParams::set_acrosschannels(bool value) {

  acrosschannels_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.MeanVarianceNormalizeLayerParams.acrossChannels)
}

// bool normalizeVariance = 2;
inline void MeanVarianceNormalizeLayerParams::clear_normalizevariance() {
  normalizevariance_ = false;
}
inline bool MeanVarianceNormalizeLayerParams::normalizevariance() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.MeanVarianceNormalizeLayerParams.normalizeVariance)
  return normalizevariance_;
}
inline void MeanVarianceNormalizeLayerParams::set_normalizevariance(bool value) {

  normalizevariance_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.MeanVarianceNormalizeLayerParams.normalizeVariance)
}

// float epsilon = 3;
inline void MeanVarianceNormalizeLayerParams::clear_epsilon() {
  epsilon_ = 0;
}
inline float MeanVarianceNormalizeLayerParams::epsilon() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.MeanVarianceNormalizeLayerParams.epsilon)
  return epsilon_;
}
inline void MeanVarianceNormalizeLayerParams::set_epsilon(float value) {

  epsilon_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.MeanVarianceNormalizeLayerParams.epsilon)
}

// -------------------------------------------------------------------

// SequenceRepeatLayerParams

// uint64 nRepetitions = 1;
inline void SequenceRepeatLayerParams::clear_nrepetitions() {
  nrepetitions_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 SequenceRepeatLayerParams::nrepetitions() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.SequenceRepeatLayerParams.nRepetitions)
  return nrepetitions_;
}
inline void SequenceRepeatLayerParams::set_nrepetitions(::google::protobuf::uint64 value) {

  nrepetitions_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.SequenceRepeatLayerParams.nRepetitions)
}

// -------------------------------------------------------------------

// SimpleRecurrentLayerParams

// uint64 inputVectorSize = 1;
inline void SimpleRecurrentLayerParams::clear_inputvectorsize() {
  inputvectorsize_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 SimpleRecurrentLayerParams::inputvectorsize() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.SimpleRecurrentLayerParams.inputVectorSize)
  return inputvectorsize_;
}
inline void SimpleRecurrentLayerParams::set_inputvectorsize(::google::protobuf::uint64 value) {

  inputvectorsize_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.SimpleRecurrentLayerParams.inputVectorSize)
}

// uint64 outputVectorSize = 2;
inline void SimpleRecurrentLayerParams::clear_outputvectorsize() {
  outputvectorsize_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 SimpleRecurrentLayerParams::outputvectorsize() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.SimpleRecurrentLayerParams.outputVectorSize)
  return outputvectorsize_;
}
inline void SimpleRecurrentLayerParams::set_outputvectorsize(::google::protobuf::uint64 value) {

  outputvectorsize_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.SimpleRecurrentLayerParams.outputVectorSize)
}

// .CoreML.Specification.ActivationParams activation = 10;
inline bool SimpleRecurrentLayerParams::has_activation() const {
  return this != internal_default_instance() && activation_ != NULL;
}
inline void SimpleRecurrentLayerParams::clear_activation() {
  if (GetArenaNoVirtual() == NULL && activation_ != NULL) delete activation_;
  activation_ = NULL;
}
inline const ::CoreML::Specification::ActivationParams& SimpleRecurrentLayerParams::activation() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.SimpleRecurrentLayerParams.activation)
  return activation_ != NULL ? *activation_
                         : *::CoreML::Specification::ActivationParams::internal_default_instance();
}
inline ::CoreML::Specification::ActivationParams* SimpleRecurrentLayerParams::mutable_activation() {

  if (activation_ == NULL) {
    activation_ = new ::CoreML::Specification::ActivationParams;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.SimpleRecurrentLayerParams.activation)
  return activation_;
}
inline ::CoreML::Specification::ActivationParams* SimpleRecurrentLayerParams::release_activation() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.SimpleRecurrentLayerParams.activation)

  ::CoreML::Specification::ActivationParams* temp = activation_;
  activation_ = NULL;
  return temp;
}
inline void SimpleRecurrentLayerParams::set_allocated_activation(::CoreML::Specification::ActivationParams* activation) {
  delete activation_;
  activation_ = activation;
  if (activation) {

  } else {

  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.SimpleRecurrentLayerParams.activation)
}

// bool sequenceOutput = 15;
inline void SimpleRecurrentLayerParams::clear_sequenceoutput() {
  sequenceoutput_ = false;
}
inline bool SimpleRecurrentLayerParams::sequenceoutput() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.SimpleRecurrentLayerParams.sequenceOutput)
  return sequenceoutput_;
}
inline void SimpleRecurrentLayerParams::set_sequenceoutput(bool value) {

  sequenceoutput_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.SimpleRecurrentLayerParams.sequenceOutput)
}

// bool hasBiasVector = 20;
inline void SimpleRecurrentLayerParams::clear_hasbiasvector() {
  hasbiasvector_ = false;
}
inline bool SimpleRecurrentLayerParams::hasbiasvector() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.SimpleRecurrentLayerParams.hasBiasVector)
  return hasbiasvector_;
}
inline void SimpleRecurrentLayerParams::set_hasbiasvector(bool value) {

  hasbiasvector_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.SimpleRecurrentLayerParams.hasBiasVector)
}

// .CoreML.Specification.WeightParams weightMatrix = 30;
inline bool SimpleRecurrentLayerParams::has_weightmatrix() const {
  return this != internal_default_instance() && weightmatrix_ != NULL;
}
inline void SimpleRecurrentLayerParams::clear_weightmatrix() {
  if (GetArenaNoVirtual() == NULL && weightmatrix_ != NULL) delete weightmatrix_;
  weightmatrix_ = NULL;
}
inline const ::CoreML::Specification::WeightParams& SimpleRecurrentLayerParams::weightmatrix() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.SimpleRecurrentLayerParams.weightMatrix)
  return weightmatrix_ != NULL ? *weightmatrix_
                         : *::CoreML::Specification::WeightParams::internal_default_instance();
}
inline ::CoreML::Specification::WeightParams* SimpleRecurrentLayerParams::mutable_weightmatrix() {

  if (weightmatrix_ == NULL) {
    weightmatrix_ = new ::CoreML::Specification::WeightParams;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.SimpleRecurrentLayerParams.weightMatrix)
  return weightmatrix_;
}
inline ::CoreML::Specification::WeightParams* SimpleRecurrentLayerParams::release_weightmatrix() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.SimpleRecurrentLayerParams.weightMatrix)

  ::CoreML::Specification::WeightParams* temp = weightmatrix_;
  weightmatrix_ = NULL;
  return temp;
}
inline void SimpleRecurrentLayerParams::set_allocated_weightmatrix(::CoreML::Specification::WeightParams* weightmatrix) {
  delete weightmatrix_;
  weightmatrix_ = weightmatrix;
  if (weightmatrix) {

  } else {

  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.SimpleRecurrentLayerParams.weightMatrix)
}

// .CoreML.Specification.WeightParams recursionMatrix = 31;
inline bool SimpleRecurrentLayerParams::has_recursionmatrix() const {
  return this != internal_default_instance() && recursionmatrix_ != NULL;
}
inline void SimpleRecurrentLayerParams::clear_recursionmatrix() {
  if (GetArenaNoVirtual() == NULL && recursionmatrix_ != NULL) delete recursionmatrix_;
  recursionmatrix_ = NULL;
}
inline const ::CoreML::Specification::WeightParams& SimpleRecurrentLayerParams::recursionmatrix() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.SimpleRecurrentLayerParams.recursionMatrix)
  return recursionmatrix_ != NULL ? *recursionmatrix_
                         : *::CoreML::Specification::WeightParams::internal_default_instance();
}
inline ::CoreML::Specification::WeightParams* SimpleRecurrentLayerParams::mutable_recursionmatrix() {

  if (recursionmatrix_ == NULL) {
    recursionmatrix_ = new ::CoreML::Specification::WeightParams;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.SimpleRecurrentLayerParams.recursionMatrix)
  return recursionmatrix_;
}
inline ::CoreML::Specification::WeightParams* SimpleRecurrentLayerParams::release_recursionmatrix() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.SimpleRecurrentLayerParams.recursionMatrix)

  ::CoreML::Specification::WeightParams* temp = recursionmatrix_;
  recursionmatrix_ = NULL;
  return temp;
}
inline void SimpleRecurrentLayerParams::set_allocated_recursionmatrix(::CoreML::Specification::WeightParams* recursionmatrix) {
  delete recursionmatrix_;
  recursionmatrix_ = recursionmatrix;
  if (recursionmatrix) {

  } else {

  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.SimpleRecurrentLayerParams.recursionMatrix)
}

// .CoreML.Specification.WeightParams biasVector = 32;
inline bool SimpleRecurrentLayerParams::has_biasvector() const {
  return this != internal_default_instance() && biasvector_ != NULL;
}
inline void SimpleRecurrentLayerParams::clear_biasvector() {
  if (GetArenaNoVirtual() == NULL && biasvector_ != NULL) delete biasvector_;
  biasvector_ = NULL;
}
inline const ::CoreML::Specification::WeightParams& SimpleRecurrentLayerParams::biasvector() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.SimpleRecurrentLayerParams.biasVector)
  return biasvector_ != NULL ? *biasvector_
                         : *::CoreML::Specification::WeightParams::internal_default_instance();
}
inline ::CoreML::Specification::WeightParams* SimpleRecurrentLayerParams::mutable_biasvector() {

  if (biasvector_ == NULL) {
    biasvector_ = new ::CoreML::Specification::WeightParams;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.SimpleRecurrentLayerParams.biasVector)
  return biasvector_;
}
inline ::CoreML::Specification::WeightParams* SimpleRecurrentLayerParams::release_biasvector() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.SimpleRecurrentLayerParams.biasVector)

  ::CoreML::Specification::WeightParams* temp = biasvector_;
  biasvector_ = NULL;
  return temp;
}
inline void SimpleRecurrentLayerParams::set_allocated_biasvector(::CoreML::Specification::WeightParams* biasvector) {
  delete biasvector_;
  biasvector_ = biasvector;
  if (biasvector) {

  } else {

  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.SimpleRecurrentLayerParams.biasVector)
}

// bool reverseInput = 100;
inline void SimpleRecurrentLayerParams::clear_reverseinput() {
  reverseinput_ = false;
}
inline bool SimpleRecurrentLayerParams::reverseinput() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.SimpleRecurrentLayerParams.reverseInput)
  return reverseinput_;
}
inline void SimpleRecurrentLayerParams::set_reverseinput(bool value) {

  reverseinput_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.SimpleRecurrentLayerParams.reverseInput)
}

// -------------------------------------------------------------------

// GRULayerParams

// uint64 inputVectorSize = 1;
inline void GRULayerParams::clear_inputvectorsize() {
  inputvectorsize_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 GRULayerParams::inputvectorsize() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.GRULayerParams.inputVectorSize)
  return inputvectorsize_;
}
inline void GRULayerParams::set_inputvectorsize(::google::protobuf::uint64 value) {

  inputvectorsize_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.GRULayerParams.inputVectorSize)
}

// uint64 outputVectorSize = 2;
inline void GRULayerParams::clear_outputvectorsize() {
  outputvectorsize_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 GRULayerParams::outputvectorsize() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.GRULayerParams.outputVectorSize)
  return outputvectorsize_;
}
inline void GRULayerParams::set_outputvectorsize(::google::protobuf::uint64 value) {

  outputvectorsize_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.GRULayerParams.outputVectorSize)
}

// repeated .CoreML.Specification.ActivationParams activations = 10;
inline int GRULayerParams::activations_size() const {
  return activations_.size();
}
inline void GRULayerParams::clear_activations() {
  activations_.Clear();
}
inline const ::CoreML::Specification::ActivationParams& GRULayerParams::activations(int index) const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.GRULayerParams.activations)
  return activations_.Get(index);
}
inline ::CoreML::Specification::ActivationParams* GRULayerParams::mutable_activations(int index) {
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.GRULayerParams.activations)
  return activations_.Mutable(index);
}
inline ::CoreML::Specification::ActivationParams* GRULayerParams::add_activations() {
  // @@protoc_insertion_point(field_add:CoreML.Specification.GRULayerParams.activations)
  return activations_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::ActivationParams >*
GRULayerParams::mutable_activations() {
  // @@protoc_insertion_point(field_mutable_list:CoreML.Specification.GRULayerParams.activations)
  return &activations_;
}
inline const ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::ActivationParams >&
GRULayerParams::activations() const {
  // @@protoc_insertion_point(field_list:CoreML.Specification.GRULayerParams.activations)
  return activations_;
}

// bool sequenceOutput = 15;
inline void GRULayerParams::clear_sequenceoutput() {
  sequenceoutput_ = false;
}
inline bool GRULayerParams::sequenceoutput() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.GRULayerParams.sequenceOutput)
  return sequenceoutput_;
}
inline void GRULayerParams::set_sequenceoutput(bool value) {

  sequenceoutput_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.GRULayerParams.sequenceOutput)
}

// bool hasBiasVectors = 20;
inline void GRULayerParams::clear_hasbiasvectors() {
  hasbiasvectors_ = false;
}
inline bool GRULayerParams::hasbiasvectors() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.GRULayerParams.hasBiasVectors)
  return hasbiasvectors_;
}
inline void GRULayerParams::set_hasbiasvectors(bool value) {

  hasbiasvectors_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.GRULayerParams.hasBiasVectors)
}

// .CoreML.Specification.WeightParams updateGateWeightMatrix = 30;
inline bool GRULayerParams::has_updategateweightmatrix() const {
  return this != internal_default_instance() && updategateweightmatrix_ != NULL;
}
inline void GRULayerParams::clear_updategateweightmatrix() {
  if (GetArenaNoVirtual() == NULL && updategateweightmatrix_ != NULL) delete updategateweightmatrix_;
  updategateweightmatrix_ = NULL;
}
inline const ::CoreML::Specification::WeightParams& GRULayerParams::updategateweightmatrix() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.GRULayerParams.updateGateWeightMatrix)
  return updategateweightmatrix_ != NULL ? *updategateweightmatrix_
                         : *::CoreML::Specification::WeightParams::internal_default_instance();
}
inline ::CoreML::Specification::WeightParams* GRULayerParams::mutable_updategateweightmatrix() {

  if (updategateweightmatrix_ == NULL) {
    updategateweightmatrix_ = new ::CoreML::Specification::WeightParams;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.GRULayerParams.updateGateWeightMatrix)
  return updategateweightmatrix_;
}
inline ::CoreML::Specification::WeightParams* GRULayerParams::release_updategateweightmatrix() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.GRULayerParams.updateGateWeightMatrix)

  ::CoreML::Specification::WeightParams* temp = updategateweightmatrix_;
  updategateweightmatrix_ = NULL;
  return temp;
}
inline void GRULayerParams::set_allocated_updategateweightmatrix(::CoreML::Specification::WeightParams* updategateweightmatrix) {
  delete updategateweightmatrix_;
  updategateweightmatrix_ = updategateweightmatrix;
  if (updategateweightmatrix) {

  } else {

  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.GRULayerParams.updateGateWeightMatrix)
}

// .CoreML.Specification.WeightParams resetGateWeightMatrix = 31;
inline bool GRULayerParams::has_resetgateweightmatrix() const {
  return this != internal_default_instance() && resetgateweightmatrix_ != NULL;
}
inline void GRULayerParams::clear_resetgateweightmatrix() {
  if (GetArenaNoVirtual() == NULL && resetgateweightmatrix_ != NULL) delete resetgateweightmatrix_;
  resetgateweightmatrix_ = NULL;
}
inline const ::CoreML::Specification::WeightParams& GRULayerParams::resetgateweightmatrix() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.GRULayerParams.resetGateWeightMatrix)
  return resetgateweightmatrix_ != NULL ? *resetgateweightmatrix_
                         : *::CoreML::Specification::WeightParams::internal_default_instance();
}
inline ::CoreML::Specification::WeightParams* GRULayerParams::mutable_resetgateweightmatrix() {

  if (resetgateweightmatrix_ == NULL) {
    resetgateweightmatrix_ = new ::CoreML::Specification::WeightParams;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.GRULayerParams.resetGateWeightMatrix)
  return resetgateweightmatrix_;
}
inline ::CoreML::Specification::WeightParams* GRULayerParams::release_resetgateweightmatrix() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.GRULayerParams.resetGateWeightMatrix)

  ::CoreML::Specification::WeightParams* temp = resetgateweightmatrix_;
  resetgateweightmatrix_ = NULL;
  return temp;
}
inline void GRULayerParams::set_allocated_resetgateweightmatrix(::CoreML::Specification::WeightParams* resetgateweightmatrix) {
  delete resetgateweightmatrix_;
  resetgateweightmatrix_ = resetgateweightmatrix;
  if (resetgateweightmatrix) {

  } else {

  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.GRULayerParams.resetGateWeightMatrix)
}

// .CoreML.Specification.WeightParams outputGateWeightMatrix = 32;
inline bool GRULayerParams::has_outputgateweightmatrix() const {
  return this != internal_default_instance() && outputgateweightmatrix_ != NULL;
}
inline void GRULayerParams::clear_outputgateweightmatrix() {
  if (GetArenaNoVirtual() == NULL && outputgateweightmatrix_ != NULL) delete outputgateweightmatrix_;
  outputgateweightmatrix_ = NULL;
}
inline const ::CoreML::Specification::WeightParams& GRULayerParams::outputgateweightmatrix() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.GRULayerParams.outputGateWeightMatrix)
  return outputgateweightmatrix_ != NULL ? *outputgateweightmatrix_
                         : *::CoreML::Specification::WeightParams::internal_default_instance();
}
inline ::CoreML::Specification::WeightParams* GRULayerParams::mutable_outputgateweightmatrix() {

  if (outputgateweightmatrix_ == NULL) {
    outputgateweightmatrix_ = new ::CoreML::Specification::WeightParams;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.GRULayerParams.outputGateWeightMatrix)
  return outputgateweightmatrix_;
}
inline ::CoreML::Specification::WeightParams* GRULayerParams::release_outputgateweightmatrix() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.GRULayerParams.outputGateWeightMatrix)

  ::CoreML::Specification::WeightParams* temp = outputgateweightmatrix_;
  outputgateweightmatrix_ = NULL;
  return temp;
}
inline void GRULayerParams::set_allocated_outputgateweightmatrix(::CoreML::Specification::WeightParams* outputgateweightmatrix) {
  delete outputgateweightmatrix_;
  outputgateweightmatrix_ = outputgateweightmatrix;
  if (outputgateweightmatrix) {

  } else {

  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.GRULayerParams.outputGateWeightMatrix)
}

// .CoreML.Specification.WeightParams updateGateRecursionMatrix = 50;
inline bool GRULayerParams::has_updategaterecursionmatrix() const {
  return this != internal_default_instance() && updategaterecursionmatrix_ != NULL;
}
inline void GRULayerParams::clear_updategaterecursionmatrix() {
  if (GetArenaNoVirtual() == NULL && updategaterecursionmatrix_ != NULL) delete updategaterecursionmatrix_;
  updategaterecursionmatrix_ = NULL;
}
inline const ::CoreML::Specification::WeightParams& GRULayerParams::updategaterecursionmatrix() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.GRULayerParams.updateGateRecursionMatrix)
  return updategaterecursionmatrix_ != NULL ? *updategaterecursionmatrix_
                         : *::CoreML::Specification::WeightParams::internal_default_instance();
}
inline ::CoreML::Specification::WeightParams* GRULayerParams::mutable_updategaterecursionmatrix() {

  if (updategaterecursionmatrix_ == NULL) {
    updategaterecursionmatrix_ = new ::CoreML::Specification::WeightParams;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.GRULayerParams.updateGateRecursionMatrix)
  return updategaterecursionmatrix_;
}
inline ::CoreML::Specification::WeightParams* GRULayerParams::release_updategaterecursionmatrix() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.GRULayerParams.updateGateRecursionMatrix)

  ::CoreML::Specification::WeightParams* temp = updategaterecursionmatrix_;
  updategaterecursionmatrix_ = NULL;
  return temp;
}
inline void GRULayerParams::set_allocated_updategaterecursionmatrix(::CoreML::Specification::WeightParams* updategaterecursionmatrix) {
  delete updategaterecursionmatrix_;
  updategaterecursionmatrix_ = updategaterecursionmatrix;
  if (updategaterecursionmatrix) {

  } else {

  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.GRULayerParams.updateGateRecursionMatrix)
}

// .CoreML.Specification.WeightParams resetGateRecursionMatrix = 51;
inline bool GRULayerParams::has_resetgaterecursionmatrix() const {
  return this != internal_default_instance() && resetgaterecursionmatrix_ != NULL;
}
inline void GRULayerParams::clear_resetgaterecursionmatrix() {
  if (GetArenaNoVirtual() == NULL && resetgaterecursionmatrix_ != NULL) delete resetgaterecursionmatrix_;
  resetgaterecursionmatrix_ = NULL;
}
inline const ::CoreML::Specification::WeightParams& GRULayerParams::resetgaterecursionmatrix() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.GRULayerParams.resetGateRecursionMatrix)
  return resetgaterecursionmatrix_ != NULL ? *resetgaterecursionmatrix_
                         : *::CoreML::Specification::WeightParams::internal_default_instance();
}
inline ::CoreML::Specification::WeightParams* GRULayerParams::mutable_resetgaterecursionmatrix() {

  if (resetgaterecursionmatrix_ == NULL) {
    resetgaterecursionmatrix_ = new ::CoreML::Specification::WeightParams;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.GRULayerParams.resetGateRecursionMatrix)
  return resetgaterecursionmatrix_;
}
inline ::CoreML::Specification::WeightParams* GRULayerParams::release_resetgaterecursionmatrix() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.GRULayerParams.resetGateRecursionMatrix)

  ::CoreML::Specification::WeightParams* temp = resetgaterecursionmatrix_;
  resetgaterecursionmatrix_ = NULL;
  return temp;
}
inline void GRULayerParams::set_allocated_resetgaterecursionmatrix(::CoreML::Specification::WeightParams* resetgaterecursionmatrix) {
  delete resetgaterecursionmatrix_;
  resetgaterecursionmatrix_ = resetgaterecursionmatrix;
  if (resetgaterecursionmatrix) {

  } else {

  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.GRULayerParams.resetGateRecursionMatrix)
}

// .CoreML.Specification.WeightParams outputGateRecursionMatrix = 52;
inline bool GRULayerParams::has_outputgaterecursionmatrix() const {
  return this != internal_default_instance() && outputgaterecursionmatrix_ != NULL;
}
inline void GRULayerParams::clear_outputgaterecursionmatrix() {
  if (GetArenaNoVirtual() == NULL && outputgaterecursionmatrix_ != NULL) delete outputgaterecursionmatrix_;
  outputgaterecursionmatrix_ = NULL;
}
inline const ::CoreML::Specification::WeightParams& GRULayerParams::outputgaterecursionmatrix() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.GRULayerParams.outputGateRecursionMatrix)
  return outputgaterecursionmatrix_ != NULL ? *outputgaterecursionmatrix_
                         : *::CoreML::Specification::WeightParams::internal_default_instance();
}
inline ::CoreML::Specification::WeightParams* GRULayerParams::mutable_outputgaterecursionmatrix() {

  if (outputgaterecursionmatrix_ == NULL) {
    outputgaterecursionmatrix_ = new ::CoreML::Specification::WeightParams;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.GRULayerParams.outputGateRecursionMatrix)
  return outputgaterecursionmatrix_;
}
inline ::CoreML::Specification::WeightParams* GRULayerParams::release_outputgaterecursionmatrix() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.GRULayerParams.outputGateRecursionMatrix)

  ::CoreML::Specification::WeightParams* temp = outputgaterecursionmatrix_;
  outputgaterecursionmatrix_ = NULL;
  return temp;
}
inline void GRULayerParams::set_allocated_outputgaterecursionmatrix(::CoreML::Specification::WeightParams* outputgaterecursionmatrix) {
  delete outputgaterecursionmatrix_;
  outputgaterecursionmatrix_ = outputgaterecursionmatrix;
  if (outputgaterecursionmatrix) {

  } else {

  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.GRULayerParams.outputGateRecursionMatrix)
}

// .CoreML.Specification.WeightParams updateGateBiasVector = 70;
inline bool GRULayerParams::has_updategatebiasvector() const {
  return this != internal_default_instance() && updategatebiasvector_ != NULL;
}
inline void GRULayerParams::clear_updategatebiasvector() {
  if (GetArenaNoVirtual() == NULL && updategatebiasvector_ != NULL) delete updategatebiasvector_;
  updategatebiasvector_ = NULL;
}
inline const ::CoreML::Specification::WeightParams& GRULayerParams::updategatebiasvector() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.GRULayerParams.updateGateBiasVector)
  return updategatebiasvector_ != NULL ? *updategatebiasvector_
                         : *::CoreML::Specification::WeightParams::internal_default_instance();
}
inline ::CoreML::Specification::WeightParams* GRULayerParams::mutable_updategatebiasvector() {

  if (updategatebiasvector_ == NULL) {
    updategatebiasvector_ = new ::CoreML::Specification::WeightParams;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.GRULayerParams.updateGateBiasVector)
  return updategatebiasvector_;
}
inline ::CoreML::Specification::WeightParams* GRULayerParams::release_updategatebiasvector() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.GRULayerParams.updateGateBiasVector)

  ::CoreML::Specification::WeightParams* temp = updategatebiasvector_;
  updategatebiasvector_ = NULL;
  return temp;
}
inline void GRULayerParams::set_allocated_updategatebiasvector(::CoreML::Specification::WeightParams* updategatebiasvector) {
  delete updategatebiasvector_;
  updategatebiasvector_ = updategatebiasvector;
  if (updategatebiasvector) {

  } else {

  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.GRULayerParams.updateGateBiasVector)
}

// .CoreML.Specification.WeightParams resetGateBiasVector = 71;
inline bool GRULayerParams::has_resetgatebiasvector() const {
  return this != internal_default_instance() && resetgatebiasvector_ != NULL;
}
inline void GRULayerParams::clear_resetgatebiasvector() {
  if (GetArenaNoVirtual() == NULL && resetgatebiasvector_ != NULL) delete resetgatebiasvector_;
  resetgatebiasvector_ = NULL;
}
inline const ::CoreML::Specification::WeightParams& GRULayerParams::resetgatebiasvector() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.GRULayerParams.resetGateBiasVector)
  return resetgatebiasvector_ != NULL ? *resetgatebiasvector_
                         : *::CoreML::Specification::WeightParams::internal_default_instance();
}
inline ::CoreML::Specification::WeightParams* GRULayerParams::mutable_resetgatebiasvector() {

  if (resetgatebiasvector_ == NULL) {
    resetgatebiasvector_ = new ::CoreML::Specification::WeightParams;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.GRULayerParams.resetGateBiasVector)
  return resetgatebiasvector_;
}
inline ::CoreML::Specification::WeightParams* GRULayerParams::release_resetgatebiasvector() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.GRULayerParams.resetGateBiasVector)

  ::CoreML::Specification::WeightParams* temp = resetgatebiasvector_;
  resetgatebiasvector_ = NULL;
  return temp;
}
inline void GRULayerParams::set_allocated_resetgatebiasvector(::CoreML::Specification::WeightParams* resetgatebiasvector) {
  delete resetgatebiasvector_;
  resetgatebiasvector_ = resetgatebiasvector;
  if (resetgatebiasvector) {

  } else {

  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.GRULayerParams.resetGateBiasVector)
}

// .CoreML.Specification.WeightParams outputGateBiasVector = 72;
inline bool GRULayerParams::has_outputgatebiasvector() const {
  return this != internal_default_instance() && outputgatebiasvector_ != NULL;
}
inline void GRULayerParams::clear_outputgatebiasvector() {
  if (GetArenaNoVirtual() == NULL && outputgatebiasvector_ != NULL) delete outputgatebiasvector_;
  outputgatebiasvector_ = NULL;
}
inline const ::CoreML::Specification::WeightParams& GRULayerParams::outputgatebiasvector() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.GRULayerParams.outputGateBiasVector)
  return outputgatebiasvector_ != NULL ? *outputgatebiasvector_
                         : *::CoreML::Specification::WeightParams::internal_default_instance();
}
inline ::CoreML::Specification::WeightParams* GRULayerParams::mutable_outputgatebiasvector() {

  if (outputgatebiasvector_ == NULL) {
    outputgatebiasvector_ = new ::CoreML::Specification::WeightParams;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.GRULayerParams.outputGateBiasVector)
  return outputgatebiasvector_;
}
inline ::CoreML::Specification::WeightParams* GRULayerParams::release_outputgatebiasvector() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.GRULayerParams.outputGateBiasVector)

  ::CoreML::Specification::WeightParams* temp = outputgatebiasvector_;
  outputgatebiasvector_ = NULL;
  return temp;
}
inline void GRULayerParams::set_allocated_outputgatebiasvector(::CoreML::Specification::WeightParams* outputgatebiasvector) {
  delete outputgatebiasvector_;
  outputgatebiasvector_ = outputgatebiasvector;
  if (outputgatebiasvector) {

  } else {

  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.GRULayerParams.outputGateBiasVector)
}

// bool reverseInput = 100;
inline void GRULayerParams::clear_reverseinput() {
  reverseinput_ = false;
}
inline bool GRULayerParams::reverseinput() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.GRULayerParams.reverseInput)
  return reverseinput_;
}
inline void GRULayerParams::set_reverseinput(bool value) {

  reverseinput_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.GRULayerParams.reverseInput)
}

// -------------------------------------------------------------------

// LSTMParams

// bool sequenceOutput = 10;
inline void LSTMParams::clear_sequenceoutput() {
  sequenceoutput_ = false;
}
inline bool LSTMParams::sequenceoutput() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.LSTMParams.sequenceOutput)
  return sequenceoutput_;
}
inline void LSTMParams::set_sequenceoutput(bool value) {

  sequenceoutput_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.LSTMParams.sequenceOutput)
}

// bool hasBiasVectors = 20;
inline void LSTMParams::clear_hasbiasvectors() {
  hasbiasvectors_ = false;
}
inline bool LSTMParams::hasbiasvectors() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.LSTMParams.hasBiasVectors)
  return hasbiasvectors_;
}
inline void LSTMParams::set_hasbiasvectors(bool value) {

  hasbiasvectors_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.LSTMParams.hasBiasVectors)
}

// bool forgetBias = 30;
inline void LSTMParams::clear_forgetbias() {
  forgetbias_ = false;
}
inline bool LSTMParams::forgetbias() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.LSTMParams.forgetBias)
  return forgetbias_;
}
inline void LSTMParams::set_forgetbias(bool value) {

  forgetbias_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.LSTMParams.forgetBias)
}

// bool hasPeepholeVectors = 40;
inline void LSTMParams::clear_haspeepholevectors() {
  haspeepholevectors_ = false;
}
inline bool LSTMParams::haspeepholevectors() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.LSTMParams.hasPeepholeVectors)
  return haspeepholevectors_;
}
inline void LSTMParams::set_haspeepholevectors(bool value) {

  haspeepholevectors_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.LSTMParams.hasPeepholeVectors)
}

// bool coupledInputAndForgetGate = 50;
inline void LSTMParams::clear_coupledinputandforgetgate() {
  coupledinputandforgetgate_ = false;
}
inline bool LSTMParams::coupledinputandforgetgate() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.LSTMParams.coupledInputAndForgetGate)
  return coupledinputandforgetgate_;
}
inline void LSTMParams::set_coupledinputandforgetgate(bool value) {

  coupledinputandforgetgate_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.LSTMParams.coupledInputAndForgetGate)
}

// float cellClipThreshold = 60;
inline void LSTMParams::clear_cellclipthreshold() {
  cellclipthreshold_ = 0;
}
inline float LSTMParams::cellclipthreshold() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.LSTMParams.cellClipThreshold)
  return cellclipthreshold_;
}
inline void LSTMParams::set_cellclipthreshold(float value) {

  cellclipthreshold_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.LSTMParams.cellClipThreshold)
}

// -------------------------------------------------------------------

// LSTMWeightParams

// .CoreML.Specification.WeightParams inputGateWeightMatrix = 1;
inline bool LSTMWeightParams::has_inputgateweightmatrix() const {
  return this != internal_default_instance() && inputgateweightmatrix_ != NULL;
}
inline void LSTMWeightParams::clear_inputgateweightmatrix() {
  if (GetArenaNoVirtual() == NULL && inputgateweightmatrix_ != NULL) delete inputgateweightmatrix_;
  inputgateweightmatrix_ = NULL;
}
inline const ::CoreML::Specification::WeightParams& LSTMWeightParams::inputgateweightmatrix() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.LSTMWeightParams.inputGateWeightMatrix)
  return inputgateweightmatrix_ != NULL ? *inputgateweightmatrix_
                         : *::CoreML::Specification::WeightParams::internal_default_instance();
}
inline ::CoreML::Specification::WeightParams* LSTMWeightParams::mutable_inputgateweightmatrix() {

  if (inputgateweightmatrix_ == NULL) {
    inputgateweightmatrix_ = new ::CoreML::Specification::WeightParams;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.LSTMWeightParams.inputGateWeightMatrix)
  return inputgateweightmatrix_;
}
inline ::CoreML::Specification::WeightParams* LSTMWeightParams::release_inputgateweightmatrix() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.LSTMWeightParams.inputGateWeightMatrix)

  ::CoreML::Specification::WeightParams* temp = inputgateweightmatrix_;
  inputgateweightmatrix_ = NULL;
  return temp;
}
inline void LSTMWeightParams::set_allocated_inputgateweightmatrix(::CoreML::Specification::WeightParams* inputgateweightmatrix) {
  delete inputgateweightmatrix_;
  inputgateweightmatrix_ = inputgateweightmatrix;
  if (inputgateweightmatrix) {

  } else {

  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.LSTMWeightParams.inputGateWeightMatrix)
}

// .CoreML.Specification.WeightParams forgetGateWeightMatrix = 2;
inline bool LSTMWeightParams::has_forgetgateweightmatrix() const {
  return this != internal_default_instance() && forgetgateweightmatrix_ != NULL;
}
inline void LSTMWeightParams::clear_forgetgateweightmatrix() {
  if (GetArenaNoVirtual() == NULL && forgetgateweightmatrix_ != NULL) delete forgetgateweightmatrix_;
  forgetgateweightmatrix_ = NULL;
}
inline const ::CoreML::Specification::WeightParams& LSTMWeightParams::forgetgateweightmatrix() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.LSTMWeightParams.forgetGateWeightMatrix)
  return forgetgateweightmatrix_ != NULL ? *forgetgateweightmatrix_
                         : *::CoreML::Specification::WeightParams::internal_default_instance();
}
inline ::CoreML::Specification::WeightParams* LSTMWeightParams::mutable_forgetgateweightmatrix() {

  if (forgetgateweightmatrix_ == NULL) {
    forgetgateweightmatrix_ = new ::CoreML::Specification::WeightParams;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.LSTMWeightParams.forgetGateWeightMatrix)
  return forgetgateweightmatrix_;
}
inline ::CoreML::Specification::WeightParams* LSTMWeightParams::release_forgetgateweightmatrix() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.LSTMWeightParams.forgetGateWeightMatrix)

  ::CoreML::Specification::WeightParams* temp = forgetgateweightmatrix_;
  forgetgateweightmatrix_ = NULL;
  return temp;
}
inline void LSTMWeightParams::set_allocated_forgetgateweightmatrix(::CoreML::Specification::WeightParams* forgetgateweightmatrix) {
  delete forgetgateweightmatrix_;
  forgetgateweightmatrix_ = forgetgateweightmatrix;
  if (forgetgateweightmatrix) {

  } else {

  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.LSTMWeightParams.forgetGateWeightMatrix)
}

// .CoreML.Specification.WeightParams blockInputWeightMatrix = 3;
inline bool LSTMWeightParams::has_blockinputweightmatrix() const {
  return this != internal_default_instance() && blockinputweightmatrix_ != NULL;
}
inline void LSTMWeightParams::clear_blockinputweightmatrix() {
  if (GetArenaNoVirtual() == NULL && blockinputweightmatrix_ != NULL) delete blockinputweightmatrix_;
  blockinputweightmatrix_ = NULL;
}
inline const ::CoreML::Specification::WeightParams& LSTMWeightParams::blockinputweightmatrix() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.LSTMWeightParams.blockInputWeightMatrix)
  return blockinputweightmatrix_ != NULL ? *blockinputweightmatrix_
                         : *::CoreML::Specification::WeightParams::internal_default_instance();
}
inline ::CoreML::Specification::WeightParams* LSTMWeightParams::mutable_blockinputweightmatrix() {

  if (blockinputweightmatrix_ == NULL) {
    blockinputweightmatrix_ = new ::CoreML::Specification::WeightParams;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.LSTMWeightParams.blockInputWeightMatrix)
  return blockinputweightmatrix_;
}
inline ::CoreML::Specification::WeightParams* LSTMWeightParams::release_blockinputweightmatrix() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.LSTMWeightParams.blockInputWeightMatrix)

  ::CoreML::Specification::WeightParams* temp = blockinputweightmatrix_;
  blockinputweightmatrix_ = NULL;
  return temp;
}
inline void LSTMWeightParams::set_allocated_blockinputweightmatrix(::CoreML::Specification::WeightParams* blockinputweightmatrix) {
  delete blockinputweightmatrix_;
  blockinputweightmatrix_ = blockinputweightmatrix;
  if (blockinputweightmatrix) {

  } else {

  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.LSTMWeightParams.blockInputWeightMatrix)
}

// .CoreML.Specification.WeightParams outputGateWeightMatrix = 4;
inline bool LSTMWeightParams::has_outputgateweightmatrix() const {
  return this != internal_default_instance() && outputgateweightmatrix_ != NULL;
}
inline void LSTMWeightParams::clear_outputgateweightmatrix() {
  if (GetArenaNoVirtual() == NULL && outputgateweightmatrix_ != NULL) delete outputgateweightmatrix_;
  outputgateweightmatrix_ = NULL;
}
inline const ::CoreML::Specification::WeightParams& LSTMWeightParams::outputgateweightmatrix() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.LSTMWeightParams.outputGateWeightMatrix)
  return outputgateweightmatrix_ != NULL ? *outputgateweightmatrix_
                         : *::CoreML::Specification::WeightParams::internal_default_instance();
}
inline ::CoreML::Specification::WeightParams* LSTMWeightParams::mutable_outputgateweightmatrix() {

  if (outputgateweightmatrix_ == NULL) {
    outputgateweightmatrix_ = new ::CoreML::Specification::WeightParams;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.LSTMWeightParams.outputGateWeightMatrix)
  return outputgateweightmatrix_;
}
inline ::CoreML::Specification::WeightParams* LSTMWeightParams::release_outputgateweightmatrix() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.LSTMWeightParams.outputGateWeightMatrix)

  ::CoreML::Specification::WeightParams* temp = outputgateweightmatrix_;
  outputgateweightmatrix_ = NULL;
  return temp;
}
inline void LSTMWeightParams::set_allocated_outputgateweightmatrix(::CoreML::Specification::WeightParams* outputgateweightmatrix) {
  delete outputgateweightmatrix_;
  outputgateweightmatrix_ = outputgateweightmatrix;
  if (outputgateweightmatrix) {

  } else {

  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.LSTMWeightParams.outputGateWeightMatrix)
}

// .CoreML.Specification.WeightParams inputGateRecursionMatrix = 20;
inline bool LSTMWeightParams::has_inputgaterecursionmatrix() const {
  return this != internal_default_instance() && inputgaterecursionmatrix_ != NULL;
}
inline void LSTMWeightParams::clear_inputgaterecursionmatrix() {
  if (GetArenaNoVirtual() == NULL && inputgaterecursionmatrix_ != NULL) delete inputgaterecursionmatrix_;
  inputgaterecursionmatrix_ = NULL;
}
inline const ::CoreML::Specification::WeightParams& LSTMWeightParams::inputgaterecursionmatrix() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.LSTMWeightParams.inputGateRecursionMatrix)
  return inputgaterecursionmatrix_ != NULL ? *inputgaterecursionmatrix_
                         : *::CoreML::Specification::WeightParams::internal_default_instance();
}
inline ::CoreML::Specification::WeightParams* LSTMWeightParams::mutable_inputgaterecursionmatrix() {

  if (inputgaterecursionmatrix_ == NULL) {
    inputgaterecursionmatrix_ = new ::CoreML::Specification::WeightParams;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.LSTMWeightParams.inputGateRecursionMatrix)
  return inputgaterecursionmatrix_;
}
inline ::CoreML::Specification::WeightParams* LSTMWeightParams::release_inputgaterecursionmatrix() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.LSTMWeightParams.inputGateRecursionMatrix)

  ::CoreML::Specification::WeightParams* temp = inputgaterecursionmatrix_;
  inputgaterecursionmatrix_ = NULL;
  return temp;
}
inline void LSTMWeightParams::set_allocated_inputgaterecursionmatrix(::CoreML::Specification::WeightParams* inputgaterecursionmatrix) {
  delete inputgaterecursionmatrix_;
  inputgaterecursionmatrix_ = inputgaterecursionmatrix;
  if (inputgaterecursionmatrix) {

  } else {

  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.LSTMWeightParams.inputGateRecursionMatrix)
}

// .CoreML.Specification.WeightParams forgetGateRecursionMatrix = 21;
inline bool LSTMWeightParams::has_forgetgaterecursionmatrix() const {
  return this != internal_default_instance() && forgetgaterecursionmatrix_ != NULL;
}
inline void LSTMWeightParams::clear_forgetgaterecursionmatrix() {
  if (GetArenaNoVirtual() == NULL && forgetgaterecursionmatrix_ != NULL) delete forgetgaterecursionmatrix_;
  forgetgaterecursionmatrix_ = NULL;
}
inline const ::CoreML::Specification::WeightParams& LSTMWeightParams::forgetgaterecursionmatrix() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.LSTMWeightParams.forgetGateRecursionMatrix)
  return forgetgaterecursionmatrix_ != NULL ? *forgetgaterecursionmatrix_
                         : *::CoreML::Specification::WeightParams::internal_default_instance();
}
inline ::CoreML::Specification::WeightParams* LSTMWeightParams::mutable_forgetgaterecursionmatrix() {

  if (forgetgaterecursionmatrix_ == NULL) {
    forgetgaterecursionmatrix_ = new ::CoreML::Specification::WeightParams;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.LSTMWeightParams.forgetGateRecursionMatrix)
  return forgetgaterecursionmatrix_;
}
inline ::CoreML::Specification::WeightParams* LSTMWeightParams::release_forgetgaterecursionmatrix() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.LSTMWeightParams.forgetGateRecursionMatrix)

  ::CoreML::Specification::WeightParams* temp = forgetgaterecursionmatrix_;
  forgetgaterecursionmatrix_ = NULL;
  return temp;
}
inline void LSTMWeightParams::set_allocated_forgetgaterecursionmatrix(::CoreML::Specification::WeightParams* forgetgaterecursionmatrix) {
  delete forgetgaterecursionmatrix_;
  forgetgaterecursionmatrix_ = forgetgaterecursionmatrix;
  if (forgetgaterecursionmatrix) {

  } else {

  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.LSTMWeightParams.forgetGateRecursionMatrix)
}

// .CoreML.Specification.WeightParams blockInputRecursionMatrix = 22;
inline bool LSTMWeightParams::has_blockinputrecursionmatrix() const {
  return this != internal_default_instance() && blockinputrecursionmatrix_ != NULL;
}
inline void LSTMWeightParams::clear_blockinputrecursionmatrix() {
  if (GetArenaNoVirtual() == NULL && blockinputrecursionmatrix_ != NULL) delete blockinputrecursionmatrix_;
  blockinputrecursionmatrix_ = NULL;
}
inline const ::CoreML::Specification::WeightParams& LSTMWeightParams::blockinputrecursionmatrix() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.LSTMWeightParams.blockInputRecursionMatrix)
  return blockinputrecursionmatrix_ != NULL ? *blockinputrecursionmatrix_
                         : *::CoreML::Specification::WeightParams::internal_default_instance();
}
inline ::CoreML::Specification::WeightParams* LSTMWeightParams::mutable_blockinputrecursionmatrix() {

  if (blockinputrecursionmatrix_ == NULL) {
    blockinputrecursionmatrix_ = new ::CoreML::Specification::WeightParams;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.LSTMWeightParams.blockInputRecursionMatrix)
  return blockinputrecursionmatrix_;
}
inline ::CoreML::Specification::WeightParams* LSTMWeightParams::release_blockinputrecursionmatrix() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.LSTMWeightParams.blockInputRecursionMatrix)

  ::CoreML::Specification::WeightParams* temp = blockinputrecursionmatrix_;
  blockinputrecursionmatrix_ = NULL;
  return temp;
}
inline void LSTMWeightParams::set_allocated_blockinputrecursionmatrix(::CoreML::Specification::WeightParams* blockinputrecursionmatrix) {
  delete blockinputrecursionmatrix_;
  blockinputrecursionmatrix_ = blockinputrecursionmatrix;
  if (blockinputrecursionmatrix) {

  } else {

  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.LSTMWeightParams.blockInputRecursionMatrix)
}

// .CoreML.Specification.WeightParams outputGateRecursionMatrix = 23;
inline bool LSTMWeightParams::has_outputgaterecursionmatrix() const {
  return this != internal_default_instance() && outputgaterecursionmatrix_ != NULL;
}
inline void LSTMWeightParams::clear_outputgaterecursionmatrix() {
  if (GetArenaNoVirtual() == NULL && outputgaterecursionmatrix_ != NULL) delete outputgaterecursionmatrix_;
  outputgaterecursionmatrix_ = NULL;
}
inline const ::CoreML::Specification::WeightParams& LSTMWeightParams::outputgaterecursionmatrix() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.LSTMWeightParams.outputGateRecursionMatrix)
  return outputgaterecursionmatrix_ != NULL ? *outputgaterecursionmatrix_
                         : *::CoreML::Specification::WeightParams::internal_default_instance();
}
inline ::CoreML::Specification::WeightParams* LSTMWeightParams::mutable_outputgaterecursionmatrix() {

  if (outputgaterecursionmatrix_ == NULL) {
    outputgaterecursionmatrix_ = new ::CoreML::Specification::WeightParams;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.LSTMWeightParams.outputGateRecursionMatrix)
  return outputgaterecursionmatrix_;
}
inline ::CoreML::Specification::WeightParams* LSTMWeightParams::release_outputgaterecursionmatrix() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.LSTMWeightParams.outputGateRecursionMatrix)

  ::CoreML::Specification::WeightParams* temp = outputgaterecursionmatrix_;
  outputgaterecursionmatrix_ = NULL;
  return temp;
}
inline void LSTMWeightParams::set_allocated_outputgaterecursionmatrix(::CoreML::Specification::WeightParams* outputgaterecursionmatrix) {
  delete outputgaterecursionmatrix_;
  outputgaterecursionmatrix_ = outputgaterecursionmatrix;
  if (outputgaterecursionmatrix) {

  } else {

  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.LSTMWeightParams.outputGateRecursionMatrix)
}

// .CoreML.Specification.WeightParams inputGateBiasVector = 40;
inline bool LSTMWeightParams::has_inputgatebiasvector() const {
  return this != internal_default_instance() && inputgatebiasvector_ != NULL;
}
inline void LSTMWeightParams::clear_inputgatebiasvector() {
  if (GetArenaNoVirtual() == NULL && inputgatebiasvector_ != NULL) delete inputgatebiasvector_;
  inputgatebiasvector_ = NULL;
}
inline const ::CoreML::Specification::WeightParams& LSTMWeightParams::inputgatebiasvector() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.LSTMWeightParams.inputGateBiasVector)
  return inputgatebiasvector_ != NULL ? *inputgatebiasvector_
                         : *::CoreML::Specification::WeightParams::internal_default_instance();
}
inline ::CoreML::Specification::WeightParams* LSTMWeightParams::mutable_inputgatebiasvector() {

  if (inputgatebiasvector_ == NULL) {
    inputgatebiasvector_ = new ::CoreML::Specification::WeightParams;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.LSTMWeightParams.inputGateBiasVector)
  return inputgatebiasvector_;
}
inline ::CoreML::Specification::WeightParams* LSTMWeightParams::release_inputgatebiasvector() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.LSTMWeightParams.inputGateBiasVector)

  ::CoreML::Specification::WeightParams* temp = inputgatebiasvector_;
  inputgatebiasvector_ = NULL;
  return temp;
}
inline void LSTMWeightParams::set_allocated_inputgatebiasvector(::CoreML::Specification::WeightParams* inputgatebiasvector) {
  delete inputgatebiasvector_;
  inputgatebiasvector_ = inputgatebiasvector;
  if (inputgatebiasvector) {

  } else {

  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.LSTMWeightParams.inputGateBiasVector)
}

// .CoreML.Specification.WeightParams forgetGateBiasVector = 41;
inline bool LSTMWeightParams::has_forgetgatebiasvector() const {
  return this != internal_default_instance() && forgetgatebiasvector_ != NULL;
}
inline void LSTMWeightParams::clear_forgetgatebiasvector() {
  if (GetArenaNoVirtual() == NULL && forgetgatebiasvector_ != NULL) delete forgetgatebiasvector_;
  forgetgatebiasvector_ = NULL;
}
inline const ::CoreML::Specification::WeightParams& LSTMWeightParams::forgetgatebiasvector() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.LSTMWeightParams.forgetGateBiasVector)
  return forgetgatebiasvector_ != NULL ? *forgetgatebiasvector_
                         : *::CoreML::Specification::WeightParams::internal_default_instance();
}
inline ::CoreML::Specification::WeightParams* LSTMWeightParams::mutable_forgetgatebiasvector() {

  if (forgetgatebiasvector_ == NULL) {
    forgetgatebiasvector_ = new ::CoreML::Specification::WeightParams;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.LSTMWeightParams.forgetGateBiasVector)
  return forgetgatebiasvector_;
}
inline ::CoreML::Specification::WeightParams* LSTMWeightParams::release_forgetgatebiasvector() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.LSTMWeightParams.forgetGateBiasVector)

  ::CoreML::Specification::WeightParams* temp = forgetgatebiasvector_;
  forgetgatebiasvector_ = NULL;
  return temp;
}
inline void LSTMWeightParams::set_allocated_forgetgatebiasvector(::CoreML::Specification::WeightParams* forgetgatebiasvector) {
  delete forgetgatebiasvector_;
  forgetgatebiasvector_ = forgetgatebiasvector;
  if (forgetgatebiasvector) {

  } else {

  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.LSTMWeightParams.forgetGateBiasVector)
}

// .CoreML.Specification.WeightParams blockInputBiasVector = 42;
inline bool LSTMWeightParams::has_blockinputbiasvector() const {
  return this != internal_default_instance() && blockinputbiasvector_ != NULL;
}
inline void LSTMWeightParams::clear_blockinputbiasvector() {
  if (GetArenaNoVirtual() == NULL && blockinputbiasvector_ != NULL) delete blockinputbiasvector_;
  blockinputbiasvector_ = NULL;
}
inline const ::CoreML::Specification::WeightParams& LSTMWeightParams::blockinputbiasvector() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.LSTMWeightParams.blockInputBiasVector)
  return blockinputbiasvector_ != NULL ? *blockinputbiasvector_
                         : *::CoreML::Specification::WeightParams::internal_default_instance();
}
inline ::CoreML::Specification::WeightParams* LSTMWeightParams::mutable_blockinputbiasvector() {

  if (blockinputbiasvector_ == NULL) {
    blockinputbiasvector_ = new ::CoreML::Specification::WeightParams;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.LSTMWeightParams.blockInputBiasVector)
  return blockinputbiasvector_;
}
inline ::CoreML::Specification::WeightParams* LSTMWeightParams::release_blockinputbiasvector() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.LSTMWeightParams.blockInputBiasVector)

  ::CoreML::Specification::WeightParams* temp = blockinputbiasvector_;
  blockinputbiasvector_ = NULL;
  return temp;
}
inline void LSTMWeightParams::set_allocated_blockinputbiasvector(::CoreML::Specification::WeightParams* blockinputbiasvector) {
  delete blockinputbiasvector_;
  blockinputbiasvector_ = blockinputbiasvector;
  if (blockinputbiasvector) {

  } else {

  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.LSTMWeightParams.blockInputBiasVector)
}

// .CoreML.Specification.WeightParams outputGateBiasVector = 43;
inline bool LSTMWeightParams::has_outputgatebiasvector() const {
  return this != internal_default_instance() && outputgatebiasvector_ != NULL;
}
inline void LSTMWeightParams::clear_outputgatebiasvector() {
  if (GetArenaNoVirtual() == NULL && outputgatebiasvector_ != NULL) delete outputgatebiasvector_;
  outputgatebiasvector_ = NULL;
}
inline const ::CoreML::Specification::WeightParams& LSTMWeightParams::outputgatebiasvector() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.LSTMWeightParams.outputGateBiasVector)
  return outputgatebiasvector_ != NULL ? *outputgatebiasvector_
                         : *::CoreML::Specification::WeightParams::internal_default_instance();
}
inline ::CoreML::Specification::WeightParams* LSTMWeightParams::mutable_outputgatebiasvector() {

  if (outputgatebiasvector_ == NULL) {
    outputgatebiasvector_ = new ::CoreML::Specification::WeightParams;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.LSTMWeightParams.outputGateBiasVector)
  return outputgatebiasvector_;
}
inline ::CoreML::Specification::WeightParams* LSTMWeightParams::release_outputgatebiasvector() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.LSTMWeightParams.outputGateBiasVector)

  ::CoreML::Specification::WeightParams* temp = outputgatebiasvector_;
  outputgatebiasvector_ = NULL;
  return temp;
}
inline void LSTMWeightParams::set_allocated_outputgatebiasvector(::CoreML::Specification::WeightParams* outputgatebiasvector) {
  delete outputgatebiasvector_;
  outputgatebiasvector_ = outputgatebiasvector;
  if (outputgatebiasvector) {

  } else {

  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.LSTMWeightParams.outputGateBiasVector)
}

// .CoreML.Specification.WeightParams inputGatePeepholeVector = 60;
inline bool LSTMWeightParams::has_inputgatepeepholevector() const {
  return this != internal_default_instance() && inputgatepeepholevector_ != NULL;
}
inline void LSTMWeightParams::clear_inputgatepeepholevector() {
  if (GetArenaNoVirtual() == NULL && inputgatepeepholevector_ != NULL) delete inputgatepeepholevector_;
  inputgatepeepholevector_ = NULL;
}
inline const ::CoreML::Specification::WeightParams& LSTMWeightParams::inputgatepeepholevector() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.LSTMWeightParams.inputGatePeepholeVector)
  return inputgatepeepholevector_ != NULL ? *inputgatepeepholevector_
                         : *::CoreML::Specification::WeightParams::internal_default_instance();
}
inline ::CoreML::Specification::WeightParams* LSTMWeightParams::mutable_inputgatepeepholevector() {

  if (inputgatepeepholevector_ == NULL) {
    inputgatepeepholevector_ = new ::CoreML::Specification::WeightParams;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.LSTMWeightParams.inputGatePeepholeVector)
  return inputgatepeepholevector_;
}
inline ::CoreML::Specification::WeightParams* LSTMWeightParams::release_inputgatepeepholevector() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.LSTMWeightParams.inputGatePeepholeVector)

  ::CoreML::Specification::WeightParams* temp = inputgatepeepholevector_;
  inputgatepeepholevector_ = NULL;
  return temp;
}
inline void LSTMWeightParams::set_allocated_inputgatepeepholevector(::CoreML::Specification::WeightParams* inputgatepeepholevector) {
  delete inputgatepeepholevector_;
  inputgatepeepholevector_ = inputgatepeepholevector;
  if (inputgatepeepholevector) {

  } else {

  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.LSTMWeightParams.inputGatePeepholeVector)
}

// .CoreML.Specification.WeightParams forgetGatePeepholeVector = 61;
inline bool LSTMWeightParams::has_forgetgatepeepholevector() const {
  return this != internal_default_instance() && forgetgatepeepholevector_ != NULL;
}
inline void LSTMWeightParams::clear_forgetgatepeepholevector() {
  if (GetArenaNoVirtual() == NULL && forgetgatepeepholevector_ != NULL) delete forgetgatepeepholevector_;
  forgetgatepeepholevector_ = NULL;
}
inline const ::CoreML::Specification::WeightParams& LSTMWeightParams::forgetgatepeepholevector() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.LSTMWeightParams.forgetGatePeepholeVector)
  return forgetgatepeepholevector_ != NULL ? *forgetgatepeepholevector_
                         : *::CoreML::Specification::WeightParams::internal_default_instance();
}
inline ::CoreML::Specification::WeightParams* LSTMWeightParams::mutable_forgetgatepeepholevector() {

  if (forgetgatepeepholevector_ == NULL) {
    forgetgatepeepholevector_ = new ::CoreML::Specification::WeightParams;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.LSTMWeightParams.forgetGatePeepholeVector)
  return forgetgatepeepholevector_;
}
inline ::CoreML::Specification::WeightParams* LSTMWeightParams::release_forgetgatepeepholevector() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.LSTMWeightParams.forgetGatePeepholeVector)

  ::CoreML::Specification::WeightParams* temp = forgetgatepeepholevector_;
  forgetgatepeepholevector_ = NULL;
  return temp;
}
inline void LSTMWeightParams::set_allocated_forgetgatepeepholevector(::CoreML::Specification::WeightParams* forgetgatepeepholevector) {
  delete forgetgatepeepholevector_;
  forgetgatepeepholevector_ = forgetgatepeepholevector;
  if (forgetgatepeepholevector) {

  } else {

  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.LSTMWeightParams.forgetGatePeepholeVector)
}

// .CoreML.Specification.WeightParams outputGatePeepholeVector = 62;
inline bool LSTMWeightParams::has_outputgatepeepholevector() const {
  return this != internal_default_instance() && outputgatepeepholevector_ != NULL;
}
inline void LSTMWeightParams::clear_outputgatepeepholevector() {
  if (GetArenaNoVirtual() == NULL && outputgatepeepholevector_ != NULL) delete outputgatepeepholevector_;
  outputgatepeepholevector_ = NULL;
}
inline const ::CoreML::Specification::WeightParams& LSTMWeightParams::outputgatepeepholevector() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.LSTMWeightParams.outputGatePeepholeVector)
  return outputgatepeepholevector_ != NULL ? *outputgatepeepholevector_
                         : *::CoreML::Specification::WeightParams::internal_default_instance();
}
inline ::CoreML::Specification::WeightParams* LSTMWeightParams::mutable_outputgatepeepholevector() {

  if (outputgatepeepholevector_ == NULL) {
    outputgatepeepholevector_ = new ::CoreML::Specification::WeightParams;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.LSTMWeightParams.outputGatePeepholeVector)
  return outputgatepeepholevector_;
}
inline ::CoreML::Specification::WeightParams* LSTMWeightParams::release_outputgatepeepholevector() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.LSTMWeightParams.outputGatePeepholeVector)

  ::CoreML::Specification::WeightParams* temp = outputgatepeepholevector_;
  outputgatepeepholevector_ = NULL;
  return temp;
}
inline void LSTMWeightParams::set_allocated_outputgatepeepholevector(::CoreML::Specification::WeightParams* outputgatepeepholevector) {
  delete outputgatepeepholevector_;
  outputgatepeepholevector_ = outputgatepeepholevector;
  if (outputgatepeepholevector) {

  } else {

  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.LSTMWeightParams.outputGatePeepholeVector)
}

// -------------------------------------------------------------------

// UniDirectionalLSTMLayerParams

// uint64 inputVectorSize = 1;
inline void UniDirectionalLSTMLayerParams::clear_inputvectorsize() {
  inputvectorsize_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 UniDirectionalLSTMLayerParams::inputvectorsize() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.UniDirectionalLSTMLayerParams.inputVectorSize)
  return inputvectorsize_;
}
inline void UniDirectionalLSTMLayerParams::set_inputvectorsize(::google::protobuf::uint64 value) {

  inputvectorsize_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.UniDirectionalLSTMLayerParams.inputVectorSize)
}

// uint64 outputVectorSize = 2;
inline void UniDirectionalLSTMLayerParams::clear_outputvectorsize() {
  outputvectorsize_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 UniDirectionalLSTMLayerParams::outputvectorsize() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.UniDirectionalLSTMLayerParams.outputVectorSize)
  return outputvectorsize_;
}
inline void UniDirectionalLSTMLayerParams::set_outputvectorsize(::google::protobuf::uint64 value) {

  outputvectorsize_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.UniDirectionalLSTMLayerParams.outputVectorSize)
}

// repeated .CoreML.Specification.ActivationParams activations = 10;
inline int UniDirectionalLSTMLayerParams::activations_size() const {
  return activations_.size();
}
inline void UniDirectionalLSTMLayerParams::clear_activations() {
  activations_.Clear();
}
inline const ::CoreML::Specification::ActivationParams& UniDirectionalLSTMLayerParams::activations(int index) const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.UniDirectionalLSTMLayerParams.activations)
  return activations_.Get(index);
}
inline ::CoreML::Specification::ActivationParams* UniDirectionalLSTMLayerParams::mutable_activations(int index) {
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.UniDirectionalLSTMLayerParams.activations)
  return activations_.Mutable(index);
}
inline ::CoreML::Specification::ActivationParams* UniDirectionalLSTMLayerParams::add_activations() {
  // @@protoc_insertion_point(field_add:CoreML.Specification.UniDirectionalLSTMLayerParams.activations)
  return activations_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::ActivationParams >*
UniDirectionalLSTMLayerParams::mutable_activations() {
  // @@protoc_insertion_point(field_mutable_list:CoreML.Specification.UniDirectionalLSTMLayerParams.activations)
  return &activations_;
}
inline const ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::ActivationParams >&
UniDirectionalLSTMLayerParams::activations() const {
  // @@protoc_insertion_point(field_list:CoreML.Specification.UniDirectionalLSTMLayerParams.activations)
  return activations_;
}

// .CoreML.Specification.LSTMParams params = 15;
inline bool UniDirectionalLSTMLayerParams::has_params() const {
  return this != internal_default_instance() && params_ != NULL;
}
inline void UniDirectionalLSTMLayerParams::clear_params() {
  if (GetArenaNoVirtual() == NULL && params_ != NULL) delete params_;
  params_ = NULL;
}
inline const ::CoreML::Specification::LSTMParams& UniDirectionalLSTMLayerParams::params() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.UniDirectionalLSTMLayerParams.params)
  return params_ != NULL ? *params_
                         : *::CoreML::Specification::LSTMParams::internal_default_instance();
}
inline ::CoreML::Specification::LSTMParams* UniDirectionalLSTMLayerParams::mutable_params() {

  if (params_ == NULL) {
    params_ = new ::CoreML::Specification::LSTMParams;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.UniDirectionalLSTMLayerParams.params)
  return params_;
}
inline ::CoreML::Specification::LSTMParams* UniDirectionalLSTMLayerParams::release_params() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.UniDirectionalLSTMLayerParams.params)

  ::CoreML::Specification::LSTMParams* temp = params_;
  params_ = NULL;
  return temp;
}
inline void UniDirectionalLSTMLayerParams::set_allocated_params(::CoreML::Specification::LSTMParams* params) {
  delete params_;
  params_ = params;
  if (params) {

  } else {

  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.UniDirectionalLSTMLayerParams.params)
}

// .CoreML.Specification.LSTMWeightParams weightParams = 20;
inline bool UniDirectionalLSTMLayerParams::has_weightparams() const {
  return this != internal_default_instance() && weightparams_ != NULL;
}
inline void UniDirectionalLSTMLayerParams::clear_weightparams() {
  if (GetArenaNoVirtual() == NULL && weightparams_ != NULL) delete weightparams_;
  weightparams_ = NULL;
}
inline const ::CoreML::Specification::LSTMWeightParams& UniDirectionalLSTMLayerParams::weightparams() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.UniDirectionalLSTMLayerParams.weightParams)
  return weightparams_ != NULL ? *weightparams_
                         : *::CoreML::Specification::LSTMWeightParams::internal_default_instance();
}
inline ::CoreML::Specification::LSTMWeightParams* UniDirectionalLSTMLayerParams::mutable_weightparams() {

  if (weightparams_ == NULL) {
    weightparams_ = new ::CoreML::Specification::LSTMWeightParams;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.UniDirectionalLSTMLayerParams.weightParams)
  return weightparams_;
}
inline ::CoreML::Specification::LSTMWeightParams* UniDirectionalLSTMLayerParams::release_weightparams() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.UniDirectionalLSTMLayerParams.weightParams)

  ::CoreML::Specification::LSTMWeightParams* temp = weightparams_;
  weightparams_ = NULL;
  return temp;
}
inline void UniDirectionalLSTMLayerParams::set_allocated_weightparams(::CoreML::Specification::LSTMWeightParams* weightparams) {
  delete weightparams_;
  weightparams_ = weightparams;
  if (weightparams) {

  } else {

  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.UniDirectionalLSTMLayerParams.weightParams)
}

// bool reverseInput = 100;
inline void UniDirectionalLSTMLayerParams::clear_reverseinput() {
  reverseinput_ = false;
}
inline bool UniDirectionalLSTMLayerParams::reverseinput() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.UniDirectionalLSTMLayerParams.reverseInput)
  return reverseinput_;
}
inline void UniDirectionalLSTMLayerParams::set_reverseinput(bool value) {

  reverseinput_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.UniDirectionalLSTMLayerParams.reverseInput)
}

// -------------------------------------------------------------------

// BiDirectionalLSTMLayerParams

// uint64 inputVectorSize = 1;
inline void BiDirectionalLSTMLayerParams::clear_inputvectorsize() {
  inputvectorsize_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 BiDirectionalLSTMLayerParams::inputvectorsize() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.BiDirectionalLSTMLayerParams.inputVectorSize)
  return inputvectorsize_;
}
inline void BiDirectionalLSTMLayerParams::set_inputvectorsize(::google::protobuf::uint64 value) {

  inputvectorsize_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.BiDirectionalLSTMLayerParams.inputVectorSize)
}

// uint64 outputVectorSize = 2;
inline void BiDirectionalLSTMLayerParams::clear_outputvectorsize() {
  outputvectorsize_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 BiDirectionalLSTMLayerParams::outputvectorsize() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.BiDirectionalLSTMLayerParams.outputVectorSize)
  return outputvectorsize_;
}
inline void BiDirectionalLSTMLayerParams::set_outputvectorsize(::google::protobuf::uint64 value) {

  outputvectorsize_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.BiDirectionalLSTMLayerParams.outputVectorSize)
}

// repeated .CoreML.Specification.ActivationParams activationsForwardLSTM = 10;
inline int BiDirectionalLSTMLayerParams::activationsforwardlstm_size() const {
  return activationsforwardlstm_.size();
}
inline void BiDirectionalLSTMLayerParams::clear_activationsforwardlstm() {
  activationsforwardlstm_.Clear();
}
inline const ::CoreML::Specification::ActivationParams& BiDirectionalLSTMLayerParams::activationsforwardlstm(int index) const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.BiDirectionalLSTMLayerParams.activationsForwardLSTM)
  return activationsforwardlstm_.Get(index);
}
inline ::CoreML::Specification::ActivationParams* BiDirectionalLSTMLayerParams::mutable_activationsforwardlstm(int index) {
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.BiDirectionalLSTMLayerParams.activationsForwardLSTM)
  return activationsforwardlstm_.Mutable(index);
}
inline ::CoreML::Specification::ActivationParams* BiDirectionalLSTMLayerParams::add_activationsforwardlstm() {
  // @@protoc_insertion_point(field_add:CoreML.Specification.BiDirectionalLSTMLayerParams.activationsForwardLSTM)
  return activationsforwardlstm_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::ActivationParams >*
BiDirectionalLSTMLayerParams::mutable_activationsforwardlstm() {
  // @@protoc_insertion_point(field_mutable_list:CoreML.Specification.BiDirectionalLSTMLayerParams.activationsForwardLSTM)
  return &activationsforwardlstm_;
}
inline const ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::ActivationParams >&
BiDirectionalLSTMLayerParams::activationsforwardlstm() const {
  // @@protoc_insertion_point(field_list:CoreML.Specification.BiDirectionalLSTMLayerParams.activationsForwardLSTM)
  return activationsforwardlstm_;
}

// repeated .CoreML.Specification.ActivationParams activationsBackwardLSTM = 11;
inline int BiDirectionalLSTMLayerParams::activationsbackwardlstm_size() const {
  return activationsbackwardlstm_.size();
}
inline void BiDirectionalLSTMLayerParams::clear_activationsbackwardlstm() {
  activationsbackwardlstm_.Clear();
}
inline const ::CoreML::Specification::ActivationParams& BiDirectionalLSTMLayerParams::activationsbackwardlstm(int index) const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.BiDirectionalLSTMLayerParams.activationsBackwardLSTM)
  return activationsbackwardlstm_.Get(index);
}
inline ::CoreML::Specification::ActivationParams* BiDirectionalLSTMLayerParams::mutable_activationsbackwardlstm(int index) {
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.BiDirectionalLSTMLayerParams.activationsBackwardLSTM)
  return activationsbackwardlstm_.Mutable(index);
}
inline ::CoreML::Specification::ActivationParams* BiDirectionalLSTMLayerParams::add_activationsbackwardlstm() {
  // @@protoc_insertion_point(field_add:CoreML.Specification.BiDirectionalLSTMLayerParams.activationsBackwardLSTM)
  return activationsbackwardlstm_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::ActivationParams >*
BiDirectionalLSTMLayerParams::mutable_activationsbackwardlstm() {
  // @@protoc_insertion_point(field_mutable_list:CoreML.Specification.BiDirectionalLSTMLayerParams.activationsBackwardLSTM)
  return &activationsbackwardlstm_;
}
inline const ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::ActivationParams >&
BiDirectionalLSTMLayerParams::activationsbackwardlstm() const {
  // @@protoc_insertion_point(field_list:CoreML.Specification.BiDirectionalLSTMLayerParams.activationsBackwardLSTM)
  return activationsbackwardlstm_;
}

// .CoreML.Specification.LSTMParams params = 15;
inline bool BiDirectionalLSTMLayerParams::has_params() const {
  return this != internal_default_instance() && params_ != NULL;
}
inline void BiDirectionalLSTMLayerParams::clear_params() {
  if (GetArenaNoVirtual() == NULL && params_ != NULL) delete params_;
  params_ = NULL;
}
inline const ::CoreML::Specification::LSTMParams& BiDirectionalLSTMLayerParams::params() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.BiDirectionalLSTMLayerParams.params)
  return params_ != NULL ? *params_
                         : *::CoreML::Specification::LSTMParams::internal_default_instance();
}
inline ::CoreML::Specification::LSTMParams* BiDirectionalLSTMLayerParams::mutable_params() {

  if (params_ == NULL) {
    params_ = new ::CoreML::Specification::LSTMParams;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.BiDirectionalLSTMLayerParams.params)
  return params_;
}
inline ::CoreML::Specification::LSTMParams* BiDirectionalLSTMLayerParams::release_params() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.BiDirectionalLSTMLayerParams.params)

  ::CoreML::Specification::LSTMParams* temp = params_;
  params_ = NULL;
  return temp;
}
inline void BiDirectionalLSTMLayerParams::set_allocated_params(::CoreML::Specification::LSTMParams* params) {
  delete params_;
  params_ = params;
  if (params) {

  } else {

  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.BiDirectionalLSTMLayerParams.params)
}

// repeated .CoreML.Specification.LSTMWeightParams weightParams = 20;
inline int BiDirectionalLSTMLayerParams::weightparams_size() const {
  return weightparams_.size();
}
inline void BiDirectionalLSTMLayerParams::clear_weightparams() {
  weightparams_.Clear();
}
inline const ::CoreML::Specification::LSTMWeightParams& BiDirectionalLSTMLayerParams::weightparams(int index) const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.BiDirectionalLSTMLayerParams.weightParams)
  return weightparams_.Get(index);
}
inline ::CoreML::Specification::LSTMWeightParams* BiDirectionalLSTMLayerParams::mutable_weightparams(int index) {
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.BiDirectionalLSTMLayerParams.weightParams)
  return weightparams_.Mutable(index);
}
inline ::CoreML::Specification::LSTMWeightParams* BiDirectionalLSTMLayerParams::add_weightparams() {
  // @@protoc_insertion_point(field_add:CoreML.Specification.BiDirectionalLSTMLayerParams.weightParams)
  return weightparams_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::LSTMWeightParams >*
BiDirectionalLSTMLayerParams::mutable_weightparams() {
  // @@protoc_insertion_point(field_mutable_list:CoreML.Specification.BiDirectionalLSTMLayerParams.weightParams)
  return &weightparams_;
}
inline const ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::LSTMWeightParams >&
BiDirectionalLSTMLayerParams::weightparams() const {
  // @@protoc_insertion_point(field_list:CoreML.Specification.BiDirectionalLSTMLayerParams.weightParams)
  return weightparams_;
}

// -------------------------------------------------------------------

// CustomLayerParams_CustomLayerParamValue

// double doubleValue = 10;
inline bool CustomLayerParams_CustomLayerParamValue::has_doublevalue() const {
  return value_case() == kDoubleValue;
}
inline void CustomLayerParams_CustomLayerParamValue::set_has_doublevalue() {
  _oneof_case_[0] = kDoubleValue;
}
inline void CustomLayerParams_CustomLayerParamValue::clear_doublevalue() {
  if (has_doublevalue()) {
    value_.doublevalue_ = 0;
    clear_has_value();
  }
}
inline double CustomLayerParams_CustomLayerParamValue::doublevalue() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.CustomLayerParams.CustomLayerParamValue.doubleValue)
  if (has_doublevalue()) {
    return value_.doublevalue_;
  }
  return 0;
}
inline void CustomLayerParams_CustomLayerParamValue::set_doublevalue(double value) {
  if (!has_doublevalue()) {
    clear_value();
    set_has_doublevalue();
  }
  value_.doublevalue_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.CustomLayerParams.CustomLayerParamValue.doubleValue)
}

// string stringValue = 20;
inline bool CustomLayerParams_CustomLayerParamValue::has_stringvalue() const {
  return value_case() == kStringValue;
}
inline void CustomLayerParams_CustomLayerParamValue::set_has_stringvalue() {
  _oneof_case_[0] = kStringValue;
}
inline void CustomLayerParams_CustomLayerParamValue::clear_stringvalue() {
  if (has_stringvalue()) {
    value_.stringvalue_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_value();
  }
}
inline const ::std::string& CustomLayerParams_CustomLayerParamValue::stringvalue() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.CustomLayerParams.CustomLayerParamValue.stringValue)
  if (has_stringvalue()) {
    return value_.stringvalue_.GetNoArena();
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void CustomLayerParams_CustomLayerParamValue::set_stringvalue(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:CoreML.Specification.CustomLayerParams.CustomLayerParamValue.stringValue)
  if (!has_stringvalue()) {
    clear_value();
    set_has_stringvalue();
    value_.stringvalue_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  value_.stringvalue_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:CoreML.Specification.CustomLayerParams.CustomLayerParamValue.stringValue)
}
#if LANG_CXX11
inline void CustomLayerParams_CustomLayerParamValue::set_stringvalue(::std::string&& value) {
  // @@protoc_insertion_point(field_set:CoreML.Specification.CustomLayerParams.CustomLayerParamValue.stringValue)
  if (!has_stringvalue()) {
    clear_value();
    set_has_stringvalue();
    value_.stringvalue_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  value_.stringvalue_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:CoreML.Specification.CustomLayerParams.CustomLayerParamValue.stringValue)
}
#endif
inline void CustomLayerParams_CustomLayerParamValue::set_stringvalue(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  if (!has_stringvalue()) {
    clear_value();
    set_has_stringvalue();
    value_.stringvalue_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  value_.stringvalue_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:CoreML.Specification.CustomLayerParams.CustomLayerParamValue.stringValue)
}
inline void CustomLayerParams_CustomLayerParamValue::set_stringvalue(const char* value, size_t size) {
  if (!has_stringvalue()) {
    clear_value();
    set_has_stringvalue();
    value_.stringvalue_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  value_.stringvalue_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:CoreML.Specification.CustomLayerParams.CustomLayerParamValue.stringValue)
}
inline ::std::string* CustomLayerParams_CustomLayerParamValue::mutable_stringvalue() {
  if (!has_stringvalue()) {
    clear_value();
    set_has_stringvalue();
    value_.stringvalue_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.CustomLayerParams.CustomLayerParamValue.stringValue)
  return value_.stringvalue_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CustomLayerParams_CustomLayerParamValue::release_stringvalue() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.CustomLayerParams.CustomLayerParamValue.stringValue)
  if (has_stringvalue()) {
    clear_has_value();
    return value_.stringvalue_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void CustomLayerParams_CustomLayerParamValue::set_allocated_stringvalue(::std::string* stringvalue) {
  if (!has_stringvalue()) {
    value_.stringvalue_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_value();
  if (stringvalue != NULL) {
    set_has_stringvalue();
    value_.stringvalue_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        stringvalue);
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.CustomLayerParams.CustomLayerParamValue.stringValue)
}

// int32 intValue = 30;
inline bool CustomLayerParams_CustomLayerParamValue::has_intvalue() const {
  return value_case() == kIntValue;
}
inline void CustomLayerParams_CustomLayerParamValue::set_has_intvalue() {
  _oneof_case_[0] = kIntValue;
}
inline void CustomLayerParams_CustomLayerParamValue::clear_intvalue() {
  if (has_intvalue()) {
    value_.intvalue_ = 0;
    clear_has_value();
  }
}
inline ::google::protobuf::int32 CustomLayerParams_CustomLayerParamValue::intvalue() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.CustomLayerParams.CustomLayerParamValue.intValue)
  if (has_intvalue()) {
    return value_.intvalue_;
  }
  return 0;
}
inline void CustomLayerParams_CustomLayerParamValue::set_intvalue(::google::protobuf::int32 value) {
  if (!has_intvalue()) {
    clear_value();
    set_has_intvalue();
  }
  value_.intvalue_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.CustomLayerParams.CustomLayerParamValue.intValue)
}

// int64 longValue = 40;
inline bool CustomLayerParams_CustomLayerParamValue::has_longvalue() const {
  return value_case() == kLongValue;
}
inline void CustomLayerParams_CustomLayerParamValue::set_has_longvalue() {
  _oneof_case_[0] = kLongValue;
}
inline void CustomLayerParams_CustomLayerParamValue::clear_longvalue() {
  if (has_longvalue()) {
    value_.longvalue_ = GOOGLE_LONGLONG(0);
    clear_has_value();
  }
}
inline ::google::protobuf::int64 CustomLayerParams_CustomLayerParamValue::longvalue() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.CustomLayerParams.CustomLayerParamValue.longValue)
  if (has_longvalue()) {
    return value_.longvalue_;
  }
  return GOOGLE_LONGLONG(0);
}
inline void CustomLayerParams_CustomLayerParamValue::set_longvalue(::google::protobuf::int64 value) {
  if (!has_longvalue()) {
    clear_value();
    set_has_longvalue();
  }
  value_.longvalue_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.CustomLayerParams.CustomLayerParamValue.longValue)
}

// bool boolValue = 50;
inline bool CustomLayerParams_CustomLayerParamValue::has_boolvalue() const {
  return value_case() == kBoolValue;
}
inline void CustomLayerParams_CustomLayerParamValue::set_has_boolvalue() {
  _oneof_case_[0] = kBoolValue;
}
inline void CustomLayerParams_CustomLayerParamValue::clear_boolvalue() {
  if (has_boolvalue()) {
    value_.boolvalue_ = false;
    clear_has_value();
  }
}
inline bool CustomLayerParams_CustomLayerParamValue::boolvalue() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.CustomLayerParams.CustomLayerParamValue.boolValue)
  if (has_boolvalue()) {
    return value_.boolvalue_;
  }
  return false;
}
inline void CustomLayerParams_CustomLayerParamValue::set_boolvalue(bool value) {
  if (!has_boolvalue()) {
    clear_value();
    set_has_boolvalue();
  }
  value_.boolvalue_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.CustomLayerParams.CustomLayerParamValue.boolValue)
}

inline bool CustomLayerParams_CustomLayerParamValue::has_value() const {
  return value_case() != VALUE_NOT_SET;
}
inline void CustomLayerParams_CustomLayerParamValue::clear_has_value() {
  _oneof_case_[0] = VALUE_NOT_SET;
}
inline CustomLayerParams_CustomLayerParamValue::ValueCase CustomLayerParams_CustomLayerParamValue::value_case() const {
  return CustomLayerParams_CustomLayerParamValue::ValueCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// CustomLayerParams

// string className = 10;
inline void CustomLayerParams::clear_classname() {
  classname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CustomLayerParams::classname() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.CustomLayerParams.className)
  return classname_.GetNoArena();
}
inline void CustomLayerParams::set_classname(const ::std::string& value) {

  classname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:CoreML.Specification.CustomLayerParams.className)
}
#if LANG_CXX11
inline void CustomLayerParams::set_classname(::std::string&& value) {

  classname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:CoreML.Specification.CustomLayerParams.className)
}
#endif
inline void CustomLayerParams::set_classname(const char* value) {
  GOOGLE_DCHECK(value != NULL);

  classname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:CoreML.Specification.CustomLayerParams.className)
}
inline void CustomLayerParams::set_classname(const char* value, size_t size) {

  classname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:CoreML.Specification.CustomLayerParams.className)
}
inline ::std::string* CustomLayerParams::mutable_classname() {

  // @@protoc_insertion_point(field_mutable:CoreML.Specification.CustomLayerParams.className)
  return classname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CustomLayerParams::release_classname() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.CustomLayerParams.className)

  return classname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CustomLayerParams::set_allocated_classname(::std::string* classname) {
  if (classname != NULL) {

  } else {

  }
  classname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), classname);
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.CustomLayerParams.className)
}

// repeated .CoreML.Specification.WeightParams weights = 20;
inline int CustomLayerParams::weights_size() const {
  return weights_.size();
}
inline void CustomLayerParams::clear_weights() {
  weights_.Clear();
}
inline const ::CoreML::Specification::WeightParams& CustomLayerParams::weights(int index) const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.CustomLayerParams.weights)
  return weights_.Get(index);
}
inline ::CoreML::Specification::WeightParams* CustomLayerParams::mutable_weights(int index) {
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.CustomLayerParams.weights)
  return weights_.Mutable(index);
}
inline ::CoreML::Specification::WeightParams* CustomLayerParams::add_weights() {
  // @@protoc_insertion_point(field_add:CoreML.Specification.CustomLayerParams.weights)
  return weights_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::WeightParams >*
CustomLayerParams::mutable_weights() {
  // @@protoc_insertion_point(field_mutable_list:CoreML.Specification.CustomLayerParams.weights)
  return &weights_;
}
inline const ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::WeightParams >&
CustomLayerParams::weights() const {
  // @@protoc_insertion_point(field_list:CoreML.Specification.CustomLayerParams.weights)
  return weights_;
}

// map<string, .CoreML.Specification.CustomLayerParams.CustomLayerParamValue> parameters = 30;
inline int CustomLayerParams::parameters_size() const {
  return parameters_.size();
}
inline void CustomLayerParams::clear_parameters() {
  parameters_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::CoreML::Specification::CustomLayerParams_CustomLayerParamValue >&
CustomLayerParams::parameters() const {
  // @@protoc_insertion_point(field_map:CoreML.Specification.CustomLayerParams.parameters)
  return parameters_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::CoreML::Specification::CustomLayerParams_CustomLayerParamValue >*
CustomLayerParams::mutable_parameters() {
  // @@protoc_insertion_point(field_mutable_map:CoreML.Specification.CustomLayerParams.parameters)
  return parameters_.MutableMap();
}

// string description = 40;
inline void CustomLayerParams::clear_description() {
  description_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CustomLayerParams::description() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.CustomLayerParams.description)
  return description_.GetNoArena();
}
inline void CustomLayerParams::set_description(const ::std::string& value) {

  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:CoreML.Specification.CustomLayerParams.description)
}
#if LANG_CXX11
inline void CustomLayerParams::set_description(::std::string&& value) {

  description_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:CoreML.Specification.CustomLayerParams.description)
}
#endif
inline void CustomLayerParams::set_description(const char* value) {
  GOOGLE_DCHECK(value != NULL);

  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:CoreML.Specification.CustomLayerParams.description)
}
inline void CustomLayerParams::set_description(const char* value, size_t size) {

  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:CoreML.Specification.CustomLayerParams.description)
}
inline ::std::string* CustomLayerParams::mutable_description() {

  // @@protoc_insertion_point(field_mutable:CoreML.Specification.CustomLayerParams.description)
  return description_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CustomLayerParams::release_description() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.CustomLayerParams.description)

  return description_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CustomLayerParams::set_allocated_description(::std::string* description) {
  if (description != NULL) {

  } else {

  }
  description_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), description);
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.CustomLayerParams.description)
}

// -------------------------------------------------------------------

// NeuralNetworkClassifier

// repeated .CoreML.Specification.NeuralNetworkLayer layers = 1;
inline int NeuralNetworkClassifier::layers_size() const {
  return layers_.size();
}
inline void NeuralNetworkClassifier::clear_layers() {
  layers_.Clear();
}
inline const ::CoreML::Specification::NeuralNetworkLayer& NeuralNetworkClassifier::layers(int index) const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.NeuralNetworkClassifier.layers)
  return layers_.Get(index);
}
inline ::CoreML::Specification::NeuralNetworkLayer* NeuralNetworkClassifier::mutable_layers(int index) {
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.NeuralNetworkClassifier.layers)
  return layers_.Mutable(index);
}
inline ::CoreML::Specification::NeuralNetworkLayer* NeuralNetworkClassifier::add_layers() {
  // @@protoc_insertion_point(field_add:CoreML.Specification.NeuralNetworkClassifier.layers)
  return layers_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::NeuralNetworkLayer >*
NeuralNetworkClassifier::mutable_layers() {
  // @@protoc_insertion_point(field_mutable_list:CoreML.Specification.NeuralNetworkClassifier.layers)
  return &layers_;
}
inline const ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::NeuralNetworkLayer >&
NeuralNetworkClassifier::layers() const {
  // @@protoc_insertion_point(field_list:CoreML.Specification.NeuralNetworkClassifier.layers)
  return layers_;
}

// repeated .CoreML.Specification.NeuralNetworkPreprocessing preprocessing = 2;
inline int NeuralNetworkClassifier::preprocessing_size() const {
  return preprocessing_.size();
}
inline void NeuralNetworkClassifier::clear_preprocessing() {
  preprocessing_.Clear();
}
inline const ::CoreML::Specification::NeuralNetworkPreprocessing& NeuralNetworkClassifier::preprocessing(int index) const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.NeuralNetworkClassifier.preprocessing)
  return preprocessing_.Get(index);
}
inline ::CoreML::Specification::NeuralNetworkPreprocessing* NeuralNetworkClassifier::mutable_preprocessing(int index) {
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.NeuralNetworkClassifier.preprocessing)
  return preprocessing_.Mutable(index);
}
inline ::CoreML::Specification::NeuralNetworkPreprocessing* NeuralNetworkClassifier::add_preprocessing() {
  // @@protoc_insertion_point(field_add:CoreML.Specification.NeuralNetworkClassifier.preprocessing)
  return preprocessing_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::NeuralNetworkPreprocessing >*
NeuralNetworkClassifier::mutable_preprocessing() {
  // @@protoc_insertion_point(field_mutable_list:CoreML.Specification.NeuralNetworkClassifier.preprocessing)
  return &preprocessing_;
}
inline const ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::NeuralNetworkPreprocessing >&
NeuralNetworkClassifier::preprocessing() const {
  // @@protoc_insertion_point(field_list:CoreML.Specification.NeuralNetworkClassifier.preprocessing)
  return preprocessing_;
}

// .CoreML.Specification.StringVector stringClassLabels = 100;
inline bool NeuralNetworkClassifier::has_stringclasslabels() const {
  return ClassLabels_case() == kStringClassLabels;
}
inline void NeuralNetworkClassifier::set_has_stringclasslabels() {
  _oneof_case_[0] = kStringClassLabels;
}
inline void NeuralNetworkClassifier::clear_stringclasslabels() {
  if (has_stringclasslabels()) {
    delete ClassLabels_.stringclasslabels_;
    clear_has_ClassLabels();
  }
}
inline  const ::CoreML::Specification::StringVector& NeuralNetworkClassifier::stringclasslabels() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.NeuralNetworkClassifier.stringClassLabels)
  return has_stringclasslabels()
      ? *ClassLabels_.stringclasslabels_
      : ::CoreML::Specification::StringVector::default_instance();
}
inline ::CoreML::Specification::StringVector* NeuralNetworkClassifier::mutable_stringclasslabels() {
  if (!has_stringclasslabels()) {
    clear_ClassLabels();
    set_has_stringclasslabels();
    ClassLabels_.stringclasslabels_ = new ::CoreML::Specification::StringVector;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.NeuralNetworkClassifier.stringClassLabels)
  return ClassLabels_.stringclasslabels_;
}
inline ::CoreML::Specification::StringVector* NeuralNetworkClassifier::release_stringclasslabels() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.NeuralNetworkClassifier.stringClassLabels)
  if (has_stringclasslabels()) {
    clear_has_ClassLabels();
    ::CoreML::Specification::StringVector* temp = ClassLabels_.stringclasslabels_;
    ClassLabels_.stringclasslabels_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void NeuralNetworkClassifier::set_allocated_stringclasslabels(::CoreML::Specification::StringVector* stringclasslabels) {
  clear_ClassLabels();
  if (stringclasslabels) {
    set_has_stringclasslabels();
    ClassLabels_.stringclasslabels_ = stringclasslabels;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkClassifier.stringClassLabels)
}

// .CoreML.Specification.Int64Vector int64ClassLabels = 101;
inline bool NeuralNetworkClassifier::has_int64classlabels() const {
  return ClassLabels_case() == kInt64ClassLabels;
}
inline void NeuralNetworkClassifier::set_has_int64classlabels() {
  _oneof_case_[0] = kInt64ClassLabels;
}
inline void NeuralNetworkClassifier::clear_int64classlabels() {
  if (has_int64classlabels()) {
    delete ClassLabels_.int64classlabels_;
    clear_has_ClassLabels();
  }
}
inline  const ::CoreML::Specification::Int64Vector& NeuralNetworkClassifier::int64classlabels() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.NeuralNetworkClassifier.int64ClassLabels)
  return has_int64classlabels()
      ? *ClassLabels_.int64classlabels_
      : ::CoreML::Specification::Int64Vector::default_instance();
}
inline ::CoreML::Specification::Int64Vector* NeuralNetworkClassifier::mutable_int64classlabels() {
  if (!has_int64classlabels()) {
    clear_ClassLabels();
    set_has_int64classlabels();
    ClassLabels_.int64classlabels_ = new ::CoreML::Specification::Int64Vector;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.NeuralNetworkClassifier.int64ClassLabels)
  return ClassLabels_.int64classlabels_;
}
inline ::CoreML::Specification::Int64Vector* NeuralNetworkClassifier::release_int64classlabels() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.NeuralNetworkClassifier.int64ClassLabels)
  if (has_int64classlabels()) {
    clear_has_ClassLabels();
    ::CoreML::Specification::Int64Vector* temp = ClassLabels_.int64classlabels_;
    ClassLabels_.int64classlabels_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void NeuralNetworkClassifier::set_allocated_int64classlabels(::CoreML::Specification::Int64Vector* int64classlabels) {
  clear_ClassLabels();
  if (int64classlabels) {
    set_has_int64classlabels();
    ClassLabels_.int64classlabels_ = int64classlabels;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkClassifier.int64ClassLabels)
}

// string labelProbabilityLayerName = 200;
inline void NeuralNetworkClassifier::clear_labelprobabilitylayername() {
  labelprobabilitylayername_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& NeuralNetworkClassifier::labelprobabilitylayername() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.NeuralNetworkClassifier.labelProbabilityLayerName)
  return labelprobabilitylayername_.GetNoArena();
}
inline void NeuralNetworkClassifier::set_labelprobabilitylayername(const ::std::string& value) {

  labelprobabilitylayername_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:CoreML.Specification.NeuralNetworkClassifier.labelProbabilityLayerName)
}
#if LANG_CXX11
inline void NeuralNetworkClassifier::set_labelprobabilitylayername(::std::string&& value) {

  labelprobabilitylayername_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:CoreML.Specification.NeuralNetworkClassifier.labelProbabilityLayerName)
}
#endif
inline void NeuralNetworkClassifier::set_labelprobabilitylayername(const char* value) {
  GOOGLE_DCHECK(value != NULL);

  labelprobabilitylayername_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:CoreML.Specification.NeuralNetworkClassifier.labelProbabilityLayerName)
}
inline void NeuralNetworkClassifier::set_labelprobabilitylayername(const char* value, size_t size) {

  labelprobabilitylayername_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:CoreML.Specification.NeuralNetworkClassifier.labelProbabilityLayerName)
}
inline ::std::string* NeuralNetworkClassifier::mutable_labelprobabilitylayername() {

  // @@protoc_insertion_point(field_mutable:CoreML.Specification.NeuralNetworkClassifier.labelProbabilityLayerName)
  return labelprobabilitylayername_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NeuralNetworkClassifier::release_labelprobabilitylayername() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.NeuralNetworkClassifier.labelProbabilityLayerName)

  return labelprobabilitylayername_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NeuralNetworkClassifier::set_allocated_labelprobabilitylayername(::std::string* labelprobabilitylayername) {
  if (labelprobabilitylayername != NULL) {

  } else {

  }
  labelprobabilitylayername_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), labelprobabilitylayername);
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.NeuralNetworkClassifier.labelProbabilityLayerName)
}

inline bool NeuralNetworkClassifier::has_ClassLabels() const {
  return ClassLabels_case() != CLASSLABELS_NOT_SET;
}
inline void NeuralNetworkClassifier::clear_has_ClassLabels() {
  _oneof_case_[0] = CLASSLABELS_NOT_SET;
}
inline NeuralNetworkClassifier::ClassLabelsCase NeuralNetworkClassifier::ClassLabels_case() const {
  return NeuralNetworkClassifier::ClassLabelsCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// NeuralNetworkRegressor

// repeated .CoreML.Specification.NeuralNetworkLayer layers = 1;
inline int NeuralNetworkRegressor::layers_size() const {
  return layers_.size();
}
inline void NeuralNetworkRegressor::clear_layers() {
  layers_.Clear();
}
inline const ::CoreML::Specification::NeuralNetworkLayer& NeuralNetworkRegressor::layers(int index) const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.NeuralNetworkRegressor.layers)
  return layers_.Get(index);
}
inline ::CoreML::Specification::NeuralNetworkLayer* NeuralNetworkRegressor::mutable_layers(int index) {
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.NeuralNetworkRegressor.layers)
  return layers_.Mutable(index);
}
inline ::CoreML::Specification::NeuralNetworkLayer* NeuralNetworkRegressor::add_layers() {
  // @@protoc_insertion_point(field_add:CoreML.Specification.NeuralNetworkRegressor.layers)
  return layers_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::NeuralNetworkLayer >*
NeuralNetworkRegressor::mutable_layers() {
  // @@protoc_insertion_point(field_mutable_list:CoreML.Specification.NeuralNetworkRegressor.layers)
  return &layers_;
}
inline const ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::NeuralNetworkLayer >&
NeuralNetworkRegressor::layers() const {
  // @@protoc_insertion_point(field_list:CoreML.Specification.NeuralNetworkRegressor.layers)
  return layers_;
}

// repeated .CoreML.Specification.NeuralNetworkPreprocessing preprocessing = 2;
inline int NeuralNetworkRegressor::preprocessing_size() const {
  return preprocessing_.size();
}
inline void NeuralNetworkRegressor::clear_preprocessing() {
  preprocessing_.Clear();
}
inline const ::CoreML::Specification::NeuralNetworkPreprocessing& NeuralNetworkRegressor::preprocessing(int index) const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.NeuralNetworkRegressor.preprocessing)
  return preprocessing_.Get(index);
}
inline ::CoreML::Specification::NeuralNetworkPreprocessing* NeuralNetworkRegressor::mutable_preprocessing(int index) {
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.NeuralNetworkRegressor.preprocessing)
  return preprocessing_.Mutable(index);
}
inline ::CoreML::Specification::NeuralNetworkPreprocessing* NeuralNetworkRegressor::add_preprocessing() {
  // @@protoc_insertion_point(field_add:CoreML.Specification.NeuralNetworkRegressor.preprocessing)
  return preprocessing_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::NeuralNetworkPreprocessing >*
NeuralNetworkRegressor::mutable_preprocessing() {
  // @@protoc_insertion_point(field_mutable_list:CoreML.Specification.NeuralNetworkRegressor.preprocessing)
  return &preprocessing_;
}
inline const ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::NeuralNetworkPreprocessing >&
NeuralNetworkRegressor::preprocessing() const {
  // @@protoc_insertion_point(field_list:CoreML.Specification.NeuralNetworkRegressor.preprocessing)
  return preprocessing_;
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace Specification
}  // namespace CoreML

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::CoreML::Specification::SamePadding_SamePaddingMode> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::CoreML::Specification::SamplingMode_Method> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::CoreML::Specification::BoxCoordinatesMode_Coordinates> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::CoreML::Specification::PoolingLayerParams_PoolingType> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::CoreML::Specification::UnaryFunctionLayerParams_Operation> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::CoreML::Specification::UpsampleLayerParams_InterpolationMode> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::CoreML::Specification::FlattenLayerParams_FlattenOrder> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::CoreML::Specification::ReshapeLayerParams_ReshapeOrder> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::CoreML::Specification::ReorganizeDataLayerParams_ReorganizationType> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::CoreML::Specification::SliceLayerParams_SliceAxis> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::CoreML::Specification::ReduceLayerParams_ReduceOperation> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::CoreML::Specification::ReduceLayerParams_ReduceAxis> : ::google::protobuf::internal::true_type {};

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_NeuralNetwork_2eproto__INCLUDED
