// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: SVM.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "SVM.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/port.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)

namespace CoreML {
namespace Specification {
class LinearKernelDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<LinearKernel> {
} _LinearKernel_default_instance_;
class RBFKernelDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<RBFKernel> {
} _RBFKernel_default_instance_;
class PolyKernelDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<PolyKernel> {
} _PolyKernel_default_instance_;
class SigmoidKernelDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<SigmoidKernel> {
} _SigmoidKernel_default_instance_;
class KernelDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<Kernel> {
  public:
  const ::CoreML::Specification::LinearKernel* linearkernel_;
  const ::CoreML::Specification::RBFKernel* rbfkernel_;
  const ::CoreML::Specification::PolyKernel* polykernel_;
  const ::CoreML::Specification::SigmoidKernel* sigmoidkernel_;
} _Kernel_default_instance_;
class SparseNodeDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<SparseNode> {
} _SparseNode_default_instance_;
class SparseVectorDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<SparseVector> {
} _SparseVector_default_instance_;
class SparseSupportVectorsDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<SparseSupportVectors> {
} _SparseSupportVectors_default_instance_;
class DenseVectorDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<DenseVector> {
} _DenseVector_default_instance_;
class DenseSupportVectorsDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<DenseSupportVectors> {
} _DenseSupportVectors_default_instance_;
class CoefficientsDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<Coefficients> {
} _Coefficients_default_instance_;
class SupportVectorRegressorDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<SupportVectorRegressor> {
  public:
  const ::CoreML::Specification::SparseSupportVectors* sparsesupportvectors_;
  const ::CoreML::Specification::DenseSupportVectors* densesupportvectors_;
} _SupportVectorRegressor_default_instance_;
class SupportVectorClassifierDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<SupportVectorClassifier> {
  public:
  const ::CoreML::Specification::SparseSupportVectors* sparsesupportvectors_;
  const ::CoreML::Specification::DenseSupportVectors* densesupportvectors_;
  const ::CoreML::Specification::StringVector* stringclasslabels_;
  const ::CoreML::Specification::Int64Vector* int64classlabels_;
} _SupportVectorClassifier_default_instance_;

namespace protobuf_SVM_2eproto {

PROTOBUF_CONSTEXPR_VAR ::google::protobuf::internal::ParseTableField
    const TableStruct::entries[] = {
  {0, 0, 0, ::google::protobuf::internal::kInvalidMask, 0, 0},
};

PROTOBUF_CONSTEXPR_VAR ::google::protobuf::internal::AuxillaryParseTableField
    const TableStruct::aux[] = {
  ::google::protobuf::internal::AuxillaryParseTableField(),
};
PROTOBUF_CONSTEXPR_VAR ::google::protobuf::internal::ParseTable const
    TableStruct::schema[] = {
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
};


void TableStruct::Shutdown() {
  _LinearKernel_default_instance_.Shutdown();
  _RBFKernel_default_instance_.Shutdown();
  _PolyKernel_default_instance_.Shutdown();
  _SigmoidKernel_default_instance_.Shutdown();
  _Kernel_default_instance_.Shutdown();
  _SparseNode_default_instance_.Shutdown();
  _SparseVector_default_instance_.Shutdown();
  _SparseSupportVectors_default_instance_.Shutdown();
  _DenseVector_default_instance_.Shutdown();
  _DenseSupportVectors_default_instance_.Shutdown();
  _Coefficients_default_instance_.Shutdown();
  _SupportVectorRegressor_default_instance_.Shutdown();
  _SupportVectorClassifier_default_instance_.Shutdown();
}

void TableStruct::InitDefaultsImpl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::internal::InitProtobufDefaults();
  ::CoreML::Specification::protobuf_DataStructures_2eproto::InitDefaults();
  _LinearKernel_default_instance_.DefaultConstruct();
  _RBFKernel_default_instance_.DefaultConstruct();
  _PolyKernel_default_instance_.DefaultConstruct();
  _SigmoidKernel_default_instance_.DefaultConstruct();
  _Kernel_default_instance_.DefaultConstruct();
  _SparseNode_default_instance_.DefaultConstruct();
  _SparseVector_default_instance_.DefaultConstruct();
  _SparseSupportVectors_default_instance_.DefaultConstruct();
  _DenseVector_default_instance_.DefaultConstruct();
  _DenseSupportVectors_default_instance_.DefaultConstruct();
  _Coefficients_default_instance_.DefaultConstruct();
  _SupportVectorRegressor_default_instance_.DefaultConstruct();
  _SupportVectorClassifier_default_instance_.DefaultConstruct();
  _SupportVectorRegressor_default_instance_.get_mutable()->kernel_ = const_cast< ::CoreML::Specification::Kernel*>(
      ::CoreML::Specification::Kernel::internal_default_instance());
  _SupportVectorRegressor_default_instance_.get_mutable()->coefficients_ = const_cast< ::CoreML::Specification::Coefficients*>(
      ::CoreML::Specification::Coefficients::internal_default_instance());
  _SupportVectorClassifier_default_instance_.get_mutable()->kernel_ = const_cast< ::CoreML::Specification::Kernel*>(
      ::CoreML::Specification::Kernel::internal_default_instance());
}

void InitDefaults() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &TableStruct::InitDefaultsImpl);
}
void AddDescriptorsImpl() {
  InitDefaults();
  ::CoreML::Specification::protobuf_DataStructures_2eproto::AddDescriptors();
  ::google::protobuf::internal::OnShutdown(&TableStruct::Shutdown);
}

void AddDescriptors() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &AddDescriptorsImpl);
}
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer {
  StaticDescriptorInitializer() {
    AddDescriptors();
  }
} static_descriptor_initializer;
#endif  // GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER

}  // namespace protobuf_SVM_2eproto


// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

LinearKernel::LinearKernel()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_SVM_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:CoreML.Specification.LinearKernel)
}
LinearKernel::LinearKernel(const LinearKernel& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.LinearKernel)
}

void LinearKernel::SharedCtor() {
  _cached_size_ = 0;
}

LinearKernel::~LinearKernel() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.LinearKernel)
  SharedDtor();
}

void LinearKernel::SharedDtor() {
}

void LinearKernel::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const LinearKernel& LinearKernel::default_instance() {
  protobuf_SVM_2eproto::InitDefaults();
  return *internal_default_instance();
}

LinearKernel* LinearKernel::New(::google::protobuf::Arena* arena) const {
  LinearKernel* n = new LinearKernel;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void LinearKernel::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.LinearKernel)
}

bool LinearKernel::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CoreML.Specification.LinearKernel)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
  }
success:
  // @@protoc_insertion_point(parse_success:CoreML.Specification.LinearKernel)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CoreML.Specification.LinearKernel)
  return false;
#undef DO_
}

void LinearKernel::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CoreML.Specification.LinearKernel)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // @@protoc_insertion_point(serialize_end:CoreML.Specification.LinearKernel)
}

size_t LinearKernel::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.LinearKernel)
  size_t total_size = 0;

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LinearKernel::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const LinearKernel*>(&from));
}

void LinearKernel::MergeFrom(const LinearKernel& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.LinearKernel)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

}

void LinearKernel::CopyFrom(const LinearKernel& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.LinearKernel)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LinearKernel::IsInitialized() const {
  return true;
}

void LinearKernel::Swap(LinearKernel* other) {
  if (other == this) return;
  InternalSwap(other);
}
void LinearKernel::InternalSwap(LinearKernel* other) {
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string LinearKernel::GetTypeName() const {
  return "CoreML.Specification.LinearKernel";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// LinearKernel

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int RBFKernel::kGammaFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

RBFKernel::RBFKernel()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_SVM_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:CoreML.Specification.RBFKernel)
}
RBFKernel::RBFKernel(const RBFKernel& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  gamma_ = from.gamma_;
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.RBFKernel)
}

void RBFKernel::SharedCtor() {
  gamma_ = 0;
  _cached_size_ = 0;
}

RBFKernel::~RBFKernel() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.RBFKernel)
  SharedDtor();
}

void RBFKernel::SharedDtor() {
}

void RBFKernel::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RBFKernel& RBFKernel::default_instance() {
  protobuf_SVM_2eproto::InitDefaults();
  return *internal_default_instance();
}

RBFKernel* RBFKernel::New(::google::protobuf::Arena* arena) const {
  RBFKernel* n = new RBFKernel;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void RBFKernel::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.RBFKernel)
  gamma_ = 0;
}

bool RBFKernel::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CoreML.Specification.RBFKernel)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // double gamma = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(9u)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &gamma_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CoreML.Specification.RBFKernel)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CoreML.Specification.RBFKernel)
  return false;
#undef DO_
}

void RBFKernel::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CoreML.Specification.RBFKernel)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // double gamma = 1;
  if (this->gamma() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(1, this->gamma(), output);
  }

  // @@protoc_insertion_point(serialize_end:CoreML.Specification.RBFKernel)
}

size_t RBFKernel::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.RBFKernel)
  size_t total_size = 0;

  // double gamma = 1;
  if (this->gamma() != 0) {
    total_size += 1 + 8;
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RBFKernel::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RBFKernel*>(&from));
}

void RBFKernel::MergeFrom(const RBFKernel& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.RBFKernel)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.gamma() != 0) {
    set_gamma(from.gamma());
  }
}

void RBFKernel::CopyFrom(const RBFKernel& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.RBFKernel)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RBFKernel::IsInitialized() const {
  return true;
}

void RBFKernel::Swap(RBFKernel* other) {
  if (other == this) return;
  InternalSwap(other);
}
void RBFKernel::InternalSwap(RBFKernel* other) {
  std::swap(gamma_, other->gamma_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string RBFKernel::GetTypeName() const {
  return "CoreML.Specification.RBFKernel";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// RBFKernel

// double gamma = 1;
void RBFKernel::clear_gamma() {
  gamma_ = 0;
}
double RBFKernel::gamma() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.RBFKernel.gamma)
  return gamma_;
}
void RBFKernel::set_gamma(double value) {

  gamma_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.RBFKernel.gamma)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int PolyKernel::kDegreeFieldNumber;
const int PolyKernel::kCFieldNumber;
const int PolyKernel::kGammaFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

PolyKernel::PolyKernel()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_SVM_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:CoreML.Specification.PolyKernel)
}
PolyKernel::PolyKernel(const PolyKernel& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&c_, &from.c_,
    reinterpret_cast<char*>(&degree_) -
    reinterpret_cast<char*>(&c_) + sizeof(degree_));
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.PolyKernel)
}

void PolyKernel::SharedCtor() {
  ::memset(&c_, 0, reinterpret_cast<char*>(&degree_) -
    reinterpret_cast<char*>(&c_) + sizeof(degree_));
  _cached_size_ = 0;
}

PolyKernel::~PolyKernel() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.PolyKernel)
  SharedDtor();
}

void PolyKernel::SharedDtor() {
}

void PolyKernel::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const PolyKernel& PolyKernel::default_instance() {
  protobuf_SVM_2eproto::InitDefaults();
  return *internal_default_instance();
}

PolyKernel* PolyKernel::New(::google::protobuf::Arena* arena) const {
  PolyKernel* n = new PolyKernel;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void PolyKernel::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.PolyKernel)
  ::memset(&c_, 0, reinterpret_cast<char*>(&degree_) -
    reinterpret_cast<char*>(&c_) + sizeof(degree_));
}

bool PolyKernel::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CoreML.Specification.PolyKernel)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // int32 degree = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &degree_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // double c = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(17u)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &c_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // double gamma = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(25u)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &gamma_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CoreML.Specification.PolyKernel)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CoreML.Specification.PolyKernel)
  return false;
#undef DO_
}

void PolyKernel::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CoreML.Specification.PolyKernel)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 degree = 1;
  if (this->degree() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->degree(), output);
  }

  // double c = 2;
  if (this->c() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->c(), output);
  }

  // double gamma = 3;
  if (this->gamma() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(3, this->gamma(), output);
  }

  // @@protoc_insertion_point(serialize_end:CoreML.Specification.PolyKernel)
}

size_t PolyKernel::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.PolyKernel)
  size_t total_size = 0;

  // double c = 2;
  if (this->c() != 0) {
    total_size += 1 + 8;
  }

  // double gamma = 3;
  if (this->gamma() != 0) {
    total_size += 1 + 8;
  }

  // int32 degree = 1;
  if (this->degree() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->degree());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PolyKernel::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const PolyKernel*>(&from));
}

void PolyKernel::MergeFrom(const PolyKernel& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.PolyKernel)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.c() != 0) {
    set_c(from.c());
  }
  if (from.gamma() != 0) {
    set_gamma(from.gamma());
  }
  if (from.degree() != 0) {
    set_degree(from.degree());
  }
}

void PolyKernel::CopyFrom(const PolyKernel& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.PolyKernel)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PolyKernel::IsInitialized() const {
  return true;
}

void PolyKernel::Swap(PolyKernel* other) {
  if (other == this) return;
  InternalSwap(other);
}
void PolyKernel::InternalSwap(PolyKernel* other) {
  std::swap(c_, other->c_);
  std::swap(gamma_, other->gamma_);
  std::swap(degree_, other->degree_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string PolyKernel::GetTypeName() const {
  return "CoreML.Specification.PolyKernel";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// PolyKernel

// int32 degree = 1;
void PolyKernel::clear_degree() {
  degree_ = 0;
}
::google::protobuf::int32 PolyKernel::degree() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.PolyKernel.degree)
  return degree_;
}
void PolyKernel::set_degree(::google::protobuf::int32 value) {

  degree_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.PolyKernel.degree)
}

// double c = 2;
void PolyKernel::clear_c() {
  c_ = 0;
}
double PolyKernel::c() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.PolyKernel.c)
  return c_;
}
void PolyKernel::set_c(double value) {

  c_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.PolyKernel.c)
}

// double gamma = 3;
void PolyKernel::clear_gamma() {
  gamma_ = 0;
}
double PolyKernel::gamma() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.PolyKernel.gamma)
  return gamma_;
}
void PolyKernel::set_gamma(double value) {

  gamma_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.PolyKernel.gamma)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int SigmoidKernel::kGammaFieldNumber;
const int SigmoidKernel::kCFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

SigmoidKernel::SigmoidKernel()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_SVM_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:CoreML.Specification.SigmoidKernel)
}
SigmoidKernel::SigmoidKernel(const SigmoidKernel& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&gamma_, &from.gamma_,
    reinterpret_cast<char*>(&c_) -
    reinterpret_cast<char*>(&gamma_) + sizeof(c_));
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.SigmoidKernel)
}

void SigmoidKernel::SharedCtor() {
  ::memset(&gamma_, 0, reinterpret_cast<char*>(&c_) -
    reinterpret_cast<char*>(&gamma_) + sizeof(c_));
  _cached_size_ = 0;
}

SigmoidKernel::~SigmoidKernel() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.SigmoidKernel)
  SharedDtor();
}

void SigmoidKernel::SharedDtor() {
}

void SigmoidKernel::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const SigmoidKernel& SigmoidKernel::default_instance() {
  protobuf_SVM_2eproto::InitDefaults();
  return *internal_default_instance();
}

SigmoidKernel* SigmoidKernel::New(::google::protobuf::Arena* arena) const {
  SigmoidKernel* n = new SigmoidKernel;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void SigmoidKernel::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.SigmoidKernel)
  ::memset(&gamma_, 0, reinterpret_cast<char*>(&c_) -
    reinterpret_cast<char*>(&gamma_) + sizeof(c_));
}

bool SigmoidKernel::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CoreML.Specification.SigmoidKernel)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // double gamma = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(9u)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &gamma_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // double c = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(17u)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &c_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CoreML.Specification.SigmoidKernel)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CoreML.Specification.SigmoidKernel)
  return false;
#undef DO_
}

void SigmoidKernel::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CoreML.Specification.SigmoidKernel)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // double gamma = 1;
  if (this->gamma() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(1, this->gamma(), output);
  }

  // double c = 2;
  if (this->c() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->c(), output);
  }

  // @@protoc_insertion_point(serialize_end:CoreML.Specification.SigmoidKernel)
}

size_t SigmoidKernel::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.SigmoidKernel)
  size_t total_size = 0;

  // double gamma = 1;
  if (this->gamma() != 0) {
    total_size += 1 + 8;
  }

  // double c = 2;
  if (this->c() != 0) {
    total_size += 1 + 8;
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SigmoidKernel::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const SigmoidKernel*>(&from));
}

void SigmoidKernel::MergeFrom(const SigmoidKernel& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.SigmoidKernel)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.gamma() != 0) {
    set_gamma(from.gamma());
  }
  if (from.c() != 0) {
    set_c(from.c());
  }
}

void SigmoidKernel::CopyFrom(const SigmoidKernel& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.SigmoidKernel)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SigmoidKernel::IsInitialized() const {
  return true;
}

void SigmoidKernel::Swap(SigmoidKernel* other) {
  if (other == this) return;
  InternalSwap(other);
}
void SigmoidKernel::InternalSwap(SigmoidKernel* other) {
  std::swap(gamma_, other->gamma_);
  std::swap(c_, other->c_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string SigmoidKernel::GetTypeName() const {
  return "CoreML.Specification.SigmoidKernel";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// SigmoidKernel

// double gamma = 1;
void SigmoidKernel::clear_gamma() {
  gamma_ = 0;
}
double SigmoidKernel::gamma() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.SigmoidKernel.gamma)
  return gamma_;
}
void SigmoidKernel::set_gamma(double value) {

  gamma_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.SigmoidKernel.gamma)
}

// double c = 2;
void SigmoidKernel::clear_c() {
  c_ = 0;
}
double SigmoidKernel::c() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.SigmoidKernel.c)
  return c_;
}
void SigmoidKernel::set_c(double value) {

  c_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.SigmoidKernel.c)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Kernel::kLinearKernelFieldNumber;
const int Kernel::kRbfKernelFieldNumber;
const int Kernel::kPolyKernelFieldNumber;
const int Kernel::kSigmoidKernelFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Kernel::Kernel()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_SVM_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:CoreML.Specification.Kernel)
}
Kernel::Kernel(const Kernel& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  clear_has_kernel();
  switch (from.kernel_case()) {
    case kLinearKernel: {
      mutable_linearkernel()->::CoreML::Specification::LinearKernel::MergeFrom(from.linearkernel());
      break;
    }
    case kRbfKernel: {
      mutable_rbfkernel()->::CoreML::Specification::RBFKernel::MergeFrom(from.rbfkernel());
      break;
    }
    case kPolyKernel: {
      mutable_polykernel()->::CoreML::Specification::PolyKernel::MergeFrom(from.polykernel());
      break;
    }
    case kSigmoidKernel: {
      mutable_sigmoidkernel()->::CoreML::Specification::SigmoidKernel::MergeFrom(from.sigmoidkernel());
      break;
    }
    case KERNEL_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.Kernel)
}

void Kernel::SharedCtor() {
  clear_has_kernel();
  _cached_size_ = 0;
}

Kernel::~Kernel() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.Kernel)
  SharedDtor();
}

void Kernel::SharedDtor() {
  if (has_kernel()) {
    clear_kernel();
  }
}

void Kernel::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Kernel& Kernel::default_instance() {
  protobuf_SVM_2eproto::InitDefaults();
  return *internal_default_instance();
}

Kernel* Kernel::New(::google::protobuf::Arena* arena) const {
  Kernel* n = new Kernel;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Kernel::clear_kernel() {
// @@protoc_insertion_point(one_of_clear_start:CoreML.Specification.Kernel)
  switch (kernel_case()) {
    case kLinearKernel: {
      delete kernel_.linearkernel_;
      break;
    }
    case kRbfKernel: {
      delete kernel_.rbfkernel_;
      break;
    }
    case kPolyKernel: {
      delete kernel_.polykernel_;
      break;
    }
    case kSigmoidKernel: {
      delete kernel_.sigmoidkernel_;
      break;
    }
    case KERNEL_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = KERNEL_NOT_SET;
}


void Kernel::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.Kernel)
  clear_kernel();
}

bool Kernel::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CoreML.Specification.Kernel)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // .CoreML.Specification.LinearKernel linearKernel = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_linearkernel()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .CoreML.Specification.RBFKernel rbfKernel = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_rbfkernel()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .CoreML.Specification.PolyKernel polyKernel = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(26u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_polykernel()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .CoreML.Specification.SigmoidKernel sigmoidKernel = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(34u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_sigmoidkernel()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CoreML.Specification.Kernel)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CoreML.Specification.Kernel)
  return false;
#undef DO_
}

void Kernel::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CoreML.Specification.Kernel)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .CoreML.Specification.LinearKernel linearKernel = 1;
  if (has_linearkernel()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, *kernel_.linearkernel_, output);
  }

  // .CoreML.Specification.RBFKernel rbfKernel = 2;
  if (has_rbfkernel()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, *kernel_.rbfkernel_, output);
  }

  // .CoreML.Specification.PolyKernel polyKernel = 3;
  if (has_polykernel()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, *kernel_.polykernel_, output);
  }

  // .CoreML.Specification.SigmoidKernel sigmoidKernel = 4;
  if (has_sigmoidkernel()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4, *kernel_.sigmoidkernel_, output);
  }

  // @@protoc_insertion_point(serialize_end:CoreML.Specification.Kernel)
}

size_t Kernel::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.Kernel)
  size_t total_size = 0;

  switch (kernel_case()) {
    // .CoreML.Specification.LinearKernel linearKernel = 1;
    case kLinearKernel: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *kernel_.linearkernel_);
      break;
    }
    // .CoreML.Specification.RBFKernel rbfKernel = 2;
    case kRbfKernel: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *kernel_.rbfkernel_);
      break;
    }
    // .CoreML.Specification.PolyKernel polyKernel = 3;
    case kPolyKernel: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *kernel_.polykernel_);
      break;
    }
    // .CoreML.Specification.SigmoidKernel sigmoidKernel = 4;
    case kSigmoidKernel: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *kernel_.sigmoidkernel_);
      break;
    }
    case KERNEL_NOT_SET: {
      break;
    }
  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Kernel::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Kernel*>(&from));
}

void Kernel::MergeFrom(const Kernel& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.Kernel)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.kernel_case()) {
    case kLinearKernel: {
      mutable_linearkernel()->::CoreML::Specification::LinearKernel::MergeFrom(from.linearkernel());
      break;
    }
    case kRbfKernel: {
      mutable_rbfkernel()->::CoreML::Specification::RBFKernel::MergeFrom(from.rbfkernel());
      break;
    }
    case kPolyKernel: {
      mutable_polykernel()->::CoreML::Specification::PolyKernel::MergeFrom(from.polykernel());
      break;
    }
    case kSigmoidKernel: {
      mutable_sigmoidkernel()->::CoreML::Specification::SigmoidKernel::MergeFrom(from.sigmoidkernel());
      break;
    }
    case KERNEL_NOT_SET: {
      break;
    }
  }
}

void Kernel::CopyFrom(const Kernel& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.Kernel)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Kernel::IsInitialized() const {
  return true;
}

void Kernel::Swap(Kernel* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Kernel::InternalSwap(Kernel* other) {
  std::swap(kernel_, other->kernel_);
  std::swap(_oneof_case_[0], other->_oneof_case_[0]);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string Kernel::GetTypeName() const {
  return "CoreML.Specification.Kernel";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Kernel

// .CoreML.Specification.LinearKernel linearKernel = 1;
bool Kernel::has_linearkernel() const {
  return kernel_case() == kLinearKernel;
}
void Kernel::set_has_linearkernel() {
  _oneof_case_[0] = kLinearKernel;
}
void Kernel::clear_linearkernel() {
  if (has_linearkernel()) {
    delete kernel_.linearkernel_;
    clear_has_kernel();
  }
}
 const ::CoreML::Specification::LinearKernel& Kernel::linearkernel() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.Kernel.linearKernel)
  return has_linearkernel()
      ? *kernel_.linearkernel_
      : ::CoreML::Specification::LinearKernel::default_instance();
}
::CoreML::Specification::LinearKernel* Kernel::mutable_linearkernel() {
  if (!has_linearkernel()) {
    clear_kernel();
    set_has_linearkernel();
    kernel_.linearkernel_ = new ::CoreML::Specification::LinearKernel;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.Kernel.linearKernel)
  return kernel_.linearkernel_;
}
::CoreML::Specification::LinearKernel* Kernel::release_linearkernel() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.Kernel.linearKernel)
  if (has_linearkernel()) {
    clear_has_kernel();
    ::CoreML::Specification::LinearKernel* temp = kernel_.linearkernel_;
    kernel_.linearkernel_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void Kernel::set_allocated_linearkernel(::CoreML::Specification::LinearKernel* linearkernel) {
  clear_kernel();
  if (linearkernel) {
    set_has_linearkernel();
    kernel_.linearkernel_ = linearkernel;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.Kernel.linearKernel)
}

// .CoreML.Specification.RBFKernel rbfKernel = 2;
bool Kernel::has_rbfkernel() const {
  return kernel_case() == kRbfKernel;
}
void Kernel::set_has_rbfkernel() {
  _oneof_case_[0] = kRbfKernel;
}
void Kernel::clear_rbfkernel() {
  if (has_rbfkernel()) {
    delete kernel_.rbfkernel_;
    clear_has_kernel();
  }
}
 const ::CoreML::Specification::RBFKernel& Kernel::rbfkernel() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.Kernel.rbfKernel)
  return has_rbfkernel()
      ? *kernel_.rbfkernel_
      : ::CoreML::Specification::RBFKernel::default_instance();
}
::CoreML::Specification::RBFKernel* Kernel::mutable_rbfkernel() {
  if (!has_rbfkernel()) {
    clear_kernel();
    set_has_rbfkernel();
    kernel_.rbfkernel_ = new ::CoreML::Specification::RBFKernel;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.Kernel.rbfKernel)
  return kernel_.rbfkernel_;
}
::CoreML::Specification::RBFKernel* Kernel::release_rbfkernel() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.Kernel.rbfKernel)
  if (has_rbfkernel()) {
    clear_has_kernel();
    ::CoreML::Specification::RBFKernel* temp = kernel_.rbfkernel_;
    kernel_.rbfkernel_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void Kernel::set_allocated_rbfkernel(::CoreML::Specification::RBFKernel* rbfkernel) {
  clear_kernel();
  if (rbfkernel) {
    set_has_rbfkernel();
    kernel_.rbfkernel_ = rbfkernel;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.Kernel.rbfKernel)
}

// .CoreML.Specification.PolyKernel polyKernel = 3;
bool Kernel::has_polykernel() const {
  return kernel_case() == kPolyKernel;
}
void Kernel::set_has_polykernel() {
  _oneof_case_[0] = kPolyKernel;
}
void Kernel::clear_polykernel() {
  if (has_polykernel()) {
    delete kernel_.polykernel_;
    clear_has_kernel();
  }
}
 const ::CoreML::Specification::PolyKernel& Kernel::polykernel() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.Kernel.polyKernel)
  return has_polykernel()
      ? *kernel_.polykernel_
      : ::CoreML::Specification::PolyKernel::default_instance();
}
::CoreML::Specification::PolyKernel* Kernel::mutable_polykernel() {
  if (!has_polykernel()) {
    clear_kernel();
    set_has_polykernel();
    kernel_.polykernel_ = new ::CoreML::Specification::PolyKernel;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.Kernel.polyKernel)
  return kernel_.polykernel_;
}
::CoreML::Specification::PolyKernel* Kernel::release_polykernel() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.Kernel.polyKernel)
  if (has_polykernel()) {
    clear_has_kernel();
    ::CoreML::Specification::PolyKernel* temp = kernel_.polykernel_;
    kernel_.polykernel_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void Kernel::set_allocated_polykernel(::CoreML::Specification::PolyKernel* polykernel) {
  clear_kernel();
  if (polykernel) {
    set_has_polykernel();
    kernel_.polykernel_ = polykernel;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.Kernel.polyKernel)
}

// .CoreML.Specification.SigmoidKernel sigmoidKernel = 4;
bool Kernel::has_sigmoidkernel() const {
  return kernel_case() == kSigmoidKernel;
}
void Kernel::set_has_sigmoidkernel() {
  _oneof_case_[0] = kSigmoidKernel;
}
void Kernel::clear_sigmoidkernel() {
  if (has_sigmoidkernel()) {
    delete kernel_.sigmoidkernel_;
    clear_has_kernel();
  }
}
 const ::CoreML::Specification::SigmoidKernel& Kernel::sigmoidkernel() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.Kernel.sigmoidKernel)
  return has_sigmoidkernel()
      ? *kernel_.sigmoidkernel_
      : ::CoreML::Specification::SigmoidKernel::default_instance();
}
::CoreML::Specification::SigmoidKernel* Kernel::mutable_sigmoidkernel() {
  if (!has_sigmoidkernel()) {
    clear_kernel();
    set_has_sigmoidkernel();
    kernel_.sigmoidkernel_ = new ::CoreML::Specification::SigmoidKernel;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.Kernel.sigmoidKernel)
  return kernel_.sigmoidkernel_;
}
::CoreML::Specification::SigmoidKernel* Kernel::release_sigmoidkernel() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.Kernel.sigmoidKernel)
  if (has_sigmoidkernel()) {
    clear_has_kernel();
    ::CoreML::Specification::SigmoidKernel* temp = kernel_.sigmoidkernel_;
    kernel_.sigmoidkernel_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void Kernel::set_allocated_sigmoidkernel(::CoreML::Specification::SigmoidKernel* sigmoidkernel) {
  clear_kernel();
  if (sigmoidkernel) {
    set_has_sigmoidkernel();
    kernel_.sigmoidkernel_ = sigmoidkernel;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.Kernel.sigmoidKernel)
}

bool Kernel::has_kernel() const {
  return kernel_case() != KERNEL_NOT_SET;
}
void Kernel::clear_has_kernel() {
  _oneof_case_[0] = KERNEL_NOT_SET;
}
Kernel::KernelCase Kernel::kernel_case() const {
  return Kernel::KernelCase(_oneof_case_[0]);
}
#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int SparseNode::kIndexFieldNumber;
const int SparseNode::kValueFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

SparseNode::SparseNode()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_SVM_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:CoreML.Specification.SparseNode)
}
SparseNode::SparseNode(const SparseNode& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&value_, &from.value_,
    reinterpret_cast<char*>(&index_) -
    reinterpret_cast<char*>(&value_) + sizeof(index_));
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.SparseNode)
}

void SparseNode::SharedCtor() {
  ::memset(&value_, 0, reinterpret_cast<char*>(&index_) -
    reinterpret_cast<char*>(&value_) + sizeof(index_));
  _cached_size_ = 0;
}

SparseNode::~SparseNode() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.SparseNode)
  SharedDtor();
}

void SparseNode::SharedDtor() {
}

void SparseNode::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const SparseNode& SparseNode::default_instance() {
  protobuf_SVM_2eproto::InitDefaults();
  return *internal_default_instance();
}

SparseNode* SparseNode::New(::google::protobuf::Arena* arena) const {
  SparseNode* n = new SparseNode;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void SparseNode::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.SparseNode)
  ::memset(&value_, 0, reinterpret_cast<char*>(&index_) -
    reinterpret_cast<char*>(&value_) + sizeof(index_));
}

bool SparseNode::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CoreML.Specification.SparseNode)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // int32 index = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &index_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // double value = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(17u)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &value_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CoreML.Specification.SparseNode)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CoreML.Specification.SparseNode)
  return false;
#undef DO_
}

void SparseNode::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CoreML.Specification.SparseNode)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 index = 1;
  if (this->index() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->index(), output);
  }

  // double value = 2;
  if (this->value() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->value(), output);
  }

  // @@protoc_insertion_point(serialize_end:CoreML.Specification.SparseNode)
}

size_t SparseNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.SparseNode)
  size_t total_size = 0;

  // double value = 2;
  if (this->value() != 0) {
    total_size += 1 + 8;
  }

  // int32 index = 1;
  if (this->index() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->index());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SparseNode::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const SparseNode*>(&from));
}

void SparseNode::MergeFrom(const SparseNode& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.SparseNode)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.value() != 0) {
    set_value(from.value());
  }
  if (from.index() != 0) {
    set_index(from.index());
  }
}

void SparseNode::CopyFrom(const SparseNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.SparseNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SparseNode::IsInitialized() const {
  return true;
}

void SparseNode::Swap(SparseNode* other) {
  if (other == this) return;
  InternalSwap(other);
}
void SparseNode::InternalSwap(SparseNode* other) {
  std::swap(value_, other->value_);
  std::swap(index_, other->index_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string SparseNode::GetTypeName() const {
  return "CoreML.Specification.SparseNode";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// SparseNode

// int32 index = 1;
void SparseNode::clear_index() {
  index_ = 0;
}
::google::protobuf::int32 SparseNode::index() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.SparseNode.index)
  return index_;
}
void SparseNode::set_index(::google::protobuf::int32 value) {

  index_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.SparseNode.index)
}

// double value = 2;
void SparseNode::clear_value() {
  value_ = 0;
}
double SparseNode::value() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.SparseNode.value)
  return value_;
}
void SparseNode::set_value(double value) {

  value_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.SparseNode.value)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int SparseVector::kNodesFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

SparseVector::SparseVector()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_SVM_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:CoreML.Specification.SparseVector)
}
SparseVector::SparseVector(const SparseVector& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      nodes_(from.nodes_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.SparseVector)
}

void SparseVector::SharedCtor() {
  _cached_size_ = 0;
}

SparseVector::~SparseVector() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.SparseVector)
  SharedDtor();
}

void SparseVector::SharedDtor() {
}

void SparseVector::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const SparseVector& SparseVector::default_instance() {
  protobuf_SVM_2eproto::InitDefaults();
  return *internal_default_instance();
}

SparseVector* SparseVector::New(::google::protobuf::Arena* arena) const {
  SparseVector* n = new SparseVector;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void SparseVector::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.SparseVector)
  nodes_.Clear();
}

bool SparseVector::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CoreML.Specification.SparseVector)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .CoreML.Specification.SparseNode nodes = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_nodes()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CoreML.Specification.SparseVector)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CoreML.Specification.SparseVector)
  return false;
#undef DO_
}

void SparseVector::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CoreML.Specification.SparseVector)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .CoreML.Specification.SparseNode nodes = 1;
  for (unsigned int i = 0, n = this->nodes_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->nodes(i), output);
  }

  // @@protoc_insertion_point(serialize_end:CoreML.Specification.SparseVector)
}

size_t SparseVector::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.SparseVector)
  size_t total_size = 0;

  // repeated .CoreML.Specification.SparseNode nodes = 1;
  {
    unsigned int count = this->nodes_size();
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->nodes(i));
    }
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SparseVector::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const SparseVector*>(&from));
}

void SparseVector::MergeFrom(const SparseVector& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.SparseVector)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  nodes_.MergeFrom(from.nodes_);
}

void SparseVector::CopyFrom(const SparseVector& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.SparseVector)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SparseVector::IsInitialized() const {
  return true;
}

void SparseVector::Swap(SparseVector* other) {
  if (other == this) return;
  InternalSwap(other);
}
void SparseVector::InternalSwap(SparseVector* other) {
  nodes_.InternalSwap(&other->nodes_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string SparseVector::GetTypeName() const {
  return "CoreML.Specification.SparseVector";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// SparseVector

// repeated .CoreML.Specification.SparseNode nodes = 1;
int SparseVector::nodes_size() const {
  return nodes_.size();
}
void SparseVector::clear_nodes() {
  nodes_.Clear();
}
const ::CoreML::Specification::SparseNode& SparseVector::nodes(int index) const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.SparseVector.nodes)
  return nodes_.Get(index);
}
::CoreML::Specification::SparseNode* SparseVector::mutable_nodes(int index) {
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.SparseVector.nodes)
  return nodes_.Mutable(index);
}
::CoreML::Specification::SparseNode* SparseVector::add_nodes() {
  // @@protoc_insertion_point(field_add:CoreML.Specification.SparseVector.nodes)
  return nodes_.Add();
}
::google::protobuf::RepeatedPtrField< ::CoreML::Specification::SparseNode >*
SparseVector::mutable_nodes() {
  // @@protoc_insertion_point(field_mutable_list:CoreML.Specification.SparseVector.nodes)
  return &nodes_;
}
const ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::SparseNode >&
SparseVector::nodes() const {
  // @@protoc_insertion_point(field_list:CoreML.Specification.SparseVector.nodes)
  return nodes_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int SparseSupportVectors::kVectorsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

SparseSupportVectors::SparseSupportVectors()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_SVM_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:CoreML.Specification.SparseSupportVectors)
}
SparseSupportVectors::SparseSupportVectors(const SparseSupportVectors& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      vectors_(from.vectors_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.SparseSupportVectors)
}

void SparseSupportVectors::SharedCtor() {
  _cached_size_ = 0;
}

SparseSupportVectors::~SparseSupportVectors() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.SparseSupportVectors)
  SharedDtor();
}

void SparseSupportVectors::SharedDtor() {
}

void SparseSupportVectors::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const SparseSupportVectors& SparseSupportVectors::default_instance() {
  protobuf_SVM_2eproto::InitDefaults();
  return *internal_default_instance();
}

SparseSupportVectors* SparseSupportVectors::New(::google::protobuf::Arena* arena) const {
  SparseSupportVectors* n = new SparseSupportVectors;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void SparseSupportVectors::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.SparseSupportVectors)
  vectors_.Clear();
}

bool SparseSupportVectors::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CoreML.Specification.SparseSupportVectors)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .CoreML.Specification.SparseVector vectors = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_vectors()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CoreML.Specification.SparseSupportVectors)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CoreML.Specification.SparseSupportVectors)
  return false;
#undef DO_
}

void SparseSupportVectors::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CoreML.Specification.SparseSupportVectors)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .CoreML.Specification.SparseVector vectors = 1;
  for (unsigned int i = 0, n = this->vectors_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->vectors(i), output);
  }

  // @@protoc_insertion_point(serialize_end:CoreML.Specification.SparseSupportVectors)
}

size_t SparseSupportVectors::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.SparseSupportVectors)
  size_t total_size = 0;

  // repeated .CoreML.Specification.SparseVector vectors = 1;
  {
    unsigned int count = this->vectors_size();
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->vectors(i));
    }
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SparseSupportVectors::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const SparseSupportVectors*>(&from));
}

void SparseSupportVectors::MergeFrom(const SparseSupportVectors& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.SparseSupportVectors)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  vectors_.MergeFrom(from.vectors_);
}

void SparseSupportVectors::CopyFrom(const SparseSupportVectors& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.SparseSupportVectors)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SparseSupportVectors::IsInitialized() const {
  return true;
}

void SparseSupportVectors::Swap(SparseSupportVectors* other) {
  if (other == this) return;
  InternalSwap(other);
}
void SparseSupportVectors::InternalSwap(SparseSupportVectors* other) {
  vectors_.InternalSwap(&other->vectors_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string SparseSupportVectors::GetTypeName() const {
  return "CoreML.Specification.SparseSupportVectors";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// SparseSupportVectors

// repeated .CoreML.Specification.SparseVector vectors = 1;
int SparseSupportVectors::vectors_size() const {
  return vectors_.size();
}
void SparseSupportVectors::clear_vectors() {
  vectors_.Clear();
}
const ::CoreML::Specification::SparseVector& SparseSupportVectors::vectors(int index) const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.SparseSupportVectors.vectors)
  return vectors_.Get(index);
}
::CoreML::Specification::SparseVector* SparseSupportVectors::mutable_vectors(int index) {
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.SparseSupportVectors.vectors)
  return vectors_.Mutable(index);
}
::CoreML::Specification::SparseVector* SparseSupportVectors::add_vectors() {
  // @@protoc_insertion_point(field_add:CoreML.Specification.SparseSupportVectors.vectors)
  return vectors_.Add();
}
::google::protobuf::RepeatedPtrField< ::CoreML::Specification::SparseVector >*
SparseSupportVectors::mutable_vectors() {
  // @@protoc_insertion_point(field_mutable_list:CoreML.Specification.SparseSupportVectors.vectors)
  return &vectors_;
}
const ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::SparseVector >&
SparseSupportVectors::vectors() const {
  // @@protoc_insertion_point(field_list:CoreML.Specification.SparseSupportVectors.vectors)
  return vectors_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int DenseVector::kValuesFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

DenseVector::DenseVector()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_SVM_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:CoreML.Specification.DenseVector)
}
DenseVector::DenseVector(const DenseVector& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      values_(from.values_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.DenseVector)
}

void DenseVector::SharedCtor() {
  _cached_size_ = 0;
}

DenseVector::~DenseVector() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.DenseVector)
  SharedDtor();
}

void DenseVector::SharedDtor() {
}

void DenseVector::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const DenseVector& DenseVector::default_instance() {
  protobuf_SVM_2eproto::InitDefaults();
  return *internal_default_instance();
}

DenseVector* DenseVector::New(::google::protobuf::Arena* arena) const {
  DenseVector* n = new DenseVector;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void DenseVector::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.DenseVector)
  values_.Clear();
}

bool DenseVector::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CoreML.Specification.DenseVector)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated double values = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, this->mutable_values())));
        } else if (static_cast< ::google::protobuf::uint8>(tag) ==
                   static_cast< ::google::protobuf::uint8>(9u)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitiveNoInline<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 1, 10u, input, this->mutable_values())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CoreML.Specification.DenseVector)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CoreML.Specification.DenseVector)
  return false;
#undef DO_
}

void DenseVector::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CoreML.Specification.DenseVector)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated double values = 1;
  if (this->values_size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteTag(1, ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED, output);
    output->WriteVarint32(_values_cached_byte_size_);
    ::google::protobuf::internal::WireFormatLite::WriteDoubleArray(
      this->values().data(), this->values_size(), output);
  }

  // @@protoc_insertion_point(serialize_end:CoreML.Specification.DenseVector)
}

size_t DenseVector::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.DenseVector)
  size_t total_size = 0;

  // repeated double values = 1;
  {
    unsigned int count = this->values_size();
    size_t data_size = 8UL * count;
    if (data_size > 0) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(data_size);
    }
    int cached_size = ::google::protobuf::internal::ToCachedSize(data_size);
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _values_cached_byte_size_ = cached_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    total_size += data_size;
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DenseVector::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const DenseVector*>(&from));
}

void DenseVector::MergeFrom(const DenseVector& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.DenseVector)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  values_.MergeFrom(from.values_);
}

void DenseVector::CopyFrom(const DenseVector& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.DenseVector)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DenseVector::IsInitialized() const {
  return true;
}

void DenseVector::Swap(DenseVector* other) {
  if (other == this) return;
  InternalSwap(other);
}
void DenseVector::InternalSwap(DenseVector* other) {
  values_.InternalSwap(&other->values_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string DenseVector::GetTypeName() const {
  return "CoreML.Specification.DenseVector";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// DenseVector

// repeated double values = 1;
int DenseVector::values_size() const {
  return values_.size();
}
void DenseVector::clear_values() {
  values_.Clear();
}
double DenseVector::values(int index) const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.DenseVector.values)
  return values_.Get(index);
}
void DenseVector::set_values(int index, double value) {
  values_.Set(index, value);
  // @@protoc_insertion_point(field_set:CoreML.Specification.DenseVector.values)
}
void DenseVector::add_values(double value) {
  values_.Add(value);
  // @@protoc_insertion_point(field_add:CoreML.Specification.DenseVector.values)
}
const ::google::protobuf::RepeatedField< double >&
DenseVector::values() const {
  // @@protoc_insertion_point(field_list:CoreML.Specification.DenseVector.values)
  return values_;
}
::google::protobuf::RepeatedField< double >*
DenseVector::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:CoreML.Specification.DenseVector.values)
  return &values_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int DenseSupportVectors::kVectorsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

DenseSupportVectors::DenseSupportVectors()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_SVM_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:CoreML.Specification.DenseSupportVectors)
}
DenseSupportVectors::DenseSupportVectors(const DenseSupportVectors& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      vectors_(from.vectors_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.DenseSupportVectors)
}

void DenseSupportVectors::SharedCtor() {
  _cached_size_ = 0;
}

DenseSupportVectors::~DenseSupportVectors() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.DenseSupportVectors)
  SharedDtor();
}

void DenseSupportVectors::SharedDtor() {
}

void DenseSupportVectors::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const DenseSupportVectors& DenseSupportVectors::default_instance() {
  protobuf_SVM_2eproto::InitDefaults();
  return *internal_default_instance();
}

DenseSupportVectors* DenseSupportVectors::New(::google::protobuf::Arena* arena) const {
  DenseSupportVectors* n = new DenseSupportVectors;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void DenseSupportVectors::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.DenseSupportVectors)
  vectors_.Clear();
}

bool DenseSupportVectors::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CoreML.Specification.DenseSupportVectors)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .CoreML.Specification.DenseVector vectors = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_vectors()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CoreML.Specification.DenseSupportVectors)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CoreML.Specification.DenseSupportVectors)
  return false;
#undef DO_
}

void DenseSupportVectors::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CoreML.Specification.DenseSupportVectors)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .CoreML.Specification.DenseVector vectors = 1;
  for (unsigned int i = 0, n = this->vectors_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->vectors(i), output);
  }

  // @@protoc_insertion_point(serialize_end:CoreML.Specification.DenseSupportVectors)
}

size_t DenseSupportVectors::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.DenseSupportVectors)
  size_t total_size = 0;

  // repeated .CoreML.Specification.DenseVector vectors = 1;
  {
    unsigned int count = this->vectors_size();
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->vectors(i));
    }
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DenseSupportVectors::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const DenseSupportVectors*>(&from));
}

void DenseSupportVectors::MergeFrom(const DenseSupportVectors& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.DenseSupportVectors)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  vectors_.MergeFrom(from.vectors_);
}

void DenseSupportVectors::CopyFrom(const DenseSupportVectors& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.DenseSupportVectors)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DenseSupportVectors::IsInitialized() const {
  return true;
}

void DenseSupportVectors::Swap(DenseSupportVectors* other) {
  if (other == this) return;
  InternalSwap(other);
}
void DenseSupportVectors::InternalSwap(DenseSupportVectors* other) {
  vectors_.InternalSwap(&other->vectors_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string DenseSupportVectors::GetTypeName() const {
  return "CoreML.Specification.DenseSupportVectors";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// DenseSupportVectors

// repeated .CoreML.Specification.DenseVector vectors = 1;
int DenseSupportVectors::vectors_size() const {
  return vectors_.size();
}
void DenseSupportVectors::clear_vectors() {
  vectors_.Clear();
}
const ::CoreML::Specification::DenseVector& DenseSupportVectors::vectors(int index) const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.DenseSupportVectors.vectors)
  return vectors_.Get(index);
}
::CoreML::Specification::DenseVector* DenseSupportVectors::mutable_vectors(int index) {
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.DenseSupportVectors.vectors)
  return vectors_.Mutable(index);
}
::CoreML::Specification::DenseVector* DenseSupportVectors::add_vectors() {
  // @@protoc_insertion_point(field_add:CoreML.Specification.DenseSupportVectors.vectors)
  return vectors_.Add();
}
::google::protobuf::RepeatedPtrField< ::CoreML::Specification::DenseVector >*
DenseSupportVectors::mutable_vectors() {
  // @@protoc_insertion_point(field_mutable_list:CoreML.Specification.DenseSupportVectors.vectors)
  return &vectors_;
}
const ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::DenseVector >&
DenseSupportVectors::vectors() const {
  // @@protoc_insertion_point(field_list:CoreML.Specification.DenseSupportVectors.vectors)
  return vectors_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Coefficients::kAlphaFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Coefficients::Coefficients()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_SVM_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:CoreML.Specification.Coefficients)
}
Coefficients::Coefficients(const Coefficients& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      alpha_(from.alpha_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.Coefficients)
}

void Coefficients::SharedCtor() {
  _cached_size_ = 0;
}

Coefficients::~Coefficients() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.Coefficients)
  SharedDtor();
}

void Coefficients::SharedDtor() {
}

void Coefficients::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Coefficients& Coefficients::default_instance() {
  protobuf_SVM_2eproto::InitDefaults();
  return *internal_default_instance();
}

Coefficients* Coefficients::New(::google::protobuf::Arena* arena) const {
  Coefficients* n = new Coefficients;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Coefficients::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.Coefficients)
  alpha_.Clear();
}

bool Coefficients::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CoreML.Specification.Coefficients)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated double alpha = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, this->mutable_alpha())));
        } else if (static_cast< ::google::protobuf::uint8>(tag) ==
                   static_cast< ::google::protobuf::uint8>(9u)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitiveNoInline<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 1, 10u, input, this->mutable_alpha())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CoreML.Specification.Coefficients)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CoreML.Specification.Coefficients)
  return false;
#undef DO_
}

void Coefficients::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CoreML.Specification.Coefficients)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated double alpha = 1;
  if (this->alpha_size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteTag(1, ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED, output);
    output->WriteVarint32(_alpha_cached_byte_size_);
    ::google::protobuf::internal::WireFormatLite::WriteDoubleArray(
      this->alpha().data(), this->alpha_size(), output);
  }

  // @@protoc_insertion_point(serialize_end:CoreML.Specification.Coefficients)
}

size_t Coefficients::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.Coefficients)
  size_t total_size = 0;

  // repeated double alpha = 1;
  {
    unsigned int count = this->alpha_size();
    size_t data_size = 8UL * count;
    if (data_size > 0) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(data_size);
    }
    int cached_size = ::google::protobuf::internal::ToCachedSize(data_size);
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _alpha_cached_byte_size_ = cached_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    total_size += data_size;
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Coefficients::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Coefficients*>(&from));
}

void Coefficients::MergeFrom(const Coefficients& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.Coefficients)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  alpha_.MergeFrom(from.alpha_);
}

void Coefficients::CopyFrom(const Coefficients& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.Coefficients)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Coefficients::IsInitialized() const {
  return true;
}

void Coefficients::Swap(Coefficients* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Coefficients::InternalSwap(Coefficients* other) {
  alpha_.InternalSwap(&other->alpha_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string Coefficients::GetTypeName() const {
  return "CoreML.Specification.Coefficients";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Coefficients

// repeated double alpha = 1;
int Coefficients::alpha_size() const {
  return alpha_.size();
}
void Coefficients::clear_alpha() {
  alpha_.Clear();
}
double Coefficients::alpha(int index) const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.Coefficients.alpha)
  return alpha_.Get(index);
}
void Coefficients::set_alpha(int index, double value) {
  alpha_.Set(index, value);
  // @@protoc_insertion_point(field_set:CoreML.Specification.Coefficients.alpha)
}
void Coefficients::add_alpha(double value) {
  alpha_.Add(value);
  // @@protoc_insertion_point(field_add:CoreML.Specification.Coefficients.alpha)
}
const ::google::protobuf::RepeatedField< double >&
Coefficients::alpha() const {
  // @@protoc_insertion_point(field_list:CoreML.Specification.Coefficients.alpha)
  return alpha_;
}
::google::protobuf::RepeatedField< double >*
Coefficients::mutable_alpha() {
  // @@protoc_insertion_point(field_mutable_list:CoreML.Specification.Coefficients.alpha)
  return &alpha_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int SupportVectorRegressor::kKernelFieldNumber;
const int SupportVectorRegressor::kSparseSupportVectorsFieldNumber;
const int SupportVectorRegressor::kDenseSupportVectorsFieldNumber;
const int SupportVectorRegressor::kCoefficientsFieldNumber;
const int SupportVectorRegressor::kRhoFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

SupportVectorRegressor::SupportVectorRegressor()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_SVM_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:CoreML.Specification.SupportVectorRegressor)
}
SupportVectorRegressor::SupportVectorRegressor(const SupportVectorRegressor& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_kernel()) {
    kernel_ = new ::CoreML::Specification::Kernel(*from.kernel_);
  } else {
    kernel_ = NULL;
  }
  if (from.has_coefficients()) {
    coefficients_ = new ::CoreML::Specification::Coefficients(*from.coefficients_);
  } else {
    coefficients_ = NULL;
  }
  rho_ = from.rho_;
  clear_has_supportVectors();
  switch (from.supportVectors_case()) {
    case kSparseSupportVectors: {
      mutable_sparsesupportvectors()->::CoreML::Specification::SparseSupportVectors::MergeFrom(from.sparsesupportvectors());
      break;
    }
    case kDenseSupportVectors: {
      mutable_densesupportvectors()->::CoreML::Specification::DenseSupportVectors::MergeFrom(from.densesupportvectors());
      break;
    }
    case SUPPORTVECTORS_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.SupportVectorRegressor)
}

void SupportVectorRegressor::SharedCtor() {
  ::memset(&kernel_, 0, reinterpret_cast<char*>(&rho_) -
    reinterpret_cast<char*>(&kernel_) + sizeof(rho_));
  clear_has_supportVectors();
  _cached_size_ = 0;
}

SupportVectorRegressor::~SupportVectorRegressor() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.SupportVectorRegressor)
  SharedDtor();
}

void SupportVectorRegressor::SharedDtor() {
  if (this != internal_default_instance()) {
    delete kernel_;
  }
  if (this != internal_default_instance()) {
    delete coefficients_;
  }
  if (has_supportVectors()) {
    clear_supportVectors();
  }
}

void SupportVectorRegressor::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const SupportVectorRegressor& SupportVectorRegressor::default_instance() {
  protobuf_SVM_2eproto::InitDefaults();
  return *internal_default_instance();
}

SupportVectorRegressor* SupportVectorRegressor::New(::google::protobuf::Arena* arena) const {
  SupportVectorRegressor* n = new SupportVectorRegressor;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void SupportVectorRegressor::clear_supportVectors() {
// @@protoc_insertion_point(one_of_clear_start:CoreML.Specification.SupportVectorRegressor)
  switch (supportVectors_case()) {
    case kSparseSupportVectors: {
      delete supportVectors_.sparsesupportvectors_;
      break;
    }
    case kDenseSupportVectors: {
      delete supportVectors_.densesupportvectors_;
      break;
    }
    case SUPPORTVECTORS_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = SUPPORTVECTORS_NOT_SET;
}


void SupportVectorRegressor::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.SupportVectorRegressor)
  if (GetArenaNoVirtual() == NULL && kernel_ != NULL) {
    delete kernel_;
  }
  kernel_ = NULL;
  if (GetArenaNoVirtual() == NULL && coefficients_ != NULL) {
    delete coefficients_;
  }
  coefficients_ = NULL;
  rho_ = 0;
  clear_supportVectors();
}

bool SupportVectorRegressor::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CoreML.Specification.SupportVectorRegressor)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // .CoreML.Specification.Kernel kernel = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_kernel()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .CoreML.Specification.SparseSupportVectors sparseSupportVectors = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_sparsesupportvectors()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .CoreML.Specification.DenseSupportVectors denseSupportVectors = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(26u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_densesupportvectors()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .CoreML.Specification.Coefficients coefficients = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(34u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_coefficients()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // double rho = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(41u)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &rho_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CoreML.Specification.SupportVectorRegressor)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CoreML.Specification.SupportVectorRegressor)
  return false;
#undef DO_
}

void SupportVectorRegressor::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CoreML.Specification.SupportVectorRegressor)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .CoreML.Specification.Kernel kernel = 1;
  if (this->has_kernel()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, *this->kernel_, output);
  }

  // .CoreML.Specification.SparseSupportVectors sparseSupportVectors = 2;
  if (has_sparsesupportvectors()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, *supportVectors_.sparsesupportvectors_, output);
  }

  // .CoreML.Specification.DenseSupportVectors denseSupportVectors = 3;
  if (has_densesupportvectors()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, *supportVectors_.densesupportvectors_, output);
  }

  // .CoreML.Specification.Coefficients coefficients = 4;
  if (this->has_coefficients()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4, *this->coefficients_, output);
  }

  // double rho = 5;
  if (this->rho() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(5, this->rho(), output);
  }

  // @@protoc_insertion_point(serialize_end:CoreML.Specification.SupportVectorRegressor)
}

size_t SupportVectorRegressor::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.SupportVectorRegressor)
  size_t total_size = 0;

  // .CoreML.Specification.Kernel kernel = 1;
  if (this->has_kernel()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->kernel_);
  }

  // .CoreML.Specification.Coefficients coefficients = 4;
  if (this->has_coefficients()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->coefficients_);
  }

  // double rho = 5;
  if (this->rho() != 0) {
    total_size += 1 + 8;
  }

  switch (supportVectors_case()) {
    // .CoreML.Specification.SparseSupportVectors sparseSupportVectors = 2;
    case kSparseSupportVectors: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *supportVectors_.sparsesupportvectors_);
      break;
    }
    // .CoreML.Specification.DenseSupportVectors denseSupportVectors = 3;
    case kDenseSupportVectors: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *supportVectors_.densesupportvectors_);
      break;
    }
    case SUPPORTVECTORS_NOT_SET: {
      break;
    }
  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SupportVectorRegressor::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const SupportVectorRegressor*>(&from));
}

void SupportVectorRegressor::MergeFrom(const SupportVectorRegressor& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.SupportVectorRegressor)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_kernel()) {
    mutable_kernel()->::CoreML::Specification::Kernel::MergeFrom(from.kernel());
  }
  if (from.has_coefficients()) {
    mutable_coefficients()->::CoreML::Specification::Coefficients::MergeFrom(from.coefficients());
  }
  if (from.rho() != 0) {
    set_rho(from.rho());
  }
  switch (from.supportVectors_case()) {
    case kSparseSupportVectors: {
      mutable_sparsesupportvectors()->::CoreML::Specification::SparseSupportVectors::MergeFrom(from.sparsesupportvectors());
      break;
    }
    case kDenseSupportVectors: {
      mutable_densesupportvectors()->::CoreML::Specification::DenseSupportVectors::MergeFrom(from.densesupportvectors());
      break;
    }
    case SUPPORTVECTORS_NOT_SET: {
      break;
    }
  }
}

void SupportVectorRegressor::CopyFrom(const SupportVectorRegressor& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.SupportVectorRegressor)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SupportVectorRegressor::IsInitialized() const {
  return true;
}

void SupportVectorRegressor::Swap(SupportVectorRegressor* other) {
  if (other == this) return;
  InternalSwap(other);
}
void SupportVectorRegressor::InternalSwap(SupportVectorRegressor* other) {
  std::swap(kernel_, other->kernel_);
  std::swap(coefficients_, other->coefficients_);
  std::swap(rho_, other->rho_);
  std::swap(supportVectors_, other->supportVectors_);
  std::swap(_oneof_case_[0], other->_oneof_case_[0]);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string SupportVectorRegressor::GetTypeName() const {
  return "CoreML.Specification.SupportVectorRegressor";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// SupportVectorRegressor

// .CoreML.Specification.Kernel kernel = 1;
bool SupportVectorRegressor::has_kernel() const {
  return this != internal_default_instance() && kernel_ != NULL;
}
void SupportVectorRegressor::clear_kernel() {
  if (GetArenaNoVirtual() == NULL && kernel_ != NULL) delete kernel_;
  kernel_ = NULL;
}
const ::CoreML::Specification::Kernel& SupportVectorRegressor::kernel() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.SupportVectorRegressor.kernel)
  return kernel_ != NULL ? *kernel_
                         : *::CoreML::Specification::Kernel::internal_default_instance();
}
::CoreML::Specification::Kernel* SupportVectorRegressor::mutable_kernel() {

  if (kernel_ == NULL) {
    kernel_ = new ::CoreML::Specification::Kernel;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.SupportVectorRegressor.kernel)
  return kernel_;
}
::CoreML::Specification::Kernel* SupportVectorRegressor::release_kernel() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.SupportVectorRegressor.kernel)

  ::CoreML::Specification::Kernel* temp = kernel_;
  kernel_ = NULL;
  return temp;
}
void SupportVectorRegressor::set_allocated_kernel(::CoreML::Specification::Kernel* kernel) {
  delete kernel_;
  kernel_ = kernel;
  if (kernel) {

  } else {

  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.SupportVectorRegressor.kernel)
}

// .CoreML.Specification.SparseSupportVectors sparseSupportVectors = 2;
bool SupportVectorRegressor::has_sparsesupportvectors() const {
  return supportVectors_case() == kSparseSupportVectors;
}
void SupportVectorRegressor::set_has_sparsesupportvectors() {
  _oneof_case_[0] = kSparseSupportVectors;
}
void SupportVectorRegressor::clear_sparsesupportvectors() {
  if (has_sparsesupportvectors()) {
    delete supportVectors_.sparsesupportvectors_;
    clear_has_supportVectors();
  }
}
 const ::CoreML::Specification::SparseSupportVectors& SupportVectorRegressor::sparsesupportvectors() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.SupportVectorRegressor.sparseSupportVectors)
  return has_sparsesupportvectors()
      ? *supportVectors_.sparsesupportvectors_
      : ::CoreML::Specification::SparseSupportVectors::default_instance();
}
::CoreML::Specification::SparseSupportVectors* SupportVectorRegressor::mutable_sparsesupportvectors() {
  if (!has_sparsesupportvectors()) {
    clear_supportVectors();
    set_has_sparsesupportvectors();
    supportVectors_.sparsesupportvectors_ = new ::CoreML::Specification::SparseSupportVectors;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.SupportVectorRegressor.sparseSupportVectors)
  return supportVectors_.sparsesupportvectors_;
}
::CoreML::Specification::SparseSupportVectors* SupportVectorRegressor::release_sparsesupportvectors() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.SupportVectorRegressor.sparseSupportVectors)
  if (has_sparsesupportvectors()) {
    clear_has_supportVectors();
    ::CoreML::Specification::SparseSupportVectors* temp = supportVectors_.sparsesupportvectors_;
    supportVectors_.sparsesupportvectors_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void SupportVectorRegressor::set_allocated_sparsesupportvectors(::CoreML::Specification::SparseSupportVectors* sparsesupportvectors) {
  clear_supportVectors();
  if (sparsesupportvectors) {
    set_has_sparsesupportvectors();
    supportVectors_.sparsesupportvectors_ = sparsesupportvectors;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.SupportVectorRegressor.sparseSupportVectors)
}

// .CoreML.Specification.DenseSupportVectors denseSupportVectors = 3;
bool SupportVectorRegressor::has_densesupportvectors() const {
  return supportVectors_case() == kDenseSupportVectors;
}
void SupportVectorRegressor::set_has_densesupportvectors() {
  _oneof_case_[0] = kDenseSupportVectors;
}
void SupportVectorRegressor::clear_densesupportvectors() {
  if (has_densesupportvectors()) {
    delete supportVectors_.densesupportvectors_;
    clear_has_supportVectors();
  }
}
 const ::CoreML::Specification::DenseSupportVectors& SupportVectorRegressor::densesupportvectors() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.SupportVectorRegressor.denseSupportVectors)
  return has_densesupportvectors()
      ? *supportVectors_.densesupportvectors_
      : ::CoreML::Specification::DenseSupportVectors::default_instance();
}
::CoreML::Specification::DenseSupportVectors* SupportVectorRegressor::mutable_densesupportvectors() {
  if (!has_densesupportvectors()) {
    clear_supportVectors();
    set_has_densesupportvectors();
    supportVectors_.densesupportvectors_ = new ::CoreML::Specification::DenseSupportVectors;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.SupportVectorRegressor.denseSupportVectors)
  return supportVectors_.densesupportvectors_;
}
::CoreML::Specification::DenseSupportVectors* SupportVectorRegressor::release_densesupportvectors() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.SupportVectorRegressor.denseSupportVectors)
  if (has_densesupportvectors()) {
    clear_has_supportVectors();
    ::CoreML::Specification::DenseSupportVectors* temp = supportVectors_.densesupportvectors_;
    supportVectors_.densesupportvectors_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void SupportVectorRegressor::set_allocated_densesupportvectors(::CoreML::Specification::DenseSupportVectors* densesupportvectors) {
  clear_supportVectors();
  if (densesupportvectors) {
    set_has_densesupportvectors();
    supportVectors_.densesupportvectors_ = densesupportvectors;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.SupportVectorRegressor.denseSupportVectors)
}

// .CoreML.Specification.Coefficients coefficients = 4;
bool SupportVectorRegressor::has_coefficients() const {
  return this != internal_default_instance() && coefficients_ != NULL;
}
void SupportVectorRegressor::clear_coefficients() {
  if (GetArenaNoVirtual() == NULL && coefficients_ != NULL) delete coefficients_;
  coefficients_ = NULL;
}
const ::CoreML::Specification::Coefficients& SupportVectorRegressor::coefficients() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.SupportVectorRegressor.coefficients)
  return coefficients_ != NULL ? *coefficients_
                         : *::CoreML::Specification::Coefficients::internal_default_instance();
}
::CoreML::Specification::Coefficients* SupportVectorRegressor::mutable_coefficients() {

  if (coefficients_ == NULL) {
    coefficients_ = new ::CoreML::Specification::Coefficients;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.SupportVectorRegressor.coefficients)
  return coefficients_;
}
::CoreML::Specification::Coefficients* SupportVectorRegressor::release_coefficients() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.SupportVectorRegressor.coefficients)

  ::CoreML::Specification::Coefficients* temp = coefficients_;
  coefficients_ = NULL;
  return temp;
}
void SupportVectorRegressor::set_allocated_coefficients(::CoreML::Specification::Coefficients* coefficients) {
  delete coefficients_;
  coefficients_ = coefficients;
  if (coefficients) {

  } else {

  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.SupportVectorRegressor.coefficients)
}

// double rho = 5;
void SupportVectorRegressor::clear_rho() {
  rho_ = 0;
}
double SupportVectorRegressor::rho() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.SupportVectorRegressor.rho)
  return rho_;
}
void SupportVectorRegressor::set_rho(double value) {

  rho_ = value;
  // @@protoc_insertion_point(field_set:CoreML.Specification.SupportVectorRegressor.rho)
}

bool SupportVectorRegressor::has_supportVectors() const {
  return supportVectors_case() != SUPPORTVECTORS_NOT_SET;
}
void SupportVectorRegressor::clear_has_supportVectors() {
  _oneof_case_[0] = SUPPORTVECTORS_NOT_SET;
}
SupportVectorRegressor::SupportVectorsCase SupportVectorRegressor::supportVectors_case() const {
  return SupportVectorRegressor::SupportVectorsCase(_oneof_case_[0]);
}
#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int SupportVectorClassifier::kKernelFieldNumber;
const int SupportVectorClassifier::kNumberOfSupportVectorsPerClassFieldNumber;
const int SupportVectorClassifier::kSparseSupportVectorsFieldNumber;
const int SupportVectorClassifier::kDenseSupportVectorsFieldNumber;
const int SupportVectorClassifier::kCoefficientsFieldNumber;
const int SupportVectorClassifier::kRhoFieldNumber;
const int SupportVectorClassifier::kProbAFieldNumber;
const int SupportVectorClassifier::kProbBFieldNumber;
const int SupportVectorClassifier::kStringClassLabelsFieldNumber;
const int SupportVectorClassifier::kInt64ClassLabelsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

SupportVectorClassifier::SupportVectorClassifier()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_SVM_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:CoreML.Specification.SupportVectorClassifier)
}
SupportVectorClassifier::SupportVectorClassifier(const SupportVectorClassifier& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      numberofsupportvectorsperclass_(from.numberofsupportvectorsperclass_),
      coefficients_(from.coefficients_),
      rho_(from.rho_),
      proba_(from.proba_),
      probb_(from.probb_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_kernel()) {
    kernel_ = new ::CoreML::Specification::Kernel(*from.kernel_);
  } else {
    kernel_ = NULL;
  }
  clear_has_supportVectors();
  switch (from.supportVectors_case()) {
    case kSparseSupportVectors: {
      mutable_sparsesupportvectors()->::CoreML::Specification::SparseSupportVectors::MergeFrom(from.sparsesupportvectors());
      break;
    }
    case kDenseSupportVectors: {
      mutable_densesupportvectors()->::CoreML::Specification::DenseSupportVectors::MergeFrom(from.densesupportvectors());
      break;
    }
    case SUPPORTVECTORS_NOT_SET: {
      break;
    }
  }
  clear_has_ClassLabels();
  switch (from.ClassLabels_case()) {
    case kStringClassLabels: {
      mutable_stringclasslabels()->::CoreML::Specification::StringVector::MergeFrom(from.stringclasslabels());
      break;
    }
    case kInt64ClassLabels: {
      mutable_int64classlabels()->::CoreML::Specification::Int64Vector::MergeFrom(from.int64classlabels());
      break;
    }
    case CLASSLABELS_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.SupportVectorClassifier)
}

void SupportVectorClassifier::SharedCtor() {
  kernel_ = NULL;
  clear_has_supportVectors();
  clear_has_ClassLabels();
  _cached_size_ = 0;
}

SupportVectorClassifier::~SupportVectorClassifier() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.SupportVectorClassifier)
  SharedDtor();
}

void SupportVectorClassifier::SharedDtor() {
  if (this != internal_default_instance()) {
    delete kernel_;
  }
  if (has_supportVectors()) {
    clear_supportVectors();
  }
  if (has_ClassLabels()) {
    clear_ClassLabels();
  }
}

void SupportVectorClassifier::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const SupportVectorClassifier& SupportVectorClassifier::default_instance() {
  protobuf_SVM_2eproto::InitDefaults();
  return *internal_default_instance();
}

SupportVectorClassifier* SupportVectorClassifier::New(::google::protobuf::Arena* arena) const {
  SupportVectorClassifier* n = new SupportVectorClassifier;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void SupportVectorClassifier::clear_supportVectors() {
// @@protoc_insertion_point(one_of_clear_start:CoreML.Specification.SupportVectorClassifier)
  switch (supportVectors_case()) {
    case kSparseSupportVectors: {
      delete supportVectors_.sparsesupportvectors_;
      break;
    }
    case kDenseSupportVectors: {
      delete supportVectors_.densesupportvectors_;
      break;
    }
    case SUPPORTVECTORS_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = SUPPORTVECTORS_NOT_SET;
}

void SupportVectorClassifier::clear_ClassLabels() {
// @@protoc_insertion_point(one_of_clear_start:CoreML.Specification.SupportVectorClassifier)
  switch (ClassLabels_case()) {
    case kStringClassLabels: {
      delete ClassLabels_.stringclasslabels_;
      break;
    }
    case kInt64ClassLabels: {
      delete ClassLabels_.int64classlabels_;
      break;
    }
    case CLASSLABELS_NOT_SET: {
      break;
    }
  }
  _oneof_case_[1] = CLASSLABELS_NOT_SET;
}


void SupportVectorClassifier::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.SupportVectorClassifier)
  numberofsupportvectorsperclass_.Clear();
  coefficients_.Clear();
  rho_.Clear();
  proba_.Clear();
  probb_.Clear();
  if (GetArenaNoVirtual() == NULL && kernel_ != NULL) {
    delete kernel_;
  }
  kernel_ = NULL;
  clear_supportVectors();
  clear_ClassLabels();
}

bool SupportVectorClassifier::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CoreML.Specification.SupportVectorClassifier)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(16383u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // .CoreML.Specification.Kernel kernel = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_kernel()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated int32 numberOfSupportVectorsPerClass = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, this->mutable_numberofsupportvectorsperclass())));
        } else if (static_cast< ::google::protobuf::uint8>(tag) ==
                   static_cast< ::google::protobuf::uint8>(16u)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitiveNoInline<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 1, 18u, input, this->mutable_numberofsupportvectorsperclass())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .CoreML.Specification.SparseSupportVectors sparseSupportVectors = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(26u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_sparsesupportvectors()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .CoreML.Specification.DenseSupportVectors denseSupportVectors = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(34u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_densesupportvectors()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .CoreML.Specification.Coefficients coefficients = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(42u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_coefficients()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated double rho = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(50u)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, this->mutable_rho())));
        } else if (static_cast< ::google::protobuf::uint8>(tag) ==
                   static_cast< ::google::protobuf::uint8>(49u)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitiveNoInline<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 1, 50u, input, this->mutable_rho())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated double probA = 7;
      case 7: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(58u)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, this->mutable_proba())));
        } else if (static_cast< ::google::protobuf::uint8>(tag) ==
                   static_cast< ::google::protobuf::uint8>(57u)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitiveNoInline<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 1, 58u, input, this->mutable_proba())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated double probB = 8;
      case 8: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(66u)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, this->mutable_probb())));
        } else if (static_cast< ::google::protobuf::uint8>(tag) ==
                   static_cast< ::google::protobuf::uint8>(65u)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitiveNoInline<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 1, 66u, input, this->mutable_probb())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .CoreML.Specification.StringVector stringClassLabels = 100;
      case 100: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(802u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_stringclasslabels()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .CoreML.Specification.Int64Vector int64ClassLabels = 101;
      case 101: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(810u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_int64classlabels()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CoreML.Specification.SupportVectorClassifier)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CoreML.Specification.SupportVectorClassifier)
  return false;
#undef DO_
}

void SupportVectorClassifier::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CoreML.Specification.SupportVectorClassifier)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .CoreML.Specification.Kernel kernel = 1;
  if (this->has_kernel()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, *this->kernel_, output);
  }

  // repeated int32 numberOfSupportVectorsPerClass = 2;
  if (this->numberofsupportvectorsperclass_size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteTag(2, ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED, output);
    output->WriteVarint32(_numberofsupportvectorsperclass_cached_byte_size_);
  }
  for (int i = 0, n = this->numberofsupportvectorsperclass_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32NoTag(
      this->numberofsupportvectorsperclass(i), output);
  }

  // .CoreML.Specification.SparseSupportVectors sparseSupportVectors = 3;
  if (has_sparsesupportvectors()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, *supportVectors_.sparsesupportvectors_, output);
  }

  // .CoreML.Specification.DenseSupportVectors denseSupportVectors = 4;
  if (has_densesupportvectors()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4, *supportVectors_.densesupportvectors_, output);
  }

  // repeated .CoreML.Specification.Coefficients coefficients = 5;
  for (unsigned int i = 0, n = this->coefficients_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      5, this->coefficients(i), output);
  }

  // repeated double rho = 6;
  if (this->rho_size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteTag(6, ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED, output);
    output->WriteVarint32(_rho_cached_byte_size_);
    ::google::protobuf::internal::WireFormatLite::WriteDoubleArray(
      this->rho().data(), this->rho_size(), output);
  }

  // repeated double probA = 7;
  if (this->proba_size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteTag(7, ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED, output);
    output->WriteVarint32(_proba_cached_byte_size_);
    ::google::protobuf::internal::WireFormatLite::WriteDoubleArray(
      this->proba().data(), this->proba_size(), output);
  }

  // repeated double probB = 8;
  if (this->probb_size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteTag(8, ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED, output);
    output->WriteVarint32(_probb_cached_byte_size_);
    ::google::protobuf::internal::WireFormatLite::WriteDoubleArray(
      this->probb().data(), this->probb_size(), output);
  }

  // .CoreML.Specification.StringVector stringClassLabels = 100;
  if (has_stringclasslabels()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      100, *ClassLabels_.stringclasslabels_, output);
  }

  // .CoreML.Specification.Int64Vector int64ClassLabels = 101;
  if (has_int64classlabels()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      101, *ClassLabels_.int64classlabels_, output);
  }

  // @@protoc_insertion_point(serialize_end:CoreML.Specification.SupportVectorClassifier)
}

size_t SupportVectorClassifier::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.SupportVectorClassifier)
  size_t total_size = 0;

  // repeated int32 numberOfSupportVectorsPerClass = 2;
  {
    size_t data_size = ::google::protobuf::internal::WireFormatLite::
      Int32Size(this->numberofsupportvectorsperclass_);
    if (data_size > 0) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(data_size);
    }
    int cached_size = ::google::protobuf::internal::ToCachedSize(data_size);
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _numberofsupportvectorsperclass_cached_byte_size_ = cached_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    total_size += data_size;
  }

  // repeated .CoreML.Specification.Coefficients coefficients = 5;
  {
    unsigned int count = this->coefficients_size();
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->coefficients(i));
    }
  }

  // repeated double rho = 6;
  {
    unsigned int count = this->rho_size();
    size_t data_size = 8UL * count;
    if (data_size > 0) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(data_size);
    }
    int cached_size = ::google::protobuf::internal::ToCachedSize(data_size);
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _rho_cached_byte_size_ = cached_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    total_size += data_size;
  }

  // repeated double probA = 7;
  {
    unsigned int count = this->proba_size();
    size_t data_size = 8UL * count;
    if (data_size > 0) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(data_size);
    }
    int cached_size = ::google::protobuf::internal::ToCachedSize(data_size);
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _proba_cached_byte_size_ = cached_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    total_size += data_size;
  }

  // repeated double probB = 8;
  {
    unsigned int count = this->probb_size();
    size_t data_size = 8UL * count;
    if (data_size > 0) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(data_size);
    }
    int cached_size = ::google::protobuf::internal::ToCachedSize(data_size);
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _probb_cached_byte_size_ = cached_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    total_size += data_size;
  }

  // .CoreML.Specification.Kernel kernel = 1;
  if (this->has_kernel()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->kernel_);
  }

  switch (supportVectors_case()) {
    // .CoreML.Specification.SparseSupportVectors sparseSupportVectors = 3;
    case kSparseSupportVectors: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *supportVectors_.sparsesupportvectors_);
      break;
    }
    // .CoreML.Specification.DenseSupportVectors denseSupportVectors = 4;
    case kDenseSupportVectors: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *supportVectors_.densesupportvectors_);
      break;
    }
    case SUPPORTVECTORS_NOT_SET: {
      break;
    }
  }
  switch (ClassLabels_case()) {
    // .CoreML.Specification.StringVector stringClassLabels = 100;
    case kStringClassLabels: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *ClassLabels_.stringclasslabels_);
      break;
    }
    // .CoreML.Specification.Int64Vector int64ClassLabels = 101;
    case kInt64ClassLabels: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *ClassLabels_.int64classlabels_);
      break;
    }
    case CLASSLABELS_NOT_SET: {
      break;
    }
  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SupportVectorClassifier::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const SupportVectorClassifier*>(&from));
}

void SupportVectorClassifier::MergeFrom(const SupportVectorClassifier& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.SupportVectorClassifier)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  numberofsupportvectorsperclass_.MergeFrom(from.numberofsupportvectorsperclass_);
  coefficients_.MergeFrom(from.coefficients_);
  rho_.MergeFrom(from.rho_);
  proba_.MergeFrom(from.proba_);
  probb_.MergeFrom(from.probb_);
  if (from.has_kernel()) {
    mutable_kernel()->::CoreML::Specification::Kernel::MergeFrom(from.kernel());
  }
  switch (from.supportVectors_case()) {
    case kSparseSupportVectors: {
      mutable_sparsesupportvectors()->::CoreML::Specification::SparseSupportVectors::MergeFrom(from.sparsesupportvectors());
      break;
    }
    case kDenseSupportVectors: {
      mutable_densesupportvectors()->::CoreML::Specification::DenseSupportVectors::MergeFrom(from.densesupportvectors());
      break;
    }
    case SUPPORTVECTORS_NOT_SET: {
      break;
    }
  }
  switch (from.ClassLabels_case()) {
    case kStringClassLabels: {
      mutable_stringclasslabels()->::CoreML::Specification::StringVector::MergeFrom(from.stringclasslabels());
      break;
    }
    case kInt64ClassLabels: {
      mutable_int64classlabels()->::CoreML::Specification::Int64Vector::MergeFrom(from.int64classlabels());
      break;
    }
    case CLASSLABELS_NOT_SET: {
      break;
    }
  }
}

void SupportVectorClassifier::CopyFrom(const SupportVectorClassifier& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.SupportVectorClassifier)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SupportVectorClassifier::IsInitialized() const {
  return true;
}

void SupportVectorClassifier::Swap(SupportVectorClassifier* other) {
  if (other == this) return;
  InternalSwap(other);
}
void SupportVectorClassifier::InternalSwap(SupportVectorClassifier* other) {
  numberofsupportvectorsperclass_.InternalSwap(&other->numberofsupportvectorsperclass_);
  coefficients_.InternalSwap(&other->coefficients_);
  rho_.InternalSwap(&other->rho_);
  proba_.InternalSwap(&other->proba_);
  probb_.InternalSwap(&other->probb_);
  std::swap(kernel_, other->kernel_);
  std::swap(supportVectors_, other->supportVectors_);
  std::swap(_oneof_case_[0], other->_oneof_case_[0]);
  std::swap(ClassLabels_, other->ClassLabels_);
  std::swap(_oneof_case_[1], other->_oneof_case_[1]);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string SupportVectorClassifier::GetTypeName() const {
  return "CoreML.Specification.SupportVectorClassifier";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// SupportVectorClassifier

// .CoreML.Specification.Kernel kernel = 1;
bool SupportVectorClassifier::has_kernel() const {
  return this != internal_default_instance() && kernel_ != NULL;
}
void SupportVectorClassifier::clear_kernel() {
  if (GetArenaNoVirtual() == NULL && kernel_ != NULL) delete kernel_;
  kernel_ = NULL;
}
const ::CoreML::Specification::Kernel& SupportVectorClassifier::kernel() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.SupportVectorClassifier.kernel)
  return kernel_ != NULL ? *kernel_
                         : *::CoreML::Specification::Kernel::internal_default_instance();
}
::CoreML::Specification::Kernel* SupportVectorClassifier::mutable_kernel() {

  if (kernel_ == NULL) {
    kernel_ = new ::CoreML::Specification::Kernel;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.SupportVectorClassifier.kernel)
  return kernel_;
}
::CoreML::Specification::Kernel* SupportVectorClassifier::release_kernel() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.SupportVectorClassifier.kernel)

  ::CoreML::Specification::Kernel* temp = kernel_;
  kernel_ = NULL;
  return temp;
}
void SupportVectorClassifier::set_allocated_kernel(::CoreML::Specification::Kernel* kernel) {
  delete kernel_;
  kernel_ = kernel;
  if (kernel) {

  } else {

  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.SupportVectorClassifier.kernel)
}

// repeated int32 numberOfSupportVectorsPerClass = 2;
int SupportVectorClassifier::numberofsupportvectorsperclass_size() const {
  return numberofsupportvectorsperclass_.size();
}
void SupportVectorClassifier::clear_numberofsupportvectorsperclass() {
  numberofsupportvectorsperclass_.Clear();
}
::google::protobuf::int32 SupportVectorClassifier::numberofsupportvectorsperclass(int index) const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.SupportVectorClassifier.numberOfSupportVectorsPerClass)
  return numberofsupportvectorsperclass_.Get(index);
}
void SupportVectorClassifier::set_numberofsupportvectorsperclass(int index, ::google::protobuf::int32 value) {
  numberofsupportvectorsperclass_.Set(index, value);
  // @@protoc_insertion_point(field_set:CoreML.Specification.SupportVectorClassifier.numberOfSupportVectorsPerClass)
}
void SupportVectorClassifier::add_numberofsupportvectorsperclass(::google::protobuf::int32 value) {
  numberofsupportvectorsperclass_.Add(value);
  // @@protoc_insertion_point(field_add:CoreML.Specification.SupportVectorClassifier.numberOfSupportVectorsPerClass)
}
const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
SupportVectorClassifier::numberofsupportvectorsperclass() const {
  // @@protoc_insertion_point(field_list:CoreML.Specification.SupportVectorClassifier.numberOfSupportVectorsPerClass)
  return numberofsupportvectorsperclass_;
}
::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
SupportVectorClassifier::mutable_numberofsupportvectorsperclass() {
  // @@protoc_insertion_point(field_mutable_list:CoreML.Specification.SupportVectorClassifier.numberOfSupportVectorsPerClass)
  return &numberofsupportvectorsperclass_;
}

// .CoreML.Specification.SparseSupportVectors sparseSupportVectors = 3;
bool SupportVectorClassifier::has_sparsesupportvectors() const {
  return supportVectors_case() == kSparseSupportVectors;
}
void SupportVectorClassifier::set_has_sparsesupportvectors() {
  _oneof_case_[0] = kSparseSupportVectors;
}
void SupportVectorClassifier::clear_sparsesupportvectors() {
  if (has_sparsesupportvectors()) {
    delete supportVectors_.sparsesupportvectors_;
    clear_has_supportVectors();
  }
}
 const ::CoreML::Specification::SparseSupportVectors& SupportVectorClassifier::sparsesupportvectors() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.SupportVectorClassifier.sparseSupportVectors)
  return has_sparsesupportvectors()
      ? *supportVectors_.sparsesupportvectors_
      : ::CoreML::Specification::SparseSupportVectors::default_instance();
}
::CoreML::Specification::SparseSupportVectors* SupportVectorClassifier::mutable_sparsesupportvectors() {
  if (!has_sparsesupportvectors()) {
    clear_supportVectors();
    set_has_sparsesupportvectors();
    supportVectors_.sparsesupportvectors_ = new ::CoreML::Specification::SparseSupportVectors;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.SupportVectorClassifier.sparseSupportVectors)
  return supportVectors_.sparsesupportvectors_;
}
::CoreML::Specification::SparseSupportVectors* SupportVectorClassifier::release_sparsesupportvectors() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.SupportVectorClassifier.sparseSupportVectors)
  if (has_sparsesupportvectors()) {
    clear_has_supportVectors();
    ::CoreML::Specification::SparseSupportVectors* temp = supportVectors_.sparsesupportvectors_;
    supportVectors_.sparsesupportvectors_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void SupportVectorClassifier::set_allocated_sparsesupportvectors(::CoreML::Specification::SparseSupportVectors* sparsesupportvectors) {
  clear_supportVectors();
  if (sparsesupportvectors) {
    set_has_sparsesupportvectors();
    supportVectors_.sparsesupportvectors_ = sparsesupportvectors;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.SupportVectorClassifier.sparseSupportVectors)
}

// .CoreML.Specification.DenseSupportVectors denseSupportVectors = 4;
bool SupportVectorClassifier::has_densesupportvectors() const {
  return supportVectors_case() == kDenseSupportVectors;
}
void SupportVectorClassifier::set_has_densesupportvectors() {
  _oneof_case_[0] = kDenseSupportVectors;
}
void SupportVectorClassifier::clear_densesupportvectors() {
  if (has_densesupportvectors()) {
    delete supportVectors_.densesupportvectors_;
    clear_has_supportVectors();
  }
}
 const ::CoreML::Specification::DenseSupportVectors& SupportVectorClassifier::densesupportvectors() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.SupportVectorClassifier.denseSupportVectors)
  return has_densesupportvectors()
      ? *supportVectors_.densesupportvectors_
      : ::CoreML::Specification::DenseSupportVectors::default_instance();
}
::CoreML::Specification::DenseSupportVectors* SupportVectorClassifier::mutable_densesupportvectors() {
  if (!has_densesupportvectors()) {
    clear_supportVectors();
    set_has_densesupportvectors();
    supportVectors_.densesupportvectors_ = new ::CoreML::Specification::DenseSupportVectors;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.SupportVectorClassifier.denseSupportVectors)
  return supportVectors_.densesupportvectors_;
}
::CoreML::Specification::DenseSupportVectors* SupportVectorClassifier::release_densesupportvectors() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.SupportVectorClassifier.denseSupportVectors)
  if (has_densesupportvectors()) {
    clear_has_supportVectors();
    ::CoreML::Specification::DenseSupportVectors* temp = supportVectors_.densesupportvectors_;
    supportVectors_.densesupportvectors_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void SupportVectorClassifier::set_allocated_densesupportvectors(::CoreML::Specification::DenseSupportVectors* densesupportvectors) {
  clear_supportVectors();
  if (densesupportvectors) {
    set_has_densesupportvectors();
    supportVectors_.densesupportvectors_ = densesupportvectors;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.SupportVectorClassifier.denseSupportVectors)
}

// repeated .CoreML.Specification.Coefficients coefficients = 5;
int SupportVectorClassifier::coefficients_size() const {
  return coefficients_.size();
}
void SupportVectorClassifier::clear_coefficients() {
  coefficients_.Clear();
}
const ::CoreML::Specification::Coefficients& SupportVectorClassifier::coefficients(int index) const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.SupportVectorClassifier.coefficients)
  return coefficients_.Get(index);
}
::CoreML::Specification::Coefficients* SupportVectorClassifier::mutable_coefficients(int index) {
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.SupportVectorClassifier.coefficients)
  return coefficients_.Mutable(index);
}
::CoreML::Specification::Coefficients* SupportVectorClassifier::add_coefficients() {
  // @@protoc_insertion_point(field_add:CoreML.Specification.SupportVectorClassifier.coefficients)
  return coefficients_.Add();
}
::google::protobuf::RepeatedPtrField< ::CoreML::Specification::Coefficients >*
SupportVectorClassifier::mutable_coefficients() {
  // @@protoc_insertion_point(field_mutable_list:CoreML.Specification.SupportVectorClassifier.coefficients)
  return &coefficients_;
}
const ::google::protobuf::RepeatedPtrField< ::CoreML::Specification::Coefficients >&
SupportVectorClassifier::coefficients() const {
  // @@protoc_insertion_point(field_list:CoreML.Specification.SupportVectorClassifier.coefficients)
  return coefficients_;
}

// repeated double rho = 6;
int SupportVectorClassifier::rho_size() const {
  return rho_.size();
}
void SupportVectorClassifier::clear_rho() {
  rho_.Clear();
}
double SupportVectorClassifier::rho(int index) const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.SupportVectorClassifier.rho)
  return rho_.Get(index);
}
void SupportVectorClassifier::set_rho(int index, double value) {
  rho_.Set(index, value);
  // @@protoc_insertion_point(field_set:CoreML.Specification.SupportVectorClassifier.rho)
}
void SupportVectorClassifier::add_rho(double value) {
  rho_.Add(value);
  // @@protoc_insertion_point(field_add:CoreML.Specification.SupportVectorClassifier.rho)
}
const ::google::protobuf::RepeatedField< double >&
SupportVectorClassifier::rho() const {
  // @@protoc_insertion_point(field_list:CoreML.Specification.SupportVectorClassifier.rho)
  return rho_;
}
::google::protobuf::RepeatedField< double >*
SupportVectorClassifier::mutable_rho() {
  // @@protoc_insertion_point(field_mutable_list:CoreML.Specification.SupportVectorClassifier.rho)
  return &rho_;
}

// repeated double probA = 7;
int SupportVectorClassifier::proba_size() const {
  return proba_.size();
}
void SupportVectorClassifier::clear_proba() {
  proba_.Clear();
}
double SupportVectorClassifier::proba(int index) const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.SupportVectorClassifier.probA)
  return proba_.Get(index);
}
void SupportVectorClassifier::set_proba(int index, double value) {
  proba_.Set(index, value);
  // @@protoc_insertion_point(field_set:CoreML.Specification.SupportVectorClassifier.probA)
}
void SupportVectorClassifier::add_proba(double value) {
  proba_.Add(value);
  // @@protoc_insertion_point(field_add:CoreML.Specification.SupportVectorClassifier.probA)
}
const ::google::protobuf::RepeatedField< double >&
SupportVectorClassifier::proba() const {
  // @@protoc_insertion_point(field_list:CoreML.Specification.SupportVectorClassifier.probA)
  return proba_;
}
::google::protobuf::RepeatedField< double >*
SupportVectorClassifier::mutable_proba() {
  // @@protoc_insertion_point(field_mutable_list:CoreML.Specification.SupportVectorClassifier.probA)
  return &proba_;
}

// repeated double probB = 8;
int SupportVectorClassifier::probb_size() const {
  return probb_.size();
}
void SupportVectorClassifier::clear_probb() {
  probb_.Clear();
}
double SupportVectorClassifier::probb(int index) const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.SupportVectorClassifier.probB)
  return probb_.Get(index);
}
void SupportVectorClassifier::set_probb(int index, double value) {
  probb_.Set(index, value);
  // @@protoc_insertion_point(field_set:CoreML.Specification.SupportVectorClassifier.probB)
}
void SupportVectorClassifier::add_probb(double value) {
  probb_.Add(value);
  // @@protoc_insertion_point(field_add:CoreML.Specification.SupportVectorClassifier.probB)
}
const ::google::protobuf::RepeatedField< double >&
SupportVectorClassifier::probb() const {
  // @@protoc_insertion_point(field_list:CoreML.Specification.SupportVectorClassifier.probB)
  return probb_;
}
::google::protobuf::RepeatedField< double >*
SupportVectorClassifier::mutable_probb() {
  // @@protoc_insertion_point(field_mutable_list:CoreML.Specification.SupportVectorClassifier.probB)
  return &probb_;
}

// .CoreML.Specification.StringVector stringClassLabels = 100;
bool SupportVectorClassifier::has_stringclasslabels() const {
  return ClassLabels_case() == kStringClassLabels;
}
void SupportVectorClassifier::set_has_stringclasslabels() {
  _oneof_case_[1] = kStringClassLabels;
}
void SupportVectorClassifier::clear_stringclasslabels() {
  if (has_stringclasslabels()) {
    delete ClassLabels_.stringclasslabels_;
    clear_has_ClassLabels();
  }
}
 const ::CoreML::Specification::StringVector& SupportVectorClassifier::stringclasslabels() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.SupportVectorClassifier.stringClassLabels)
  return has_stringclasslabels()
      ? *ClassLabels_.stringclasslabels_
      : ::CoreML::Specification::StringVector::default_instance();
}
::CoreML::Specification::StringVector* SupportVectorClassifier::mutable_stringclasslabels() {
  if (!has_stringclasslabels()) {
    clear_ClassLabels();
    set_has_stringclasslabels();
    ClassLabels_.stringclasslabels_ = new ::CoreML::Specification::StringVector;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.SupportVectorClassifier.stringClassLabels)
  return ClassLabels_.stringclasslabels_;
}
::CoreML::Specification::StringVector* SupportVectorClassifier::release_stringclasslabels() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.SupportVectorClassifier.stringClassLabels)
  if (has_stringclasslabels()) {
    clear_has_ClassLabels();
    ::CoreML::Specification::StringVector* temp = ClassLabels_.stringclasslabels_;
    ClassLabels_.stringclasslabels_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void SupportVectorClassifier::set_allocated_stringclasslabels(::CoreML::Specification::StringVector* stringclasslabels) {
  clear_ClassLabels();
  if (stringclasslabels) {
    set_has_stringclasslabels();
    ClassLabels_.stringclasslabels_ = stringclasslabels;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.SupportVectorClassifier.stringClassLabels)
}

// .CoreML.Specification.Int64Vector int64ClassLabels = 101;
bool SupportVectorClassifier::has_int64classlabels() const {
  return ClassLabels_case() == kInt64ClassLabels;
}
void SupportVectorClassifier::set_has_int64classlabels() {
  _oneof_case_[1] = kInt64ClassLabels;
}
void SupportVectorClassifier::clear_int64classlabels() {
  if (has_int64classlabels()) {
    delete ClassLabels_.int64classlabels_;
    clear_has_ClassLabels();
  }
}
 const ::CoreML::Specification::Int64Vector& SupportVectorClassifier::int64classlabels() const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.SupportVectorClassifier.int64ClassLabels)
  return has_int64classlabels()
      ? *ClassLabels_.int64classlabels_
      : ::CoreML::Specification::Int64Vector::default_instance();
}
::CoreML::Specification::Int64Vector* SupportVectorClassifier::mutable_int64classlabels() {
  if (!has_int64classlabels()) {
    clear_ClassLabels();
    set_has_int64classlabels();
    ClassLabels_.int64classlabels_ = new ::CoreML::Specification::Int64Vector;
  }
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.SupportVectorClassifier.int64ClassLabels)
  return ClassLabels_.int64classlabels_;
}
::CoreML::Specification::Int64Vector* SupportVectorClassifier::release_int64classlabels() {
  // @@protoc_insertion_point(field_release:CoreML.Specification.SupportVectorClassifier.int64ClassLabels)
  if (has_int64classlabels()) {
    clear_has_ClassLabels();
    ::CoreML::Specification::Int64Vector* temp = ClassLabels_.int64classlabels_;
    ClassLabels_.int64classlabels_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void SupportVectorClassifier::set_allocated_int64classlabels(::CoreML::Specification::Int64Vector* int64classlabels) {
  clear_ClassLabels();
  if (int64classlabels) {
    set_has_int64classlabels();
    ClassLabels_.int64classlabels_ = int64classlabels;
  }
  // @@protoc_insertion_point(field_set_allocated:CoreML.Specification.SupportVectorClassifier.int64ClassLabels)
}

bool SupportVectorClassifier::has_supportVectors() const {
  return supportVectors_case() != SUPPORTVECTORS_NOT_SET;
}
void SupportVectorClassifier::clear_has_supportVectors() {
  _oneof_case_[0] = SUPPORTVECTORS_NOT_SET;
}
bool SupportVectorClassifier::has_ClassLabels() const {
  return ClassLabels_case() != CLASSLABELS_NOT_SET;
}
void SupportVectorClassifier::clear_has_ClassLabels() {
  _oneof_case_[1] = CLASSLABELS_NOT_SET;
}
SupportVectorClassifier::SupportVectorsCase SupportVectorClassifier::supportVectors_case() const {
  return SupportVectorClassifier::SupportVectorsCase(_oneof_case_[0]);
}
SupportVectorClassifier::ClassLabelsCase SupportVectorClassifier::ClassLabels_case() const {
  return SupportVectorClassifier::ClassLabelsCase(_oneof_case_[1]);
}
#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace Specification
}  // namespace CoreML

// @@protoc_insertion_point(global_scope)
