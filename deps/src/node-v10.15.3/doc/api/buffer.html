<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width">
  <title>Buffer | Node.js v10.15.3 Documentation</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:400,700,400italic">
  <link rel="stylesheet" href="assets/style.css">
  <link rel="stylesheet" href="assets/sh.css">
  <link rel="canonical" href="https://nodejs.org/api/buffer.html">
</head>
<body class="alt apidoc" id="api-section-buffer">
  <div id="content" class="clearfix">
    <div id="column2" class="interior">
      <div id="intro" class="interior">
        <a href="/" title="Go back to the home page">
          Node.js
        </a>
      </div>
      <ul>
<li><a href="documentation.html" class="nav-documentation">About these Docs</a></li>
<li><a href="synopsis.html" class="nav-synopsis">Usage &#x26; Example</a></li>
</ul>
<div class="line"></div>
<ul>
<li><a href="assert.html" class="nav-assert">Assertion Testing</a></li>
<li><a href="async_hooks.html" class="nav-async_hooks">Async Hooks</a></li>
<li><a href="buffer.html" class="nav-buffer active">Buffer</a></li>
<li><a href="addons.html" class="nav-addons">C++ Addons</a></li>
<li><a href="n-api.html" class="nav-n-api">C/C++ Addons - N-API</a></li>
<li><a href="child_process.html" class="nav-child_process">Child Processes</a></li>
<li><a href="cluster.html" class="nav-cluster">Cluster</a></li>
<li><a href="cli.html" class="nav-cli">Command Line Options</a></li>
<li><a href="console.html" class="nav-console">Console</a></li>
<li><a href="crypto.html" class="nav-crypto">Crypto</a></li>
<li><a href="debugger.html" class="nav-debugger">Debugger</a></li>
<li><a href="deprecations.html" class="nav-deprecations">Deprecated APIs</a></li>
<li><a href="dns.html" class="nav-dns">DNS</a></li>
<li><a href="domain.html" class="nav-domain">Domain</a></li>
<li><a href="esm.html" class="nav-esm">ECMAScript Modules</a></li>
<li><a href="errors.html" class="nav-errors">Errors</a></li>
<li><a href="events.html" class="nav-events">Events</a></li>
<li><a href="fs.html" class="nav-fs">File System</a></li>
<li><a href="globals.html" class="nav-globals">Globals</a></li>
<li><a href="http.html" class="nav-http">HTTP</a></li>
<li><a href="http2.html" class="nav-http2">HTTP/2</a></li>
<li><a href="https.html" class="nav-https">HTTPS</a></li>
<li><a href="inspector.html" class="nav-inspector">Inspector</a></li>
<li><a href="intl.html" class="nav-intl">Internationalization</a></li>
<li><a href="modules.html" class="nav-modules">Modules</a></li>
<li><a href="net.html" class="nav-net">Net</a></li>
<li><a href="os.html" class="nav-os">OS</a></li>
<li><a href="path.html" class="nav-path">Path</a></li>
<li><a href="perf_hooks.html" class="nav-perf_hooks">Performance Hooks</a></li>
<li><a href="process.html" class="nav-process">Process</a></li>
<li><a href="punycode.html" class="nav-punycode">Punycode</a></li>
<li><a href="querystring.html" class="nav-querystring">Query Strings</a></li>
<li><a href="readline.html" class="nav-readline">Readline</a></li>
<li><a href="repl.html" class="nav-repl">REPL</a></li>
<li><a href="stream.html" class="nav-stream">Stream</a></li>
<li><a href="string_decoder.html" class="nav-string_decoder">String Decoder</a></li>
<li><a href="timers.html" class="nav-timers">Timers</a></li>
<li><a href="tls.html" class="nav-tls">TLS/SSL</a></li>
<li><a href="tracing.html" class="nav-tracing">Trace Events</a></li>
<li><a href="tty.html" class="nav-tty">TTY</a></li>
<li><a href="dgram.html" class="nav-dgram">UDP/Datagram</a></li>
<li><a href="url.html" class="nav-url">URL</a></li>
<li><a href="util.html" class="nav-util">Utilities</a></li>
<li><a href="v8.html" class="nav-v8">V8</a></li>
<li><a href="vm.html" class="nav-vm">VM</a></li>
<li><a href="worker_threads.html" class="nav-worker_threads">Worker Threads</a></li>
<li><a href="zlib.html" class="nav-zlib">ZLIB</a></li>
</ul>
<div class="line"></div>
<ul>
<li><a href="https://github.com/nodejs/node" class="nav-https-github-com-nodejs-node">GitHub Repo &#x26; Issue Tracker</a></li>
</ul>
    </div>

    <div id="column1" data-id="buffer" class="interior">
      <header>
        <h1>Node.js v10.15.3 Documentation</h1>
        <div id="gtoc">
          <ul>
            <li>
              <a href="index.html" name="toc">Index</a>
            </li>
            <li>
              <a href="all.html">View on single page</a>
            </li>
            <li>
              <a href="buffer.json">View as JSON</a>
            </li>
            
    <li class="version-picker">
      <a href="#">View another version <span>&#x25bc;</span></a>
      <ol class="version-picker"><li><a href="https://nodejs.org/docs/latest-v11.x/api/buffer.html">11.x</a></li>
<li><a href="https://nodejs.org/docs/latest-v10.x/api/buffer.html">10.x <b>LTS</b></a></li>
<li><a href="https://nodejs.org/docs/latest-v9.x/api/buffer.html">9.x</a></li>
<li><a href="https://nodejs.org/docs/latest-v8.x/api/buffer.html">8.x <b>LTS</b></a></li>
<li><a href="https://nodejs.org/docs/latest-v7.x/api/buffer.html">7.x</a></li>
<li><a href="https://nodejs.org/docs/latest-v6.x/api/buffer.html">6.x <b>LTS</b></a></li>
<li><a href="https://nodejs.org/docs/latest-v5.x/api/buffer.html">5.x</a></li>
<li><a href="https://nodejs.org/docs/latest-v4.x/api/buffer.html">4.x</a></li>
<li><a href="https://nodejs.org/docs/latest-v0.12.x/api/buffer.html">0.12.x</a></li>
<li><a href="https://nodejs.org/docs/latest-v0.10.x/api/buffer.html">0.10.x</a></li></ol>
    </li>
  
            <li class="edit_on_github"><a href="https://github.com/nodejs/node/edit/master/doc/api/buffer.md"><span class="github_icon"><svg height="16" width="16" viewBox="0 0 16.1 16.1" fill="currentColor"><path d="M8 0a8 8 0 0 0-2.5 15.6c.4 0 .5-.2.5-.4v-1.5c-2 .4-2.5-.5-2.7-1 0-.1-.5-.9-.8-1-.3-.2-.7-.6 0-.6.6 0 1 .6 1.2.8.7 1.2 1.9 1 2.4.7 0-.5.2-.9.5-1-1.8-.3-3.7-1-3.7-4 0-.9.3-1.6.8-2.2 0-.2-.3-1 .1-2 0 0 .7-.3 2.2.7a7.4 7.4 0 0 1 4 0c1.5-1 2.2-.8 2.2-.8.5 1.1.2 2 .1 2.1.5.6.8 1.3.8 2.2 0 3-1.9 3.7-3.6 4 .3.2.5.7.5 1.4v2.2c0 .2.1.5.5.4A8 8 0 0 0 16 8a8 8 0 0 0-8-8z"/></svg></span>Edit on GitHub</a></li>
          </ul>
        </div>
        <hr>
      </header>

      <div id="toc">
        <h2>Table of Contents</h2>
        <ul>
<li>
<p><span class="stability_2"><a href="#buffer_buffer">Buffer</a></span></p>
<ul>
<li>
<p><a href="#buffer_buffer_from_buffer_alloc_and_buffer_allocunsafe"><code>Buffer.from()</code>, <code>Buffer.alloc()</code>, and <code>Buffer.allocUnsafe()</code></a></p>
<ul>
<li><a href="#buffer_the_zero_fill_buffers_command_line_option">The <code>--zero-fill-buffers</code> command line option</a></li>
<li><a href="#buffer_what_makes_buffer_allocunsafe_and_buffer_allocunsafeslow_unsafe">What makes <code>Buffer.allocUnsafe()</code> and <code>Buffer.allocUnsafeSlow()</code> "unsafe"?</a></li>
</ul>
</li>
<li><a href="#buffer_buffers_and_character_encodings">Buffers and Character Encodings</a></li>
<li><a href="#buffer_buffers_and_typedarray">Buffers and TypedArray</a></li>
<li><a href="#buffer_buffers_and_iteration">Buffers and iteration</a></li>
<li>
<p><a href="#buffer_class_buffer">Class: Buffer</a></p>
<ul>
<li><span class="stability_0"><a href="#buffer_new_buffer_array">new Buffer(array)</a></span></li>
<li><span class="stability_0"><a href="#buffer_new_buffer_arraybuffer_byteoffset_length">new Buffer(arrayBuffer[, byteOffset[, length]])</a></span></li>
<li><span class="stability_0"><a href="#buffer_new_buffer_buffer">new Buffer(buffer)</a></span></li>
<li><span class="stability_0"><a href="#buffer_new_buffer_size">new Buffer(size)</a></span></li>
<li><span class="stability_0"><a href="#buffer_new_buffer_string_encoding">new Buffer(string[, encoding])</a></span></li>
<li><a href="#buffer_class_method_buffer_alloc_size_fill_encoding">Class Method: Buffer.alloc(size[, fill[, encoding]])</a></li>
<li><a href="#buffer_class_method_buffer_allocunsafe_size">Class Method: Buffer.allocUnsafe(size)</a></li>
<li><a href="#buffer_class_method_buffer_allocunsafeslow_size">Class Method: Buffer.allocUnsafeSlow(size)</a></li>
<li><a href="#buffer_class_method_buffer_bytelength_string_encoding">Class Method: Buffer.byteLength(string[, encoding])</a></li>
<li><a href="#buffer_class_method_buffer_compare_buf1_buf2">Class Method: Buffer.compare(buf1, buf2)</a></li>
<li><a href="#buffer_class_method_buffer_concat_list_totallength">Class Method: Buffer.concat(list[, totalLength])</a></li>
<li><a href="#buffer_class_method_buffer_from_array">Class Method: Buffer.from(array)</a></li>
<li><a href="#buffer_class_method_buffer_from_arraybuffer_byteoffset_length">Class Method: Buffer.from(arrayBuffer[, byteOffset[, length]])</a></li>
<li><a href="#buffer_class_method_buffer_from_buffer">Class Method: Buffer.from(buffer)</a></li>
<li><a href="#buffer_class_method_buffer_from_string_encoding">Class Method: Buffer.from(string[, encoding])</a></li>
<li><a href="#buffer_class_method_buffer_from_object_offsetorencoding_length">Class Method: Buffer.from(object[, offsetOrEncoding[, length]])</a></li>
<li><a href="#buffer_class_method_buffer_isbuffer_obj">Class Method: Buffer.isBuffer(obj)</a></li>
<li><a href="#buffer_class_method_buffer_isencoding_encoding">Class Method: Buffer.isEncoding(encoding)</a></li>
<li><a href="#buffer_class_property_buffer_poolsize">Class Property: Buffer.poolSize</a></li>
<li><a href="#buffer_buf_index">buf[index]</a></li>
<li><a href="#buffer_buf_buffer">buf.buffer</a></li>
<li><a href="#buffer_buf_byteoffset">buf.byteOffset</a></li>
<li><a href="#buffer_buf_compare_target_targetstart_targetend_sourcestart_sourceend">buf.compare(target[, targetStart[, targetEnd[, sourceStart[, sourceEnd]]]])</a></li>
<li><a href="#buffer_buf_copy_target_targetstart_sourcestart_sourceend">buf.copy(target[, targetStart[, sourceStart[, sourceEnd]]])</a></li>
<li><a href="#buffer_buf_entries">buf.entries()</a></li>
<li><a href="#buffer_buf_equals_otherbuffer">buf.equals(otherBuffer)</a></li>
<li><a href="#buffer_buf_fill_value_offset_end_encoding">buf.fill(value[, offset[, end]][, encoding])</a></li>
<li><a href="#buffer_buf_includes_value_byteoffset_encoding">buf.includes(value[, byteOffset][, encoding])</a></li>
<li><a href="#buffer_buf_indexof_value_byteoffset_encoding">buf.indexOf(value[, byteOffset][, encoding])</a></li>
<li><a href="#buffer_buf_keys">buf.keys()</a></li>
<li><a href="#buffer_buf_lastindexof_value_byteoffset_encoding">buf.lastIndexOf(value[, byteOffset][, encoding])</a></li>
<li><a href="#buffer_buf_length">buf.length</a></li>
<li><span class="stability_0"><a href="#buffer_buf_parent">buf.parent</a></span></li>
<li><a href="#buffer_buf_readdoublebe_offset">buf.readDoubleBE(offset)</a></li>
<li><a href="#buffer_buf_readdoublele_offset">buf.readDoubleLE(offset)</a></li>
<li><a href="#buffer_buf_readfloatbe_offset">buf.readFloatBE(offset)</a></li>
<li><a href="#buffer_buf_readfloatle_offset">buf.readFloatLE(offset)</a></li>
<li><a href="#buffer_buf_readint8_offset">buf.readInt8(offset)</a></li>
<li><a href="#buffer_buf_readint16be_offset">buf.readInt16BE(offset)</a></li>
<li><a href="#buffer_buf_readint16le_offset">buf.readInt16LE(offset)</a></li>
<li><a href="#buffer_buf_readint32be_offset">buf.readInt32BE(offset)</a></li>
<li><a href="#buffer_buf_readint32le_offset">buf.readInt32LE(offset)</a></li>
<li><a href="#buffer_buf_readintbe_offset_bytelength">buf.readIntBE(offset, byteLength)</a></li>
<li><a href="#buffer_buf_readintle_offset_bytelength">buf.readIntLE(offset, byteLength)</a></li>
<li><a href="#buffer_buf_readuint8_offset">buf.readUInt8(offset)</a></li>
<li><a href="#buffer_buf_readuint16be_offset">buf.readUInt16BE(offset)</a></li>
<li><a href="#buffer_buf_readuint16le_offset">buf.readUInt16LE(offset)</a></li>
<li><a href="#buffer_buf_readuint32be_offset">buf.readUInt32BE(offset)</a></li>
<li><a href="#buffer_buf_readuint32le_offset">buf.readUInt32LE(offset)</a></li>
<li><a href="#buffer_buf_readuintbe_offset_bytelength">buf.readUIntBE(offset, byteLength)</a></li>
<li><a href="#buffer_buf_readuintle_offset_bytelength">buf.readUIntLE(offset, byteLength)</a></li>
<li><a href="#buffer_buf_slice_start_end">buf.slice([start[, end]])</a></li>
<li><a href="#buffer_buf_swap16">buf.swap16()</a></li>
<li><a href="#buffer_buf_swap32">buf.swap32()</a></li>
<li><a href="#buffer_buf_swap64">buf.swap64()</a></li>
<li><a href="#buffer_buf_tojson">buf.toJSON()</a></li>
<li><a href="#buffer_buf_tostring_encoding_start_end">buf.toString([encoding[, start[, end]]])</a></li>
<li><a href="#buffer_buf_values">buf.values()</a></li>
<li><a href="#buffer_buf_write_string_offset_length_encoding">buf.write(string[, offset[, length]][, encoding])</a></li>
<li><a href="#buffer_buf_writedoublebe_value_offset">buf.writeDoubleBE(value, offset)</a></li>
<li><a href="#buffer_buf_writedoublele_value_offset">buf.writeDoubleLE(value, offset)</a></li>
<li><a href="#buffer_buf_writefloatbe_value_offset">buf.writeFloatBE(value, offset)</a></li>
<li><a href="#buffer_buf_writefloatle_value_offset">buf.writeFloatLE(value, offset)</a></li>
<li><a href="#buffer_buf_writeint8_value_offset">buf.writeInt8(value, offset)</a></li>
<li><a href="#buffer_buf_writeint16be_value_offset">buf.writeInt16BE(value, offset)</a></li>
<li><a href="#buffer_buf_writeint16le_value_offset">buf.writeInt16LE(value, offset)</a></li>
<li><a href="#buffer_buf_writeint32be_value_offset">buf.writeInt32BE(value, offset)</a></li>
<li><a href="#buffer_buf_writeint32le_value_offset">buf.writeInt32LE(value, offset)</a></li>
<li><a href="#buffer_buf_writeintbe_value_offset_bytelength">buf.writeIntBE(value, offset, byteLength)</a></li>
<li><a href="#buffer_buf_writeintle_value_offset_bytelength">buf.writeIntLE(value, offset, byteLength)</a></li>
<li><a href="#buffer_buf_writeuint8_value_offset">buf.writeUInt8(value, offset)</a></li>
<li><a href="#buffer_buf_writeuint16be_value_offset">buf.writeUInt16BE(value, offset)</a></li>
<li><a href="#buffer_buf_writeuint16le_value_offset">buf.writeUInt16LE(value, offset)</a></li>
<li><a href="#buffer_buf_writeuint32be_value_offset">buf.writeUInt32BE(value, offset)</a></li>
<li><a href="#buffer_buf_writeuint32le_value_offset">buf.writeUInt32LE(value, offset)</a></li>
<li><a href="#buffer_buf_writeuintbe_value_offset_bytelength">buf.writeUIntBE(value, offset, byteLength)</a></li>
<li><a href="#buffer_buf_writeuintle_value_offset_bytelength">buf.writeUIntLE(value, offset, byteLength)</a></li>
</ul>
</li>
<li><a href="#buffer_buffer_inspect_max_bytes">buffer.INSPECT_MAX_BYTES</a></li>
<li><a href="#buffer_buffer_kmaxlength">buffer.kMaxLength</a></li>
<li><a href="#buffer_buffer_transcode_source_fromenc_toenc">buffer.transcode(source, fromEnc, toEnc)</a></li>
<li>
<p><span class="stability_0"><a href="#buffer_class_slowbuffer">Class: SlowBuffer</a></span></p>
<ul>
<li><span class="stability_0"><a href="#buffer_new_slowbuffer_size">new SlowBuffer(size)</a></span></li>
</ul>
</li>
<li>
<p><a href="#buffer_buffer_constants">Buffer Constants</a></p>
<ul>
<li><a href="#buffer_buffer_constants_max_length">buffer.constants.MAX_LENGTH</a></li>
<li><a href="#buffer_buffer_constants_max_string_length">buffer.constants.MAX_STRING_LENGTH</a></li>
</ul>
</li>
</ul>
</li>
</ul>
      </div>

      <div id="apicontent">
        <h1>Buffer<span><a class="mark" href="#buffer_buffer" id="buffer_buffer">#</a></span></h1>

<p></p><div class="api_stability api_stability_2"><a href="documentation.html#documentation_stability_index">Stability: 2</a> - Stable</div><p></p>
<p>Prior to the introduction of <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray"><code>TypedArray</code></a>, the JavaScript language had no
mechanism for reading or manipulating streams of binary data. The <code>Buffer</code> class
was introduced as part of the Node.js API to enable interaction with octet
streams in TCP streams, file system operations, and other contexts.</p>
<p>With <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray"><code>TypedArray</code></a> now available, the <code>Buffer</code> class implements the
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array"><code>Uint8Array</code></a> API in a manner that is more optimized and suitable for Node.js.</p>
<p>Instances of the <code>Buffer</code> class are similar to arrays of integers but
correspond to fixed-sized, raw memory allocations outside the V8 heap.
The size of the <code>Buffer</code> is established when it is created and cannot be
changed.</p>
<p>The <code>Buffer</code> class is within the global scope, making it unlikely that one
would need to ever use <code>require('buffer').Buffer</code>.</p>
<pre><code class="language-js">// Creates a zero-filled Buffer of length 10.
const buf1 = Buffer.alloc(10);

// Creates a Buffer of length 10, filled with 0x1.
const buf2 = Buffer.alloc(10, 1);

// Creates an uninitialized buffer of length 10.
// This is faster than calling Buffer.alloc() but the returned
// Buffer instance might contain old data that needs to be
// overwritten using either fill() or write().
const buf3 = Buffer.allocUnsafe(10);

// Creates a Buffer containing [0x1, 0x2, 0x3].
const buf4 = Buffer.from([1, 2, 3]);

// Creates a Buffer containing UTF-8 bytes [0x74, 0xc3, 0xa9, 0x73, 0x74].
const buf5 = Buffer.from('tést');

// Creates a Buffer containing Latin-1 bytes [0x74, 0xe9, 0x73, 0x74].
const buf6 = Buffer.from('tést', 'latin1');
</code></pre>
<h2>`Buffer.from()`, `Buffer.alloc()`, and `Buffer.allocUnsafe()`<span><a class="mark" href="#buffer_buffer_from_buffer_alloc_and_buffer_allocunsafe" id="buffer_buffer_from_buffer_alloc_and_buffer_allocunsafe">#</a></span></h2>
<p>In versions of Node.js prior to 6.0.0, <code>Buffer</code> instances were created using the
<code>Buffer</code> constructor function, which allocates the returned <code>Buffer</code>
differently based on what arguments are provided:</p>
<ul>
<li>Passing a number as the first argument to <code>Buffer()</code> (e.g. <code>new Buffer(10)</code>)
allocates a new <code>Buffer</code> object of the specified size. Prior to Node.js 8.0.0,
the memory allocated for such <code>Buffer</code> instances is <em>not</em> initialized and
<em>can contain sensitive data</em>. Such <code>Buffer</code> instances <em>must</em> be subsequently
initialized by using either <a href="#buffer_buf_fill_value_offset_end_encoding"><code>buf.fill(0)</code></a> or by writing to the
entire <code>Buffer</code>. While this behavior is <em>intentional</em> to improve performance,
development experience has demonstrated that a more explicit distinction is
required between creating a fast-but-uninitialized <code>Buffer</code> versus creating a
slower-but-safer <code>Buffer</code>. Starting in Node.js 8.0.0, <code>Buffer(num)</code> and
<code>new Buffer(num)</code> will return a <code>Buffer</code> with initialized memory.</li>
<li>Passing a string, array, or <code>Buffer</code> as the first argument copies the
passed object's data into the <code>Buffer</code>.</li>
<li>Passing an <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer"><code>ArrayBuffer</code></a> or a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer"><code>SharedArrayBuffer</code></a> returns a <code>Buffer</code> that
shares allocated memory with the given array buffer.</li>
</ul>
<p>Because the behavior of <code>new Buffer()</code> is different depending on the type of the
first argument, security and reliability issues can be inadvertently introduced
into applications when argument validation or <code>Buffer</code> initialization is not
performed.</p>
<p>To make the creation of <code>Buffer</code> instances more reliable and less error-prone,
the various forms of the <code>new Buffer()</code> constructor have been <strong>deprecated</strong>
and replaced by separate <code>Buffer.from()</code>, <a href="#buffer_class_method_buffer_alloc_size_fill_encoding"><code>Buffer.alloc()</code></a>, and
<a href="#buffer_class_method_buffer_allocunsafe_size"><code>Buffer.allocUnsafe()</code></a> methods.</p>
<p><em>Developers should migrate all existing uses of the <code>new Buffer()</code> constructors
to one of these new APIs.</em></p>
<ul>
<li><a href="#buffer_class_method_buffer_from_array"><code>Buffer.from(array)</code></a> returns a new <code>Buffer</code> that <em>contains a copy</em> of the
provided octets.</li>
<li><a href="#buffer_class_method_buffer_from_arraybuffer_byteoffset_length"><code>Buffer.from(arrayBuffer[, byteOffset[, length]])</code></a>
returns a new <code>Buffer</code> that <em>shares the same allocated memory</em> as the given
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer"><code>ArrayBuffer</code></a>.</li>
<li><a href="#buffer_class_method_buffer_from_buffer"><code>Buffer.from(buffer)</code></a> returns a new <code>Buffer</code> that <em>contains a copy</em> of the
contents of the given <code>Buffer</code>.</li>
<li><a href="#buffer_class_method_buffer_from_string_encoding"><code>Buffer.from(string[, encoding])</code></a> returns a new
<code>Buffer</code> that <em>contains a copy</em> of the provided string.</li>
<li><a href="#buffer_class_method_buffer_alloc_size_fill_encoding"><code>Buffer.alloc(size[, fill[, encoding]])</code></a> returns a new
initialized <code>Buffer</code> of the specified size. This method is slower than
<a href="#buffer_class_method_buffer_allocunsafe_size"><code>Buffer.allocUnsafe(size)</code></a> but guarantees that newly
created <code>Buffer</code> instances never contain old data that is potentially
sensitive.</li>
<li><a href="#buffer_class_method_buffer_allocunsafe_size"><code>Buffer.allocUnsafe(size)</code></a> and
<a href="#buffer_class_method_buffer_allocunsafeslow_size"><code>Buffer.allocUnsafeSlow(size)</code></a> each return a
new uninitialized <code>Buffer</code> of the specified <code>size</code>. Because the <code>Buffer</code> is
uninitialized, the allocated segment of memory might contain old data that is
potentially sensitive.</li>
</ul>
<p><code>Buffer</code> instances returned by <a href="#buffer_class_method_buffer_allocunsafe_size"><code>Buffer.allocUnsafe()</code></a> <em>may</em> be allocated off
a shared internal memory pool if <code>size</code> is less than or equal to half
<a href="#buffer_class_property_buffer_poolsize"><code>Buffer.poolSize</code></a>. Instances returned by <a href="#buffer_class_method_buffer_allocunsafeslow_size"><code>Buffer.allocUnsafeSlow()</code></a> <em>never</em>
use the shared internal memory pool.</p>
<h3>The `--zero-fill-buffers` command line option<span><a class="mark" href="#buffer_the_zero_fill_buffers_command_line_option" id="buffer_the_zero_fill_buffers_command_line_option">#</a></span></h3>
<div class="api_metadata">
<span>Added in: v5.10.0</span>
</div>
<p>Node.js can be started using the <code>--zero-fill-buffers</code> command line option to
cause all newly allocated <code>Buffer</code> instances to be zero-filled upon creation by
default, including buffers returned by <code>new Buffer(size)</code>,
<a href="#buffer_class_method_buffer_allocunsafe_size"><code>Buffer.allocUnsafe()</code></a>, <a href="#buffer_class_method_buffer_allocunsafeslow_size"><code>Buffer.allocUnsafeSlow()</code></a>, and <code>new SlowBuffer(size)</code>. Use of this flag can have a significant negative impact on
performance. Use of the <code>--zero-fill-buffers</code> option is recommended only when
necessary to enforce that newly allocated <code>Buffer</code> instances cannot contain old
data that is potentially sensitive.</p>
<pre><code class="language-txt">$ node --zero-fill-buffers
> Buffer.allocUnsafe(5);
&#x3C;Buffer 00 00 00 00 00>
</code></pre>
<h3>What makes `Buffer.allocUnsafe()` and `Buffer.allocUnsafeSlow()` "unsafe"?<span><a class="mark" href="#buffer_what_makes_buffer_allocunsafe_and_buffer_allocunsafeslow_unsafe" id="buffer_what_makes_buffer_allocunsafe_and_buffer_allocunsafeslow_unsafe">#</a></span></h3>
<p>When calling <a href="#buffer_class_method_buffer_allocunsafe_size"><code>Buffer.allocUnsafe()</code></a> and <a href="#buffer_class_method_buffer_allocunsafeslow_size"><code>Buffer.allocUnsafeSlow()</code></a>, the
segment of allocated memory is <em>uninitialized</em> (it is not zeroed-out). While
this design makes the allocation of memory quite fast, the allocated segment of
memory might contain old data that is potentially sensitive. Using a <code>Buffer</code>
created by <a href="#buffer_class_method_buffer_allocunsafe_size"><code>Buffer.allocUnsafe()</code></a> without <em>completely</em> overwriting the memory
can allow this old data to be leaked when the <code>Buffer</code> memory is read.</p>
<p>While there are clear performance advantages to using <a href="#buffer_class_method_buffer_allocunsafe_size"><code>Buffer.allocUnsafe()</code></a>,
extra care <em>must</em> be taken in order to avoid introducing security
vulnerabilities into an application.</p>
<h2>Buffers and Character Encodings<span><a class="mark" href="#buffer_buffers_and_character_encodings" id="buffer_buffers_and_character_encodings">#</a></span></h2>
<div class="api_metadata">
<details class="changelog"><summary>History</summary>
<table>
<tbody><tr><th>Version</th><th>Changes</th></tr>
<tr><td>v6.4.0</td>
<td><p>Introduced <code>latin1</code> as an alias for <code>binary</code>.</p></td></tr>
<tr><td>v5.0.0</td>
<td><p>Removed the deprecated <code>raw</code> and <code>raws</code> encodings.</p></td></tr>
</tbody></table>
</details>
</div>
<p>When string data is stored in or extracted out of a <code>Buffer</code> instance, a
character encoding may be specified.</p>
<pre><code class="language-js">const buf = Buffer.from('hello world', 'ascii');

console.log(buf.toString('hex'));
// Prints: 68656c6c6f20776f726c64
console.log(buf.toString('base64'));
// Prints: aGVsbG8gd29ybGQ=

console.log(Buffer.from('fhqwhgads', 'ascii'));
// Prints: &#x3C;Buffer 66 68 71 77 68 67 61 64 73>
console.log(Buffer.from('fhqwhgads', 'utf16le'));
// Prints: &#x3C;Buffer 66 00 68 00 71 00 77 00 68 00 67 00 61 00 64 00 73 00>
</code></pre>
<p>The character encodings currently supported by Node.js include:</p>
<ul>
<li>
<p><code>'ascii'</code> - For 7-bit ASCII data only. This encoding is fast and will strip
the high bit if set.</p>
</li>
<li>
<p><code>'utf8'</code> - Multibyte encoded Unicode characters. Many web pages and other
document formats use UTF-8.</p>
</li>
<li>
<p><code>'utf16le'</code> - 2 or 4 bytes, little-endian encoded Unicode characters.
Surrogate pairs (U+10000 to U+10FFFF) are supported.</p>
</li>
<li>
<p><code>'ucs2'</code> - Alias of <code>'utf16le'</code>.</p>
</li>
<li>
<p><code>'base64'</code> - Base64 encoding. When creating a <code>Buffer</code> from a string,
this encoding will also correctly accept "URL and Filename Safe Alphabet" as
specified in <a href="https://tools.ietf.org/html/rfc4648#section-5">RFC4648, Section 5</a>.</p>
</li>
<li>
<p><code>'latin1'</code> - A way of encoding the <code>Buffer</code> into a one-byte encoded string
(as defined by the IANA in <a href="https://tools.ietf.org/html/rfc1345">RFC1345</a>,
page 63, to be the Latin-1 supplement block and C0/C1 control codes).</p>
</li>
<li>
<p><code>'binary'</code> - Alias for <code>'latin1'</code>.</p>
</li>
<li>
<p><code>'hex'</code> - Encode each byte as two hexadecimal characters.</p>
</li>
</ul>
<p>Modern Web browsers follow the <a href="https://encoding.spec.whatwg.org/">WHATWG Encoding Standard</a> which aliases
both <code>'latin1'</code> and <code>'ISO-8859-1'</code> to <code>'win-1252'</code>. This means that while doing
something like <code>http.get()</code>, if the returned charset is one of those listed in
the WHATWG specification it is possible that the server actually returned
<code>'win-1252'</code>-encoded data, and using <code>'latin1'</code> encoding may incorrectly decode
the characters.</p>
<h2>Buffers and TypedArray<span><a class="mark" href="#buffer_buffers_and_typedarray" id="buffer_buffers_and_typedarray">#</a></span></h2>
<div class="api_metadata">
<details class="changelog"><summary>History</summary>
<table>
<tbody><tr><th>Version</th><th>Changes</th></tr>
<tr><td>v3.0.0</td>
<td><p>The <code>Buffer</code>s class now inherits from <code>Uint8Array</code>.</p></td></tr>
</tbody></table>
</details>
</div>
<p><code>Buffer</code> instances are also <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array"><code>Uint8Array</code></a> instances. However, there are subtle
incompatibilities with <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray"><code>TypedArray</code></a>. For example, while
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer/slice"><code>ArrayBuffer#slice()</code></a> creates a copy of the slice, the implementation of
<a href="#buffer_buf_slice_start_end"><code>Buffer#slice()</code></a> creates a view over the existing <code>Buffer</code>
without copying, making <a href="#buffer_buf_slice_start_end"><code>Buffer#slice()</code></a> far more efficient.</p>
<p>It is also possible to create new <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray"><code>TypedArray</code></a> instances from a <code>Buffer</code> with
the following caveats:</p>
<ol>
<li>
<p>The <code>Buffer</code> object's memory is copied to the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray"><code>TypedArray</code></a>, not shared.</p>
</li>
<li>
<p>The <code>Buffer</code> object's memory is interpreted as an array of distinct
elements, and not as a byte array of the target type. That is,
<code>new Uint32Array(Buffer.from([1, 2, 3, 4]))</code> creates a 4-element <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint32Array"><code>Uint32Array</code></a>
with elements <code>[1, 2, 3, 4]</code>, not a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint32Array"><code>Uint32Array</code></a> with a single element
<code>[0x1020304]</code> or <code>[0x4030201]</code>.</p>
</li>
</ol>
<p>It is possible to create a new <code>Buffer</code> that shares the same allocated memory as
a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray"><code>TypedArray</code></a> instance by using the <code>TypeArray</code> object's <code>.buffer</code> property.</p>
<pre><code class="language-js">const arr = new Uint16Array(2);

arr[0] = 5000;
arr[1] = 4000;

// Copies the contents of `arr`
const buf1 = Buffer.from(arr);
// Shares memory with `arr`
const buf2 = Buffer.from(arr.buffer);

console.log(buf1);
// Prints: &#x3C;Buffer 88 a0>
console.log(buf2);
// Prints: &#x3C;Buffer 88 13 a0 0f>

arr[1] = 6000;

console.log(buf1);
// Prints: &#x3C;Buffer 88 a0>
console.log(buf2);
// Prints: &#x3C;Buffer 88 13 70 17>
</code></pre>
<p>Note that when creating a <code>Buffer</code> using a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray"><code>TypedArray</code></a>'s <code>.buffer</code>, it is
possible to use only a portion of the underlying <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer"><code>ArrayBuffer</code></a> by passing in
<code>byteOffset</code> and <code>length</code> parameters.</p>
<pre><code class="language-js">const arr = new Uint16Array(20);
const buf = Buffer.from(arr.buffer, 0, 16);

console.log(buf.length);
// Prints: 16
</code></pre>
<p>The <code>Buffer.from()</code> and <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/from"><code>TypedArray.from()</code></a> have different signatures and
implementations. Specifically, the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray"><code>TypedArray</code></a> variants accept a second
argument that is a mapping function that is invoked on every element of the
typed array:</p>
<ul>
<li><code>TypedArray.from(source[, mapFn[, thisArg]])</code></li>
</ul>
<p>The <code>Buffer.from()</code> method, however, does not support the use of a mapping
function:</p>
<ul>
<li><a href="#buffer_class_method_buffer_from_array"><code>Buffer.from(array)</code></a></li>
<li><a href="#buffer_class_method_buffer_from_buffer"><code>Buffer.from(buffer)</code></a></li>
<li><a href="#buffer_class_method_buffer_from_arraybuffer_byteoffset_length"><code>Buffer.from(arrayBuffer[, byteOffset[, length]])</code></a></li>
<li><a href="#buffer_class_method_buffer_from_string_encoding"><code>Buffer.from(string[, encoding])</code></a></li>
</ul>
<h2>Buffers and iteration<span><a class="mark" href="#buffer_buffers_and_iteration" id="buffer_buffers_and_iteration">#</a></span></h2>
<p><code>Buffer</code> instances can be iterated over using <code>for..of</code> syntax:</p>
<pre><code class="language-js">const buf = Buffer.from([1, 2, 3]);

// Prints:
//   1
//   2
//   3
for (const b of buf) {
  console.log(b);
}
</code></pre>
<p>Additionally, the <a href="#buffer_buf_values"><code>buf.values()</code></a>, <a href="#buffer_buf_keys"><code>buf.keys()</code></a>, and
<a href="#buffer_buf_entries"><code>buf.entries()</code></a> methods can be used to create iterators.</p>
<h2>Class: Buffer<span><a class="mark" href="#buffer_class_buffer" id="buffer_class_buffer">#</a></span></h2>
<p>The <code>Buffer</code> class is a global type for dealing with binary data directly.
It can be constructed in a variety of ways.</p>
<h3>new Buffer(array)<span><a class="mark" href="#buffer_new_buffer_array" id="buffer_new_buffer_array">#</a></span></h3>
<div class="api_metadata">
<details class="changelog"><summary>History</summary>
<table>
<tbody><tr><th>Version</th><th>Changes</th></tr>
<tr><td>v10.0.0</td>
<td><p>Calling this constructor emits a deprecation warning when run from code outside the <code>node_modules</code> directory.</p></td></tr>
<tr><td>v7.2.1</td>
<td><p>Calling this constructor no longer emits a deprecation warning.</p></td></tr>
<tr><td>v7.0.0</td>
<td><p>Calling this constructor emits a deprecation warning now.</p></td></tr>
<tr><td>v6.0.0</td>
<td><p><span>Deprecated since: v6.0.0</span></p></td></tr>
</tbody></table>
</details>
</div>
<p></p><div class="api_stability api_stability_0"><a href="documentation.html#documentation_stability_index">Stability: 0</a> - Deprecated: Use <a href="#buffer_class_method_buffer_from_array"><code>Buffer.from(array)</code></a> instead.</div><p></p>
<ul>
<li><code>array</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type">&#x3C;integer[]></a> An array of bytes to copy from.</li>
</ul>
<p>Allocates a new <code>Buffer</code> using an <code>array</code> of octets.</p>
<pre><code class="language-js">// Creates a new Buffer containing the UTF-8 bytes of the string 'buffer'
const buf = new Buffer([0x62, 0x75, 0x66, 0x66, 0x65, 0x72]);
</code></pre>
<h3>new Buffer(arrayBuffer[, byteOffset[, length]])<span><a class="mark" href="#buffer_new_buffer_arraybuffer_byteoffset_length" id="buffer_new_buffer_arraybuffer_byteoffset_length">#</a></span></h3>
<div class="api_metadata">
<details class="changelog"><summary>History</summary>
<table>
<tbody><tr><th>Version</th><th>Changes</th></tr>
<tr><td>v10.0.0</td>
<td><p>Calling this constructor emits a deprecation warning when run from code outside the <code>node_modules</code> directory.</p></td></tr>
<tr><td>v7.2.1</td>
<td><p>Calling this constructor no longer emits a deprecation warning.</p></td></tr>
<tr><td>v7.0.0</td>
<td><p>Calling this constructor emits a deprecation warning now.</p></td></tr>
<tr><td>v6.0.0</td>
<td><p>The <code>byteOffset</code> and <code>length</code> parameters are supported now.</p></td></tr>
<tr><td>v6.0.0</td>
<td><p><span>Deprecated since: v6.0.0</span></p></td></tr>
<tr><td>v3.0.0</td>
<td><p><span>Added in: v3.0.0</span></p></td></tr>
</tbody></table>
</details>
</div>
<p></p><div class="api_stability api_stability_0"><a href="documentation.html#documentation_stability_index">Stability: 0</a> - Deprecated: Use
<a href="#buffer_class_method_buffer_from_arraybuffer_byteoffset_length"><code>Buffer.from(arrayBuffer[, byteOffset[, length]])</code></a>
instead.</div><p></p>
<ul>
<li><code>arrayBuffer</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer" class="type">&#x3C;ArrayBuffer></a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer" class="type">&#x3C;SharedArrayBuffer></a> An <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer"><code>ArrayBuffer</code></a>,
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer"><code>SharedArrayBuffer</code></a> or the <code>.buffer</code> property of a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray"><code>TypedArray</code></a>.</li>
<li><code>byteOffset</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type">&#x3C;integer></a> Index of first byte to expose. <strong>Default:</strong> <code>0</code>.</li>
<li><code>length</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type">&#x3C;integer></a> Number of bytes to expose.
<strong>Default:</strong> <code>arrayBuffer.length - byteOffset</code>.</li>
</ul>
<p>This creates a view of the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer"><code>ArrayBuffer</code></a> or <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer"><code>SharedArrayBuffer</code></a> without
copying the underlying memory. For example, when passed a reference to the
<code>.buffer</code> property of a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray"><code>TypedArray</code></a> instance, the newly created <code>Buffer</code> will
share the same allocated memory as the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray"><code>TypedArray</code></a>.</p>
<p>The optional <code>byteOffset</code> and <code>length</code> arguments specify a memory range within
the <code>arrayBuffer</code> that will be shared by the <code>Buffer</code>.</p>
<pre><code class="language-js">const arr = new Uint16Array(2);

arr[0] = 5000;
arr[1] = 4000;

// Shares memory with `arr`
const buf = new Buffer(arr.buffer);

console.log(buf);
// Prints: &#x3C;Buffer 88 13 a0 0f>

// Changing the original Uint16Array changes the Buffer also
arr[1] = 6000;

console.log(buf);
// Prints: &#x3C;Buffer 88 13 70 17>
</code></pre>
<h3>new Buffer(buffer)<span><a class="mark" href="#buffer_new_buffer_buffer" id="buffer_new_buffer_buffer">#</a></span></h3>
<div class="api_metadata">
<details class="changelog"><summary>History</summary>
<table>
<tbody><tr><th>Version</th><th>Changes</th></tr>
<tr><td>v10.0.0</td>
<td><p>Calling this constructor emits a deprecation warning when run from code outside the <code>node_modules</code> directory.</p></td></tr>
<tr><td>v7.2.1</td>
<td><p>Calling this constructor no longer emits a deprecation warning.</p></td></tr>
<tr><td>v7.0.0</td>
<td><p>Calling this constructor emits a deprecation warning now.</p></td></tr>
<tr><td>v6.0.0</td>
<td><p><span>Deprecated since: v6.0.0</span></p></td></tr>
</tbody></table>
</details>
</div>
<p></p><div class="api_stability api_stability_0"><a href="documentation.html#documentation_stability_index">Stability: 0</a> - Deprecated: Use <a href="#buffer_class_method_buffer_from_buffer"><code>Buffer.from(buffer)</code></a> instead.</div><p></p>
<ul>
<li><code>buffer</code> <a href="buffer.html#buffer_class_buffer" class="type">&#x3C;Buffer></a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array" class="type">&#x3C;Uint8Array></a> An existing <code>Buffer</code> or <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array"><code>Uint8Array</code></a> from which
to copy data.</li>
</ul>
<p>Copies the passed <code>buffer</code> data onto a new <code>Buffer</code> instance.</p>
<pre><code class="language-js">const buf1 = new Buffer('buffer');
const buf2 = new Buffer(buf1);

buf1[0] = 0x61;

console.log(buf1.toString());
// Prints: auffer
console.log(buf2.toString());
// Prints: buffer
</code></pre>
<h3>new Buffer(size)<span><a class="mark" href="#buffer_new_buffer_size" id="buffer_new_buffer_size">#</a></span></h3>
<div class="api_metadata">
<details class="changelog"><summary>History</summary>
<table>
<tbody><tr><th>Version</th><th>Changes</th></tr>
<tr><td>v10.0.0</td>
<td><p>Calling this constructor emits a deprecation warning when run from code outside the <code>node_modules</code> directory.</p></td></tr>
<tr><td>v8.0.0</td>
<td><p>The <code>new Buffer(size)</code> will return zero-filled memory by default.</p></td></tr>
<tr><td>v7.2.1</td>
<td><p>Calling this constructor no longer emits a deprecation warning.</p></td></tr>
<tr><td>v7.0.0</td>
<td><p>Calling this constructor emits a deprecation warning now.</p></td></tr>
<tr><td>v6.0.0</td>
<td><p><span>Deprecated since: v6.0.0</span></p></td></tr>
</tbody></table>
</details>
</div>
<p></p><div class="api_stability api_stability_0"><a href="documentation.html#documentation_stability_index">Stability: 0</a> - Deprecated: Use <a href="#buffer_class_method_buffer_alloc_size_fill_encoding"><code>Buffer.alloc()</code></a> instead (also see
<a href="#buffer_class_method_buffer_allocunsafe_size"><code>Buffer.allocUnsafe()</code></a>).</div><p></p>
<ul>
<li><code>size</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type">&#x3C;integer></a> The desired length of the new <code>Buffer</code>.</li>
</ul>
<p>Allocates a new <code>Buffer</code> of <code>size</code> bytes. If <code>size</code> is larger than
<a href="#buffer_buffer_constants_max_length"><code>buffer.constants.MAX_LENGTH</code></a> or smaller than 0, <a href="errors.html#ERR_INVALID_OPT_VALUE"><code>ERR_INVALID_OPT_VALUE</code></a> is
thrown. A zero-length <code>Buffer</code> is created if <code>size</code> is 0.</p>
<p>Prior to Node.js 8.0.0, the underlying memory for <code>Buffer</code> instances
created in this way is <em>not initialized</em>. The contents of a newly created
<code>Buffer</code> are unknown and <em>may contain sensitive data</em>. Use
<a href="#buffer_class_method_buffer_alloc_size_fill_encoding"><code>Buffer.alloc(size)</code></a> instead to initialize a <code>Buffer</code>
with zeroes.</p>
<pre><code class="language-js">const buf = new Buffer(10);

console.log(buf);
// Prints: &#x3C;Buffer 00 00 00 00 00 00 00 00 00 00>
</code></pre>
<h3>new Buffer(string[, encoding])<span><a class="mark" href="#buffer_new_buffer_string_encoding" id="buffer_new_buffer_string_encoding">#</a></span></h3>
<div class="api_metadata">
<details class="changelog"><summary>History</summary>
<table>
<tbody><tr><th>Version</th><th>Changes</th></tr>
<tr><td>v10.0.0</td>
<td><p>Calling this constructor emits a deprecation warning when run from code outside the <code>node_modules</code> directory.</p></td></tr>
<tr><td>v7.2.1</td>
<td><p>Calling this constructor no longer emits a deprecation warning.</p></td></tr>
<tr><td>v7.0.0</td>
<td><p>Calling this constructor emits a deprecation warning now.</p></td></tr>
<tr><td>v6.0.0</td>
<td><p><span>Deprecated since: v6.0.0</span></p></td></tr>
</tbody></table>
</details>
</div>
<p></p><div class="api_stability api_stability_0"><a href="documentation.html#documentation_stability_index">Stability: 0</a> - Deprecated:
Use <a href="#buffer_class_method_buffer_from_string_encoding"><code>Buffer.from(string[, encoding])</code></a> instead.</div><p></p>
<ul>
<li><code>string</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" class="type">&#x3C;string></a> String to encode.</li>
<li><code>encoding</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" class="type">&#x3C;string></a> The encoding of <code>string</code>. <strong>Default:</strong> <code>'utf8'</code>.</li>
</ul>
<p>Creates a new <code>Buffer</code> containing <code>string</code>. The <code>encoding</code> parameter identifies
the character encoding of <code>string</code>.</p>
<pre><code class="language-js">const buf1 = new Buffer('this is a tést');
const buf2 = new Buffer('7468697320697320612074c3a97374', 'hex');

console.log(buf1.toString());
// Prints: this is a tést
console.log(buf2.toString());
// Prints: this is a tést
console.log(buf1.toString('ascii'));
// Prints: this is a tC)st
</code></pre>
<h3>Class Method: Buffer.alloc(size[, fill[, encoding]])<a class="srclink" href="https://github.com/nodejs/node/blob/1a96d83a223ff9f05f7d942fb84440d323f7b596/lib/buffer.js#L277">[src]</a><span><a class="mark" href="#buffer_class_method_buffer_alloc_size_fill_encoding" id="buffer_class_method_buffer_alloc_size_fill_encoding">#</a></span></h3>
<div class="api_metadata">
<details class="changelog"><summary>History</summary>
<table>
<tbody><tr><th>Version</th><th>Changes</th></tr>
<tr><td>v10.0.0</td>
<td><p>Attempting to fill a non-zero length buffer with a zero length buffer triggers a thrown exception.</p></td></tr>
<tr><td>v10.0.0</td>
<td><p>Specifying an invalid string for <code>fill</code> triggers a thrown exception.</p></td></tr>
<tr><td>v8.9.3</td>
<td><p>Specifying an invalid string for <code>fill</code> now results in a zero-filled buffer.</p></td></tr>
<tr><td>v5.10.0</td>
<td><p><span>Added in: v5.10.0</span></p></td></tr>
</tbody></table>
</details>
</div>
<ul>
<li><code>size</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type">&#x3C;integer></a> The desired length of the new <code>Buffer</code>.</li>
<li><code>fill</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" class="type">&#x3C;string></a> | <a href="buffer.html#buffer_class_buffer" class="type">&#x3C;Buffer></a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type">&#x3C;integer></a> A value to pre-fill the new <code>Buffer</code> with.
<strong>Default:</strong> <code>0</code>.</li>
<li><code>encoding</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" class="type">&#x3C;string></a> If <code>fill</code> is a string, this is its encoding.
<strong>Default:</strong> <code>'utf8'</code>.</li>
</ul>
<p>Allocates a new <code>Buffer</code> of <code>size</code> bytes. If <code>fill</code> is <code>undefined</code>, the
<code>Buffer</code> will be <em>zero-filled</em>.</p>
<pre><code class="language-js">const buf = Buffer.alloc(5);

console.log(buf);
// Prints: &#x3C;Buffer 00 00 00 00 00>
</code></pre>
<p>Allocates a new <code>Buffer</code> of <code>size</code> bytes. If <code>size</code> is larger than
<a href="#buffer_buffer_constants_max_length"><code>buffer.constants.MAX_LENGTH</code></a> or smaller than 0, <a href="errors.html#ERR_INVALID_OPT_VALUE"><code>ERR_INVALID_OPT_VALUE</code></a> is
thrown. A zero-length <code>Buffer</code> is created if <code>size</code> is 0.</p>
<p>If <code>fill</code> is specified, the allocated <code>Buffer</code> will be initialized by calling
<a href="#buffer_buf_fill_value_offset_end_encoding"><code>buf.fill(fill)</code></a>.</p>
<pre><code class="language-js">const buf = Buffer.alloc(5, 'a');

console.log(buf);
// Prints: &#x3C;Buffer 61 61 61 61 61>
</code></pre>
<p>If both <code>fill</code> and <code>encoding</code> are specified, the allocated <code>Buffer</code> will be
initialized by calling <a href="#buffer_buf_fill_value_offset_end_encoding"><code>buf.fill(fill, encoding)</code></a>.</p>
<pre><code class="language-js">const buf = Buffer.alloc(11, 'aGVsbG8gd29ybGQ=', 'base64');

console.log(buf);
// Prints: &#x3C;Buffer 68 65 6c 6c 6f 20 77 6f 72 6c 64>
</code></pre>
<p>Calling <a href="#buffer_class_method_buffer_alloc_size_fill_encoding"><code>Buffer.alloc()</code></a> can be significantly slower than the alternative
<a href="#buffer_class_method_buffer_allocunsafe_size"><code>Buffer.allocUnsafe()</code></a> but ensures that the newly created <code>Buffer</code> instance
contents will <em>never contain sensitive data</em>.</p>
<p>A <code>TypeError</code> will be thrown if <code>size</code> is not a number.</p>
<h3>Class Method: Buffer.allocUnsafe(size)<a class="srclink" href="https://github.com/nodejs/node/blob/1a96d83a223ff9f05f7d942fb84440d323f7b596/lib/buffer.js#L290">[src]</a><span><a class="mark" href="#buffer_class_method_buffer_allocunsafe_size" id="buffer_class_method_buffer_allocunsafe_size">#</a></span></h3>
<div class="api_metadata">
<details class="changelog"><summary>History</summary>
<table>
<tbody><tr><th>Version</th><th>Changes</th></tr>
<tr><td>v7.0.0</td>
<td><p>Passing a negative <code>size</code> will now throw an error.</p></td></tr>
<tr><td>v5.10.0</td>
<td><p><span>Added in: v5.10.0</span></p></td></tr>
</tbody></table>
</details>
</div>
<ul>
<li><code>size</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type">&#x3C;integer></a> The desired length of the new <code>Buffer</code>.</li>
</ul>
<p>Allocates a new <code>Buffer</code> of <code>size</code> bytes. If <code>size</code> is larger than
<a href="#buffer_buffer_constants_max_length"><code>buffer.constants.MAX_LENGTH</code></a> or smaller than 0, <a href="errors.html#ERR_INVALID_OPT_VALUE"><code>ERR_INVALID_OPT_VALUE</code></a> is
thrown. A zero-length <code>Buffer</code> is created if <code>size</code> is 0.</p>
<p>The underlying memory for <code>Buffer</code> instances created in this way is <em>not
initialized</em>. The contents of the newly created <code>Buffer</code> are unknown and
<em>may contain sensitive data</em>. Use <a href="#buffer_class_method_buffer_alloc_size_fill_encoding"><code>Buffer.alloc()</code></a> instead to initialize
<code>Buffer</code> instances with zeroes.</p>
<pre><code class="language-js">const buf = Buffer.allocUnsafe(10);

console.log(buf);
// Prints: (contents may vary): &#x3C;Buffer a0 8b 28 3f 01 00 00 00 50 32>

buf.fill(0);

console.log(buf);
// Prints: &#x3C;Buffer 00 00 00 00 00 00 00 00 00 00>
</code></pre>
<p>A <code>TypeError</code> will be thrown if <code>size</code> is not a number.</p>
<p>Note that the <code>Buffer</code> module pre-allocates an internal <code>Buffer</code> instance of
size <a href="#buffer_class_property_buffer_poolsize"><code>Buffer.poolSize</code></a> that is used as a pool for the fast allocation of new
<code>Buffer</code> instances created using <a href="#buffer_class_method_buffer_allocunsafe_size"><code>Buffer.allocUnsafe()</code></a> and the deprecated
<code>new Buffer(size)</code> constructor only when <code>size</code> is less than or equal to
<code>Buffer.poolSize >> 1</code> (floor of <a href="#buffer_class_property_buffer_poolsize"><code>Buffer.poolSize</code></a> divided by two).</p>
<p>Use of this pre-allocated internal memory pool is a key difference between
calling <code>Buffer.alloc(size, fill)</code> vs. <code>Buffer.allocUnsafe(size).fill(fill)</code>.
Specifically, <code>Buffer.alloc(size, fill)</code> will <em>never</em> use the internal <code>Buffer</code>
pool, while <code>Buffer.allocUnsafe(size).fill(fill)</code> <em>will</em> use the internal
<code>Buffer</code> pool if <code>size</code> is less than or equal to half <a href="#buffer_class_property_buffer_poolsize"><code>Buffer.poolSize</code></a>. The
difference is subtle but can be important when an application requires the
additional performance that <a href="#buffer_class_method_buffer_allocunsafe_size"><code>Buffer.allocUnsafe()</code></a> provides.</p>
<h3>Class Method: Buffer.allocUnsafeSlow(size)<a class="srclink" href="https://github.com/nodejs/node/blob/1a96d83a223ff9f05f7d942fb84440d323f7b596/lib/buffer.js#L300">[src]</a><span><a class="mark" href="#buffer_class_method_buffer_allocunsafeslow_size" id="buffer_class_method_buffer_allocunsafeslow_size">#</a></span></h3>
<div class="api_metadata">
<span>Added in: v5.12.0</span>
</div>
<ul>
<li><code>size</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type">&#x3C;integer></a> The desired length of the new <code>Buffer</code>.</li>
</ul>
<p>Allocates a new <code>Buffer</code> of <code>size</code> bytes. If <code>size</code> is larger than
<a href="#buffer_buffer_constants_max_length"><code>buffer.constants.MAX_LENGTH</code></a> or smaller than 0, <a href="errors.html#ERR_INVALID_OPT_VALUE"><code>ERR_INVALID_OPT_VALUE</code></a> is
thrown. A zero-length <code>Buffer</code> is created if <code>size</code> is 0.</p>
<p>The underlying memory for <code>Buffer</code> instances created in this way is <em>not
initialized</em>. The contents of the newly created <code>Buffer</code> are unknown and
<em>may contain sensitive data</em>. Use <a href="#buffer_buf_fill_value_offset_end_encoding"><code>buf.fill(0)</code></a> to initialize
such <code>Buffer</code> instances with zeroes.</p>
<p>When using <a href="#buffer_class_method_buffer_allocunsafe_size"><code>Buffer.allocUnsafe()</code></a> to allocate new <code>Buffer</code> instances,
allocations under 4KB are sliced from a single pre-allocated <code>Buffer</code>. This
allows applications to avoid the garbage collection overhead of creating many
individually allocated <code>Buffer</code> instances. This approach improves both
performance and memory usage by eliminating the need to track and clean up as
many persistent objects.</p>
<p>However, in the case where a developer may need to retain a small chunk of
memory from a pool for an indeterminate amount of time, it may be appropriate
to create an un-pooled <code>Buffer</code> instance using <code>Buffer.allocUnsafeSlow()</code> and
then copying out the relevant bits.</p>
<pre><code class="language-js">// Need to keep around a few small chunks of memory
const store = [];

socket.on('readable', () => {
  const data = socket.read();

  // Allocate for retained data
  const sb = Buffer.allocUnsafeSlow(10);

  // Copy the data into the new allocation
  data.copy(sb, 0, 0, 10);

  store.push(sb);
});
</code></pre>
<p><code>Buffer.allocUnsafeSlow()</code> should be used only as a last resort after a
developer has observed undue memory retention in their applications.</p>
<p>A <code>TypeError</code> will be thrown if <code>size</code> is not a number.</p>
<h3>Class Method: Buffer.byteLength(string[, encoding])<a class="srclink" href="https://github.com/nodejs/node/blob/1a96d83a223ff9f05f7d942fb84440d323f7b596/lib/buffer.js#L509">[src]</a><span><a class="mark" href="#buffer_class_method_buffer_bytelength_string_encoding" id="buffer_class_method_buffer_bytelength_string_encoding">#</a></span></h3>
<div class="api_metadata">
<details class="changelog"><summary>History</summary>
<table>
<tbody><tr><th>Version</th><th>Changes</th></tr>
<tr><td>v7.0.0</td>
<td><p>Passing invalid input will now throw an error.</p></td></tr>
<tr><td>v5.10.0</td>
<td><p>The <code>string</code> parameter can now be any <code>TypedArray</code>, <code>DataView</code> or <code>ArrayBuffer</code>.</p></td></tr>
<tr><td>v0.1.90</td>
<td><p><span>Added in: v0.1.90</span></p></td></tr>
</tbody></table>
</details>
</div>
<ul>
<li><code>string</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" class="type">&#x3C;string></a> | <a href="buffer.html#buffer_class_buffer" class="type">&#x3C;Buffer></a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray" class="type">&#x3C;TypedArray></a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView" class="type">&#x3C;DataView></a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer" class="type">&#x3C;ArrayBuffer></a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer" class="type">&#x3C;SharedArrayBuffer></a> A
value to calculate the length of.</li>
<li><code>encoding</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" class="type">&#x3C;string></a> If <code>string</code> is a string, this is its encoding.
<strong>Default:</strong> <code>'utf8'</code>.</li>
<li>Returns: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type">&#x3C;integer></a> The number of bytes contained within <code>string</code>.</li>
</ul>
<p>Returns the actual byte length of a string. This is not the same as
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/length"><code>String.prototype.length</code></a> since that returns the number of <em>characters</em> in
a string.</p>
<p>For <code>'base64'</code> and <code>'hex'</code>, this function assumes valid input. For strings that
contain non-Base64/Hex-encoded data (e.g. whitespace), the return value might be
greater than the length of a <code>Buffer</code> created from the string.</p>
<pre><code class="language-js">const str = '\u00bd + \u00bc = \u00be';

console.log(`${str}: ${str.length} characters, ` +
            `${Buffer.byteLength(str, 'utf8')} bytes`);
// Prints: ½ + ¼ = ¾: 9 characters, 12 bytes
</code></pre>
<p>When <code>string</code> is a <code>Buffer</code>/<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView"><code>DataView</code></a>/<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray"><code>TypedArray</code></a>/<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer"><code>ArrayBuffer</code></a>/
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer"><code>SharedArrayBuffer</code></a>, the actual byte length is returned.</p>
<h3>Class Method: Buffer.compare(buf1, buf2)<a class="srclink" href="https://github.com/nodejs/node/blob/1a96d83a223ff9f05f7d942fb84440d323f7b596/lib/buffer.js#L433">[src]</a><span><a class="mark" href="#buffer_class_method_buffer_compare_buf1_buf2" id="buffer_class_method_buffer_compare_buf1_buf2">#</a></span></h3>
<div class="api_metadata">
<details class="changelog"><summary>History</summary>
<table>
<tbody><tr><th>Version</th><th>Changes</th></tr>
<tr><td>v8.0.0</td>
<td><p>The arguments can now be <code>Uint8Array</code>s.</p></td></tr>
<tr><td>v0.11.13</td>
<td><p><span>Added in: v0.11.13</span></p></td></tr>
</tbody></table>
</details>
</div>
<ul>
<li><code>buf1</code> <a href="buffer.html#buffer_class_buffer" class="type">&#x3C;Buffer></a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array" class="type">&#x3C;Uint8Array></a></li>
<li><code>buf2</code> <a href="buffer.html#buffer_class_buffer" class="type">&#x3C;Buffer></a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array" class="type">&#x3C;Uint8Array></a></li>
<li>Returns: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type">&#x3C;integer></a></li>
</ul>
<p>Compares <code>buf1</code> to <code>buf2</code> typically for the purpose of sorting arrays of
<code>Buffer</code> instances. This is equivalent to calling
<a href="#buffer_buf_compare_target_targetstart_targetend_sourcestart_sourceend"><code>buf1.compare(buf2)</code></a>.</p>
<pre><code class="language-js">const buf1 = Buffer.from('1234');
const buf2 = Buffer.from('0123');
const arr = [buf1, buf2];

console.log(arr.sort(Buffer.compare));
// Prints: [ &#x3C;Buffer 30 31 32 33>, &#x3C;Buffer 31 32 33 34> ]
// (This result is equal to: [buf2, buf1])
</code></pre>
<h3>Class Method: Buffer.concat(list[, totalLength])<a class="srclink" href="https://github.com/nodejs/node/blob/1a96d83a223ff9f05f7d942fb84440d323f7b596/lib/buffer.js#L455">[src]</a><span><a class="mark" href="#buffer_class_method_buffer_concat_list_totallength" id="buffer_class_method_buffer_concat_list_totallength">#</a></span></h3>
<div class="api_metadata">
<details class="changelog"><summary>History</summary>
<table>
<tbody><tr><th>Version</th><th>Changes</th></tr>
<tr><td>v8.0.0</td>
<td><p>The elements of <code>list</code> can now be <code>Uint8Array</code>s.</p></td></tr>
<tr><td>v0.7.11</td>
<td><p><span>Added in: v0.7.11</span></p></td></tr>
</tbody></table>
</details>
</div>
<ul>
<li><code>list</code> <a href="buffer.html#buffer_class_buffer" class="type">&#x3C;Buffer[]></a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array" class="type">&#x3C;Uint8Array[]></a> List of <code>Buffer</code> or <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array"><code>Uint8Array</code></a> instances
to concat.</li>
<li><code>totalLength</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type">&#x3C;integer></a> Total length of the <code>Buffer</code> instances in <code>list</code>
when concatenated.</li>
<li>Returns: <a href="buffer.html#buffer_class_buffer" class="type">&#x3C;Buffer></a></li>
</ul>
<p>Returns a new <code>Buffer</code> which is the result of concatenating all the <code>Buffer</code>
instances in the <code>list</code> together.</p>
<p>If the list has no items, or if the <code>totalLength</code> is 0, then a new zero-length
<code>Buffer</code> is returned.</p>
<p>If <code>totalLength</code> is not provided, it is calculated from the <code>Buffer</code> instances
in <code>list</code>. This however causes an additional loop to be executed in order to
calculate the <code>totalLength</code>, so it is faster to provide the length explicitly if
it is already known.</p>
<p>If <code>totalLength</code> is provided, it is coerced to an unsigned integer. If the
combined length of the <code>Buffer</code>s in <code>list</code> exceeds <code>totalLength</code>, the result is
truncated to <code>totalLength</code>.</p>
<pre><code class="language-js">// Create a single `Buffer` from a list of three `Buffer` instances.

const buf1 = Buffer.alloc(10);
const buf2 = Buffer.alloc(14);
const buf3 = Buffer.alloc(18);
const totalLength = buf1.length + buf2.length + buf3.length;

console.log(totalLength);
// Prints: 42

const bufA = Buffer.concat([buf1, buf2, buf3], totalLength);

console.log(bufA);
// Prints: &#x3C;Buffer 00 00 00 00 ...>
console.log(bufA.length);
// Prints: 42
</code></pre>
<h3>Class Method: Buffer.from(array)<a class="srclink" href="https://github.com/nodejs/node/blob/1a96d83a223ff9f05f7d942fb84440d323f7b596/lib/buffer.js#L199">[src]</a><span><a class="mark" href="#buffer_class_method_buffer_from_array" id="buffer_class_method_buffer_from_array">#</a></span></h3>
<div class="api_metadata">
<span>Added in: v5.10.0</span>
</div>
<ul>
<li><code>array</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type">&#x3C;integer[]></a></li>
</ul>
<p>Allocates a new <code>Buffer</code> using an <code>array</code> of octets.</p>
<pre><code class="language-js">// Creates a new Buffer containing UTF-8 bytes of the string 'buffer'
const buf = Buffer.from([0x62, 0x75, 0x66, 0x66, 0x65, 0x72]);
</code></pre>
<p>A <code>TypeError</code> will be thrown if <code>array</code> is not an <code>Array</code>.</p>
<h3>Class Method: Buffer.from(arrayBuffer[, byteOffset[, length]])<a class="srclink" href="https://github.com/nodejs/node/blob/1a96d83a223ff9f05f7d942fb84440d323f7b596/lib/buffer.js#L199">[src]</a><span><a class="mark" href="#buffer_class_method_buffer_from_arraybuffer_byteoffset_length" id="buffer_class_method_buffer_from_arraybuffer_byteoffset_length">#</a></span></h3>
<div class="api_metadata">
<span>Added in: v5.10.0</span>
</div>
<ul>
<li><code>arrayBuffer</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer" class="type">&#x3C;ArrayBuffer></a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer" class="type">&#x3C;SharedArrayBuffer></a> An <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer"><code>ArrayBuffer</code></a>,
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer"><code>SharedArrayBuffer</code></a>, or the <code>.buffer</code> property of a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray"><code>TypedArray</code></a>.</li>
<li><code>byteOffset</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type">&#x3C;integer></a> Index of first byte to expose. <strong>Default:</strong> <code>0</code>.</li>
<li><code>length</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type">&#x3C;integer></a> Number of bytes to expose.
<strong>Default:</strong> <code>arrayBuffer.length - byteOffset</code>.</li>
</ul>
<p>This creates a view of the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer"><code>ArrayBuffer</code></a> without copying the underlying
memory. For example, when passed a reference to the <code>.buffer</code> property of a
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray"><code>TypedArray</code></a> instance, the newly created <code>Buffer</code> will share the same
allocated memory as the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray"><code>TypedArray</code></a>.</p>
<pre><code class="language-js">const arr = new Uint16Array(2);

arr[0] = 5000;
arr[1] = 4000;

// Shares memory with `arr`
const buf = Buffer.from(arr.buffer);

console.log(buf);
// Prints: &#x3C;Buffer 88 13 a0 0f>

// Changing the original Uint16Array changes the Buffer also
arr[1] = 6000;

console.log(buf);
// Prints: &#x3C;Buffer 88 13 70 17>
</code></pre>
<p>The optional <code>byteOffset</code> and <code>length</code> arguments specify a memory range within
the <code>arrayBuffer</code> that will be shared by the <code>Buffer</code>.</p>
<pre><code class="language-js">const ab = new ArrayBuffer(10);
const buf = Buffer.from(ab, 0, 2);

console.log(buf.length);
// Prints: 2
</code></pre>
<p>A <code>TypeError</code> will be thrown if <code>arrayBuffer</code> is not an <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer"><code>ArrayBuffer</code></a> or a
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer"><code>SharedArrayBuffer</code></a>.</p>
<h3>Class Method: Buffer.from(buffer)<a class="srclink" href="https://github.com/nodejs/node/blob/1a96d83a223ff9f05f7d942fb84440d323f7b596/lib/buffer.js#L199">[src]</a><span><a class="mark" href="#buffer_class_method_buffer_from_buffer" id="buffer_class_method_buffer_from_buffer">#</a></span></h3>
<div class="api_metadata">
<span>Added in: v5.10.0</span>
</div>
<ul>
<li><code>buffer</code> <a href="buffer.html#buffer_class_buffer" class="type">&#x3C;Buffer></a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array" class="type">&#x3C;Uint8Array></a> An existing <code>Buffer</code> or <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array"><code>Uint8Array</code></a> from which
to copy data.</li>
</ul>
<p>Copies the passed <code>buffer</code> data onto a new <code>Buffer</code> instance.</p>
<pre><code class="language-js">const buf1 = Buffer.from('buffer');
const buf2 = Buffer.from(buf1);

buf1[0] = 0x61;

console.log(buf1.toString());
// Prints: auffer
console.log(buf2.toString());
// Prints: buffer
</code></pre>
<p>A <code>TypeError</code> will be thrown if <code>buffer</code> is not a <code>Buffer</code>.</p>
<h3>Class Method: Buffer.from(string[, encoding])<a class="srclink" href="https://github.com/nodejs/node/blob/1a96d83a223ff9f05f7d942fb84440d323f7b596/lib/buffer.js#L199">[src]</a><span><a class="mark" href="#buffer_class_method_buffer_from_string_encoding" id="buffer_class_method_buffer_from_string_encoding">#</a></span></h3>
<div class="api_metadata">
<span>Added in: v5.10.0</span>
</div>
<ul>
<li><code>string</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" class="type">&#x3C;string></a> A string to encode.</li>
<li><code>encoding</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" class="type">&#x3C;string></a> The encoding of <code>string</code>. <strong>Default:</strong> <code>'utf8'</code>.</li>
</ul>
<p>Creates a new <code>Buffer</code> containing <code>string</code>. The <code>encoding</code> parameter identifies
the character encoding of <code>string</code>.</p>
<pre><code class="language-js">const buf1 = Buffer.from('this is a tést');
const buf2 = Buffer.from('7468697320697320612074c3a97374', 'hex');

console.log(buf1.toString());
// Prints: this is a tést
console.log(buf2.toString());
// Prints: this is a tést
console.log(buf1.toString('ascii'));
// Prints: this is a tC)st
</code></pre>
<p>A <code>TypeError</code> will be thrown if <code>string</code> is not a string.</p>
<h3>Class Method: Buffer.from(object[, offsetOrEncoding[, length]])<a class="srclink" href="https://github.com/nodejs/node/blob/1a96d83a223ff9f05f7d942fb84440d323f7b596/lib/buffer.js#L199">[src]</a><span><a class="mark" href="#buffer_class_method_buffer_from_object_offsetorencoding_length" id="buffer_class_method_buffer_from_object_offsetorencoding_length">#</a></span></h3>
<div class="api_metadata">
<span>Added in: v8.2.0</span>
</div>
<ul>
<li><code>object</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" class="type">&#x3C;Object></a> An object supporting <code>Symbol.toPrimitive</code> or <code>valueOf()</code></li>
<li><code>offsetOrEncoding</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type">&#x3C;number></a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" class="type">&#x3C;string></a> A byte-offset or encoding, depending on
the value returned either by <code>object.valueOf()</code> or
<code>object[Symbol.toPrimitive]()</code>.</li>
<li><code>length</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type">&#x3C;number></a> A length, depending on the value returned either by
<code>object.valueOf()</code> or <code>object[Symbol.toPrimitive]()</code>.</li>
</ul>
<p>For objects whose <code>valueOf()</code> function returns a value not strictly equal to
<code>object</code>, returns <code>Buffer.from(object.valueOf(), offsetOrEncoding, length)</code>.</p>
<pre><code class="language-js">const buf = Buffer.from(new String('this is a test'));
// Prints: &#x3C;Buffer 74 68 69 73 20 69 73 20 61 20 74 65 73 74>
</code></pre>
<p>For objects that support <code>Symbol.toPrimitive</code>, returns
<code>Buffer.from(object[Symbol.toPrimitive](), offsetOrEncoding, length)</code>.</p>
<pre><code class="language-js">class Foo {
  [Symbol.toPrimitive]() {
    return 'this is a test';
  }
}

const buf = Buffer.from(new Foo(), 'utf8');
// Prints: &#x3C;Buffer 74 68 69 73 20 69 73 20 61 20 74 65 73 74>
</code></pre>
<h3>Class Method: Buffer.isBuffer(obj)<a class="srclink" href="https://github.com/nodejs/node/blob/1a96d83a223ff9f05f7d942fb84440d323f7b596/lib/buffer.js#L429">[src]</a><span><a class="mark" href="#buffer_class_method_buffer_isbuffer_obj" id="buffer_class_method_buffer_isbuffer_obj">#</a></span></h3>
<div class="api_metadata">
<span>Added in: v0.1.101</span>
</div>
<ul>
<li><code>obj</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" class="type">&#x3C;Object></a></li>
<li>Returns: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" class="type">&#x3C;boolean></a></li>
</ul>
<p>Returns <code>true</code> if <code>obj</code> is a <code>Buffer</code>, <code>false</code> otherwise.</p>
<h3>Class Method: Buffer.isEncoding(encoding)<a class="srclink" href="https://github.com/nodejs/node/blob/1a96d83a223ff9f05f7d942fb84440d323f7b596/lib/buffer.js#L449">[src]</a><span><a class="mark" href="#buffer_class_method_buffer_isencoding_encoding" id="buffer_class_method_buffer_isencoding_encoding">#</a></span></h3>
<div class="api_metadata">
<span>Added in: v0.9.1</span>
</div>
<ul>
<li><code>encoding</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" class="type">&#x3C;string></a> A character encoding name to check.</li>
<li>Returns: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" class="type">&#x3C;boolean></a></li>
</ul>
<p>Returns <code>true</code> if <code>encoding</code> contains a supported character encoding, or <code>false</code>
otherwise.</p>
<h3>Class Property: Buffer.poolSize<a class="srclink" href="https://github.com/nodejs/node/blob/1a96d83a223ff9f05f7d942fb84440d323f7b596/lib/buffer.js#L102">[src]</a><span><a class="mark" href="#buffer_class_property_buffer_poolsize" id="buffer_class_property_buffer_poolsize">#</a></span></h3>
<div class="api_metadata">
<span>Added in: v0.11.3</span>
</div>
<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type">&#x3C;integer></a> <strong>Default:</strong> <code>8192</code></li>
</ul>
<p>This is the size (in bytes) of pre-allocated internal <code>Buffer</code> instances used
for pooling. This value may be modified.</p>
<h3>buf[index]<span><a class="mark" href="#buffer_buf_index" id="buffer_buf_index">#</a></span></h3>
<div class="api_metadata">

</div>
<p>The index operator <code>[index]</code> can be used to get and set the octet at position
<code>index</code> in <code>buf</code>. The values refer to individual bytes, so the legal value
range is between <code>0x00</code> and <code>0xFF</code> (hex) or <code>0</code> and <code>255</code> (decimal).</p>
<p>This operator is inherited from <code>Uint8Array</code>, so its behavior on out-of-bounds
access is the same as <code>UInt8Array</code> - that is, getting returns <code>undefined</code> and
setting does nothing.</p>
<pre><code class="language-js">// Copy an ASCII string into a `Buffer` one byte at a time.

const str = 'Node.js';
const buf = Buffer.allocUnsafe(str.length);

for (let i = 0; i &#x3C; str.length; i++) {
  buf[i] = str.charCodeAt(i);
}

console.log(buf.toString('ascii'));
// Prints: Node.js
</code></pre>
<h3>buf.buffer<span><a class="mark" href="#buffer_buf_buffer" id="buffer_buf_buffer">#</a></span></h3>
<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer" class="type">&#x3C;ArrayBuffer></a> The underlying <code>ArrayBuffer</code> object based on
which this <code>Buffer</code> object is created.</li>
</ul>
<pre><code class="language-js">const arrayBuffer = new ArrayBuffer(16);
const buffer = Buffer.from(arrayBuffer);

console.log(buffer.buffer === arrayBuffer);
// Prints: true
</code></pre>
<h3>buf.byteOffset<span><a class="mark" href="#buffer_buf_byteoffset" id="buffer_buf_byteoffset">#</a></span></h3>
<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type">&#x3C;integer></a> The <code>byteOffset</code> on the underlying <code>ArrayBuffer</code> object based on
which this <code>Buffer</code> object is created.</li>
</ul>
<p>When setting <code>byteOffset</code> in <code>Buffer.from(ArrayBuffer, byteOffset, length)</code>
or sometimes when allocating a buffer smaller than <code>Buffer.poolSize</code> the
buffer doesn't start from a zero offset on the underlying <code>ArrayBuffer</code>.</p>
<p>This can cause problems when accessing the underlying <code>ArrayBuffer</code> directly
using <code>buf.buffer</code>, as the first bytes in this <code>ArrayBuffer</code> may be unrelated
to the <code>buf</code> object itself.</p>
<p>A common issue is when casting a <code>Buffer</code> object to a <code>TypedArray</code> object,
in this case one needs to specify the <code>byteOffset</code> correctly:</p>
<pre><code class="language-js">// Create a buffer smaller than `Buffer.poolSize`.
const nodeBuffer = new Buffer.from([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]);

// When casting the Node.js Buffer to an Int8 TypedArray remember to use the
// byteOffset.
new Int8Array(nodeBuffer.buffer, nodeBuffer.byteOffset, nodeBuffer.length);
</code></pre>
<h3>buf.compare(target[, targetStart[, targetEnd[, sourceStart[, sourceEnd]]]])<a class="srclink" href="https://github.com/nodejs/node/blob/1a96d83a223ff9f05f7d942fb84440d323f7b596/lib/buffer.js#L692">[src]</a><span><a class="mark" href="#buffer_buf_compare_target_targetstart_targetend_sourcestart_sourceend" id="buffer_buf_compare_target_targetstart_targetend_sourcestart_sourceend">#</a></span></h3>
<div class="api_metadata">
<details class="changelog"><summary>History</summary>
<table>
<tbody><tr><th>Version</th><th>Changes</th></tr>
<tr><td>v8.0.0</td>
<td><p>The <code>target</code> parameter can now be a <code>Uint8Array</code>.</p></td></tr>
<tr><td>v5.11.0</td>
<td><p>Additional parameters for specifying offsets are supported now.</p></td></tr>
<tr><td>v0.11.13</td>
<td><p><span>Added in: v0.11.13</span></p></td></tr>
</tbody></table>
</details>
</div>
<ul>
<li><code>target</code> <a href="buffer.html#buffer_class_buffer" class="type">&#x3C;Buffer></a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array" class="type">&#x3C;Uint8Array></a> A <code>Buffer</code> or <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array"><code>Uint8Array</code></a> with which to
compare <code>buf</code>.</li>
<li><code>targetStart</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type">&#x3C;integer></a> The offset within <code>target</code> at which to begin
comparison. <strong>Default:</strong> <code>0</code>.</li>
<li><code>targetEnd</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type">&#x3C;integer></a> The offset with <code>target</code> at which to end comparison
(not inclusive). <strong>Default:</strong> <code>target.length</code>.</li>
<li><code>sourceStart</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type">&#x3C;integer></a> The offset within <code>buf</code> at which to begin comparison.
<strong>Default:</strong> <code>0</code>.</li>
<li><code>sourceEnd</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type">&#x3C;integer></a> The offset within <code>buf</code> at which to end comparison
(not inclusive). <strong>Default:</strong> <a href="#buffer_buf_length"><code>buf.length</code></a>.</li>
<li>Returns: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type">&#x3C;integer></a></li>
</ul>
<p>Compares <code>buf</code> with <code>target</code> and returns a number indicating whether <code>buf</code>
comes before, after, or is the same as <code>target</code> in sort order.
Comparison is based on the actual sequence of bytes in each <code>Buffer</code>.</p>
<ul>
<li><code>0</code> is returned if <code>target</code> is the same as <code>buf</code></li>
<li><code>1</code> is returned if <code>target</code> should come <em>before</em> <code>buf</code> when sorted.</li>
<li><code>-1</code> is returned if <code>target</code> should come <em>after</em> <code>buf</code> when sorted.</li>
</ul>
<pre><code class="language-js">const buf1 = Buffer.from('ABC');
const buf2 = Buffer.from('BCD');
const buf3 = Buffer.from('ABCD');

console.log(buf1.compare(buf1));
// Prints: 0
console.log(buf1.compare(buf2));
// Prints: -1
console.log(buf1.compare(buf3));
// Prints: -1
console.log(buf2.compare(buf1));
// Prints: 1
console.log(buf2.compare(buf3));
// Prints: 1
console.log([buf1, buf2, buf3].sort(Buffer.compare));
// Prints: [ &#x3C;Buffer 41 42 43>, &#x3C;Buffer 41 42 43 44>, &#x3C;Buffer 42 43 44> ]
// (This result is equal to: [buf1, buf3, buf2])
</code></pre>
<p>The optional <code>targetStart</code>, <code>targetEnd</code>, <code>sourceStart</code>, and <code>sourceEnd</code>
arguments can be used to limit the comparison to specific ranges within <code>target</code>
and <code>buf</code> respectively.</p>
<pre><code class="language-js">const buf1 = Buffer.from([1, 2, 3, 4, 5, 6, 7, 8, 9]);
const buf2 = Buffer.from([5, 6, 7, 8, 9, 1, 2, 3, 4]);

console.log(buf1.compare(buf2, 5, 9, 0, 4));
// Prints: 0
console.log(buf1.compare(buf2, 0, 6, 4));
// Prints: -1
console.log(buf1.compare(buf2, 5, 6, 5));
// Prints: 1
</code></pre>
<p><a href="errors.html#ERR_INDEX_OUT_OF_RANGE"><code>ERR_INDEX_OUT_OF_RANGE</code></a> is thrown if <code>targetStart &#x3C; 0</code>, <code>sourceStart &#x3C; 0</code>,
<code>targetEnd > target.byteLength</code>, or <code>sourceEnd > source.byteLength</code>.</p>
<h3>buf.copy(target[, targetStart[, sourceStart[, sourceEnd]]])<a class="srclink" href="https://github.com/nodejs/node/blob/1a96d83a223ff9f05f7d942fb84440d323f7b596/lib/buffer.js#L634">[src]</a><span><a class="mark" href="#buffer_buf_copy_target_targetstart_sourcestart_sourceend" id="buffer_buf_copy_target_targetstart_sourcestart_sourceend">#</a></span></h3>
<div class="api_metadata">
<span>Added in: v0.1.90</span>
</div>
<ul>
<li><code>target</code> <a href="buffer.html#buffer_class_buffer" class="type">&#x3C;Buffer></a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array" class="type">&#x3C;Uint8Array></a> A <code>Buffer</code> or <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array"><code>Uint8Array</code></a> to copy into.</li>
<li><code>targetStart</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type">&#x3C;integer></a> The offset within <code>target</code> at which to begin
writing. <strong>Default:</strong> <code>0</code>.</li>
<li><code>sourceStart</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type">&#x3C;integer></a> The offset within <code>buf</code> from which to begin copying.
<strong>Default:</strong> <code>0</code>.</li>
<li><code>sourceEnd</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type">&#x3C;integer></a> The offset within <code>buf</code> at which to stop copying (not
inclusive). <strong>Default:</strong> <a href="#buffer_buf_length"><code>buf.length</code></a>.</li>
<li>Returns: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type">&#x3C;integer></a> The number of bytes copied.</li>
</ul>
<p>Copies data from a region of <code>buf</code> to a region in <code>target</code> even if the <code>target</code>
memory region overlaps with <code>buf</code>.</p>
<pre><code class="language-js">// Create two `Buffer` instances.
const buf1 = Buffer.allocUnsafe(26);
const buf2 = Buffer.allocUnsafe(26).fill('!');

for (let i = 0; i &#x3C; 26; i++) {
  // 97 is the decimal ASCII value for 'a'
  buf1[i] = i + 97;
}

// Copy `buf1` bytes 16 through 19 into `buf2` starting at byte 8 of `buf2`
buf1.copy(buf2, 8, 16, 20);

console.log(buf2.toString('ascii', 0, 25));
// Prints: !!!!!!!!qrst!!!!!!!!!!!!!
</code></pre>
<pre><code class="language-js">// Create a `Buffer` and copy data from one region to an overlapping region
// within the same `Buffer`.

const buf = Buffer.allocUnsafe(26);

for (let i = 0; i &#x3C; 26; i++) {
  // 97 is the decimal ASCII value for 'a'
  buf[i] = i + 97;
}

buf.copy(buf, 0, 4, 10);

console.log(buf.toString());
// Prints: efghijghijklmnopqrstuvwxyz
</code></pre>
<h3>buf.entries()<span><a class="mark" href="#buffer_buf_entries" id="buffer_buf_entries">#</a></span></h3>
<div class="api_metadata">
<span>Added in: v1.1.0</span>
</div>
<ul>
<li>Returns: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#The_iterator_protocol" class="type">&#x3C;Iterator></a></li>
</ul>
<p>Creates and returns an <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols">iterator</a> of <code>[index, byte]</code> pairs from the contents of
<code>buf</code>.</p>
<pre><code class="language-js">// Log the entire contents of a `Buffer`.

const buf = Buffer.from('buffer');

for (const pair of buf.entries()) {
  console.log(pair);
}
// Prints:
//   [0, 98]
//   [1, 117]
//   [2, 102]
//   [3, 102]
//   [4, 101]
//   [5, 114]
</code></pre>
<h3>buf.equals(otherBuffer)<a class="srclink" href="https://github.com/nodejs/node/blob/1a96d83a223ff9f05f7d942fb84440d323f7b596/lib/buffer.js#L670">[src]</a><span><a class="mark" href="#buffer_buf_equals_otherbuffer" id="buffer_buf_equals_otherbuffer">#</a></span></h3>
<div class="api_metadata">
<details class="changelog"><summary>History</summary>
<table>
<tbody><tr><th>Version</th><th>Changes</th></tr>
<tr><td>v8.0.0</td>
<td><p>The arguments can now be <code>Uint8Array</code>s.</p></td></tr>
<tr><td>v0.11.13</td>
<td><p><span>Added in: v0.11.13</span></p></td></tr>
</tbody></table>
</details>
</div>
<ul>
<li><code>otherBuffer</code> <a href="buffer.html#buffer_class_buffer" class="type">&#x3C;Buffer></a> A <code>Buffer</code> or <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array"><code>Uint8Array</code></a> with which to compare
<code>buf</code>.</li>
<li>Returns: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" class="type">&#x3C;boolean></a></li>
</ul>
<p>Returns <code>true</code> if both <code>buf</code> and <code>otherBuffer</code> have exactly the same bytes,
<code>false</code> otherwise.</p>
<pre><code class="language-js">const buf1 = Buffer.from('ABC');
const buf2 = Buffer.from('414243', 'hex');
const buf3 = Buffer.from('ABCD');

console.log(buf1.equals(buf2));
// Prints: true
console.log(buf1.equals(buf3));
// Prints: false
</code></pre>
<h3>buf.fill(value[, offset[, end]][, encoding])<a class="srclink" href="https://github.com/nodejs/node/blob/1a96d83a223ff9f05f7d942fb84440d323f7b596/lib/buffer.js#L828">[src]</a><span><a class="mark" href="#buffer_buf_fill_value_offset_end_encoding" id="buffer_buf_fill_value_offset_end_encoding">#</a></span></h3>
<div class="api_metadata">
<details class="changelog"><summary>History</summary>
<table>
<tbody><tr><th>Version</th><th>Changes</th></tr>
<tr><td>v10.0.0</td>
<td><p>Negative <code>end</code> values throw an <code>ERR_INDEX_OUT_OF_RANGE</code> error.</p></td></tr>
<tr><td>v10.0.0</td>
<td><p>Attempting to fill a non-zero length buffer with a zero length buffer triggers a thrown exception.</p></td></tr>
<tr><td>v10.0.0</td>
<td><p>Specifying an invalid string for <code>value</code> triggers a thrown exception.</p></td></tr>
<tr><td>v5.7.0</td>
<td><p>The <code>encoding</code> parameter is supported now.</p></td></tr>
<tr><td>v0.5.0</td>
<td><p><span>Added in: v0.5.0</span></p></td></tr>
</tbody></table>
</details>
</div>
<ul>
<li><code>value</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" class="type">&#x3C;string></a> | <a href="buffer.html#buffer_class_buffer" class="type">&#x3C;Buffer></a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type">&#x3C;integer></a> The value with which to fill <code>buf</code>.</li>
<li><code>offset</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type">&#x3C;integer></a> Number of bytes to skip before starting to fill <code>buf</code>.
<strong>Default:</strong> <code>0</code>.</li>
<li><code>end</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type">&#x3C;integer></a> Where to stop filling <code>buf</code> (not inclusive). <strong>Default:</strong>
<a href="#buffer_buf_length"><code>buf.length</code></a>.</li>
<li><code>encoding</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" class="type">&#x3C;string></a> The encoding for <code>value</code> if <code>value</code> is a string.
<strong>Default:</strong> <code>'utf8'</code>.</li>
<li>Returns: <a href="buffer.html#buffer_class_buffer" class="type">&#x3C;Buffer></a> A reference to <code>buf</code>.</li>
</ul>
<p>Fills <code>buf</code> with the specified <code>value</code>. If the <code>offset</code> and <code>end</code> are not given,
the entire <code>buf</code> will be filled:</p>
<pre><code class="language-js">// Fill a `Buffer` with the ASCII character 'h'.

const b = Buffer.allocUnsafe(50).fill('h');

console.log(b.toString());
// Prints: hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh
</code></pre>
<p><code>value</code> is coerced to a <code>uint32</code> value if it is not a string or integer.</p>
<p>If the final write of a <code>fill()</code> operation falls on a multi-byte character,
then only the bytes of that character that fit into <code>buf</code> are written:</p>
<pre><code class="language-js">// Fill a `Buffer` with a two-byte character.

console.log(Buffer.allocUnsafe(3).fill('\u0222'));
// Prints: &#x3C;Buffer c8 a2 c8>
</code></pre>
<p>If <code>value</code> contains invalid characters, it is truncated; if no valid
fill data remains, an exception is thrown:</p>
<pre><code class="language-js">const buf = Buffer.allocUnsafe(5);

console.log(buf.fill('a'));
// Prints: &#x3C;Buffer 61 61 61 61 61>
console.log(buf.fill('aazz', 'hex'));
// Prints: &#x3C;Buffer aa aa aa aa aa>
console.log(buf.fill('zz', 'hex'));
// Throws an exception.
</code></pre>
<h3>buf.includes(value[, byteOffset][, encoding])<a class="srclink" href="https://github.com/nodejs/node/blob/1a96d83a223ff9f05f7d942fb84440d323f7b596/lib/buffer.js#L820">[src]</a><span><a class="mark" href="#buffer_buf_includes_value_byteoffset_encoding" id="buffer_buf_includes_value_byteoffset_encoding">#</a></span></h3>
<div class="api_metadata">
<span>Added in: v5.3.0</span>
</div>
<ul>
<li><code>value</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" class="type">&#x3C;string></a> | <a href="buffer.html#buffer_class_buffer" class="type">&#x3C;Buffer></a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type">&#x3C;integer></a> What to search for.</li>
<li><code>byteOffset</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type">&#x3C;integer></a> Where to begin searching in <code>buf</code>. <strong>Default:</strong> <code>0</code>.</li>
<li><code>encoding</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" class="type">&#x3C;string></a> If <code>value</code> is a string, this is its encoding.
<strong>Default:</strong> <code>'utf8'</code>.</li>
<li>Returns: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" class="type">&#x3C;boolean></a> <code>true</code> if <code>value</code> was found in <code>buf</code>, <code>false</code> otherwise.</li>
</ul>
<p>Equivalent to <a href="#buffer_buf_indexof_value_byteoffset_encoding"><code>buf.indexOf() !== -1</code></a>.</p>
<pre><code class="language-js">const buf = Buffer.from('this is a buffer');

console.log(buf.includes('this'));
// Prints: true
console.log(buf.includes('is'));
// Prints: true
console.log(buf.includes(Buffer.from('a buffer')));
// Prints: true
console.log(buf.includes(97));
// Prints: true (97 is the decimal ASCII value for 'a')
console.log(buf.includes(Buffer.from('a buffer example')));
// Prints: false
console.log(buf.includes(Buffer.from('a buffer example').slice(0, 8)));
// Prints: true
console.log(buf.includes('this', 4));
// Prints: false
</code></pre>
<h3>buf.indexOf(value[, byteOffset][, encoding])<a class="srclink" href="https://github.com/nodejs/node/blob/1a96d83a223ff9f05f7d942fb84440d323f7b596/lib/buffer.js#L812">[src]</a><span><a class="mark" href="#buffer_buf_indexof_value_byteoffset_encoding" id="buffer_buf_indexof_value_byteoffset_encoding">#</a></span></h3>
<div class="api_metadata">
<details class="changelog"><summary>History</summary>
<table>
<tbody><tr><th>Version</th><th>Changes</th></tr>
<tr><td>v8.0.0</td>
<td><p>The <code>value</code> can now be a <code>Uint8Array</code>.</p></td></tr>
<tr><td>v5.7.0, v4.4.0</td>
<td><p>When <code>encoding</code> is being passed, the <code>byteOffset</code> parameter is no longer required.</p></td></tr>
<tr><td>v1.5.0</td>
<td><p><span>Added in: v1.5.0</span></p></td></tr>
</tbody></table>
</details>
</div>
<ul>
<li><code>value</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" class="type">&#x3C;string></a> | <a href="buffer.html#buffer_class_buffer" class="type">&#x3C;Buffer></a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array" class="type">&#x3C;Uint8Array></a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type">&#x3C;integer></a> What to search for.</li>
<li><code>byteOffset</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type">&#x3C;integer></a> Where to begin searching in <code>buf</code>. <strong>Default:</strong> <code>0</code>.</li>
<li><code>encoding</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" class="type">&#x3C;string></a> If <code>value</code> is a string, this is the encoding used to
determine the binary representation of the string that will be searched for in
<code>buf</code>. <strong>Default:</strong> <code>'utf8'</code>.</li>
<li>Returns: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type">&#x3C;integer></a> The index of the first occurrence of <code>value</code> in <code>buf</code>, or
<code>-1</code> if <code>buf</code> does not contain <code>value</code>.</li>
</ul>
<p>If <code>value</code> is:</p>
<ul>
<li>a string, <code>value</code> is interpreted according to the character encoding in
<code>encoding</code>.</li>
<li>a <code>Buffer</code> or <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array"><code>Uint8Array</code></a>, <code>value</code> will be used in its entirety.
To compare a partial <code>Buffer</code>, use <a href="#buffer_buf_slice_start_end"><code>buf.slice()</code></a>.</li>
<li>a number, <code>value</code> will be interpreted as an unsigned 8-bit integer
value between <code>0</code> and <code>255</code>.</li>
</ul>
<pre><code class="language-js">const buf = Buffer.from('this is a buffer');

console.log(buf.indexOf('this'));
// Prints: 0
console.log(buf.indexOf('is'));
// Prints: 2
console.log(buf.indexOf(Buffer.from('a buffer')));
// Prints: 8
console.log(buf.indexOf(97));
// Prints: 8 (97 is the decimal ASCII value for 'a')
console.log(buf.indexOf(Buffer.from('a buffer example')));
// Prints: -1
console.log(buf.indexOf(Buffer.from('a buffer example').slice(0, 8)));
// Prints: 8

const utf16Buffer = Buffer.from('\u039a\u0391\u03a3\u03a3\u0395', 'utf16le');

console.log(utf16Buffer.indexOf('\u03a3', 0, 'utf16le'));
// Prints: 4
console.log(utf16Buffer.indexOf('\u03a3', -4, 'utf16le'));
// Prints: 6
</code></pre>
<p>If <code>value</code> is not a string, number, or <code>Buffer</code>, this method will throw a
<code>TypeError</code>. If <code>value</code> is a number, it will be coerced to a valid byte value,
an integer between 0 and 255.</p>
<p>If <code>byteOffset</code> is not a number, it will be coerced to a number. If the result
of coercion is <code>NaN</code> or <code>0</code>, then the entire buffer will be searched. This
behavior matches <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/indexOf"><code>String#indexOf()</code></a>.</p>
<pre><code class="language-js">const b = Buffer.from('abcdef');

// Passing a value that's a number, but not a valid byte
// Prints: 2, equivalent to searching for 99 or 'c'
console.log(b.indexOf(99.9));
console.log(b.indexOf(256 + 99));

// Passing a byteOffset that coerces to NaN or 0
// Prints: 1, searching the whole buffer
console.log(b.indexOf('b', undefined));
console.log(b.indexOf('b', {}));
console.log(b.indexOf('b', null));
console.log(b.indexOf('b', []));
</code></pre>
<p>If <code>value</code> is an empty string or empty <code>Buffer</code> and <code>byteOffset</code> is less
than <code>buf.length</code>, <code>byteOffset</code> will be returned. If <code>value</code> is empty and
<code>byteOffset</code> is at least <code>buf.length</code>, <code>buf.length</code> will be returned.</p>
<h3>buf.keys()<span><a class="mark" href="#buffer_buf_keys" id="buffer_buf_keys">#</a></span></h3>
<div class="api_metadata">
<span>Added in: v1.1.0</span>
</div>
<ul>
<li>Returns: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#The_iterator_protocol" class="type">&#x3C;Iterator></a></li>
</ul>
<p>Creates and returns an <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols">iterator</a> of <code>buf</code> keys (indices).</p>
<pre><code class="language-js">const buf = Buffer.from('buffer');

for (const key of buf.keys()) {
  console.log(key);
}
// Prints:
//   0
//   1
//   2
//   3
//   4
//   5
</code></pre>
<h3>buf.lastIndexOf(value[, byteOffset][, encoding])<a class="srclink" href="https://github.com/nodejs/node/blob/1a96d83a223ff9f05f7d942fb84440d323f7b596/lib/buffer.js#L816">[src]</a><span><a class="mark" href="#buffer_buf_lastindexof_value_byteoffset_encoding" id="buffer_buf_lastindexof_value_byteoffset_encoding">#</a></span></h3>
<div class="api_metadata">
<details class="changelog"><summary>History</summary>
<table>
<tbody><tr><th>Version</th><th>Changes</th></tr>
<tr><td>v8.0.0</td>
<td><p>The <code>value</code> can now be a <code>Uint8Array</code>.</p></td></tr>
<tr><td>v6.0.0</td>
<td><p><span>Added in: v6.0.0</span></p></td></tr>
</tbody></table>
</details>
</div>
<ul>
<li><code>value</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" class="type">&#x3C;string></a> | <a href="buffer.html#buffer_class_buffer" class="type">&#x3C;Buffer></a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array" class="type">&#x3C;Uint8Array></a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type">&#x3C;integer></a> What to search for.</li>
<li><code>byteOffset</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type">&#x3C;integer></a> Where to begin searching in <code>buf</code>.
<strong>Default:</strong> <a href="#buffer_buf_length"><code>buf.length</code></a><code>- 1</code>.</li>
<li><code>encoding</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" class="type">&#x3C;string></a> If <code>value</code> is a string, this is the encoding used to
determine the binary representation of the string that will be searched for in
<code>buf</code>. <strong>Default:</strong> <code>'utf8'</code>.</li>
<li>Returns: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type">&#x3C;integer></a> The index of the last occurrence of <code>value</code> in <code>buf</code>, or
<code>-1</code> if <code>buf</code> does not contain <code>value</code>.</li>
</ul>
<p>Identical to <a href="#buffer_buf_indexof_value_byteoffset_encoding"><code>buf.indexOf()</code></a>, except the last occurrence of <code>value</code> is found
rather than the first occurrence.</p>
<pre><code class="language-js">const buf = Buffer.from('this buffer is a buffer');

console.log(buf.lastIndexOf('this'));
// Prints: 0
console.log(buf.lastIndexOf('buffer'));
// Prints: 17
console.log(buf.lastIndexOf(Buffer.from('buffer')));
// Prints: 17
console.log(buf.lastIndexOf(97));
// Prints: 15 (97 is the decimal ASCII value for 'a')
console.log(buf.lastIndexOf(Buffer.from('yolo')));
// Prints: -1
console.log(buf.lastIndexOf('buffer', 5));
// Prints: 5
console.log(buf.lastIndexOf('buffer', 4));
// Prints: -1

const utf16Buffer = Buffer.from('\u039a\u0391\u03a3\u03a3\u0395', 'utf16le');

console.log(utf16Buffer.lastIndexOf('\u03a3', undefined, 'utf16le'));
// Prints: 6
console.log(utf16Buffer.lastIndexOf('\u03a3', -5, 'utf16le'));
// Prints: 4
</code></pre>
<p>If <code>value</code> is not a string, number, or <code>Buffer</code>, this method will throw a
<code>TypeError</code>. If <code>value</code> is a number, it will be coerced to a valid byte value,
an integer between 0 and 255.</p>
<p>If <code>byteOffset</code> is not a number, it will be coerced to a number. Any arguments
that coerce to <code>NaN</code>, like <code>{}</code> or <code>undefined</code>, will search the whole buffer.
This behavior matches <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/lastIndexOf"><code>String#lastIndexOf()</code></a>.</p>
<pre><code class="language-js">const b = Buffer.from('abcdef');

// Passing a value that's a number, but not a valid byte
// Prints: 2, equivalent to searching for 99 or 'c'
console.log(b.lastIndexOf(99.9));
console.log(b.lastIndexOf(256 + 99));

// Passing a byteOffset that coerces to NaN
// Prints: 1, searching the whole buffer
console.log(b.lastIndexOf('b', undefined));
console.log(b.lastIndexOf('b', {}));

// Passing a byteOffset that coerces to 0
// Prints: -1, equivalent to passing 0
console.log(b.lastIndexOf('b', null));
console.log(b.lastIndexOf('b', []));
</code></pre>
<p>If <code>value</code> is an empty string or empty <code>Buffer</code>, <code>byteOffset</code> will be returned.</p>
<h3>buf.length<span><a class="mark" href="#buffer_buf_length" id="buffer_buf_length">#</a></span></h3>
<div class="api_metadata">
<span>Added in: v0.1.90</span>
</div>
<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type">&#x3C;integer></a></li>
</ul>
<p>Returns the amount of memory allocated for <code>buf</code> in bytes. Note that this
does not necessarily reflect the amount of "usable" data within <code>buf</code>.</p>
<pre><code class="language-js">// Create a `Buffer` and write a shorter ASCII string to it.

const buf = Buffer.alloc(1234);

console.log(buf.length);
// Prints: 1234

buf.write('some string', 0, 'ascii');

console.log(buf.length);
// Prints: 1234
</code></pre>
<p>While the <code>length</code> property is not immutable, changing the value of <code>length</code>
can result in undefined and inconsistent behavior. Applications that wish to
modify the length of a <code>Buffer</code> should therefore treat <code>length</code> as read-only and
use <a href="#buffer_buf_slice_start_end"><code>buf.slice()</code></a> to create a new <code>Buffer</code>.</p>
<pre><code class="language-js">let buf = Buffer.allocUnsafe(10);

buf.write('abcdefghj', 0, 'ascii');

console.log(buf.length);
// Prints: 10

buf = buf.slice(0, 5);

console.log(buf.length);
// Prints: 5
</code></pre>
<h3>buf.parent<span><a class="mark" href="#buffer_buf_parent" id="buffer_buf_parent">#</a></span></h3>
<div class="api_metadata">
<span>Deprecated since: v8.0.0</span>
</div>
<p></p><div class="api_stability api_stability_0"><a href="documentation.html#documentation_stability_index">Stability: 0</a> - Deprecated: Use <a href="#buffer_buf_buffer"><code>buf.buffer</code></a> instead.</div><p></p>
<p>The <code>buf.parent</code> property is a deprecated alias for <code>buf.buffer</code>.</p>
<h3>buf.readDoubleBE(offset)<span><a class="mark" href="#buffer_buf_readdoublebe_offset" id="buffer_buf_readdoublebe_offset">#</a></span></h3>
<h3>buf.readDoubleLE(offset)<span><a class="mark" href="#buffer_buf_readdoublele_offset" id="buffer_buf_readdoublele_offset">#</a></span></h3>
<div class="api_metadata">
<details class="changelog"><summary>History</summary>
<table>
<tbody><tr><th>Version</th><th>Changes</th></tr>
<tr><td>v10.0.0</td>
<td><p>Removed <code>noAssert</code> and no implicit coercion of the offset to <code>uint32</code> anymore.</p></td></tr>
<tr><td>v0.11.15</td>
<td><p><span>Added in: v0.11.15</span></p></td></tr>
</tbody></table>
</details>
</div>
<ul>
<li><code>offset</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type">&#x3C;integer></a> Number of bytes to skip before starting to read. Must
satisfy <code>0 &#x3C;= offset &#x3C;= buf.length - 8</code>.</li>
<li>Returns: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type">&#x3C;number></a></li>
</ul>
<p>Reads a 64-bit double from <code>buf</code> at the specified <code>offset</code> with specified
endian format (<code>readDoubleBE()</code> returns big endian, <code>readDoubleLE()</code> returns
little endian).</p>
<pre><code class="language-js">const buf = Buffer.from([1, 2, 3, 4, 5, 6, 7, 8]);

console.log(buf.readDoubleBE(0));
// Prints: 8.20788039913184e-304
console.log(buf.readDoubleLE(0));
// Prints: 5.447603722011605e-270
console.log(buf.readDoubleLE(1));
// Throws ERR_OUT_OF_RANGE
</code></pre>
<h3>buf.readFloatBE(offset)<span><a class="mark" href="#buffer_buf_readfloatbe_offset" id="buffer_buf_readfloatbe_offset">#</a></span></h3>
<h3>buf.readFloatLE(offset)<span><a class="mark" href="#buffer_buf_readfloatle_offset" id="buffer_buf_readfloatle_offset">#</a></span></h3>
<div class="api_metadata">
<details class="changelog"><summary>History</summary>
<table>
<tbody><tr><th>Version</th><th>Changes</th></tr>
<tr><td>v10.0.0</td>
<td><p>Removed <code>noAssert</code> and no implicit coercion of the offset to <code>uint32</code> anymore.</p></td></tr>
<tr><td>v0.11.15</td>
<td><p><span>Added in: v0.11.15</span></p></td></tr>
</tbody></table>
</details>
</div>
<ul>
<li><code>offset</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type">&#x3C;integer></a> Number of bytes to skip before starting to read. Must
satisfy <code>0 &#x3C;= offset &#x3C;= buf.length - 4</code>.</li>
<li>Returns: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type">&#x3C;number></a></li>
</ul>
<p>Reads a 32-bit float from <code>buf</code> at the specified <code>offset</code> with specified
endian format (<code>readFloatBE()</code> returns big endian, <code>readFloatLE()</code> returns
little endian).</p>
<pre><code class="language-js">const buf = Buffer.from([1, 2, 3, 4]);

console.log(buf.readFloatBE(0));
// Prints: 2.387939260590663e-38
console.log(buf.readFloatLE(0));
// Prints: 1.539989614439558e-36
console.log(buf.readFloatLE(1));
// Throws ERR_OUT_OF_RANGE
</code></pre>
<h3>buf.readInt8(offset)<span><a class="mark" href="#buffer_buf_readint8_offset" id="buffer_buf_readint8_offset">#</a></span></h3>
<div class="api_metadata">
<details class="changelog"><summary>History</summary>
<table>
<tbody><tr><th>Version</th><th>Changes</th></tr>
<tr><td>v10.0.0</td>
<td><p>Removed <code>noAssert</code> and no implicit coercion of the offset to <code>uint32</code> anymore.</p></td></tr>
<tr><td>v0.5.0</td>
<td><p><span>Added in: v0.5.0</span></p></td></tr>
</tbody></table>
</details>
</div>
<ul>
<li><code>offset</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type">&#x3C;integer></a> Number of bytes to skip before starting to read. Must
satisfy <code>0 &#x3C;= offset &#x3C;= buf.length - 1</code>.</li>
<li>Returns: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type">&#x3C;integer></a></li>
</ul>
<p>Reads a signed 8-bit integer from <code>buf</code> at the specified <code>offset</code>.</p>
<p>Integers read from a <code>Buffer</code> are interpreted as two's complement signed values.</p>
<pre><code class="language-js">const buf = Buffer.from([-1, 5]);

console.log(buf.readInt8(0));
// Prints: -1
console.log(buf.readInt8(1));
// Prints: 5
console.log(buf.readInt8(2));
// Throws ERR_OUT_OF_RANGE
</code></pre>
<h3>buf.readInt16BE(offset)<span><a class="mark" href="#buffer_buf_readint16be_offset" id="buffer_buf_readint16be_offset">#</a></span></h3>
<h3>buf.readInt16LE(offset)<span><a class="mark" href="#buffer_buf_readint16le_offset" id="buffer_buf_readint16le_offset">#</a></span></h3>
<div class="api_metadata">
<details class="changelog"><summary>History</summary>
<table>
<tbody><tr><th>Version</th><th>Changes</th></tr>
<tr><td>v10.0.0</td>
<td><p>Removed <code>noAssert</code> and no implicit coercion of the offset to <code>uint32</code> anymore.</p></td></tr>
<tr><td>v0.5.5</td>
<td><p><span>Added in: v0.5.5</span></p></td></tr>
</tbody></table>
</details>
</div>
<ul>
<li><code>offset</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type">&#x3C;integer></a> Number of bytes to skip before starting to read. Must
satisfy <code>0 &#x3C;= offset &#x3C;= buf.length - 2</code>.</li>
<li>Returns: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type">&#x3C;integer></a></li>
</ul>
<p>Reads a signed 16-bit integer from <code>buf</code> at the specified <code>offset</code> with
the specified endian format (<code>readInt16BE()</code> returns big endian,
<code>readInt16LE()</code> returns little endian).</p>
<p>Integers read from a <code>Buffer</code> are interpreted as two's complement signed values.</p>
<pre><code class="language-js">const buf = Buffer.from([0, 5]);

console.log(buf.readInt16BE(0));
// Prints: 5
console.log(buf.readInt16LE(0));
// Prints: 1280
console.log(buf.readInt16LE(1));
// Throws ERR_OUT_OF_RANGE
</code></pre>
<h3>buf.readInt32BE(offset)<span><a class="mark" href="#buffer_buf_readint32be_offset" id="buffer_buf_readint32be_offset">#</a></span></h3>
<h3>buf.readInt32LE(offset)<span><a class="mark" href="#buffer_buf_readint32le_offset" id="buffer_buf_readint32le_offset">#</a></span></h3>
<div class="api_metadata">
<details class="changelog"><summary>History</summary>
<table>
<tbody><tr><th>Version</th><th>Changes</th></tr>
<tr><td>v10.0.0</td>
<td><p>Removed <code>noAssert</code> and no implicit coercion of the offset to <code>uint32</code> anymore.</p></td></tr>
<tr><td>v0.5.5</td>
<td><p><span>Added in: v0.5.5</span></p></td></tr>
</tbody></table>
</details>
</div>
<ul>
<li><code>offset</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type">&#x3C;integer></a> Number of bytes to skip before starting to read. Must
satisfy <code>0 &#x3C;= offset &#x3C;= buf.length - 4</code>.</li>
<li>Returns: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type">&#x3C;integer></a></li>
</ul>
<p>Reads a signed 32-bit integer from <code>buf</code> at the specified <code>offset</code> with
the specified endian format (<code>readInt32BE()</code> returns big endian,
<code>readInt32LE()</code> returns little endian).</p>
<p>Integers read from a <code>Buffer</code> are interpreted as two's complement signed values.</p>
<pre><code class="language-js">const buf = Buffer.from([0, 0, 0, 5]);

console.log(buf.readInt32BE(0));
// Prints: 5
console.log(buf.readInt32LE(0));
// Prints: 83886080
console.log(buf.readInt32LE(1));
// Throws ERR_OUT_OF_RANGE
</code></pre>
<h3>buf.readIntBE(offset, byteLength)<span><a class="mark" href="#buffer_buf_readintbe_offset_bytelength" id="buffer_buf_readintbe_offset_bytelength">#</a></span></h3>
<h3>buf.readIntLE(offset, byteLength)<span><a class="mark" href="#buffer_buf_readintle_offset_bytelength" id="buffer_buf_readintle_offset_bytelength">#</a></span></h3>
<div class="api_metadata">
<details class="changelog"><summary>History</summary>
<table>
<tbody><tr><th>Version</th><th>Changes</th></tr>
<tr><td>v10.0.0</td>
<td><p>Removed <code>noAssert</code> and no implicit coercion of the offset and <code>byteLength</code> to <code>uint32</code> anymore.</p></td></tr>
<tr><td>v0.11.15</td>
<td><p><span>Added in: v0.11.15</span></p></td></tr>
</tbody></table>
</details>
</div>
<ul>
<li><code>offset</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type">&#x3C;integer></a> Number of bytes to skip before starting to read. Must
satisfy <code>0 &#x3C;= offset &#x3C;= buf.length - byteLength</code>.</li>
<li><code>byteLength</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type">&#x3C;integer></a> Number of bytes to read. Must satisfy
<code>0 &#x3C; byteLength &#x3C;= 6</code>.</li>
<li>Returns: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type">&#x3C;integer></a></li>
</ul>
<p>Reads <code>byteLength</code> number of bytes from <code>buf</code> at the specified <code>offset</code>
and interprets the result as a two's complement signed value. Supports up to 48
bits of accuracy.</p>
<pre><code class="language-js">const buf = Buffer.from([0x12, 0x34, 0x56, 0x78, 0x90, 0xab]);

console.log(buf.readIntLE(0, 6).toString(16));
// Prints: -546f87a9cbee
console.log(buf.readIntBE(0, 6).toString(16));
// Prints: 1234567890ab
console.log(buf.readIntBE(1, 6).toString(16));
// Throws ERR_INDEX_OUT_OF_RANGE
console.log(buf.readIntBE(1, 0).toString(16));
// Throws ERR_OUT_OF_RANGE
</code></pre>
<h3>buf.readUInt8(offset)<span><a class="mark" href="#buffer_buf_readuint8_offset" id="buffer_buf_readuint8_offset">#</a></span></h3>
<div class="api_metadata">
<details class="changelog"><summary>History</summary>
<table>
<tbody><tr><th>Version</th><th>Changes</th></tr>
<tr><td>v10.0.0</td>
<td><p>Removed <code>noAssert</code> and no implicit coercion of the offset to <code>uint32</code> anymore.</p></td></tr>
<tr><td>v0.5.0</td>
<td><p><span>Added in: v0.5.0</span></p></td></tr>
</tbody></table>
</details>
</div>
<ul>
<li><code>offset</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type">&#x3C;integer></a> Number of bytes to skip before starting to read. Must
satisfy <code>0 &#x3C;= offset &#x3C;= buf.length - 1</code>.</li>
<li>Returns: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type">&#x3C;integer></a></li>
</ul>
<p>Reads an unsigned 8-bit integer from <code>buf</code> at the specified <code>offset</code>.</p>
<pre><code class="language-js">const buf = Buffer.from([1, -2]);

console.log(buf.readUInt8(0));
// Prints: 1
console.log(buf.readUInt8(1));
// Prints: 254
console.log(buf.readUInt8(2));
// Throws ERR_OUT_OF_RANGE
</code></pre>
<h3>buf.readUInt16BE(offset)<span><a class="mark" href="#buffer_buf_readuint16be_offset" id="buffer_buf_readuint16be_offset">#</a></span></h3>
<h3>buf.readUInt16LE(offset)<span><a class="mark" href="#buffer_buf_readuint16le_offset" id="buffer_buf_readuint16le_offset">#</a></span></h3>
<div class="api_metadata">
<details class="changelog"><summary>History</summary>
<table>
<tbody><tr><th>Version</th><th>Changes</th></tr>
<tr><td>v10.0.0</td>
<td><p>Removed <code>noAssert</code> and no implicit coercion of the offset to <code>uint32</code> anymore.</p></td></tr>
<tr><td>v0.5.5</td>
<td><p><span>Added in: v0.5.5</span></p></td></tr>
</tbody></table>
</details>
</div>
<ul>
<li><code>offset</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type">&#x3C;integer></a> Number of bytes to skip before starting to read. Must
satisfy <code>0 &#x3C;= offset &#x3C;= buf.length - 2</code>.</li>
<li>Returns: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type">&#x3C;integer></a></li>
</ul>
<p>Reads an unsigned 16-bit integer from <code>buf</code> at the specified <code>offset</code> with
specified endian format (<code>readUInt16BE()</code> returns big endian, <code>readUInt16LE()</code>
returns little endian).</p>
<pre><code class="language-js">const buf = Buffer.from([0x12, 0x34, 0x56]);

console.log(buf.readUInt16BE(0).toString(16));
// Prints: 1234
console.log(buf.readUInt16LE(0).toString(16));
// Prints: 3412
console.log(buf.readUInt16BE(1).toString(16));
// Prints: 3456
console.log(buf.readUInt16LE(1).toString(16));
// Prints: 5634
console.log(buf.readUInt16LE(2).toString(16));
// Throws ERR_OUT_OF_RANGE
</code></pre>
<h3>buf.readUInt32BE(offset)<span><a class="mark" href="#buffer_buf_readuint32be_offset" id="buffer_buf_readuint32be_offset">#</a></span></h3>
<h3>buf.readUInt32LE(offset)<span><a class="mark" href="#buffer_buf_readuint32le_offset" id="buffer_buf_readuint32le_offset">#</a></span></h3>
<div class="api_metadata">
<details class="changelog"><summary>History</summary>
<table>
<tbody><tr><th>Version</th><th>Changes</th></tr>
<tr><td>v10.0.0</td>
<td><p>Removed <code>noAssert</code> and no implicit coercion of the offset to <code>uint32</code> anymore.</p></td></tr>
<tr><td>v0.5.5</td>
<td><p><span>Added in: v0.5.5</span></p></td></tr>
</tbody></table>
</details>
</div>
<ul>
<li><code>offset</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type">&#x3C;integer></a> Number of bytes to skip before starting to read. Must
satisfy <code>0 &#x3C;= offset &#x3C;= buf.length - 4</code>.</li>
<li>Returns: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type">&#x3C;integer></a></li>
</ul>
<p>Reads an unsigned 32-bit integer from <code>buf</code> at the specified <code>offset</code> with
specified endian format (<code>readUInt32BE()</code> returns big endian,
<code>readUInt32LE()</code> returns little endian).</p>
<pre><code class="language-js">const buf = Buffer.from([0x12, 0x34, 0x56, 0x78]);

console.log(buf.readUInt32BE(0).toString(16));
// Prints: 12345678
console.log(buf.readUInt32LE(0).toString(16));
// Prints: 78563412
console.log(buf.readUInt32LE(1).toString(16));
// Throws ERR_OUT_OF_RANGE
</code></pre>
<h3>buf.readUIntBE(offset, byteLength)<span><a class="mark" href="#buffer_buf_readuintbe_offset_bytelength" id="buffer_buf_readuintbe_offset_bytelength">#</a></span></h3>
<h3>buf.readUIntLE(offset, byteLength)<span><a class="mark" href="#buffer_buf_readuintle_offset_bytelength" id="buffer_buf_readuintle_offset_bytelength">#</a></span></h3>
<div class="api_metadata">
<details class="changelog"><summary>History</summary>
<table>
<tbody><tr><th>Version</th><th>Changes</th></tr>
<tr><td>v10.0.0</td>
<td><p>Removed <code>noAssert</code> and no implicit coercion of the offset and <code>byteLength</code> to <code>uint32</code> anymore.</p></td></tr>
<tr><td>v0.11.15</td>
<td><p><span>Added in: v0.11.15</span></p></td></tr>
</tbody></table>
</details>
</div>
<ul>
<li><code>offset</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type">&#x3C;integer></a> Number of bytes to skip before starting to read. Must
satisfy <code>0 &#x3C;= offset &#x3C;= buf.length - byteLength</code>.</li>
<li><code>byteLength</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type">&#x3C;integer></a> Number of bytes to read. Must satisfy
<code>0 &#x3C; byteLength &#x3C;= 6</code>.</li>
<li>Returns: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type">&#x3C;integer></a></li>
</ul>
<p>Reads <code>byteLength</code> number of bytes from <code>buf</code> at the specified <code>offset</code>
and interprets the result as an unsigned integer. Supports up to 48
bits of accuracy.</p>
<pre><code class="language-js">const buf = Buffer.from([0x12, 0x34, 0x56, 0x78, 0x90, 0xab]);

console.log(buf.readUIntBE(0, 6).toString(16));
// Prints: 1234567890ab
console.log(buf.readUIntLE(0, 6).toString(16));
// Prints: ab9078563412
console.log(buf.readUIntBE(1, 6).toString(16));
// Throws ERR_OUT_OF_RANGE
</code></pre>
<h3>buf.slice([start[, end]])<a class="srclink" href="https://github.com/nodejs/node/blob/1a96d83a223ff9f05f7d942fb84440d323f7b596/lib/buffer.js#L1007">[src]</a><span><a class="mark" href="#buffer_buf_slice_start_end" id="buffer_buf_slice_start_end">#</a></span></h3>
<div class="api_metadata">
<details class="changelog"><summary>History</summary>
<table>
<tbody><tr><th>Version</th><th>Changes</th></tr>
<tr><td>v7.1.0, v6.9.2</td>
<td><p>Coercing the offsets to integers now handles values outside the 32-bit integer range properly.</p></td></tr>
<tr><td>v7.0.0</td>
<td><p>All offsets are now coerced to integers before doing any calculations with them.</p></td></tr>
<tr><td>v0.3.0</td>
<td><p><span>Added in: v0.3.0</span></p></td></tr>
</tbody></table>
</details>
</div>
<ul>
<li><code>start</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type">&#x3C;integer></a> Where the new <code>Buffer</code> will start. <strong>Default:</strong> <code>0</code>.</li>
<li><code>end</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type">&#x3C;integer></a> Where the new <code>Buffer</code> will end (not inclusive).
<strong>Default:</strong> <a href="#buffer_buf_length"><code>buf.length</code></a>.</li>
<li>Returns: <a href="buffer.html#buffer_class_buffer" class="type">&#x3C;Buffer></a></li>
</ul>
<p>Returns a new <code>Buffer</code> that references the same memory as the original, but
offset and cropped by the <code>start</code> and <code>end</code> indices.</p>
<p>Specifying <code>end</code> greater than <a href="#buffer_buf_length"><code>buf.length</code></a> will return the same result as
that of <code>end</code> equal to <a href="#buffer_buf_length"><code>buf.length</code></a>.</p>
<p>Modifying the new <code>Buffer</code> slice will modify the memory in the original <code>Buffer</code>
because the allocated memory of the two objects overlap.</p>
<pre><code class="language-js">// Create a `Buffer` with the ASCII alphabet, take a slice, and modify one byte
// from the original `Buffer`.

const buf1 = Buffer.allocUnsafe(26);

for (let i = 0; i &#x3C; 26; i++) {
  // 97 is the decimal ASCII value for 'a'
  buf1[i] = i + 97;
}

const buf2 = buf1.slice(0, 3);

console.log(buf2.toString('ascii', 0, buf2.length));
// Prints: abc

buf1[0] = 33;

console.log(buf2.toString('ascii', 0, buf2.length));
// Prints: !bc
</code></pre>
<p>Specifying negative indexes causes the slice to be generated relative to the
end of <code>buf</code> rather than the beginning.</p>
<pre><code class="language-js">const buf = Buffer.from('buffer');

console.log(buf.slice(-6, -1).toString());
// Prints: buffe
// (Equivalent to buf.slice(0, 5))

console.log(buf.slice(-6, -2).toString());
// Prints: buff
// (Equivalent to buf.slice(0, 4))

console.log(buf.slice(-5, -2).toString());
// Prints: uff
// (Equivalent to buf.slice(1, 4))
</code></pre>
<h3>buf.swap16()<a class="srclink" href="https://github.com/nodejs/node/blob/1a96d83a223ff9f05f7d942fb84440d323f7b596/lib/buffer.js#L1021">[src]</a><span><a class="mark" href="#buffer_buf_swap16" id="buffer_buf_swap16">#</a></span></h3>
<div class="api_metadata">
<span>Added in: v5.10.0</span>
</div>
<ul>
<li>Returns: <a href="buffer.html#buffer_class_buffer" class="type">&#x3C;Buffer></a> A reference to <code>buf</code>.</li>
</ul>
<p>Interprets <code>buf</code> as an array of unsigned 16-bit integers and swaps the
byte order <em>in-place</em>. Throws <a href="errors.html#ERR_INVALID_BUFFER_SIZE"><code>ERR_INVALID_BUFFER_SIZE</code></a> if <a href="#buffer_buf_length"><code>buf.length</code></a> is
not a multiple of 2.</p>
<pre><code class="language-js">const buf1 = Buffer.from([0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8]);

console.log(buf1);
// Prints: &#x3C;Buffer 01 02 03 04 05 06 07 08>

buf1.swap16();

console.log(buf1);
// Prints: &#x3C;Buffer 02 01 04 03 06 05 08 07>

const buf2 = Buffer.from([0x1, 0x2, 0x3]);

buf2.swap16();
// Throws ERR_INVALID_BUFFER_SIZE
</code></pre>
<p>One convenient use of <code>buf.swap16()</code> is to perform a fast in-place conversion
between UTF-16 little-endian and UTF-16 big-endian:</p>
<pre><code class="language-js">const buf = Buffer.from('This is little-endian UTF-16', 'utf16le');
buf.swap16(); // Convert to big-endian UTF-16 text.
</code></pre>
<h3>buf.swap32()<a class="srclink" href="https://github.com/nodejs/node/blob/1a96d83a223ff9f05f7d942fb84440d323f7b596/lib/buffer.js#L1036">[src]</a><span><a class="mark" href="#buffer_buf_swap32" id="buffer_buf_swap32">#</a></span></h3>
<div class="api_metadata">
<span>Added in: v5.10.0</span>
</div>
<ul>
<li>Returns: <a href="buffer.html#buffer_class_buffer" class="type">&#x3C;Buffer></a> A reference to <code>buf</code>.</li>
</ul>
<p>Interprets <code>buf</code> as an array of unsigned 32-bit integers and swaps the
byte order <em>in-place</em>. Throws <a href="errors.html#ERR_INVALID_BUFFER_SIZE"><code>ERR_INVALID_BUFFER_SIZE</code></a> if <a href="#buffer_buf_length"><code>buf.length</code></a> is
not a multiple of 4.</p>
<pre><code class="language-js">const buf1 = Buffer.from([0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8]);

console.log(buf1);
// Prints: &#x3C;Buffer 01 02 03 04 05 06 07 08>

buf1.swap32();

console.log(buf1);
// Prints: &#x3C;Buffer 04 03 02 01 08 07 06 05>

const buf2 = Buffer.from([0x1, 0x2, 0x3]);

buf2.swap32();
// Throws ERR_INVALID_BUFFER_SIZE
</code></pre>
<h3>buf.swap64()<a class="srclink" href="https://github.com/nodejs/node/blob/1a96d83a223ff9f05f7d942fb84440d323f7b596/lib/buffer.js#L1053">[src]</a><span><a class="mark" href="#buffer_buf_swap64" id="buffer_buf_swap64">#</a></span></h3>
<div class="api_metadata">
<span>Added in: v6.3.0</span>
</div>
<ul>
<li>Returns: <a href="buffer.html#buffer_class_buffer" class="type">&#x3C;Buffer></a> A reference to <code>buf</code>.</li>
</ul>
<p>Interprets <code>buf</code> as an array of 64-bit numbers and swaps byte order <em>in-place</em>.
Throws <a href="errors.html#ERR_INVALID_BUFFER_SIZE"><code>ERR_INVALID_BUFFER_SIZE</code></a> if <a href="#buffer_buf_length"><code>buf.length</code></a> is not a multiple of 8.</p>
<pre><code class="language-js">const buf1 = Buffer.from([0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8]);

console.log(buf1);
// Prints: &#x3C;Buffer 01 02 03 04 05 06 07 08>

buf1.swap64();

console.log(buf1);
// Prints: &#x3C;Buffer 08 07 06 05 04 03 02 01>

const buf2 = Buffer.from([0x1, 0x2, 0x3]);

buf2.swap64();
// Throws ERR_INVALID_BUFFER_SIZE
</code></pre>
<p>Note that JavaScript cannot encode 64-bit integers. This method is intended
for working with 64-bit floats.</p>
<h3>buf.toJSON()<a class="srclink" href="https://github.com/nodejs/node/blob/1a96d83a223ff9f05f7d942fb84440d323f7b596/lib/buffer.js#L979">[src]</a><span><a class="mark" href="#buffer_buf_tojson" id="buffer_buf_tojson">#</a></span></h3>
<div class="api_metadata">
<span>Added in: v0.9.2</span>
</div>
<ul>
<li>Returns: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" class="type">&#x3C;Object></a></li>
</ul>
<p>Returns a JSON representation of <code>buf</code>. <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify"><code>JSON.stringify()</code></a> implicitly calls
this function when stringifying a <code>Buffer</code> instance.</p>
<pre><code class="language-js">const buf = Buffer.from([0x1, 0x2, 0x3, 0x4, 0x5]);
const json = JSON.stringify(buf);

console.log(json);
// Prints: {"type":"Buffer","data":[1,2,3,4,5]}

const copy = JSON.parse(json, (key, value) => {
  return value &#x26;&#x26; value.type === 'Buffer' ?
    Buffer.from(value.data) :
    value;
});

console.log(copy);
// Prints: &#x3C;Buffer 01 02 03 04 05>
</code></pre>
<h3>buf.toString([encoding[, start[, end]]])<a class="srclink" href="https://github.com/nodejs/node/blob/1a96d83a223ff9f05f7d942fb84440d323f7b596/lib/buffer.js#L643">[src]</a><span><a class="mark" href="#buffer_buf_tostring_encoding_start_end" id="buffer_buf_tostring_encoding_start_end">#</a></span></h3>
<div class="api_metadata">
<span>Added in: v0.1.90</span>
</div>
<ul>
<li><code>encoding</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" class="type">&#x3C;string></a> The character encoding to use. <strong>Default:</strong> <code>'utf8'</code>.</li>
<li><code>start</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type">&#x3C;integer></a> The byte offset to start decoding at. <strong>Default:</strong> <code>0</code>.</li>
<li><code>end</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type">&#x3C;integer></a> The byte offset to stop decoding at (not inclusive).
<strong>Default:</strong> <a href="#buffer_buf_length"><code>buf.length</code></a>.</li>
<li>Returns: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" class="type">&#x3C;string></a></li>
</ul>
<p>Decodes <code>buf</code> to a string according to the specified character encoding in
<code>encoding</code>. <code>start</code> and <code>end</code> may be passed to decode only a subset of <code>buf</code>.</p>
<p>The maximum length of a string instance (in UTF-16 code units) is available
as <a href="#buffer_buffer_constants_max_string_length"><code>buffer.constants.MAX_STRING_LENGTH</code></a>.</p>
<pre><code class="language-js">const buf1 = Buffer.allocUnsafe(26);

for (let i = 0; i &#x3C; 26; i++) {
  // 97 is the decimal ASCII value for 'a'
  buf1[i] = i + 97;
}

console.log(buf1.toString('ascii'));
// Prints: abcdefghijklmnopqrstuvwxyz
console.log(buf1.toString('ascii', 0, 5));
// Prints: abcde

const buf2 = Buffer.from('tést');

console.log(buf2.toString('hex'));
// Prints: 74c3a97374
console.log(buf2.toString('utf8', 0, 3));
// Prints: té
console.log(buf2.toString(undefined, 0, 3));
// Prints: té
</code></pre>
<h3>buf.values()<span><a class="mark" href="#buffer_buf_values" id="buffer_buf_values">#</a></span></h3>
<div class="api_metadata">
<span>Added in: v1.1.0</span>
</div>
<ul>
<li>Returns: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#The_iterator_protocol" class="type">&#x3C;Iterator></a></li>
</ul>
<p>Creates and returns an <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols">iterator</a> for <code>buf</code> values (bytes). This function is
called automatically when a <code>Buffer</code> is used in a <code>for..of</code> statement.</p>
<pre><code class="language-js">const buf = Buffer.from('buffer');

for (const value of buf.values()) {
  console.log(value);
}
// Prints:
//   98
//   117
//   102
//   102
//   101
//   114

for (const value of buf) {
  console.log(value);
}
// Prints:
//   98
//   117
//   102
//   102
//   101
//   114
</code></pre>
<h3>buf.write(string[, offset[, length]][, encoding])<a class="srclink" href="https://github.com/nodejs/node/blob/1a96d83a223ff9f05f7d942fb84440d323f7b596/lib/buffer.js#L896">[src]</a><span><a class="mark" href="#buffer_buf_write_string_offset_length_encoding" id="buffer_buf_write_string_offset_length_encoding">#</a></span></h3>
<div class="api_metadata">
<span>Added in: v0.1.90</span>
</div>
<ul>
<li><code>string</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" class="type">&#x3C;string></a> String to write to <code>buf</code>.</li>
<li><code>offset</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type">&#x3C;integer></a> Number of bytes to skip before starting to write <code>string</code>.
<strong>Default:</strong> <code>0</code>.</li>
<li><code>length</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type">&#x3C;integer></a> Number of bytes to write. <strong>Default:</strong>
<code>buf.length - offset</code>.</li>
<li><code>encoding</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" class="type">&#x3C;string></a> The character encoding of <code>string</code>. <strong>Default:</strong> <code>'utf8'</code>.</li>
<li>Returns: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type">&#x3C;integer></a> Number of bytes written.</li>
</ul>
<p>Writes <code>string</code> to <code>buf</code> at <code>offset</code> according to the character encoding in
<code>encoding</code>. The <code>length</code> parameter is the number of bytes to write. If <code>buf</code> did
not contain enough space to fit the entire string, only part of <code>string</code> will be
written. However, partially encoded characters will not be written.</p>
<pre><code class="language-js">const buf = Buffer.alloc(256);

const len = buf.write('\u00bd + \u00bc = \u00be', 0);

console.log(`${len} bytes: ${buf.toString('utf8', 0, len)}`);
// Prints: 12 bytes: ½ + ¼ = ¾
</code></pre>
<h3>buf.writeDoubleBE(value, offset)<span><a class="mark" href="#buffer_buf_writedoublebe_value_offset" id="buffer_buf_writedoublebe_value_offset">#</a></span></h3>
<h3>buf.writeDoubleLE(value, offset)<span><a class="mark" href="#buffer_buf_writedoublele_value_offset" id="buffer_buf_writedoublele_value_offset">#</a></span></h3>
<div class="api_metadata">
<details class="changelog"><summary>History</summary>
<table>
<tbody><tr><th>Version</th><th>Changes</th></tr>
<tr><td>v10.0.0</td>
<td><p>Removed <code>noAssert</code> and no implicit coercion of the offset to <code>uint32</code> anymore.</p></td></tr>
<tr><td>v0.11.15</td>
<td><p><span>Added in: v0.11.15</span></p></td></tr>
</tbody></table>
</details>
</div>
<ul>
<li><code>value</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type">&#x3C;number></a> Number to be written to <code>buf</code>.</li>
<li><code>offset</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type">&#x3C;integer></a> Number of bytes to skip before starting to write. Must
satisfy <code>0 &#x3C;= offset &#x3C;= buf.length - 8</code>.</li>
<li>Returns: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type">&#x3C;integer></a> <code>offset</code> plus the number of bytes written.</li>
</ul>
<p>Writes <code>value</code> to <code>buf</code> at the specified <code>offset</code> with specified endian
format (<code>writeDoubleBE()</code> writes big endian, <code>writeDoubleLE()</code> writes little
endian). <code>value</code> <em>should</em> be a valid 64-bit double. Behavior is undefined when
<code>value</code> is anything other than a 64-bit double.</p>
<pre><code class="language-js">const buf = Buffer.allocUnsafe(8);

buf.writeDoubleBE(123.456, 0);

console.log(buf);
// Prints: &#x3C;Buffer 40 5e dd 2f 1a 9f be 77>

buf.writeDoubleLE(123.456, 0);

console.log(buf);
// Prints: &#x3C;Buffer 77 be 9f 1a 2f dd 5e 40>
</code></pre>
<h3>buf.writeFloatBE(value, offset)<span><a class="mark" href="#buffer_buf_writefloatbe_value_offset" id="buffer_buf_writefloatbe_value_offset">#</a></span></h3>
<h3>buf.writeFloatLE(value, offset)<span><a class="mark" href="#buffer_buf_writefloatle_value_offset" id="buffer_buf_writefloatle_value_offset">#</a></span></h3>
<div class="api_metadata">
<details class="changelog"><summary>History</summary>
<table>
<tbody><tr><th>Version</th><th>Changes</th></tr>
<tr><td>v10.0.0</td>
<td><p>Removed <code>noAssert</code> and no implicit coercion of the offset to <code>uint32</code> anymore.</p></td></tr>
<tr><td>v0.11.15</td>
<td><p><span>Added in: v0.11.15</span></p></td></tr>
</tbody></table>
</details>
</div>
<ul>
<li><code>value</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type">&#x3C;number></a> Number to be written to <code>buf</code>.</li>
<li><code>offset</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type">&#x3C;integer></a> Number of bytes to skip before starting to write. Must
satisfy <code>0 &#x3C;= offset &#x3C;= buf.length - 4</code>.</li>
<li>Returns: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type">&#x3C;integer></a> <code>offset</code> plus the number of bytes written.</li>
</ul>
<p>Writes <code>value</code> to <code>buf</code> at the specified <code>offset</code> with specified endian
format (<code>writeFloatBE()</code> writes big endian, <code>writeFloatLE()</code> writes little
endian). <code>value</code> <em>should</em> be a valid 32-bit float. Behavior is undefined when
<code>value</code> is anything other than a 32-bit float.</p>
<pre><code class="language-js">const buf = Buffer.allocUnsafe(4);

buf.writeFloatBE(0xcafebabe, 0);

console.log(buf);
// Prints: &#x3C;Buffer 4f 4a fe bb>

buf.writeFloatLE(0xcafebabe, 0);

console.log(buf);
// Prints: &#x3C;Buffer bb fe 4a 4f>
</code></pre>
<h3>buf.writeInt8(value, offset)<span><a class="mark" href="#buffer_buf_writeint8_value_offset" id="buffer_buf_writeint8_value_offset">#</a></span></h3>
<div class="api_metadata">
<details class="changelog"><summary>History</summary>
<table>
<tbody><tr><th>Version</th><th>Changes</th></tr>
<tr><td>v10.0.0</td>
<td><p>Removed <code>noAssert</code> and no implicit coercion of the offset to <code>uint32</code> anymore.</p></td></tr>
<tr><td>v0.5.0</td>
<td><p><span>Added in: v0.5.0</span></p></td></tr>
</tbody></table>
</details>
</div>
<ul>
<li><code>value</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type">&#x3C;integer></a> Number to be written to <code>buf</code>.</li>
<li><code>offset</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type">&#x3C;integer></a> Number of bytes to skip before starting to write. Must
satisfy <code>0 &#x3C;= offset &#x3C;= buf.length - 1</code>.</li>
<li>Returns: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type">&#x3C;integer></a> <code>offset</code> plus the number of bytes written.</li>
</ul>
<p>Writes <code>value</code> to <code>buf</code> at the specified <code>offset</code>. <code>value</code> <em>should</em> be a valid
signed 8-bit integer. Behavior is undefined when <code>value</code> is anything other than
a signed 8-bit integer.</p>
<p><code>value</code> is interpreted and written as a two's complement signed integer.</p>
<pre><code class="language-js">const buf = Buffer.allocUnsafe(2);

buf.writeInt8(2, 0);
buf.writeInt8(-2, 1);

console.log(buf);
// Prints: &#x3C;Buffer 02 fe>
</code></pre>
<h3>buf.writeInt16BE(value, offset)<span><a class="mark" href="#buffer_buf_writeint16be_value_offset" id="buffer_buf_writeint16be_value_offset">#</a></span></h3>
<h3>buf.writeInt16LE(value, offset)<span><a class="mark" href="#buffer_buf_writeint16le_value_offset" id="buffer_buf_writeint16le_value_offset">#</a></span></h3>
<div class="api_metadata">
<details class="changelog"><summary>History</summary>
<table>
<tbody><tr><th>Version</th><th>Changes</th></tr>
<tr><td>v10.0.0</td>
<td><p>Removed <code>noAssert</code> and no implicit coercion of the offset to <code>uint32</code> anymore.</p></td></tr>
<tr><td>v0.5.5</td>
<td><p><span>Added in: v0.5.5</span></p></td></tr>
</tbody></table>
</details>
</div>
<ul>
<li><code>value</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type">&#x3C;integer></a> Number to be written to <code>buf</code>.</li>
<li><code>offset</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type">&#x3C;integer></a> Number of bytes to skip before starting to write. Must
satisfy <code>0 &#x3C;= offset &#x3C;= buf.length - 2</code>.</li>
<li>Returns: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type">&#x3C;integer></a> <code>offset</code> plus the number of bytes written.</li>
</ul>
<p>Writes <code>value</code> to <code>buf</code> at the specified <code>offset</code> with specified endian
format (<code>writeInt16BE()</code> writes big endian, <code>writeInt16LE()</code> writes little
endian). <code>value</code> <em>should</em> be a valid signed 16-bit integer. Behavior is
undefined when <code>value</code> is anything other than a signed 16-bit integer.</p>
<p><code>value</code> is interpreted and written as a two's complement signed integer.</p>
<pre><code class="language-js">const buf = Buffer.allocUnsafe(4);

buf.writeInt16BE(0x0102, 0);
buf.writeInt16LE(0x0304, 2);

console.log(buf);
// Prints: &#x3C;Buffer 01 02 04 03>
</code></pre>
<h3>buf.writeInt32BE(value, offset)<span><a class="mark" href="#buffer_buf_writeint32be_value_offset" id="buffer_buf_writeint32be_value_offset">#</a></span></h3>
<h3>buf.writeInt32LE(value, offset)<span><a class="mark" href="#buffer_buf_writeint32le_value_offset" id="buffer_buf_writeint32le_value_offset">#</a></span></h3>
<div class="api_metadata">
<details class="changelog"><summary>History</summary>
<table>
<tbody><tr><th>Version</th><th>Changes</th></tr>
<tr><td>v10.0.0</td>
<td><p>Removed <code>noAssert</code> and no implicit coercion of the offset to <code>uint32</code> anymore.</p></td></tr>
<tr><td>v0.5.5</td>
<td><p><span>Added in: v0.5.5</span></p></td></tr>
</tbody></table>
</details>
</div>
<ul>
<li><code>value</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type">&#x3C;integer></a> Number to be written to <code>buf</code>.</li>
<li><code>offset</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type">&#x3C;integer></a> Number of bytes to skip before starting to write. Must
satisfy <code>0 &#x3C;= offset &#x3C;= buf.length - 4</code>.</li>
<li>Returns: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type">&#x3C;integer></a> <code>offset</code> plus the number of bytes written.</li>
</ul>
<p>Writes <code>value</code> to <code>buf</code> at the specified <code>offset</code> with specified endian
format (<code>writeInt32BE()</code> writes big endian, <code>writeInt32LE()</code> writes little
endian). <code>value</code> <em>should</em> be a valid signed 32-bit integer. Behavior is
undefined when <code>value</code> is anything other than a signed 32-bit integer.</p>
<p><code>value</code> is interpreted and written as a two's complement signed integer.</p>
<pre><code class="language-js">const buf = Buffer.allocUnsafe(8);

buf.writeInt32BE(0x01020304, 0);
buf.writeInt32LE(0x05060708, 4);

console.log(buf);
// Prints: &#x3C;Buffer 01 02 03 04 08 07 06 05>
</code></pre>
<h3>buf.writeIntBE(value, offset, byteLength)<span><a class="mark" href="#buffer_buf_writeintbe_value_offset_bytelength" id="buffer_buf_writeintbe_value_offset_bytelength">#</a></span></h3>
<h3>buf.writeIntLE(value, offset, byteLength)<span><a class="mark" href="#buffer_buf_writeintle_value_offset_bytelength" id="buffer_buf_writeintle_value_offset_bytelength">#</a></span></h3>
<div class="api_metadata">
<details class="changelog"><summary>History</summary>
<table>
<tbody><tr><th>Version</th><th>Changes</th></tr>
<tr><td>v10.0.0</td>
<td><p>Removed <code>noAssert</code> and no implicit coercion of the offset and <code>byteLength</code> to <code>uint32</code> anymore.</p></td></tr>
<tr><td>v0.11.15</td>
<td><p><span>Added in: v0.11.15</span></p></td></tr>
</tbody></table>
</details>
</div>
<ul>
<li><code>value</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type">&#x3C;integer></a> Number to be written to <code>buf</code>.</li>
<li><code>offset</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type">&#x3C;integer></a> Number of bytes to skip before starting to write. Must
satisfy <code>0 &#x3C;= offset &#x3C;= buf.length - byteLength</code>.</li>
<li><code>byteLength</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type">&#x3C;integer></a> Number of bytes to write. Must satisfy
<code>0 &#x3C; byteLength &#x3C;= 6</code>.</li>
<li>Returns: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type">&#x3C;integer></a> <code>offset</code> plus the number of bytes written.</li>
</ul>
<p>Writes <code>byteLength</code> bytes of <code>value</code> to <code>buf</code> at the specified <code>offset</code>.
Supports up to 48 bits of accuracy. Behavior is undefined when <code>value</code> is
anything other than a signed integer.</p>
<pre><code class="language-js">const buf = Buffer.allocUnsafe(6);

buf.writeIntBE(0x1234567890ab, 0, 6);

console.log(buf);
// Prints: &#x3C;Buffer 12 34 56 78 90 ab>

buf.writeIntLE(0x1234567890ab, 0, 6);

console.log(buf);
// Prints: &#x3C;Buffer ab 90 78 56 34 12>
</code></pre>
<h3>buf.writeUInt8(value, offset)<span><a class="mark" href="#buffer_buf_writeuint8_value_offset" id="buffer_buf_writeuint8_value_offset">#</a></span></h3>
<div class="api_metadata">
<details class="changelog"><summary>History</summary>
<table>
<tbody><tr><th>Version</th><th>Changes</th></tr>
<tr><td>v10.0.0</td>
<td><p>Removed <code>noAssert</code> and no implicit coercion of the offset to <code>uint32</code> anymore.</p></td></tr>
<tr><td>v0.5.0</td>
<td><p><span>Added in: v0.5.0</span></p></td></tr>
</tbody></table>
</details>
</div>
<ul>
<li><code>value</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type">&#x3C;integer></a> Number to be written to <code>buf</code>.</li>
<li><code>offset</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type">&#x3C;integer></a> Number of bytes to skip before starting to write. Must
satisfy <code>0 &#x3C;= offset &#x3C;= buf.length - 1</code>.</li>
<li>Returns: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type">&#x3C;integer></a> <code>offset</code> plus the number of bytes written.</li>
</ul>
<p>Writes <code>value</code> to <code>buf</code> at the specified <code>offset</code>. <code>value</code> <em>should</em> be a
valid unsigned 8-bit integer. Behavior is undefined when <code>value</code> is anything
other than an unsigned 8-bit integer.</p>
<pre><code class="language-js">const buf = Buffer.allocUnsafe(4);

buf.writeUInt8(0x3, 0);
buf.writeUInt8(0x4, 1);
buf.writeUInt8(0x23, 2);
buf.writeUInt8(0x42, 3);

console.log(buf);
// Prints: &#x3C;Buffer 03 04 23 42>
</code></pre>
<h3>buf.writeUInt16BE(value, offset)<span><a class="mark" href="#buffer_buf_writeuint16be_value_offset" id="buffer_buf_writeuint16be_value_offset">#</a></span></h3>
<h3>buf.writeUInt16LE(value, offset)<span><a class="mark" href="#buffer_buf_writeuint16le_value_offset" id="buffer_buf_writeuint16le_value_offset">#</a></span></h3>
<div class="api_metadata">
<details class="changelog"><summary>History</summary>
<table>
<tbody><tr><th>Version</th><th>Changes</th></tr>
<tr><td>v10.0.0</td>
<td><p>Removed <code>noAssert</code> and no implicit coercion of the offset to <code>uint32</code> anymore.</p></td></tr>
<tr><td>v0.5.5</td>
<td><p><span>Added in: v0.5.5</span></p></td></tr>
</tbody></table>
</details>
</div>
<ul>
<li><code>value</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type">&#x3C;integer></a> Number to be written to <code>buf</code>.</li>
<li><code>offset</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type">&#x3C;integer></a> Number of bytes to skip before starting to write. Must
satisfy <code>0 &#x3C;= offset &#x3C;= buf.length - 2</code>.</li>
<li>Returns: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type">&#x3C;integer></a> <code>offset</code> plus the number of bytes written.</li>
</ul>
<p>Writes <code>value</code> to <code>buf</code> at the specified <code>offset</code> with specified endian
format (<code>writeUInt16BE()</code> writes big endian, <code>writeUInt16LE()</code> writes little
endian). <code>value</code> should be a valid unsigned 16-bit integer. Behavior is
undefined when <code>value</code> is anything other than an unsigned 16-bit integer.</p>
<pre><code class="language-js">const buf = Buffer.allocUnsafe(4);

buf.writeUInt16BE(0xdead, 0);
buf.writeUInt16BE(0xbeef, 2);

console.log(buf);
// Prints: &#x3C;Buffer de ad be ef>

buf.writeUInt16LE(0xdead, 0);
buf.writeUInt16LE(0xbeef, 2);

console.log(buf);
// Prints: &#x3C;Buffer ad de ef be>
</code></pre>
<h3>buf.writeUInt32BE(value, offset)<span><a class="mark" href="#buffer_buf_writeuint32be_value_offset" id="buffer_buf_writeuint32be_value_offset">#</a></span></h3>
<h3>buf.writeUInt32LE(value, offset)<span><a class="mark" href="#buffer_buf_writeuint32le_value_offset" id="buffer_buf_writeuint32le_value_offset">#</a></span></h3>
<div class="api_metadata">
<details class="changelog"><summary>History</summary>
<table>
<tbody><tr><th>Version</th><th>Changes</th></tr>
<tr><td>v10.0.0</td>
<td><p>Removed <code>noAssert</code> and no implicit coercion of the offset to <code>uint32</code> anymore.</p></td></tr>
<tr><td>v0.5.5</td>
<td><p><span>Added in: v0.5.5</span></p></td></tr>
</tbody></table>
</details>
</div>
<ul>
<li><code>value</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type">&#x3C;integer></a> Number to be written to <code>buf</code>.</li>
<li><code>offset</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type">&#x3C;integer></a> Number of bytes to skip before starting to write. Must
satisfy <code>0 &#x3C;= offset &#x3C;= buf.length - 4</code>.</li>
<li>Returns: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type">&#x3C;integer></a> <code>offset</code> plus the number of bytes written.</li>
</ul>
<p>Writes <code>value</code> to <code>buf</code> at the specified <code>offset</code> with specified endian
format (<code>writeUInt32BE()</code> writes big endian, <code>writeUInt32LE()</code> writes little
endian). <code>value</code> should be a valid unsigned 32-bit integer. Behavior is
undefined when <code>value</code> is anything other than an unsigned 32-bit integer.</p>
<pre><code class="language-js">const buf = Buffer.allocUnsafe(4);

buf.writeUInt32BE(0xfeedface, 0);

console.log(buf);
// Prints: &#x3C;Buffer fe ed fa ce>

buf.writeUInt32LE(0xfeedface, 0);

console.log(buf);
// Prints: &#x3C;Buffer ce fa ed fe>
</code></pre>
<h3>buf.writeUIntBE(value, offset, byteLength)<span><a class="mark" href="#buffer_buf_writeuintbe_value_offset_bytelength" id="buffer_buf_writeuintbe_value_offset_bytelength">#</a></span></h3>
<h3>buf.writeUIntLE(value, offset, byteLength)<span><a class="mark" href="#buffer_buf_writeuintle_value_offset_bytelength" id="buffer_buf_writeuintle_value_offset_bytelength">#</a></span></h3>
<div class="api_metadata">
<details class="changelog"><summary>History</summary>
<table>
<tbody><tr><th>Version</th><th>Changes</th></tr>
<tr><td>v10.0.0</td>
<td><p>Removed <code>noAssert</code> and no implicit coercion of the offset and <code>byteLength</code> to <code>uint32</code> anymore.</p></td></tr>
<tr><td>v0.5.5</td>
<td><p><span>Added in: v0.5.5</span></p></td></tr>
</tbody></table>
</details>
</div>
<ul>
<li><code>value</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type">&#x3C;integer></a> Number to be written to <code>buf</code>.</li>
<li><code>offset</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type">&#x3C;integer></a> Number of bytes to skip before starting to write. Must
satisfy <code>0 &#x3C;= offset &#x3C;= buf.length - byteLength</code>.</li>
<li><code>byteLength</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type">&#x3C;integer></a> Number of bytes to write. Must satisfy
<code>0 &#x3C; byteLength &#x3C;= 6</code>.</li>
<li>Returns: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type">&#x3C;integer></a> <code>offset</code> plus the number of bytes written.</li>
</ul>
<p>Writes <code>byteLength</code> bytes of <code>value</code> to <code>buf</code> at the specified <code>offset</code>.
Supports up to 48 bits of accuracy. Behavior is undefined when <code>value</code> is
anything other than an unsigned integer.</p>
<pre><code class="language-js">const buf = Buffer.allocUnsafe(6);

buf.writeUIntBE(0x1234567890ab, 0, 6);

console.log(buf);
// Prints: &#x3C;Buffer 12 34 56 78 90 ab>

buf.writeUIntLE(0x1234567890ab, 0, 6);

console.log(buf);
// Prints: &#x3C;Buffer ab 90 78 56 34 12>
</code></pre>
<h2>buffer.INSPECT_MAX_BYTES<span><a class="mark" href="#buffer_buffer_inspect_max_bytes" id="buffer_buffer_inspect_max_bytes">#</a></span></h2>
<div class="api_metadata">
<span>Added in: v0.5.4</span>
</div>
<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type">&#x3C;integer></a> <strong>Default:</strong> <code>50</code></li>
</ul>
<p>Returns the maximum number of bytes that will be returned when
<code>buf.inspect()</code> is called. This can be overridden by user modules. See
<a href="util.html#util_util_inspect_object_options"><code>util.inspect()</code></a> for more details on <code>buf.inspect()</code> behavior.</p>
<p>Note that this is a property on the <code>buffer</code> module returned by
<code>require('buffer')</code>, not on the <code>Buffer</code> global or a <code>Buffer</code> instance.</p>
<h2>buffer.kMaxLength<span><a class="mark" href="#buffer_buffer_kmaxlength" id="buffer_buffer_kmaxlength">#</a></span></h2>
<div class="api_metadata">
<span>Added in: v3.0.0</span>
</div>
<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type">&#x3C;integer></a> The largest size allowed for a single <code>Buffer</code> instance.</li>
</ul>
<p>An alias for <a href="#buffer_buffer_constants_max_length"><code>buffer.constants.MAX_LENGTH</code></a>.</p>
<p>Note that this is a property on the <code>buffer</code> module returned by
<code>require('buffer')</code>, not on the <code>Buffer</code> global or a <code>Buffer</code> instance.</p>
<h2>buffer.transcode(source, fromEnc, toEnc)<span><a class="mark" href="#buffer_buffer_transcode_source_fromenc_toenc" id="buffer_buffer_transcode_source_fromenc_toenc">#</a></span></h2>
<div class="api_metadata">
<details class="changelog"><summary>History</summary>
<table>
<tbody><tr><th>Version</th><th>Changes</th></tr>
<tr><td>v8.0.0</td>
<td><p>The <code>source</code> parameter can now be a <code>Uint8Array</code>.</p></td></tr>
<tr><td>v7.1.0</td>
<td><p><span>Added in: v7.1.0</span></p></td></tr>
</tbody></table>
</details>
</div>
<ul>
<li><code>source</code> <a href="buffer.html#buffer_class_buffer" class="type">&#x3C;Buffer></a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array" class="type">&#x3C;Uint8Array></a> A <code>Buffer</code> or <code>Uint8Array</code> instance.</li>
<li><code>fromEnc</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" class="type">&#x3C;string></a> The current encoding.</li>
<li><code>toEnc</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" class="type">&#x3C;string></a> To target encoding.</li>
</ul>
<p>Re-encodes the given <code>Buffer</code> or <code>Uint8Array</code> instance from one character
encoding to another. Returns a new <code>Buffer</code> instance.</p>
<p>Throws if the <code>fromEnc</code> or <code>toEnc</code> specify invalid character encodings or if
conversion from <code>fromEnc</code> to <code>toEnc</code> is not permitted.</p>
<p>Encodings supported by <code>buffer.transcode()</code> are: <code>'ascii'</code>, <code>'utf8'</code>,
<code>'utf16le'</code>, <code>'ucs2'</code>, <code>'latin1'</code>, and <code>'binary'</code>.</p>
<p>The transcoding process will use substitution characters if a given byte
sequence cannot be adequately represented in the target encoding. For instance:</p>
<pre><code class="language-js">const buffer = require('buffer');

const newBuf = buffer.transcode(Buffer.from('€'), 'utf8', 'ascii');
console.log(newBuf.toString('ascii'));
// Prints: '?'
</code></pre>
<p>Because the Euro (<code>€</code>) sign is not representable in US-ASCII, it is replaced
with <code>?</code> in the transcoded <code>Buffer</code>.</p>
<p>Note that this is a property on the <code>buffer</code> module returned by
<code>require('buffer')</code>, not on the <code>Buffer</code> global or a <code>Buffer</code> instance.</p>
<h2>Class: SlowBuffer<span><a class="mark" href="#buffer_class_slowbuffer" id="buffer_class_slowbuffer">#</a></span></h2>
<div class="api_metadata">
<span>Deprecated since: v6.0.0</span>
</div>
<p></p><div class="api_stability api_stability_0"><a href="documentation.html#documentation_stability_index">Stability: 0</a> - Deprecated: Use <a href="#buffer_class_method_buffer_allocunsafeslow_size"><code>Buffer.allocUnsafeSlow()</code></a> instead.</div><p></p>
<p>Returns an un-pooled <code>Buffer</code>.</p>
<p>In order to avoid the garbage collection overhead of creating many individually
allocated <code>Buffer</code> instances, by default allocations under 4KB are sliced from a
single larger allocated object.</p>
<p>In the case where a developer may need to retain a small chunk of memory from a
pool for an indeterminate amount of time, it may be appropriate to create an
un-pooled <code>Buffer</code> instance using <code>SlowBuffer</code> then copy out the relevant bits.</p>
<pre><code class="language-js">// Need to keep around a few small chunks of memory
const store = [];

socket.on('readable', () => {
  const data = socket.read();

  // Allocate for retained data
  const sb = SlowBuffer(10);

  // Copy the data into the new allocation
  data.copy(sb, 0, 0, 10);

  store.push(sb);
});
</code></pre>
<p>Use of <code>SlowBuffer</code> should be used only as a last resort <em>after</em> a developer
has observed undue memory retention in their applications.</p>
<h3>new SlowBuffer(size)<span><a class="mark" href="#buffer_new_slowbuffer_size" id="buffer_new_slowbuffer_size">#</a></span></h3>
<div class="api_metadata">
<span>Deprecated since: v6.0.0</span>
</div>
<p></p><div class="api_stability api_stability_0"><a href="documentation.html#documentation_stability_index">Stability: 0</a> - Deprecated: Use <a href="#buffer_class_method_buffer_allocunsafeslow_size"><code>Buffer.allocUnsafeSlow()</code></a> instead.</div><p></p>
<ul>
<li><code>size</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type">&#x3C;integer></a> The desired length of the new <code>SlowBuffer</code>.</li>
</ul>
<p>Allocates a new <code>Buffer</code> of <code>size</code> bytes. If <code>size</code> is larger than
<a href="#buffer_buffer_constants_max_length"><code>buffer.constants.MAX_LENGTH</code></a> or smaller than 0, <a href="errors.html#ERR_INVALID_OPT_VALUE"><code>ERR_INVALID_OPT_VALUE</code></a> is
thrown. A zero-length <code>Buffer</code> is created if <code>size</code> is 0.</p>
<p>The underlying memory for <code>SlowBuffer</code> instances is <em>not initialized</em>. The
contents of a newly created <code>SlowBuffer</code> are unknown and may contain sensitive
data. Use <a href="#buffer_buf_fill_value_offset_end_encoding"><code>buf.fill(0)</code></a> to initialize a <code>SlowBuffer</code> with
zeroes.</p>
<pre><code class="language-js">const { SlowBuffer } = require('buffer');

const buf = new SlowBuffer(5);

console.log(buf);
// Prints: (contents may vary): &#x3C;Buffer 78 e0 82 02 01>

buf.fill(0);

console.log(buf);
// Prints: &#x3C;Buffer 00 00 00 00 00>
</code></pre>
<h2>Buffer Constants<span><a class="mark" href="#buffer_buffer_constants" id="buffer_buffer_constants">#</a></span></h2>
<div class="api_metadata">
<span>Added in: v8.2.0</span>
</div>
<p>Note that <code>buffer.constants</code> is a property on the <code>buffer</code> module returned by
<code>require('buffer')</code>, not on the <code>Buffer</code> global or a <code>Buffer</code> instance.</p>
<h3>buffer.constants.MAX_LENGTH<span><a class="mark" href="#buffer_buffer_constants_max_length" id="buffer_buffer_constants_max_length">#</a></span></h3>
<div class="api_metadata">
<span>Added in: v8.2.0</span>
</div>
<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type">&#x3C;integer></a> The largest size allowed for a single <code>Buffer</code> instance.</li>
</ul>
<p>On 32-bit architectures, this value is <code>(2^30)-1</code> (~1GB).
On 64-bit architectures, this value is <code>(2^31)-1</code> (~2GB).</p>
<p>This value is also available as <a href="#buffer_buffer_kmaxlength"><code>buffer.kMaxLength</code></a>.</p>
<h3>buffer.constants.MAX_STRING_LENGTH<span><a class="mark" href="#buffer_buffer_constants_max_string_length" id="buffer_buffer_constants_max_string_length">#</a></span></h3>
<div class="api_metadata">
<span>Added in: v8.2.0</span>
</div>
<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type">&#x3C;integer></a> The largest length allowed for a single <code>string</code> instance.</li>
</ul>
<p>Represents the largest <code>length</code> that a <code>string</code> primitive can have, counted
in UTF-16 code units.</p>
<p>This value may depend on the JS engine that is being used.</p>
      </div>
    </div>
  </div>
  <script src="assets/sh_main.js"></script>
  <script src="assets/sh_javascript.min.js"></script>
  <script>highlight(undefined, undefined, 'pre');</script>
</body>
</html>
