{
  "type": "module",
  "source": "doc/api/buffer.md",
  "modules": [
    {
      "textRaw": "Buffer",
      "name": "buffer",
      "introduced_in": "v0.1.90",
      "stability": 2,
      "stabilityText": "Stable",
      "desc": "<p>Prior to the introduction of <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray\"><code>TypedArray</code></a>, the JavaScript language had no\nmechanism for reading or manipulating streams of binary data. The <code>Buffer</code> class\nwas introduced as part of the Node.js API to enable interaction with octet\nstreams in TCP streams, file system operations, and other contexts.</p>\n<p>With <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray\"><code>TypedArray</code></a> now available, the <code>Buffer</code> class implements the\n<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array\"><code>Uint8Array</code></a> API in a manner that is more optimized and suitable for Node.js.</p>\n<p>Instances of the <code>Buffer</code> class are similar to arrays of integers but\ncorrespond to fixed-sized, raw memory allocations outside the V8 heap.\nThe size of the <code>Buffer</code> is established when it is created and cannot be\nchanged.</p>\n<p>The <code>Buffer</code> class is within the global scope, making it unlikely that one\nwould need to ever use <code>require('buffer').Buffer</code>.</p>\n<pre><code class=\"language-js\">// Creates a zero-filled Buffer of length 10.\nconst buf1 = Buffer.alloc(10);\n\n// Creates a Buffer of length 10, filled with 0x1.\nconst buf2 = Buffer.alloc(10, 1);\n\n// Creates an uninitialized buffer of length 10.\n// This is faster than calling Buffer.alloc() but the returned\n// Buffer instance might contain old data that needs to be\n// overwritten using either fill() or write().\nconst buf3 = Buffer.allocUnsafe(10);\n\n// Creates a Buffer containing [0x1, 0x2, 0x3].\nconst buf4 = Buffer.from([1, 2, 3]);\n\n// Creates a Buffer containing UTF-8 bytes [0x74, 0xc3, 0xa9, 0x73, 0x74].\nconst buf5 = Buffer.from('tést');\n\n// Creates a Buffer containing Latin-1 bytes [0x74, 0xe9, 0x73, 0x74].\nconst buf6 = Buffer.from('tést', 'latin1');\n</code></pre>",
      "modules": [
        {
          "textRaw": "`Buffer.from()`, `Buffer.alloc()`, and `Buffer.allocUnsafe()`",
          "name": "`buffer.from()`,_`buffer.alloc()`,_and_`buffer.allocunsafe()`",
          "desc": "<p>In versions of Node.js prior to 6.0.0, <code>Buffer</code> instances were created using the\n<code>Buffer</code> constructor function, which allocates the returned <code>Buffer</code>\ndifferently based on what arguments are provided:</p>\n<ul>\n<li>Passing a number as the first argument to <code>Buffer()</code> (e.g. <code>new Buffer(10)</code>)\nallocates a new <code>Buffer</code> object of the specified size. Prior to Node.js 8.0.0,\nthe memory allocated for such <code>Buffer</code> instances is <em>not</em> initialized and\n<em>can contain sensitive data</em>. Such <code>Buffer</code> instances <em>must</em> be subsequently\ninitialized by using either <a href=\"#buffer_buf_fill_value_offset_end_encoding\"><code>buf.fill(0)</code></a> or by writing to the\nentire <code>Buffer</code>. While this behavior is <em>intentional</em> to improve performance,\ndevelopment experience has demonstrated that a more explicit distinction is\nrequired between creating a fast-but-uninitialized <code>Buffer</code> versus creating a\nslower-but-safer <code>Buffer</code>. Starting in Node.js 8.0.0, <code>Buffer(num)</code> and\n<code>new Buffer(num)</code> will return a <code>Buffer</code> with initialized memory.</li>\n<li>Passing a string, array, or <code>Buffer</code> as the first argument copies the\npassed object's data into the <code>Buffer</code>.</li>\n<li>Passing an <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer\"><code>ArrayBuffer</code></a> or a <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer\"><code>SharedArrayBuffer</code></a> returns a <code>Buffer</code> that\nshares allocated memory with the given array buffer.</li>\n</ul>\n<p>Because the behavior of <code>new Buffer()</code> is different depending on the type of the\nfirst argument, security and reliability issues can be inadvertently introduced\ninto applications when argument validation or <code>Buffer</code> initialization is not\nperformed.</p>\n<p>To make the creation of <code>Buffer</code> instances more reliable and less error-prone,\nthe various forms of the <code>new Buffer()</code> constructor have been <strong>deprecated</strong>\nand replaced by separate <code>Buffer.from()</code>, <a href=\"#buffer_class_method_buffer_alloc_size_fill_encoding\"><code>Buffer.alloc()</code></a>, and\n<a href=\"#buffer_class_method_buffer_allocunsafe_size\"><code>Buffer.allocUnsafe()</code></a> methods.</p>\n<p><em>Developers should migrate all existing uses of the <code>new Buffer()</code> constructors\nto one of these new APIs.</em></p>\n<ul>\n<li><a href=\"#buffer_class_method_buffer_from_array\"><code>Buffer.from(array)</code></a> returns a new <code>Buffer</code> that <em>contains a copy</em> of the\nprovided octets.</li>\n<li><a href=\"#buffer_class_method_buffer_from_arraybuffer_byteoffset_length\"><code>Buffer.from(arrayBuffer[, byteOffset[, length]])</code></a>\nreturns a new <code>Buffer</code> that <em>shares the same allocated memory</em> as the given\n<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer\"><code>ArrayBuffer</code></a>.</li>\n<li><a href=\"#buffer_class_method_buffer_from_buffer\"><code>Buffer.from(buffer)</code></a> returns a new <code>Buffer</code> that <em>contains a copy</em> of the\ncontents of the given <code>Buffer</code>.</li>\n<li><a href=\"#buffer_class_method_buffer_from_string_encoding\"><code>Buffer.from(string[, encoding])</code></a> returns a new\n<code>Buffer</code> that <em>contains a copy</em> of the provided string.</li>\n<li><a href=\"#buffer_class_method_buffer_alloc_size_fill_encoding\"><code>Buffer.alloc(size[, fill[, encoding]])</code></a> returns a new\ninitialized <code>Buffer</code> of the specified size. This method is slower than\n<a href=\"#buffer_class_method_buffer_allocunsafe_size\"><code>Buffer.allocUnsafe(size)</code></a> but guarantees that newly\ncreated <code>Buffer</code> instances never contain old data that is potentially\nsensitive.</li>\n<li><a href=\"#buffer_class_method_buffer_allocunsafe_size\"><code>Buffer.allocUnsafe(size)</code></a> and\n<a href=\"#buffer_class_method_buffer_allocunsafeslow_size\"><code>Buffer.allocUnsafeSlow(size)</code></a> each return a\nnew uninitialized <code>Buffer</code> of the specified <code>size</code>. Because the <code>Buffer</code> is\nuninitialized, the allocated segment of memory might contain old data that is\npotentially sensitive.</li>\n</ul>\n<p><code>Buffer</code> instances returned by <a href=\"#buffer_class_method_buffer_allocunsafe_size\"><code>Buffer.allocUnsafe()</code></a> <em>may</em> be allocated off\na shared internal memory pool if <code>size</code> is less than or equal to half\n<a href=\"#buffer_class_property_buffer_poolsize\"><code>Buffer.poolSize</code></a>. Instances returned by <a href=\"#buffer_class_method_buffer_allocunsafeslow_size\"><code>Buffer.allocUnsafeSlow()</code></a> <em>never</em>\nuse the shared internal memory pool.</p>",
          "modules": [
            {
              "textRaw": "The `--zero-fill-buffers` command line option",
              "name": "the_`--zero-fill-buffers`_command_line_option",
              "meta": {
                "added": [
                  "v5.10.0"
                ],
                "changes": []
              },
              "desc": "<p>Node.js can be started using the <code>--zero-fill-buffers</code> command line option to\ncause all newly allocated <code>Buffer</code> instances to be zero-filled upon creation by\ndefault, including buffers returned by <code>new Buffer(size)</code>,\n<a href=\"#buffer_class_method_buffer_allocunsafe_size\"><code>Buffer.allocUnsafe()</code></a>, <a href=\"#buffer_class_method_buffer_allocunsafeslow_size\"><code>Buffer.allocUnsafeSlow()</code></a>, and <code>new SlowBuffer(size)</code>. Use of this flag can have a significant negative impact on\nperformance. Use of the <code>--zero-fill-buffers</code> option is recommended only when\nnecessary to enforce that newly allocated <code>Buffer</code> instances cannot contain old\ndata that is potentially sensitive.</p>\n<pre><code class=\"language-txt\">$ node --zero-fill-buffers\n> Buffer.allocUnsafe(5);\n&#x3C;Buffer 00 00 00 00 00>\n</code></pre>",
              "type": "module",
              "displayName": "The `--zero-fill-buffers` command line option"
            },
            {
              "textRaw": "What makes `Buffer.allocUnsafe()` and `Buffer.allocUnsafeSlow()` \"unsafe\"?",
              "name": "what_makes_`buffer.allocunsafe()`_and_`buffer.allocunsafeslow()`_\"unsafe\"?",
              "desc": "<p>When calling <a href=\"#buffer_class_method_buffer_allocunsafe_size\"><code>Buffer.allocUnsafe()</code></a> and <a href=\"#buffer_class_method_buffer_allocunsafeslow_size\"><code>Buffer.allocUnsafeSlow()</code></a>, the\nsegment of allocated memory is <em>uninitialized</em> (it is not zeroed-out). While\nthis design makes the allocation of memory quite fast, the allocated segment of\nmemory might contain old data that is potentially sensitive. Using a <code>Buffer</code>\ncreated by <a href=\"#buffer_class_method_buffer_allocunsafe_size\"><code>Buffer.allocUnsafe()</code></a> without <em>completely</em> overwriting the memory\ncan allow this old data to be leaked when the <code>Buffer</code> memory is read.</p>\n<p>While there are clear performance advantages to using <a href=\"#buffer_class_method_buffer_allocunsafe_size\"><code>Buffer.allocUnsafe()</code></a>,\nextra care <em>must</em> be taken in order to avoid introducing security\nvulnerabilities into an application.</p>",
              "type": "module",
              "displayName": "What makes `Buffer.allocUnsafe()` and `Buffer.allocUnsafeSlow()` \"unsafe\"?"
            }
          ],
          "type": "module",
          "displayName": "`Buffer.from()`, `Buffer.alloc()`, and `Buffer.allocUnsafe()`"
        },
        {
          "textRaw": "Buffers and Character Encodings",
          "name": "buffers_and_character_encodings",
          "meta": {
            "changes": [
              {
                "version": "v6.4.0",
                "pr-url": "https://github.com/nodejs/node/pull/7111",
                "description": "Introduced `latin1` as an alias for `binary`."
              },
              {
                "version": "v5.0.0",
                "pr-url": "https://github.com/nodejs/node/pull/2859",
                "description": "Removed the deprecated `raw` and `raws` encodings."
              }
            ]
          },
          "desc": "<p>When string data is stored in or extracted out of a <code>Buffer</code> instance, a\ncharacter encoding may be specified.</p>\n<pre><code class=\"language-js\">const buf = Buffer.from('hello world', 'ascii');\n\nconsole.log(buf.toString('hex'));\n// Prints: 68656c6c6f20776f726c64\nconsole.log(buf.toString('base64'));\n// Prints: aGVsbG8gd29ybGQ=\n\nconsole.log(Buffer.from('fhqwhgads', 'ascii'));\n// Prints: &#x3C;Buffer 66 68 71 77 68 67 61 64 73>\nconsole.log(Buffer.from('fhqwhgads', 'utf16le'));\n// Prints: &#x3C;Buffer 66 00 68 00 71 00 77 00 68 00 67 00 61 00 64 00 73 00>\n</code></pre>\n<p>The character encodings currently supported by Node.js include:</p>\n<ul>\n<li>\n<p><code>'ascii'</code> - For 7-bit ASCII data only. This encoding is fast and will strip\nthe high bit if set.</p>\n</li>\n<li>\n<p><code>'utf8'</code> - Multibyte encoded Unicode characters. Many web pages and other\ndocument formats use UTF-8.</p>\n</li>\n<li>\n<p><code>'utf16le'</code> - 2 or 4 bytes, little-endian encoded Unicode characters.\nSurrogate pairs (U+10000 to U+10FFFF) are supported.</p>\n</li>\n<li>\n<p><code>'ucs2'</code> - Alias of <code>'utf16le'</code>.</p>\n</li>\n<li>\n<p><code>'base64'</code> - Base64 encoding. When creating a <code>Buffer</code> from a string,\nthis encoding will also correctly accept \"URL and Filename Safe Alphabet\" as\nspecified in <a href=\"https://tools.ietf.org/html/rfc4648#section-5\">RFC4648, Section 5</a>.</p>\n</li>\n<li>\n<p><code>'latin1'</code> - A way of encoding the <code>Buffer</code> into a one-byte encoded string\n(as defined by the IANA in <a href=\"https://tools.ietf.org/html/rfc1345\">RFC1345</a>,\npage 63, to be the Latin-1 supplement block and C0/C1 control codes).</p>\n</li>\n<li>\n<p><code>'binary'</code> - Alias for <code>'latin1'</code>.</p>\n</li>\n<li>\n<p><code>'hex'</code> - Encode each byte as two hexadecimal characters.</p>\n</li>\n</ul>\n<p>Modern Web browsers follow the <a href=\"https://encoding.spec.whatwg.org/\">WHATWG Encoding Standard</a> which aliases\nboth <code>'latin1'</code> and <code>'ISO-8859-1'</code> to <code>'win-1252'</code>. This means that while doing\nsomething like <code>http.get()</code>, if the returned charset is one of those listed in\nthe WHATWG specification it is possible that the server actually returned\n<code>'win-1252'</code>-encoded data, and using <code>'latin1'</code> encoding may incorrectly decode\nthe characters.</p>",
          "type": "module",
          "displayName": "Buffers and Character Encodings"
        },
        {
          "textRaw": "Buffers and TypedArray",
          "name": "buffers_and_typedarray",
          "meta": {
            "changes": [
              {
                "version": "v3.0.0",
                "pr-url": "https://github.com/nodejs/node/pull/2002",
                "description": "The `Buffer`s class now inherits from `Uint8Array`."
              }
            ]
          },
          "desc": "<p><code>Buffer</code> instances are also <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array\"><code>Uint8Array</code></a> instances. However, there are subtle\nincompatibilities with <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray\"><code>TypedArray</code></a>. For example, while\n<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer/slice\"><code>ArrayBuffer#slice()</code></a> creates a copy of the slice, the implementation of\n<a href=\"#buffer_buf_slice_start_end\"><code>Buffer#slice()</code></a> creates a view over the existing <code>Buffer</code>\nwithout copying, making <a href=\"#buffer_buf_slice_start_end\"><code>Buffer#slice()</code></a> far more efficient.</p>\n<p>It is also possible to create new <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray\"><code>TypedArray</code></a> instances from a <code>Buffer</code> with\nthe following caveats:</p>\n<ol>\n<li>\n<p>The <code>Buffer</code> object's memory is copied to the <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray\"><code>TypedArray</code></a>, not shared.</p>\n</li>\n<li>\n<p>The <code>Buffer</code> object's memory is interpreted as an array of distinct\nelements, and not as a byte array of the target type. That is,\n<code>new Uint32Array(Buffer.from([1, 2, 3, 4]))</code> creates a 4-element <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint32Array\"><code>Uint32Array</code></a>\nwith elements <code>[1, 2, 3, 4]</code>, not a <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint32Array\"><code>Uint32Array</code></a> with a single element\n<code>[0x1020304]</code> or <code>[0x4030201]</code>.</p>\n</li>\n</ol>\n<p>It is possible to create a new <code>Buffer</code> that shares the same allocated memory as\na <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray\"><code>TypedArray</code></a> instance by using the <code>TypeArray</code> object's <code>.buffer</code> property.</p>\n<pre><code class=\"language-js\">const arr = new Uint16Array(2);\n\narr[0] = 5000;\narr[1] = 4000;\n\n// Copies the contents of `arr`\nconst buf1 = Buffer.from(arr);\n// Shares memory with `arr`\nconst buf2 = Buffer.from(arr.buffer);\n\nconsole.log(buf1);\n// Prints: &#x3C;Buffer 88 a0>\nconsole.log(buf2);\n// Prints: &#x3C;Buffer 88 13 a0 0f>\n\narr[1] = 6000;\n\nconsole.log(buf1);\n// Prints: &#x3C;Buffer 88 a0>\nconsole.log(buf2);\n// Prints: &#x3C;Buffer 88 13 70 17>\n</code></pre>\n<p>Note that when creating a <code>Buffer</code> using a <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray\"><code>TypedArray</code></a>'s <code>.buffer</code>, it is\npossible to use only a portion of the underlying <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer\"><code>ArrayBuffer</code></a> by passing in\n<code>byteOffset</code> and <code>length</code> parameters.</p>\n<pre><code class=\"language-js\">const arr = new Uint16Array(20);\nconst buf = Buffer.from(arr.buffer, 0, 16);\n\nconsole.log(buf.length);\n// Prints: 16\n</code></pre>\n<p>The <code>Buffer.from()</code> and <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/from\"><code>TypedArray.from()</code></a> have different signatures and\nimplementations. Specifically, the <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray\"><code>TypedArray</code></a> variants accept a second\nargument that is a mapping function that is invoked on every element of the\ntyped array:</p>\n<ul>\n<li><code>TypedArray.from(source[, mapFn[, thisArg]])</code></li>\n</ul>\n<p>The <code>Buffer.from()</code> method, however, does not support the use of a mapping\nfunction:</p>\n<ul>\n<li><a href=\"#buffer_class_method_buffer_from_array\"><code>Buffer.from(array)</code></a></li>\n<li><a href=\"#buffer_class_method_buffer_from_buffer\"><code>Buffer.from(buffer)</code></a></li>\n<li><a href=\"#buffer_class_method_buffer_from_arraybuffer_byteoffset_length\"><code>Buffer.from(arrayBuffer[, byteOffset[, length]])</code></a></li>\n<li><a href=\"#buffer_class_method_buffer_from_string_encoding\"><code>Buffer.from(string[, encoding])</code></a></li>\n</ul>",
          "type": "module",
          "displayName": "Buffers and TypedArray"
        },
        {
          "textRaw": "Buffers and iteration",
          "name": "buffers_and_iteration",
          "desc": "<p><code>Buffer</code> instances can be iterated over using <code>for..of</code> syntax:</p>\n<pre><code class=\"language-js\">const buf = Buffer.from([1, 2, 3]);\n\n// Prints:\n//   1\n//   2\n//   3\nfor (const b of buf) {\n  console.log(b);\n}\n</code></pre>\n<p>Additionally, the <a href=\"#buffer_buf_values\"><code>buf.values()</code></a>, <a href=\"#buffer_buf_keys\"><code>buf.keys()</code></a>, and\n<a href=\"#buffer_buf_entries\"><code>buf.entries()</code></a> methods can be used to create iterators.</p>",
          "type": "module",
          "displayName": "Buffers and iteration"
        },
        {
          "textRaw": "Buffer Constants",
          "name": "buffer_constants",
          "meta": {
            "added": [
              "v8.2.0"
            ],
            "changes": []
          },
          "desc": "<p>Note that <code>buffer.constants</code> is a property on the <code>buffer</code> module returned by\n<code>require('buffer')</code>, not on the <code>Buffer</code> global or a <code>Buffer</code> instance.</p>",
          "properties": [
            {
              "textRaw": "`MAX_LENGTH` {integer} The largest size allowed for a single `Buffer` instance.",
              "type": "integer",
              "name": "MAX_LENGTH",
              "meta": {
                "added": [
                  "v8.2.0"
                ],
                "changes": []
              },
              "desc": "<p>On 32-bit architectures, this value is <code>(2^30)-1</code> (~1GB).\nOn 64-bit architectures, this value is <code>(2^31)-1</code> (~2GB).</p>\n<p>This value is also available as <a href=\"#buffer_buffer_kmaxlength\"><code>buffer.kMaxLength</code></a>.</p>",
              "shortDesc": "The largest size allowed for a single `Buffer` instance."
            },
            {
              "textRaw": "`MAX_STRING_LENGTH` {integer} The largest length allowed for a single `string` instance.",
              "type": "integer",
              "name": "MAX_STRING_LENGTH",
              "meta": {
                "added": [
                  "v8.2.0"
                ],
                "changes": []
              },
              "desc": "<p>Represents the largest <code>length</code> that a <code>string</code> primitive can have, counted\nin UTF-16 code units.</p>\n<p>This value may depend on the JS engine that is being used.</p>",
              "shortDesc": "The largest length allowed for a single `string` instance."
            }
          ],
          "type": "module",
          "displayName": "Buffer Constants"
        }
      ],
      "classes": [
        {
          "textRaw": "Class: Buffer",
          "type": "class",
          "name": "Buffer",
          "desc": "<p>The <code>Buffer</code> class is a global type for dealing with binary data directly.\nIt can be constructed in a variety of ways.</p>",
          "classMethods": [
            {
              "textRaw": "Class Method: Buffer.alloc(size[, fill[, encoding]])",
              "type": "classMethod",
              "name": "alloc",
              "meta": {
                "added": [
                  "v5.10.0"
                ],
                "changes": [
                  {
                    "version": "v10.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/18129",
                    "description": "Attempting to fill a non-zero length buffer with a zero length buffer triggers a thrown exception."
                  },
                  {
                    "version": "v10.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/17427",
                    "description": "Specifying an invalid string for `fill` triggers a thrown exception."
                  },
                  {
                    "version": "v8.9.3",
                    "pr-url": "https://github.com/nodejs/node/pull/17428",
                    "description": "Specifying an invalid string for `fill` now results in a zero-filled buffer."
                  }
                ]
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`size` {integer} The desired length of the new `Buffer`.",
                      "name": "size",
                      "type": "integer",
                      "desc": "The desired length of the new `Buffer`."
                    },
                    {
                      "textRaw": "`fill` {string|Buffer|integer} A value to pre-fill the new `Buffer` with. **Default:** `0`.",
                      "name": "fill",
                      "type": "string|Buffer|integer",
                      "default": "`0`",
                      "desc": "A value to pre-fill the new `Buffer` with.",
                      "optional": true
                    },
                    {
                      "textRaw": "`encoding` {string} If `fill` is a string, this is its encoding. **Default:** `'utf8'`.",
                      "name": "encoding",
                      "type": "string",
                      "default": "`'utf8'`",
                      "desc": "If `fill` is a string, this is its encoding.",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Allocates a new <code>Buffer</code> of <code>size</code> bytes. If <code>fill</code> is <code>undefined</code>, the\n<code>Buffer</code> will be <em>zero-filled</em>.</p>\n<pre><code class=\"language-js\">const buf = Buffer.alloc(5);\n\nconsole.log(buf);\n// Prints: &#x3C;Buffer 00 00 00 00 00>\n</code></pre>\n<p>Allocates a new <code>Buffer</code> of <code>size</code> bytes. If <code>size</code> is larger than\n<a href=\"#buffer_buffer_constants_max_length\"><code>buffer.constants.MAX_LENGTH</code></a> or smaller than 0, <a href=\"errors.html#ERR_INVALID_OPT_VALUE\"><code>ERR_INVALID_OPT_VALUE</code></a> is\nthrown. A zero-length <code>Buffer</code> is created if <code>size</code> is 0.</p>\n<p>If <code>fill</code> is specified, the allocated <code>Buffer</code> will be initialized by calling\n<a href=\"#buffer_buf_fill_value_offset_end_encoding\"><code>buf.fill(fill)</code></a>.</p>\n<pre><code class=\"language-js\">const buf = Buffer.alloc(5, 'a');\n\nconsole.log(buf);\n// Prints: &#x3C;Buffer 61 61 61 61 61>\n</code></pre>\n<p>If both <code>fill</code> and <code>encoding</code> are specified, the allocated <code>Buffer</code> will be\ninitialized by calling <a href=\"#buffer_buf_fill_value_offset_end_encoding\"><code>buf.fill(fill, encoding)</code></a>.</p>\n<pre><code class=\"language-js\">const buf = Buffer.alloc(11, 'aGVsbG8gd29ybGQ=', 'base64');\n\nconsole.log(buf);\n// Prints: &#x3C;Buffer 68 65 6c 6c 6f 20 77 6f 72 6c 64>\n</code></pre>\n<p>Calling <a href=\"#buffer_class_method_buffer_alloc_size_fill_encoding\"><code>Buffer.alloc()</code></a> can be significantly slower than the alternative\n<a href=\"#buffer_class_method_buffer_allocunsafe_size\"><code>Buffer.allocUnsafe()</code></a> but ensures that the newly created <code>Buffer</code> instance\ncontents will <em>never contain sensitive data</em>.</p>\n<p>A <code>TypeError</code> will be thrown if <code>size</code> is not a number.</p>"
            },
            {
              "textRaw": "Class Method: Buffer.allocUnsafe(size)",
              "type": "classMethod",
              "name": "allocUnsafe",
              "meta": {
                "added": [
                  "v5.10.0"
                ],
                "changes": [
                  {
                    "version": "v7.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/7079",
                    "description": "Passing a negative `size` will now throw an error."
                  }
                ]
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`size` {integer} The desired length of the new `Buffer`.",
                      "name": "size",
                      "type": "integer",
                      "desc": "The desired length of the new `Buffer`."
                    }
                  ]
                }
              ],
              "desc": "<p>Allocates a new <code>Buffer</code> of <code>size</code> bytes. If <code>size</code> is larger than\n<a href=\"#buffer_buffer_constants_max_length\"><code>buffer.constants.MAX_LENGTH</code></a> or smaller than 0, <a href=\"errors.html#ERR_INVALID_OPT_VALUE\"><code>ERR_INVALID_OPT_VALUE</code></a> is\nthrown. A zero-length <code>Buffer</code> is created if <code>size</code> is 0.</p>\n<p>The underlying memory for <code>Buffer</code> instances created in this way is <em>not\ninitialized</em>. The contents of the newly created <code>Buffer</code> are unknown and\n<em>may contain sensitive data</em>. Use <a href=\"#buffer_class_method_buffer_alloc_size_fill_encoding\"><code>Buffer.alloc()</code></a> instead to initialize\n<code>Buffer</code> instances with zeroes.</p>\n<pre><code class=\"language-js\">const buf = Buffer.allocUnsafe(10);\n\nconsole.log(buf);\n// Prints: (contents may vary): &#x3C;Buffer a0 8b 28 3f 01 00 00 00 50 32>\n\nbuf.fill(0);\n\nconsole.log(buf);\n// Prints: &#x3C;Buffer 00 00 00 00 00 00 00 00 00 00>\n</code></pre>\n<p>A <code>TypeError</code> will be thrown if <code>size</code> is not a number.</p>\n<p>Note that the <code>Buffer</code> module pre-allocates an internal <code>Buffer</code> instance of\nsize <a href=\"#buffer_class_property_buffer_poolsize\"><code>Buffer.poolSize</code></a> that is used as a pool for the fast allocation of new\n<code>Buffer</code> instances created using <a href=\"#buffer_class_method_buffer_allocunsafe_size\"><code>Buffer.allocUnsafe()</code></a> and the deprecated\n<code>new Buffer(size)</code> constructor only when <code>size</code> is less than or equal to\n<code>Buffer.poolSize >> 1</code> (floor of <a href=\"#buffer_class_property_buffer_poolsize\"><code>Buffer.poolSize</code></a> divided by two).</p>\n<p>Use of this pre-allocated internal memory pool is a key difference between\ncalling <code>Buffer.alloc(size, fill)</code> vs. <code>Buffer.allocUnsafe(size).fill(fill)</code>.\nSpecifically, <code>Buffer.alloc(size, fill)</code> will <em>never</em> use the internal <code>Buffer</code>\npool, while <code>Buffer.allocUnsafe(size).fill(fill)</code> <em>will</em> use the internal\n<code>Buffer</code> pool if <code>size</code> is less than or equal to half <a href=\"#buffer_class_property_buffer_poolsize\"><code>Buffer.poolSize</code></a>. The\ndifference is subtle but can be important when an application requires the\nadditional performance that <a href=\"#buffer_class_method_buffer_allocunsafe_size\"><code>Buffer.allocUnsafe()</code></a> provides.</p>"
            },
            {
              "textRaw": "Class Method: Buffer.allocUnsafeSlow(size)",
              "type": "classMethod",
              "name": "allocUnsafeSlow",
              "meta": {
                "added": [
                  "v5.12.0"
                ],
                "changes": []
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`size` {integer} The desired length of the new `Buffer`.",
                      "name": "size",
                      "type": "integer",
                      "desc": "The desired length of the new `Buffer`."
                    }
                  ]
                }
              ],
              "desc": "<p>Allocates a new <code>Buffer</code> of <code>size</code> bytes. If <code>size</code> is larger than\n<a href=\"#buffer_buffer_constants_max_length\"><code>buffer.constants.MAX_LENGTH</code></a> or smaller than 0, <a href=\"errors.html#ERR_INVALID_OPT_VALUE\"><code>ERR_INVALID_OPT_VALUE</code></a> is\nthrown. A zero-length <code>Buffer</code> is created if <code>size</code> is 0.</p>\n<p>The underlying memory for <code>Buffer</code> instances created in this way is <em>not\ninitialized</em>. The contents of the newly created <code>Buffer</code> are unknown and\n<em>may contain sensitive data</em>. Use <a href=\"#buffer_buf_fill_value_offset_end_encoding\"><code>buf.fill(0)</code></a> to initialize\nsuch <code>Buffer</code> instances with zeroes.</p>\n<p>When using <a href=\"#buffer_class_method_buffer_allocunsafe_size\"><code>Buffer.allocUnsafe()</code></a> to allocate new <code>Buffer</code> instances,\nallocations under 4KB are sliced from a single pre-allocated <code>Buffer</code>. This\nallows applications to avoid the garbage collection overhead of creating many\nindividually allocated <code>Buffer</code> instances. This approach improves both\nperformance and memory usage by eliminating the need to track and clean up as\nmany persistent objects.</p>\n<p>However, in the case where a developer may need to retain a small chunk of\nmemory from a pool for an indeterminate amount of time, it may be appropriate\nto create an un-pooled <code>Buffer</code> instance using <code>Buffer.allocUnsafeSlow()</code> and\nthen copying out the relevant bits.</p>\n<pre><code class=\"language-js\">// Need to keep around a few small chunks of memory\nconst store = [];\n\nsocket.on('readable', () => {\n  const data = socket.read();\n\n  // Allocate for retained data\n  const sb = Buffer.allocUnsafeSlow(10);\n\n  // Copy the data into the new allocation\n  data.copy(sb, 0, 0, 10);\n\n  store.push(sb);\n});\n</code></pre>\n<p><code>Buffer.allocUnsafeSlow()</code> should be used only as a last resort after a\ndeveloper has observed undue memory retention in their applications.</p>\n<p>A <code>TypeError</code> will be thrown if <code>size</code> is not a number.</p>"
            },
            {
              "textRaw": "Class Method: Buffer.byteLength(string[, encoding])",
              "type": "classMethod",
              "name": "byteLength",
              "meta": {
                "added": [
                  "v0.1.90"
                ],
                "changes": [
                  {
                    "version": "v7.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/8946",
                    "description": "Passing invalid input will now throw an error."
                  },
                  {
                    "version": "v5.10.0",
                    "pr-url": "https://github.com/nodejs/node/pull/5255",
                    "description": "The `string` parameter can now be any `TypedArray`, `DataView` or `ArrayBuffer`."
                  }
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {integer} The number of bytes contained within `string`.",
                    "name": "return",
                    "type": "integer",
                    "desc": "The number of bytes contained within `string`."
                  },
                  "params": [
                    {
                      "textRaw": "`string` {string|Buffer|TypedArray|DataView|ArrayBuffer|SharedArrayBuffer} A value to calculate the length of.",
                      "name": "string",
                      "type": "string|Buffer|TypedArray|DataView|ArrayBuffer|SharedArrayBuffer",
                      "desc": "A value to calculate the length of."
                    },
                    {
                      "textRaw": "`encoding` {string} If `string` is a string, this is its encoding. **Default:** `'utf8'`.",
                      "name": "encoding",
                      "type": "string",
                      "default": "`'utf8'`",
                      "desc": "If `string` is a string, this is its encoding.",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Returns the actual byte length of a string. This is not the same as\n<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/length\"><code>String.prototype.length</code></a> since that returns the number of <em>characters</em> in\na string.</p>\n<p>For <code>'base64'</code> and <code>'hex'</code>, this function assumes valid input. For strings that\ncontain non-Base64/Hex-encoded data (e.g. whitespace), the return value might be\ngreater than the length of a <code>Buffer</code> created from the string.</p>\n<pre><code class=\"language-js\">const str = '\\u00bd + \\u00bc = \\u00be';\n\nconsole.log(`${str}: ${str.length} characters, ` +\n            `${Buffer.byteLength(str, 'utf8')} bytes`);\n// Prints: ½ + ¼ = ¾: 9 characters, 12 bytes\n</code></pre>\n<p>When <code>string</code> is a <code>Buffer</code>/<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView\"><code>DataView</code></a>/<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray\"><code>TypedArray</code></a>/<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer\"><code>ArrayBuffer</code></a>/\n<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer\"><code>SharedArrayBuffer</code></a>, the actual byte length is returned.</p>"
            },
            {
              "textRaw": "Class Method: Buffer.compare(buf1, buf2)",
              "type": "classMethod",
              "name": "compare",
              "meta": {
                "added": [
                  "v0.11.13"
                ],
                "changes": [
                  {
                    "version": "v8.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/10236",
                    "description": "The arguments can now be `Uint8Array`s."
                  }
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {integer}",
                    "name": "return",
                    "type": "integer"
                  },
                  "params": [
                    {
                      "textRaw": "`buf1` {Buffer|Uint8Array}",
                      "name": "buf1",
                      "type": "Buffer|Uint8Array"
                    },
                    {
                      "textRaw": "`buf2` {Buffer|Uint8Array}",
                      "name": "buf2",
                      "type": "Buffer|Uint8Array"
                    }
                  ]
                }
              ],
              "desc": "<p>Compares <code>buf1</code> to <code>buf2</code> typically for the purpose of sorting arrays of\n<code>Buffer</code> instances. This is equivalent to calling\n<a href=\"#buffer_buf_compare_target_targetstart_targetend_sourcestart_sourceend\"><code>buf1.compare(buf2)</code></a>.</p>\n<pre><code class=\"language-js\">const buf1 = Buffer.from('1234');\nconst buf2 = Buffer.from('0123');\nconst arr = [buf1, buf2];\n\nconsole.log(arr.sort(Buffer.compare));\n// Prints: [ &#x3C;Buffer 30 31 32 33>, &#x3C;Buffer 31 32 33 34> ]\n// (This result is equal to: [buf2, buf1])\n</code></pre>"
            },
            {
              "textRaw": "Class Method: Buffer.concat(list[, totalLength])",
              "type": "classMethod",
              "name": "concat",
              "meta": {
                "added": [
                  "v0.7.11"
                ],
                "changes": [
                  {
                    "version": "v8.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/10236",
                    "description": "The elements of `list` can now be `Uint8Array`s."
                  }
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {Buffer}",
                    "name": "return",
                    "type": "Buffer"
                  },
                  "params": [
                    {
                      "textRaw": "`list` {Buffer[] | Uint8Array[]} List of `Buffer` or [`Uint8Array`] instances to concat.",
                      "name": "list",
                      "type": "Buffer[] | Uint8Array[]",
                      "desc": "List of `Buffer` or [`Uint8Array`] instances to concat."
                    },
                    {
                      "textRaw": "`totalLength` {integer} Total length of the `Buffer` instances in `list` when concatenated.",
                      "name": "totalLength",
                      "type": "integer",
                      "desc": "Total length of the `Buffer` instances in `list` when concatenated.",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Returns a new <code>Buffer</code> which is the result of concatenating all the <code>Buffer</code>\ninstances in the <code>list</code> together.</p>\n<p>If the list has no items, or if the <code>totalLength</code> is 0, then a new zero-length\n<code>Buffer</code> is returned.</p>\n<p>If <code>totalLength</code> is not provided, it is calculated from the <code>Buffer</code> instances\nin <code>list</code>. This however causes an additional loop to be executed in order to\ncalculate the <code>totalLength</code>, so it is faster to provide the length explicitly if\nit is already known.</p>\n<p>If <code>totalLength</code> is provided, it is coerced to an unsigned integer. If the\ncombined length of the <code>Buffer</code>s in <code>list</code> exceeds <code>totalLength</code>, the result is\ntruncated to <code>totalLength</code>.</p>\n<pre><code class=\"language-js\">// Create a single `Buffer` from a list of three `Buffer` instances.\n\nconst buf1 = Buffer.alloc(10);\nconst buf2 = Buffer.alloc(14);\nconst buf3 = Buffer.alloc(18);\nconst totalLength = buf1.length + buf2.length + buf3.length;\n\nconsole.log(totalLength);\n// Prints: 42\n\nconst bufA = Buffer.concat([buf1, buf2, buf3], totalLength);\n\nconsole.log(bufA);\n// Prints: &#x3C;Buffer 00 00 00 00 ...>\nconsole.log(bufA.length);\n// Prints: 42\n</code></pre>"
            },
            {
              "textRaw": "Class Method: Buffer.from(array)",
              "type": "classMethod",
              "name": "from",
              "meta": {
                "added": [
                  "v5.10.0"
                ],
                "changes": []
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`array` {integer[]}",
                      "name": "array",
                      "type": "integer[]"
                    }
                  ]
                }
              ],
              "desc": "<p>Allocates a new <code>Buffer</code> using an <code>array</code> of octets.</p>\n<pre><code class=\"language-js\">// Creates a new Buffer containing UTF-8 bytes of the string 'buffer'\nconst buf = Buffer.from([0x62, 0x75, 0x66, 0x66, 0x65, 0x72]);\n</code></pre>\n<p>A <code>TypeError</code> will be thrown if <code>array</code> is not an <code>Array</code>.</p>"
            },
            {
              "textRaw": "Class Method: Buffer.from(arrayBuffer[, byteOffset[, length]])",
              "type": "classMethod",
              "name": "from",
              "meta": {
                "added": [
                  "v5.10.0"
                ],
                "changes": []
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`arrayBuffer` {ArrayBuffer|SharedArrayBuffer} An [`ArrayBuffer`], [`SharedArrayBuffer`], or the `.buffer` property of a [`TypedArray`].",
                      "name": "arrayBuffer",
                      "type": "ArrayBuffer|SharedArrayBuffer",
                      "desc": "An [`ArrayBuffer`], [`SharedArrayBuffer`], or the `.buffer` property of a [`TypedArray`]."
                    },
                    {
                      "textRaw": "`byteOffset` {integer} Index of first byte to expose. **Default:** `0`.",
                      "name": "byteOffset",
                      "type": "integer",
                      "default": "`0`",
                      "desc": "Index of first byte to expose.",
                      "optional": true
                    },
                    {
                      "textRaw": "`length` {integer} Number of bytes to expose. **Default:** `arrayBuffer.length - byteOffset`.",
                      "name": "length",
                      "type": "integer",
                      "default": "`arrayBuffer.length - byteOffset`",
                      "desc": "Number of bytes to expose.",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>This creates a view of the <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer\"><code>ArrayBuffer</code></a> without copying the underlying\nmemory. For example, when passed a reference to the <code>.buffer</code> property of a\n<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray\"><code>TypedArray</code></a> instance, the newly created <code>Buffer</code> will share the same\nallocated memory as the <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray\"><code>TypedArray</code></a>.</p>\n<pre><code class=\"language-js\">const arr = new Uint16Array(2);\n\narr[0] = 5000;\narr[1] = 4000;\n\n// Shares memory with `arr`\nconst buf = Buffer.from(arr.buffer);\n\nconsole.log(buf);\n// Prints: &#x3C;Buffer 88 13 a0 0f>\n\n// Changing the original Uint16Array changes the Buffer also\narr[1] = 6000;\n\nconsole.log(buf);\n// Prints: &#x3C;Buffer 88 13 70 17>\n</code></pre>\n<p>The optional <code>byteOffset</code> and <code>length</code> arguments specify a memory range within\nthe <code>arrayBuffer</code> that will be shared by the <code>Buffer</code>.</p>\n<pre><code class=\"language-js\">const ab = new ArrayBuffer(10);\nconst buf = Buffer.from(ab, 0, 2);\n\nconsole.log(buf.length);\n// Prints: 2\n</code></pre>\n<p>A <code>TypeError</code> will be thrown if <code>arrayBuffer</code> is not an <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer\"><code>ArrayBuffer</code></a> or a\n<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer\"><code>SharedArrayBuffer</code></a>.</p>"
            },
            {
              "textRaw": "Class Method: Buffer.from(buffer)",
              "type": "classMethod",
              "name": "from",
              "meta": {
                "added": [
                  "v5.10.0"
                ],
                "changes": []
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`buffer` {Buffer|Uint8Array} An existing `Buffer` or [`Uint8Array`] from which to copy data.",
                      "name": "buffer",
                      "type": "Buffer|Uint8Array",
                      "desc": "An existing `Buffer` or [`Uint8Array`] from which to copy data."
                    }
                  ]
                }
              ],
              "desc": "<p>Copies the passed <code>buffer</code> data onto a new <code>Buffer</code> instance.</p>\n<pre><code class=\"language-js\">const buf1 = Buffer.from('buffer');\nconst buf2 = Buffer.from(buf1);\n\nbuf1[0] = 0x61;\n\nconsole.log(buf1.toString());\n// Prints: auffer\nconsole.log(buf2.toString());\n// Prints: buffer\n</code></pre>\n<p>A <code>TypeError</code> will be thrown if <code>buffer</code> is not a <code>Buffer</code>.</p>"
            },
            {
              "textRaw": "Class Method: Buffer.from(string[, encoding])",
              "type": "classMethod",
              "name": "from",
              "meta": {
                "added": [
                  "v5.10.0"
                ],
                "changes": []
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`string` {string} A string to encode.",
                      "name": "string",
                      "type": "string",
                      "desc": "A string to encode."
                    },
                    {
                      "textRaw": "`encoding` {string} The encoding of `string`. **Default:** `'utf8'`.",
                      "name": "encoding",
                      "type": "string",
                      "default": "`'utf8'`",
                      "desc": "The encoding of `string`.",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Creates a new <code>Buffer</code> containing <code>string</code>. The <code>encoding</code> parameter identifies\nthe character encoding of <code>string</code>.</p>\n<pre><code class=\"language-js\">const buf1 = Buffer.from('this is a tést');\nconst buf2 = Buffer.from('7468697320697320612074c3a97374', 'hex');\n\nconsole.log(buf1.toString());\n// Prints: this is a tést\nconsole.log(buf2.toString());\n// Prints: this is a tést\nconsole.log(buf1.toString('ascii'));\n// Prints: this is a tC)st\n</code></pre>\n<p>A <code>TypeError</code> will be thrown if <code>string</code> is not a string.</p>"
            },
            {
              "textRaw": "Class Method: Buffer.from(object[, offsetOrEncoding[, length]])",
              "type": "classMethod",
              "name": "from",
              "meta": {
                "added": [
                  "v8.2.0"
                ],
                "changes": []
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`object` {Object} An object supporting `Symbol.toPrimitive` or `valueOf()`",
                      "name": "object",
                      "type": "Object",
                      "desc": "An object supporting `Symbol.toPrimitive` or `valueOf()`"
                    },
                    {
                      "textRaw": "`offsetOrEncoding` {number|string} A byte-offset or encoding, depending on the value returned either by `object.valueOf()` or `object[Symbol.toPrimitive]()`.",
                      "name": "offsetOrEncoding",
                      "type": "number|string",
                      "desc": "A byte-offset or encoding, depending on the value returned either by `object.valueOf()` or `object[Symbol.toPrimitive]()`.",
                      "optional": true
                    },
                    {
                      "textRaw": "`length` {number} A length, depending on the value returned either by `object.valueOf()` or `object[Symbol.toPrimitive]()`.",
                      "name": "length",
                      "type": "number",
                      "desc": "A length, depending on the value returned either by `object.valueOf()` or `object[Symbol.toPrimitive]()`.",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>For objects whose <code>valueOf()</code> function returns a value not strictly equal to\n<code>object</code>, returns <code>Buffer.from(object.valueOf(), offsetOrEncoding, length)</code>.</p>\n<pre><code class=\"language-js\">const buf = Buffer.from(new String('this is a test'));\n// Prints: &#x3C;Buffer 74 68 69 73 20 69 73 20 61 20 74 65 73 74>\n</code></pre>\n<p>For objects that support <code>Symbol.toPrimitive</code>, returns\n<code>Buffer.from(object[Symbol.toPrimitive](), offsetOrEncoding, length)</code>.</p>\n<pre><code class=\"language-js\">class Foo {\n  [Symbol.toPrimitive]() {\n    return 'this is a test';\n  }\n}\n\nconst buf = Buffer.from(new Foo(), 'utf8');\n// Prints: &#x3C;Buffer 74 68 69 73 20 69 73 20 61 20 74 65 73 74>\n</code></pre>"
            },
            {
              "textRaw": "Class Method: Buffer.isBuffer(obj)",
              "type": "classMethod",
              "name": "isBuffer",
              "meta": {
                "added": [
                  "v0.1.101"
                ],
                "changes": []
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {boolean}",
                    "name": "return",
                    "type": "boolean"
                  },
                  "params": [
                    {
                      "textRaw": "`obj` {Object}",
                      "name": "obj",
                      "type": "Object"
                    }
                  ]
                }
              ],
              "desc": "<p>Returns <code>true</code> if <code>obj</code> is a <code>Buffer</code>, <code>false</code> otherwise.</p>"
            },
            {
              "textRaw": "Class Method: Buffer.isEncoding(encoding)",
              "type": "classMethod",
              "name": "isEncoding",
              "meta": {
                "added": [
                  "v0.9.1"
                ],
                "changes": []
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {boolean}",
                    "name": "return",
                    "type": "boolean"
                  },
                  "params": [
                    {
                      "textRaw": "`encoding` {string} A character encoding name to check.",
                      "name": "encoding",
                      "type": "string",
                      "desc": "A character encoding name to check."
                    }
                  ]
                }
              ],
              "desc": "<p>Returns <code>true</code> if <code>encoding</code> contains a supported character encoding, or <code>false</code>\notherwise.</p>"
            }
          ],
          "properties": [
            {
              "textRaw": "`poolSize` {integer} **Default:** `8192`",
              "type": "integer",
              "name": "poolSize",
              "meta": {
                "added": [
                  "v0.11.3"
                ],
                "changes": []
              },
              "default": "`8192`",
              "desc": "<p>This is the size (in bytes) of pre-allocated internal <code>Buffer</code> instances used\nfor pooling. This value may be modified.</p>"
            },
            {
              "textRaw": "buf[index]",
              "name": "[index]",
              "meta": {
                "type": "property",
                "name": [
                  "index"
                ],
                "changes": []
              },
              "desc": "<p>The index operator <code>[index]</code> can be used to get and set the octet at position\n<code>index</code> in <code>buf</code>. The values refer to individual bytes, so the legal value\nrange is between <code>0x00</code> and <code>0xFF</code> (hex) or <code>0</code> and <code>255</code> (decimal).</p>\n<p>This operator is inherited from <code>Uint8Array</code>, so its behavior on out-of-bounds\naccess is the same as <code>UInt8Array</code> - that is, getting returns <code>undefined</code> and\nsetting does nothing.</p>\n<pre><code class=\"language-js\">// Copy an ASCII string into a `Buffer` one byte at a time.\n\nconst str = 'Node.js';\nconst buf = Buffer.allocUnsafe(str.length);\n\nfor (let i = 0; i &#x3C; str.length; i++) {\n  buf[i] = str.charCodeAt(i);\n}\n\nconsole.log(buf.toString('ascii'));\n// Prints: Node.js\n</code></pre>"
            },
            {
              "textRaw": "`buffer` {ArrayBuffer} The underlying `ArrayBuffer` object based on which this `Buffer` object is created.",
              "type": "ArrayBuffer",
              "name": "buffer",
              "desc": "<pre><code class=\"language-js\">const arrayBuffer = new ArrayBuffer(16);\nconst buffer = Buffer.from(arrayBuffer);\n\nconsole.log(buffer.buffer === arrayBuffer);\n// Prints: true\n</code></pre>",
              "shortDesc": "The underlying `ArrayBuffer` object based on which this `Buffer` object is created."
            },
            {
              "textRaw": "`byteOffset` {integer} The `byteOffset` on the underlying `ArrayBuffer` object based on which this `Buffer` object is created.",
              "type": "integer",
              "name": "byteOffset",
              "desc": "<p>When setting <code>byteOffset</code> in <code>Buffer.from(ArrayBuffer, byteOffset, length)</code>\nor sometimes when allocating a buffer smaller than <code>Buffer.poolSize</code> the\nbuffer doesn't start from a zero offset on the underlying <code>ArrayBuffer</code>.</p>\n<p>This can cause problems when accessing the underlying <code>ArrayBuffer</code> directly\nusing <code>buf.buffer</code>, as the first bytes in this <code>ArrayBuffer</code> may be unrelated\nto the <code>buf</code> object itself.</p>\n<p>A common issue is when casting a <code>Buffer</code> object to a <code>TypedArray</code> object,\nin this case one needs to specify the <code>byteOffset</code> correctly:</p>\n<pre><code class=\"language-js\">// Create a buffer smaller than `Buffer.poolSize`.\nconst nodeBuffer = new Buffer.from([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]);\n\n// When casting the Node.js Buffer to an Int8 TypedArray remember to use the\n// byteOffset.\nnew Int8Array(nodeBuffer.buffer, nodeBuffer.byteOffset, nodeBuffer.length);\n</code></pre>",
              "shortDesc": "The `byteOffset` on the underlying `ArrayBuffer` object based on which this `Buffer` object is created."
            },
            {
              "textRaw": "`length` {integer}",
              "type": "integer",
              "name": "length",
              "meta": {
                "added": [
                  "v0.1.90"
                ],
                "changes": []
              },
              "desc": "<p>Returns the amount of memory allocated for <code>buf</code> in bytes. Note that this\ndoes not necessarily reflect the amount of \"usable\" data within <code>buf</code>.</p>\n<pre><code class=\"language-js\">// Create a `Buffer` and write a shorter ASCII string to it.\n\nconst buf = Buffer.alloc(1234);\n\nconsole.log(buf.length);\n// Prints: 1234\n\nbuf.write('some string', 0, 'ascii');\n\nconsole.log(buf.length);\n// Prints: 1234\n</code></pre>\n<p>While the <code>length</code> property is not immutable, changing the value of <code>length</code>\ncan result in undefined and inconsistent behavior. Applications that wish to\nmodify the length of a <code>Buffer</code> should therefore treat <code>length</code> as read-only and\nuse <a href=\"#buffer_buf_slice_start_end\"><code>buf.slice()</code></a> to create a new <code>Buffer</code>.</p>\n<pre><code class=\"language-js\">let buf = Buffer.allocUnsafe(10);\n\nbuf.write('abcdefghj', 0, 'ascii');\n\nconsole.log(buf.length);\n// Prints: 10\n\nbuf = buf.slice(0, 5);\n\nconsole.log(buf.length);\n// Prints: 5\n</code></pre>"
            },
            {
              "textRaw": "buf.parent",
              "name": "parent",
              "meta": {
                "deprecated": [
                  "v8.0.0"
                ],
                "changes": []
              },
              "stability": 0,
              "stabilityText": "Deprecated: Use [`buf.buffer`] instead.",
              "desc": "<p>The <code>buf.parent</code> property is a deprecated alias for <code>buf.buffer</code>.</p>"
            }
          ],
          "methods": [
            {
              "textRaw": "buf.compare(target[, targetStart[, targetEnd[, sourceStart[, sourceEnd]]]])",
              "type": "method",
              "name": "compare",
              "meta": {
                "added": [
                  "v0.11.13"
                ],
                "changes": [
                  {
                    "version": "v8.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/10236",
                    "description": "The `target` parameter can now be a `Uint8Array`."
                  },
                  {
                    "version": "v5.11.0",
                    "pr-url": "https://github.com/nodejs/node/pull/5880",
                    "description": "Additional parameters for specifying offsets are supported now."
                  }
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {integer}",
                    "name": "return",
                    "type": "integer"
                  },
                  "params": [
                    {
                      "textRaw": "`target` {Buffer|Uint8Array} A `Buffer` or [`Uint8Array`] with which to compare `buf`.",
                      "name": "target",
                      "type": "Buffer|Uint8Array",
                      "desc": "A `Buffer` or [`Uint8Array`] with which to compare `buf`."
                    },
                    {
                      "textRaw": "`targetStart` {integer} The offset within `target` at which to begin comparison. **Default:** `0`.",
                      "name": "targetStart",
                      "type": "integer",
                      "default": "`0`",
                      "desc": "The offset within `target` at which to begin comparison.",
                      "optional": true
                    },
                    {
                      "textRaw": "`targetEnd` {integer} The offset with `target` at which to end comparison (not inclusive). **Default:** `target.length`.",
                      "name": "targetEnd",
                      "type": "integer",
                      "default": "`target.length`",
                      "desc": "The offset with `target` at which to end comparison (not inclusive).",
                      "optional": true
                    },
                    {
                      "textRaw": "`sourceStart` {integer} The offset within `buf` at which to begin comparison. **Default:** `0`.",
                      "name": "sourceStart",
                      "type": "integer",
                      "default": "`0`",
                      "desc": "The offset within `buf` at which to begin comparison.",
                      "optional": true
                    },
                    {
                      "textRaw": "`sourceEnd` {integer} The offset within `buf` at which to end comparison (not inclusive). **Default:** [`buf.length`].",
                      "name": "sourceEnd",
                      "type": "integer",
                      "default": "[`buf.length`]",
                      "desc": "The offset within `buf` at which to end comparison (not inclusive).",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Compares <code>buf</code> with <code>target</code> and returns a number indicating whether <code>buf</code>\ncomes before, after, or is the same as <code>target</code> in sort order.\nComparison is based on the actual sequence of bytes in each <code>Buffer</code>.</p>\n<ul>\n<li><code>0</code> is returned if <code>target</code> is the same as <code>buf</code></li>\n<li><code>1</code> is returned if <code>target</code> should come <em>before</em> <code>buf</code> when sorted.</li>\n<li><code>-1</code> is returned if <code>target</code> should come <em>after</em> <code>buf</code> when sorted.</li>\n</ul>\n<pre><code class=\"language-js\">const buf1 = Buffer.from('ABC');\nconst buf2 = Buffer.from('BCD');\nconst buf3 = Buffer.from('ABCD');\n\nconsole.log(buf1.compare(buf1));\n// Prints: 0\nconsole.log(buf1.compare(buf2));\n// Prints: -1\nconsole.log(buf1.compare(buf3));\n// Prints: -1\nconsole.log(buf2.compare(buf1));\n// Prints: 1\nconsole.log(buf2.compare(buf3));\n// Prints: 1\nconsole.log([buf1, buf2, buf3].sort(Buffer.compare));\n// Prints: [ &#x3C;Buffer 41 42 43>, &#x3C;Buffer 41 42 43 44>, &#x3C;Buffer 42 43 44> ]\n// (This result is equal to: [buf1, buf3, buf2])\n</code></pre>\n<p>The optional <code>targetStart</code>, <code>targetEnd</code>, <code>sourceStart</code>, and <code>sourceEnd</code>\narguments can be used to limit the comparison to specific ranges within <code>target</code>\nand <code>buf</code> respectively.</p>\n<pre><code class=\"language-js\">const buf1 = Buffer.from([1, 2, 3, 4, 5, 6, 7, 8, 9]);\nconst buf2 = Buffer.from([5, 6, 7, 8, 9, 1, 2, 3, 4]);\n\nconsole.log(buf1.compare(buf2, 5, 9, 0, 4));\n// Prints: 0\nconsole.log(buf1.compare(buf2, 0, 6, 4));\n// Prints: -1\nconsole.log(buf1.compare(buf2, 5, 6, 5));\n// Prints: 1\n</code></pre>\n<p><a href=\"errors.html#ERR_INDEX_OUT_OF_RANGE\"><code>ERR_INDEX_OUT_OF_RANGE</code></a> is thrown if <code>targetStart &#x3C; 0</code>, <code>sourceStart &#x3C; 0</code>,\n<code>targetEnd > target.byteLength</code>, or <code>sourceEnd > source.byteLength</code>.</p>"
            },
            {
              "textRaw": "buf.copy(target[, targetStart[, sourceStart[, sourceEnd]]])",
              "type": "method",
              "name": "copy",
              "meta": {
                "added": [
                  "v0.1.90"
                ],
                "changes": []
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {integer} The number of bytes copied.",
                    "name": "return",
                    "type": "integer",
                    "desc": "The number of bytes copied."
                  },
                  "params": [
                    {
                      "textRaw": "`target` {Buffer|Uint8Array} A `Buffer` or [`Uint8Array`] to copy into.",
                      "name": "target",
                      "type": "Buffer|Uint8Array",
                      "desc": "A `Buffer` or [`Uint8Array`] to copy into."
                    },
                    {
                      "textRaw": "`targetStart` {integer} The offset within `target` at which to begin writing. **Default:** `0`.",
                      "name": "targetStart",
                      "type": "integer",
                      "default": "`0`",
                      "desc": "The offset within `target` at which to begin writing.",
                      "optional": true
                    },
                    {
                      "textRaw": "`sourceStart` {integer} The offset within `buf` from which to begin copying. **Default:** `0`.",
                      "name": "sourceStart",
                      "type": "integer",
                      "default": "`0`",
                      "desc": "The offset within `buf` from which to begin copying.",
                      "optional": true
                    },
                    {
                      "textRaw": "`sourceEnd` {integer} The offset within `buf` at which to stop copying (not inclusive). **Default:** [`buf.length`].",
                      "name": "sourceEnd",
                      "type": "integer",
                      "default": "[`buf.length`]",
                      "desc": "The offset within `buf` at which to stop copying (not inclusive).",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Copies data from a region of <code>buf</code> to a region in <code>target</code> even if the <code>target</code>\nmemory region overlaps with <code>buf</code>.</p>\n<pre><code class=\"language-js\">// Create two `Buffer` instances.\nconst buf1 = Buffer.allocUnsafe(26);\nconst buf2 = Buffer.allocUnsafe(26).fill('!');\n\nfor (let i = 0; i &#x3C; 26; i++) {\n  // 97 is the decimal ASCII value for 'a'\n  buf1[i] = i + 97;\n}\n\n// Copy `buf1` bytes 16 through 19 into `buf2` starting at byte 8 of `buf2`\nbuf1.copy(buf2, 8, 16, 20);\n\nconsole.log(buf2.toString('ascii', 0, 25));\n// Prints: !!!!!!!!qrst!!!!!!!!!!!!!\n</code></pre>\n<pre><code class=\"language-js\">// Create a `Buffer` and copy data from one region to an overlapping region\n// within the same `Buffer`.\n\nconst buf = Buffer.allocUnsafe(26);\n\nfor (let i = 0; i &#x3C; 26; i++) {\n  // 97 is the decimal ASCII value for 'a'\n  buf[i] = i + 97;\n}\n\nbuf.copy(buf, 0, 4, 10);\n\nconsole.log(buf.toString());\n// Prints: efghijghijklmnopqrstuvwxyz\n</code></pre>"
            },
            {
              "textRaw": "buf.entries()",
              "type": "method",
              "name": "entries",
              "meta": {
                "added": [
                  "v1.1.0"
                ],
                "changes": []
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {Iterator}",
                    "name": "return",
                    "type": "Iterator"
                  },
                  "params": []
                }
              ],
              "desc": "<p>Creates and returns an <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols\">iterator</a> of <code>[index, byte]</code> pairs from the contents of\n<code>buf</code>.</p>\n<pre><code class=\"language-js\">// Log the entire contents of a `Buffer`.\n\nconst buf = Buffer.from('buffer');\n\nfor (const pair of buf.entries()) {\n  console.log(pair);\n}\n// Prints:\n//   [0, 98]\n//   [1, 117]\n//   [2, 102]\n//   [3, 102]\n//   [4, 101]\n//   [5, 114]\n</code></pre>"
            },
            {
              "textRaw": "buf.equals(otherBuffer)",
              "type": "method",
              "name": "equals",
              "meta": {
                "added": [
                  "v0.11.13"
                ],
                "changes": [
                  {
                    "version": "v8.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/10236",
                    "description": "The arguments can now be `Uint8Array`s."
                  }
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {boolean}",
                    "name": "return",
                    "type": "boolean"
                  },
                  "params": [
                    {
                      "textRaw": "`otherBuffer` {Buffer} A `Buffer` or [`Uint8Array`] with which to compare `buf`.",
                      "name": "otherBuffer",
                      "type": "Buffer",
                      "desc": "A `Buffer` or [`Uint8Array`] with which to compare `buf`."
                    }
                  ]
                }
              ],
              "desc": "<p>Returns <code>true</code> if both <code>buf</code> and <code>otherBuffer</code> have exactly the same bytes,\n<code>false</code> otherwise.</p>\n<pre><code class=\"language-js\">const buf1 = Buffer.from('ABC');\nconst buf2 = Buffer.from('414243', 'hex');\nconst buf3 = Buffer.from('ABCD');\n\nconsole.log(buf1.equals(buf2));\n// Prints: true\nconsole.log(buf1.equals(buf3));\n// Prints: false\n</code></pre>"
            },
            {
              "textRaw": "buf.fill(value[, offset[, end]][, encoding])",
              "type": "method",
              "name": "fill",
              "meta": {
                "added": [
                  "v0.5.0"
                ],
                "changes": [
                  {
                    "version": "v10.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/18790",
                    "description": "Negative `end` values throw an `ERR_INDEX_OUT_OF_RANGE` error."
                  },
                  {
                    "version": "v10.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/18129",
                    "description": "Attempting to fill a non-zero length buffer with a zero length buffer triggers a thrown exception."
                  },
                  {
                    "version": "v10.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/17427",
                    "description": "Specifying an invalid string for `value` triggers a thrown exception."
                  },
                  {
                    "version": "v5.7.0",
                    "pr-url": "https://github.com/nodejs/node/pull/4935",
                    "description": "The `encoding` parameter is supported now."
                  }
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {Buffer} A reference to `buf`.",
                    "name": "return",
                    "type": "Buffer",
                    "desc": "A reference to `buf`."
                  },
                  "params": [
                    {
                      "textRaw": "`value` {string|Buffer|integer} The value with which to fill `buf`.",
                      "name": "value",
                      "type": "string|Buffer|integer",
                      "desc": "The value with which to fill `buf`."
                    },
                    {
                      "textRaw": "`offset` {integer} Number of bytes to skip before starting to fill `buf`. **Default:** `0`.",
                      "name": "offset",
                      "type": "integer",
                      "default": "`0`",
                      "desc": "Number of bytes to skip before starting to fill `buf`.",
                      "optional": true
                    },
                    {
                      "textRaw": "`end` {integer} Where to stop filling `buf` (not inclusive). **Default:** [`buf.length`].",
                      "name": "end",
                      "type": "integer",
                      "default": "[`buf.length`]",
                      "desc": "Where to stop filling `buf` (not inclusive).",
                      "optional": true
                    },
                    {
                      "textRaw": "`encoding` {string} The encoding for `value` if `value` is a string. **Default:** `'utf8'`.",
                      "name": "encoding",
                      "type": "string",
                      "default": "`'utf8'`",
                      "desc": "The encoding for `value` if `value` is a string.",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Fills <code>buf</code> with the specified <code>value</code>. If the <code>offset</code> and <code>end</code> are not given,\nthe entire <code>buf</code> will be filled:</p>\n<pre><code class=\"language-js\">// Fill a `Buffer` with the ASCII character 'h'.\n\nconst b = Buffer.allocUnsafe(50).fill('h');\n\nconsole.log(b.toString());\n// Prints: hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh\n</code></pre>\n<p><code>value</code> is coerced to a <code>uint32</code> value if it is not a string or integer.</p>\n<p>If the final write of a <code>fill()</code> operation falls on a multi-byte character,\nthen only the bytes of that character that fit into <code>buf</code> are written:</p>\n<pre><code class=\"language-js\">// Fill a `Buffer` with a two-byte character.\n\nconsole.log(Buffer.allocUnsafe(3).fill('\\u0222'));\n// Prints: &#x3C;Buffer c8 a2 c8>\n</code></pre>\n<p>If <code>value</code> contains invalid characters, it is truncated; if no valid\nfill data remains, an exception is thrown:</p>\n<pre><code class=\"language-js\">const buf = Buffer.allocUnsafe(5);\n\nconsole.log(buf.fill('a'));\n// Prints: &#x3C;Buffer 61 61 61 61 61>\nconsole.log(buf.fill('aazz', 'hex'));\n// Prints: &#x3C;Buffer aa aa aa aa aa>\nconsole.log(buf.fill('zz', 'hex'));\n// Throws an exception.\n</code></pre>"
            },
            {
              "textRaw": "buf.includes(value[, byteOffset][, encoding])",
              "type": "method",
              "name": "includes",
              "meta": {
                "added": [
                  "v5.3.0"
                ],
                "changes": []
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {boolean} `true` if `value` was found in `buf`, `false` otherwise.",
                    "name": "return",
                    "type": "boolean",
                    "desc": "`true` if `value` was found in `buf`, `false` otherwise."
                  },
                  "params": [
                    {
                      "textRaw": "`value` {string|Buffer|integer} What to search for.",
                      "name": "value",
                      "type": "string|Buffer|integer",
                      "desc": "What to search for."
                    },
                    {
                      "textRaw": "`byteOffset` {integer} Where to begin searching in `buf`. **Default:** `0`.",
                      "name": "byteOffset",
                      "type": "integer",
                      "default": "`0`",
                      "desc": "Where to begin searching in `buf`.",
                      "optional": true
                    },
                    {
                      "textRaw": "`encoding` {string} If `value` is a string, this is its encoding. **Default:** `'utf8'`.",
                      "name": "encoding",
                      "type": "string",
                      "default": "`'utf8'`",
                      "desc": "If `value` is a string, this is its encoding.",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Equivalent to <a href=\"#buffer_buf_indexof_value_byteoffset_encoding\"><code>buf.indexOf() !== -1</code></a>.</p>\n<pre><code class=\"language-js\">const buf = Buffer.from('this is a buffer');\n\nconsole.log(buf.includes('this'));\n// Prints: true\nconsole.log(buf.includes('is'));\n// Prints: true\nconsole.log(buf.includes(Buffer.from('a buffer')));\n// Prints: true\nconsole.log(buf.includes(97));\n// Prints: true (97 is the decimal ASCII value for 'a')\nconsole.log(buf.includes(Buffer.from('a buffer example')));\n// Prints: false\nconsole.log(buf.includes(Buffer.from('a buffer example').slice(0, 8)));\n// Prints: true\nconsole.log(buf.includes('this', 4));\n// Prints: false\n</code></pre>"
            },
            {
              "textRaw": "buf.indexOf(value[, byteOffset][, encoding])",
              "type": "method",
              "name": "indexOf",
              "meta": {
                "added": [
                  "v1.5.0"
                ],
                "changes": [
                  {
                    "version": "v8.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/10236",
                    "description": "The `value` can now be a `Uint8Array`."
                  },
                  {
                    "version": "v5.7.0, v4.4.0",
                    "pr-url": "https://github.com/nodejs/node/pull/4803",
                    "description": "When `encoding` is being passed, the `byteOffset` parameter is no longer required."
                  }
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {integer} The index of the first occurrence of `value` in `buf`, or `-1` if `buf` does not contain `value`.",
                    "name": "return",
                    "type": "integer",
                    "desc": "The index of the first occurrence of `value` in `buf`, or `-1` if `buf` does not contain `value`."
                  },
                  "params": [
                    {
                      "textRaw": "`value` {string|Buffer|Uint8Array|integer} What to search for.",
                      "name": "value",
                      "type": "string|Buffer|Uint8Array|integer",
                      "desc": "What to search for."
                    },
                    {
                      "textRaw": "`byteOffset` {integer} Where to begin searching in `buf`. **Default:** `0`.",
                      "name": "byteOffset",
                      "type": "integer",
                      "default": "`0`",
                      "desc": "Where to begin searching in `buf`.",
                      "optional": true
                    },
                    {
                      "textRaw": "`encoding` {string} If `value` is a string, this is the encoding used to determine the binary representation of the string that will be searched for in `buf`. **Default:** `'utf8'`.",
                      "name": "encoding",
                      "type": "string",
                      "default": "`'utf8'`",
                      "desc": "If `value` is a string, this is the encoding used to determine the binary representation of the string that will be searched for in `buf`.",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>If <code>value</code> is:</p>\n<ul>\n<li>a string, <code>value</code> is interpreted according to the character encoding in\n<code>encoding</code>.</li>\n<li>a <code>Buffer</code> or <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array\"><code>Uint8Array</code></a>, <code>value</code> will be used in its entirety.\nTo compare a partial <code>Buffer</code>, use <a href=\"#buffer_buf_slice_start_end\"><code>buf.slice()</code></a>.</li>\n<li>a number, <code>value</code> will be interpreted as an unsigned 8-bit integer\nvalue between <code>0</code> and <code>255</code>.</li>\n</ul>\n<pre><code class=\"language-js\">const buf = Buffer.from('this is a buffer');\n\nconsole.log(buf.indexOf('this'));\n// Prints: 0\nconsole.log(buf.indexOf('is'));\n// Prints: 2\nconsole.log(buf.indexOf(Buffer.from('a buffer')));\n// Prints: 8\nconsole.log(buf.indexOf(97));\n// Prints: 8 (97 is the decimal ASCII value for 'a')\nconsole.log(buf.indexOf(Buffer.from('a buffer example')));\n// Prints: -1\nconsole.log(buf.indexOf(Buffer.from('a buffer example').slice(0, 8)));\n// Prints: 8\n\nconst utf16Buffer = Buffer.from('\\u039a\\u0391\\u03a3\\u03a3\\u0395', 'utf16le');\n\nconsole.log(utf16Buffer.indexOf('\\u03a3', 0, 'utf16le'));\n// Prints: 4\nconsole.log(utf16Buffer.indexOf('\\u03a3', -4, 'utf16le'));\n// Prints: 6\n</code></pre>\n<p>If <code>value</code> is not a string, number, or <code>Buffer</code>, this method will throw a\n<code>TypeError</code>. If <code>value</code> is a number, it will be coerced to a valid byte value,\nan integer between 0 and 255.</p>\n<p>If <code>byteOffset</code> is not a number, it will be coerced to a number. If the result\nof coercion is <code>NaN</code> or <code>0</code>, then the entire buffer will be searched. This\nbehavior matches <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/indexOf\"><code>String#indexOf()</code></a>.</p>\n<pre><code class=\"language-js\">const b = Buffer.from('abcdef');\n\n// Passing a value that's a number, but not a valid byte\n// Prints: 2, equivalent to searching for 99 or 'c'\nconsole.log(b.indexOf(99.9));\nconsole.log(b.indexOf(256 + 99));\n\n// Passing a byteOffset that coerces to NaN or 0\n// Prints: 1, searching the whole buffer\nconsole.log(b.indexOf('b', undefined));\nconsole.log(b.indexOf('b', {}));\nconsole.log(b.indexOf('b', null));\nconsole.log(b.indexOf('b', []));\n</code></pre>\n<p>If <code>value</code> is an empty string or empty <code>Buffer</code> and <code>byteOffset</code> is less\nthan <code>buf.length</code>, <code>byteOffset</code> will be returned. If <code>value</code> is empty and\n<code>byteOffset</code> is at least <code>buf.length</code>, <code>buf.length</code> will be returned.</p>"
            },
            {
              "textRaw": "buf.keys()",
              "type": "method",
              "name": "keys",
              "meta": {
                "added": [
                  "v1.1.0"
                ],
                "changes": []
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {Iterator}",
                    "name": "return",
                    "type": "Iterator"
                  },
                  "params": []
                }
              ],
              "desc": "<p>Creates and returns an <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols\">iterator</a> of <code>buf</code> keys (indices).</p>\n<pre><code class=\"language-js\">const buf = Buffer.from('buffer');\n\nfor (const key of buf.keys()) {\n  console.log(key);\n}\n// Prints:\n//   0\n//   1\n//   2\n//   3\n//   4\n//   5\n</code></pre>"
            },
            {
              "textRaw": "buf.lastIndexOf(value[, byteOffset][, encoding])",
              "type": "method",
              "name": "lastIndexOf",
              "meta": {
                "added": [
                  "v6.0.0"
                ],
                "changes": [
                  {
                    "version": "v8.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/10236",
                    "description": "The `value` can now be a `Uint8Array`."
                  }
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {integer} The index of the last occurrence of `value` in `buf`, or `-1` if `buf` does not contain `value`.",
                    "name": "return",
                    "type": "integer",
                    "desc": "The index of the last occurrence of `value` in `buf`, or `-1` if `buf` does not contain `value`."
                  },
                  "params": [
                    {
                      "textRaw": "`value` {string|Buffer|Uint8Array|integer} What to search for.",
                      "name": "value",
                      "type": "string|Buffer|Uint8Array|integer",
                      "desc": "What to search for."
                    },
                    {
                      "textRaw": "`byteOffset` {integer} Where to begin searching in `buf`. **Default:** [`buf.length`]` - 1`.",
                      "name": "byteOffset",
                      "type": "integer",
                      "default": "[`buf.length`]` - 1`",
                      "desc": "Where to begin searching in `buf`.",
                      "optional": true
                    },
                    {
                      "textRaw": "`encoding` {string} If `value` is a string, this is the encoding used to determine the binary representation of the string that will be searched for in `buf`. **Default:** `'utf8'`.",
                      "name": "encoding",
                      "type": "string",
                      "default": "`'utf8'`",
                      "desc": "If `value` is a string, this is the encoding used to determine the binary representation of the string that will be searched for in `buf`.",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Identical to <a href=\"#buffer_buf_indexof_value_byteoffset_encoding\"><code>buf.indexOf()</code></a>, except the last occurrence of <code>value</code> is found\nrather than the first occurrence.</p>\n<pre><code class=\"language-js\">const buf = Buffer.from('this buffer is a buffer');\n\nconsole.log(buf.lastIndexOf('this'));\n// Prints: 0\nconsole.log(buf.lastIndexOf('buffer'));\n// Prints: 17\nconsole.log(buf.lastIndexOf(Buffer.from('buffer')));\n// Prints: 17\nconsole.log(buf.lastIndexOf(97));\n// Prints: 15 (97 is the decimal ASCII value for 'a')\nconsole.log(buf.lastIndexOf(Buffer.from('yolo')));\n// Prints: -1\nconsole.log(buf.lastIndexOf('buffer', 5));\n// Prints: 5\nconsole.log(buf.lastIndexOf('buffer', 4));\n// Prints: -1\n\nconst utf16Buffer = Buffer.from('\\u039a\\u0391\\u03a3\\u03a3\\u0395', 'utf16le');\n\nconsole.log(utf16Buffer.lastIndexOf('\\u03a3', undefined, 'utf16le'));\n// Prints: 6\nconsole.log(utf16Buffer.lastIndexOf('\\u03a3', -5, 'utf16le'));\n// Prints: 4\n</code></pre>\n<p>If <code>value</code> is not a string, number, or <code>Buffer</code>, this method will throw a\n<code>TypeError</code>. If <code>value</code> is a number, it will be coerced to a valid byte value,\nan integer between 0 and 255.</p>\n<p>If <code>byteOffset</code> is not a number, it will be coerced to a number. Any arguments\nthat coerce to <code>NaN</code>, like <code>{}</code> or <code>undefined</code>, will search the whole buffer.\nThis behavior matches <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/lastIndexOf\"><code>String#lastIndexOf()</code></a>.</p>\n<pre><code class=\"language-js\">const b = Buffer.from('abcdef');\n\n// Passing a value that's a number, but not a valid byte\n// Prints: 2, equivalent to searching for 99 or 'c'\nconsole.log(b.lastIndexOf(99.9));\nconsole.log(b.lastIndexOf(256 + 99));\n\n// Passing a byteOffset that coerces to NaN\n// Prints: 1, searching the whole buffer\nconsole.log(b.lastIndexOf('b', undefined));\nconsole.log(b.lastIndexOf('b', {}));\n\n// Passing a byteOffset that coerces to 0\n// Prints: -1, equivalent to passing 0\nconsole.log(b.lastIndexOf('b', null));\nconsole.log(b.lastIndexOf('b', []));\n</code></pre>\n<p>If <code>value</code> is an empty string or empty <code>Buffer</code>, <code>byteOffset</code> will be returned.</p>"
            },
            {
              "textRaw": "buf.readDoubleBE(offset)",
              "type": "method",
              "name": "readDoubleBE",
              "meta": {
                "added": [
                  "v0.11.15"
                ],
                "changes": [
                  {
                    "version": "v10.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/18395",
                    "description": "Removed `noAssert` and no implicit coercion of the offset to `uint32` anymore."
                  }
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {number}",
                    "name": "return",
                    "type": "number"
                  },
                  "params": [
                    {
                      "textRaw": "`offset` {integer} Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 8`.",
                      "name": "offset",
                      "type": "integer",
                      "desc": "Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 8`."
                    }
                  ]
                }
              ],
              "desc": "<p>Reads a 64-bit double from <code>buf</code> at the specified <code>offset</code> with specified\nendian format (<code>readDoubleBE()</code> returns big endian, <code>readDoubleLE()</code> returns\nlittle endian).</p>\n<pre><code class=\"language-js\">const buf = Buffer.from([1, 2, 3, 4, 5, 6, 7, 8]);\n\nconsole.log(buf.readDoubleBE(0));\n// Prints: 8.20788039913184e-304\nconsole.log(buf.readDoubleLE(0));\n// Prints: 5.447603722011605e-270\nconsole.log(buf.readDoubleLE(1));\n// Throws ERR_OUT_OF_RANGE\n</code></pre>"
            },
            {
              "textRaw": "buf.readDoubleLE(offset)",
              "type": "method",
              "name": "readDoubleLE",
              "meta": {
                "added": [
                  "v0.11.15"
                ],
                "changes": [
                  {
                    "version": "v10.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/18395",
                    "description": "Removed `noAssert` and no implicit coercion of the offset to `uint32` anymore."
                  }
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {number}",
                    "name": "return",
                    "type": "number"
                  },
                  "params": [
                    {
                      "textRaw": "`offset` {integer} Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 8`.",
                      "name": "offset",
                      "type": "integer",
                      "desc": "Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 8`."
                    }
                  ]
                }
              ],
              "desc": "<p>Reads a 64-bit double from <code>buf</code> at the specified <code>offset</code> with specified\nendian format (<code>readDoubleBE()</code> returns big endian, <code>readDoubleLE()</code> returns\nlittle endian).</p>\n<pre><code class=\"language-js\">const buf = Buffer.from([1, 2, 3, 4, 5, 6, 7, 8]);\n\nconsole.log(buf.readDoubleBE(0));\n// Prints: 8.20788039913184e-304\nconsole.log(buf.readDoubleLE(0));\n// Prints: 5.447603722011605e-270\nconsole.log(buf.readDoubleLE(1));\n// Throws ERR_OUT_OF_RANGE\n</code></pre>"
            },
            {
              "textRaw": "buf.readFloatBE(offset)",
              "type": "method",
              "name": "readFloatBE",
              "meta": {
                "added": [
                  "v0.11.15"
                ],
                "changes": [
                  {
                    "version": "v10.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/18395",
                    "description": "Removed `noAssert` and no implicit coercion of the offset to `uint32` anymore."
                  }
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {number}",
                    "name": "return",
                    "type": "number"
                  },
                  "params": [
                    {
                      "textRaw": "`offset` {integer} Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 4`.",
                      "name": "offset",
                      "type": "integer",
                      "desc": "Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 4`."
                    }
                  ]
                }
              ],
              "desc": "<p>Reads a 32-bit float from <code>buf</code> at the specified <code>offset</code> with specified\nendian format (<code>readFloatBE()</code> returns big endian, <code>readFloatLE()</code> returns\nlittle endian).</p>\n<pre><code class=\"language-js\">const buf = Buffer.from([1, 2, 3, 4]);\n\nconsole.log(buf.readFloatBE(0));\n// Prints: 2.387939260590663e-38\nconsole.log(buf.readFloatLE(0));\n// Prints: 1.539989614439558e-36\nconsole.log(buf.readFloatLE(1));\n// Throws ERR_OUT_OF_RANGE\n</code></pre>"
            },
            {
              "textRaw": "buf.readFloatLE(offset)",
              "type": "method",
              "name": "readFloatLE",
              "meta": {
                "added": [
                  "v0.11.15"
                ],
                "changes": [
                  {
                    "version": "v10.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/18395",
                    "description": "Removed `noAssert` and no implicit coercion of the offset to `uint32` anymore."
                  }
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {number}",
                    "name": "return",
                    "type": "number"
                  },
                  "params": [
                    {
                      "textRaw": "`offset` {integer} Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 4`.",
                      "name": "offset",
                      "type": "integer",
                      "desc": "Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 4`."
                    }
                  ]
                }
              ],
              "desc": "<p>Reads a 32-bit float from <code>buf</code> at the specified <code>offset</code> with specified\nendian format (<code>readFloatBE()</code> returns big endian, <code>readFloatLE()</code> returns\nlittle endian).</p>\n<pre><code class=\"language-js\">const buf = Buffer.from([1, 2, 3, 4]);\n\nconsole.log(buf.readFloatBE(0));\n// Prints: 2.387939260590663e-38\nconsole.log(buf.readFloatLE(0));\n// Prints: 1.539989614439558e-36\nconsole.log(buf.readFloatLE(1));\n// Throws ERR_OUT_OF_RANGE\n</code></pre>"
            },
            {
              "textRaw": "buf.readInt8(offset)",
              "type": "method",
              "name": "readInt8",
              "meta": {
                "added": [
                  "v0.5.0"
                ],
                "changes": [
                  {
                    "version": "v10.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/18395",
                    "description": "Removed `noAssert` and no implicit coercion of the offset to `uint32` anymore."
                  }
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {integer}",
                    "name": "return",
                    "type": "integer"
                  },
                  "params": [
                    {
                      "textRaw": "`offset` {integer} Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 1`.",
                      "name": "offset",
                      "type": "integer",
                      "desc": "Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 1`."
                    }
                  ]
                }
              ],
              "desc": "<p>Reads a signed 8-bit integer from <code>buf</code> at the specified <code>offset</code>.</p>\n<p>Integers read from a <code>Buffer</code> are interpreted as two's complement signed values.</p>\n<pre><code class=\"language-js\">const buf = Buffer.from([-1, 5]);\n\nconsole.log(buf.readInt8(0));\n// Prints: -1\nconsole.log(buf.readInt8(1));\n// Prints: 5\nconsole.log(buf.readInt8(2));\n// Throws ERR_OUT_OF_RANGE\n</code></pre>"
            },
            {
              "textRaw": "buf.readInt16BE(offset)",
              "type": "method",
              "name": "readInt16BE",
              "meta": {
                "added": [
                  "v0.5.5"
                ],
                "changes": [
                  {
                    "version": "v10.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/18395",
                    "description": "Removed `noAssert` and no implicit coercion of the offset to `uint32` anymore."
                  }
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {integer}",
                    "name": "return",
                    "type": "integer"
                  },
                  "params": [
                    {
                      "textRaw": "`offset` {integer} Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 2`.",
                      "name": "offset",
                      "type": "integer",
                      "desc": "Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 2`."
                    }
                  ]
                }
              ],
              "desc": "<p>Reads a signed 16-bit integer from <code>buf</code> at the specified <code>offset</code> with\nthe specified endian format (<code>readInt16BE()</code> returns big endian,\n<code>readInt16LE()</code> returns little endian).</p>\n<p>Integers read from a <code>Buffer</code> are interpreted as two's complement signed values.</p>\n<pre><code class=\"language-js\">const buf = Buffer.from([0, 5]);\n\nconsole.log(buf.readInt16BE(0));\n// Prints: 5\nconsole.log(buf.readInt16LE(0));\n// Prints: 1280\nconsole.log(buf.readInt16LE(1));\n// Throws ERR_OUT_OF_RANGE\n</code></pre>"
            },
            {
              "textRaw": "buf.readInt16LE(offset)",
              "type": "method",
              "name": "readInt16LE",
              "meta": {
                "added": [
                  "v0.5.5"
                ],
                "changes": [
                  {
                    "version": "v10.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/18395",
                    "description": "Removed `noAssert` and no implicit coercion of the offset to `uint32` anymore."
                  }
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {integer}",
                    "name": "return",
                    "type": "integer"
                  },
                  "params": [
                    {
                      "textRaw": "`offset` {integer} Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 2`.",
                      "name": "offset",
                      "type": "integer",
                      "desc": "Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 2`."
                    }
                  ]
                }
              ],
              "desc": "<p>Reads a signed 16-bit integer from <code>buf</code> at the specified <code>offset</code> with\nthe specified endian format (<code>readInt16BE()</code> returns big endian,\n<code>readInt16LE()</code> returns little endian).</p>\n<p>Integers read from a <code>Buffer</code> are interpreted as two's complement signed values.</p>\n<pre><code class=\"language-js\">const buf = Buffer.from([0, 5]);\n\nconsole.log(buf.readInt16BE(0));\n// Prints: 5\nconsole.log(buf.readInt16LE(0));\n// Prints: 1280\nconsole.log(buf.readInt16LE(1));\n// Throws ERR_OUT_OF_RANGE\n</code></pre>"
            },
            {
              "textRaw": "buf.readInt32BE(offset)",
              "type": "method",
              "name": "readInt32BE",
              "meta": {
                "added": [
                  "v0.5.5"
                ],
                "changes": [
                  {
                    "version": "v10.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/18395",
                    "description": "Removed `noAssert` and no implicit coercion of the offset to `uint32` anymore."
                  }
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {integer}",
                    "name": "return",
                    "type": "integer"
                  },
                  "params": [
                    {
                      "textRaw": "`offset` {integer} Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 4`.",
                      "name": "offset",
                      "type": "integer",
                      "desc": "Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 4`."
                    }
                  ]
                }
              ],
              "desc": "<p>Reads a signed 32-bit integer from <code>buf</code> at the specified <code>offset</code> with\nthe specified endian format (<code>readInt32BE()</code> returns big endian,\n<code>readInt32LE()</code> returns little endian).</p>\n<p>Integers read from a <code>Buffer</code> are interpreted as two's complement signed values.</p>\n<pre><code class=\"language-js\">const buf = Buffer.from([0, 0, 0, 5]);\n\nconsole.log(buf.readInt32BE(0));\n// Prints: 5\nconsole.log(buf.readInt32LE(0));\n// Prints: 83886080\nconsole.log(buf.readInt32LE(1));\n// Throws ERR_OUT_OF_RANGE\n</code></pre>"
            },
            {
              "textRaw": "buf.readInt32LE(offset)",
              "type": "method",
              "name": "readInt32LE",
              "meta": {
                "added": [
                  "v0.5.5"
                ],
                "changes": [
                  {
                    "version": "v10.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/18395",
                    "description": "Removed `noAssert` and no implicit coercion of the offset to `uint32` anymore."
                  }
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {integer}",
                    "name": "return",
                    "type": "integer"
                  },
                  "params": [
                    {
                      "textRaw": "`offset` {integer} Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 4`.",
                      "name": "offset",
                      "type": "integer",
                      "desc": "Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 4`."
                    }
                  ]
                }
              ],
              "desc": "<p>Reads a signed 32-bit integer from <code>buf</code> at the specified <code>offset</code> with\nthe specified endian format (<code>readInt32BE()</code> returns big endian,\n<code>readInt32LE()</code> returns little endian).</p>\n<p>Integers read from a <code>Buffer</code> are interpreted as two's complement signed values.</p>\n<pre><code class=\"language-js\">const buf = Buffer.from([0, 0, 0, 5]);\n\nconsole.log(buf.readInt32BE(0));\n// Prints: 5\nconsole.log(buf.readInt32LE(0));\n// Prints: 83886080\nconsole.log(buf.readInt32LE(1));\n// Throws ERR_OUT_OF_RANGE\n</code></pre>"
            },
            {
              "textRaw": "buf.readIntBE(offset, byteLength)",
              "type": "method",
              "name": "readIntBE",
              "meta": {
                "added": [
                  "v0.11.15"
                ],
                "changes": [
                  {
                    "version": "v10.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/18395",
                    "description": "Removed `noAssert` and no implicit coercion of the offset and `byteLength` to `uint32` anymore."
                  }
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {integer}",
                    "name": "return",
                    "type": "integer"
                  },
                  "params": [
                    {
                      "textRaw": "`offset` {integer} Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - byteLength`.",
                      "name": "offset",
                      "type": "integer",
                      "desc": "Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - byteLength`."
                    },
                    {
                      "textRaw": "`byteLength` {integer} Number of bytes to read. Must satisfy `0 < byteLength <= 6`.",
                      "name": "byteLength",
                      "type": "integer",
                      "desc": "Number of bytes to read. Must satisfy `0 < byteLength <= 6`."
                    }
                  ]
                }
              ],
              "desc": "<p>Reads <code>byteLength</code> number of bytes from <code>buf</code> at the specified <code>offset</code>\nand interprets the result as a two's complement signed value. Supports up to 48\nbits of accuracy.</p>\n<pre><code class=\"language-js\">const buf = Buffer.from([0x12, 0x34, 0x56, 0x78, 0x90, 0xab]);\n\nconsole.log(buf.readIntLE(0, 6).toString(16));\n// Prints: -546f87a9cbee\nconsole.log(buf.readIntBE(0, 6).toString(16));\n// Prints: 1234567890ab\nconsole.log(buf.readIntBE(1, 6).toString(16));\n// Throws ERR_INDEX_OUT_OF_RANGE\nconsole.log(buf.readIntBE(1, 0).toString(16));\n// Throws ERR_OUT_OF_RANGE\n</code></pre>"
            },
            {
              "textRaw": "buf.readIntLE(offset, byteLength)",
              "type": "method",
              "name": "readIntLE",
              "meta": {
                "added": [
                  "v0.11.15"
                ],
                "changes": [
                  {
                    "version": "v10.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/18395",
                    "description": "Removed `noAssert` and no implicit coercion of the offset and `byteLength` to `uint32` anymore."
                  }
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {integer}",
                    "name": "return",
                    "type": "integer"
                  },
                  "params": [
                    {
                      "textRaw": "`offset` {integer} Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - byteLength`.",
                      "name": "offset",
                      "type": "integer",
                      "desc": "Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - byteLength`."
                    },
                    {
                      "textRaw": "`byteLength` {integer} Number of bytes to read. Must satisfy `0 < byteLength <= 6`.",
                      "name": "byteLength",
                      "type": "integer",
                      "desc": "Number of bytes to read. Must satisfy `0 < byteLength <= 6`."
                    }
                  ]
                }
              ],
              "desc": "<p>Reads <code>byteLength</code> number of bytes from <code>buf</code> at the specified <code>offset</code>\nand interprets the result as a two's complement signed value. Supports up to 48\nbits of accuracy.</p>\n<pre><code class=\"language-js\">const buf = Buffer.from([0x12, 0x34, 0x56, 0x78, 0x90, 0xab]);\n\nconsole.log(buf.readIntLE(0, 6).toString(16));\n// Prints: -546f87a9cbee\nconsole.log(buf.readIntBE(0, 6).toString(16));\n// Prints: 1234567890ab\nconsole.log(buf.readIntBE(1, 6).toString(16));\n// Throws ERR_INDEX_OUT_OF_RANGE\nconsole.log(buf.readIntBE(1, 0).toString(16));\n// Throws ERR_OUT_OF_RANGE\n</code></pre>"
            },
            {
              "textRaw": "buf.readUInt8(offset)",
              "type": "method",
              "name": "readUInt8",
              "meta": {
                "added": [
                  "v0.5.0"
                ],
                "changes": [
                  {
                    "version": "v10.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/18395",
                    "description": "Removed `noAssert` and no implicit coercion of the offset to `uint32` anymore."
                  }
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {integer}",
                    "name": "return",
                    "type": "integer"
                  },
                  "params": [
                    {
                      "textRaw": "`offset` {integer} Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 1`.",
                      "name": "offset",
                      "type": "integer",
                      "desc": "Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 1`."
                    }
                  ]
                }
              ],
              "desc": "<p>Reads an unsigned 8-bit integer from <code>buf</code> at the specified <code>offset</code>.</p>\n<pre><code class=\"language-js\">const buf = Buffer.from([1, -2]);\n\nconsole.log(buf.readUInt8(0));\n// Prints: 1\nconsole.log(buf.readUInt8(1));\n// Prints: 254\nconsole.log(buf.readUInt8(2));\n// Throws ERR_OUT_OF_RANGE\n</code></pre>"
            },
            {
              "textRaw": "buf.readUInt16BE(offset)",
              "type": "method",
              "name": "readUInt16BE",
              "meta": {
                "added": [
                  "v0.5.5"
                ],
                "changes": [
                  {
                    "version": "v10.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/18395",
                    "description": "Removed `noAssert` and no implicit coercion of the offset to `uint32` anymore."
                  }
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {integer}",
                    "name": "return",
                    "type": "integer"
                  },
                  "params": [
                    {
                      "textRaw": "`offset` {integer} Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 2`.",
                      "name": "offset",
                      "type": "integer",
                      "desc": "Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 2`."
                    }
                  ]
                }
              ],
              "desc": "<p>Reads an unsigned 16-bit integer from <code>buf</code> at the specified <code>offset</code> with\nspecified endian format (<code>readUInt16BE()</code> returns big endian, <code>readUInt16LE()</code>\nreturns little endian).</p>\n<pre><code class=\"language-js\">const buf = Buffer.from([0x12, 0x34, 0x56]);\n\nconsole.log(buf.readUInt16BE(0).toString(16));\n// Prints: 1234\nconsole.log(buf.readUInt16LE(0).toString(16));\n// Prints: 3412\nconsole.log(buf.readUInt16BE(1).toString(16));\n// Prints: 3456\nconsole.log(buf.readUInt16LE(1).toString(16));\n// Prints: 5634\nconsole.log(buf.readUInt16LE(2).toString(16));\n// Throws ERR_OUT_OF_RANGE\n</code></pre>"
            },
            {
              "textRaw": "buf.readUInt16LE(offset)",
              "type": "method",
              "name": "readUInt16LE",
              "meta": {
                "added": [
                  "v0.5.5"
                ],
                "changes": [
                  {
                    "version": "v10.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/18395",
                    "description": "Removed `noAssert` and no implicit coercion of the offset to `uint32` anymore."
                  }
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {integer}",
                    "name": "return",
                    "type": "integer"
                  },
                  "params": [
                    {
                      "textRaw": "`offset` {integer} Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 2`.",
                      "name": "offset",
                      "type": "integer",
                      "desc": "Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 2`."
                    }
                  ]
                }
              ],
              "desc": "<p>Reads an unsigned 16-bit integer from <code>buf</code> at the specified <code>offset</code> with\nspecified endian format (<code>readUInt16BE()</code> returns big endian, <code>readUInt16LE()</code>\nreturns little endian).</p>\n<pre><code class=\"language-js\">const buf = Buffer.from([0x12, 0x34, 0x56]);\n\nconsole.log(buf.readUInt16BE(0).toString(16));\n// Prints: 1234\nconsole.log(buf.readUInt16LE(0).toString(16));\n// Prints: 3412\nconsole.log(buf.readUInt16BE(1).toString(16));\n// Prints: 3456\nconsole.log(buf.readUInt16LE(1).toString(16));\n// Prints: 5634\nconsole.log(buf.readUInt16LE(2).toString(16));\n// Throws ERR_OUT_OF_RANGE\n</code></pre>"
            },
            {
              "textRaw": "buf.readUInt32BE(offset)",
              "type": "method",
              "name": "readUInt32BE",
              "meta": {
                "added": [
                  "v0.5.5"
                ],
                "changes": [
                  {
                    "version": "v10.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/18395",
                    "description": "Removed `noAssert` and no implicit coercion of the offset to `uint32` anymore."
                  }
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {integer}",
                    "name": "return",
                    "type": "integer"
                  },
                  "params": [
                    {
                      "textRaw": "`offset` {integer} Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 4`.",
                      "name": "offset",
                      "type": "integer",
                      "desc": "Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 4`."
                    }
                  ]
                }
              ],
              "desc": "<p>Reads an unsigned 32-bit integer from <code>buf</code> at the specified <code>offset</code> with\nspecified endian format (<code>readUInt32BE()</code> returns big endian,\n<code>readUInt32LE()</code> returns little endian).</p>\n<pre><code class=\"language-js\">const buf = Buffer.from([0x12, 0x34, 0x56, 0x78]);\n\nconsole.log(buf.readUInt32BE(0).toString(16));\n// Prints: 12345678\nconsole.log(buf.readUInt32LE(0).toString(16));\n// Prints: 78563412\nconsole.log(buf.readUInt32LE(1).toString(16));\n// Throws ERR_OUT_OF_RANGE\n</code></pre>"
            },
            {
              "textRaw": "buf.readUInt32LE(offset)",
              "type": "method",
              "name": "readUInt32LE",
              "meta": {
                "added": [
                  "v0.5.5"
                ],
                "changes": [
                  {
                    "version": "v10.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/18395",
                    "description": "Removed `noAssert` and no implicit coercion of the offset to `uint32` anymore."
                  }
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {integer}",
                    "name": "return",
                    "type": "integer"
                  },
                  "params": [
                    {
                      "textRaw": "`offset` {integer} Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 4`.",
                      "name": "offset",
                      "type": "integer",
                      "desc": "Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 4`."
                    }
                  ]
                }
              ],
              "desc": "<p>Reads an unsigned 32-bit integer from <code>buf</code> at the specified <code>offset</code> with\nspecified endian format (<code>readUInt32BE()</code> returns big endian,\n<code>readUInt32LE()</code> returns little endian).</p>\n<pre><code class=\"language-js\">const buf = Buffer.from([0x12, 0x34, 0x56, 0x78]);\n\nconsole.log(buf.readUInt32BE(0).toString(16));\n// Prints: 12345678\nconsole.log(buf.readUInt32LE(0).toString(16));\n// Prints: 78563412\nconsole.log(buf.readUInt32LE(1).toString(16));\n// Throws ERR_OUT_OF_RANGE\n</code></pre>"
            },
            {
              "textRaw": "buf.readUIntBE(offset, byteLength)",
              "type": "method",
              "name": "readUIntBE",
              "meta": {
                "added": [
                  "v0.11.15"
                ],
                "changes": [
                  {
                    "version": "v10.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/18395",
                    "description": "Removed `noAssert` and no implicit coercion of the offset and `byteLength` to `uint32` anymore."
                  }
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {integer}",
                    "name": "return",
                    "type": "integer"
                  },
                  "params": [
                    {
                      "textRaw": "`offset` {integer} Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - byteLength`.",
                      "name": "offset",
                      "type": "integer",
                      "desc": "Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - byteLength`."
                    },
                    {
                      "textRaw": "`byteLength` {integer} Number of bytes to read. Must satisfy `0 < byteLength <= 6`.",
                      "name": "byteLength",
                      "type": "integer",
                      "desc": "Number of bytes to read. Must satisfy `0 < byteLength <= 6`."
                    }
                  ]
                }
              ],
              "desc": "<p>Reads <code>byteLength</code> number of bytes from <code>buf</code> at the specified <code>offset</code>\nand interprets the result as an unsigned integer. Supports up to 48\nbits of accuracy.</p>\n<pre><code class=\"language-js\">const buf = Buffer.from([0x12, 0x34, 0x56, 0x78, 0x90, 0xab]);\n\nconsole.log(buf.readUIntBE(0, 6).toString(16));\n// Prints: 1234567890ab\nconsole.log(buf.readUIntLE(0, 6).toString(16));\n// Prints: ab9078563412\nconsole.log(buf.readUIntBE(1, 6).toString(16));\n// Throws ERR_OUT_OF_RANGE\n</code></pre>"
            },
            {
              "textRaw": "buf.readUIntLE(offset, byteLength)",
              "type": "method",
              "name": "readUIntLE",
              "meta": {
                "added": [
                  "v0.11.15"
                ],
                "changes": [
                  {
                    "version": "v10.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/18395",
                    "description": "Removed `noAssert` and no implicit coercion of the offset and `byteLength` to `uint32` anymore."
                  }
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {integer}",
                    "name": "return",
                    "type": "integer"
                  },
                  "params": [
                    {
                      "textRaw": "`offset` {integer} Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - byteLength`.",
                      "name": "offset",
                      "type": "integer",
                      "desc": "Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - byteLength`."
                    },
                    {
                      "textRaw": "`byteLength` {integer} Number of bytes to read. Must satisfy `0 < byteLength <= 6`.",
                      "name": "byteLength",
                      "type": "integer",
                      "desc": "Number of bytes to read. Must satisfy `0 < byteLength <= 6`."
                    }
                  ]
                }
              ],
              "desc": "<p>Reads <code>byteLength</code> number of bytes from <code>buf</code> at the specified <code>offset</code>\nand interprets the result as an unsigned integer. Supports up to 48\nbits of accuracy.</p>\n<pre><code class=\"language-js\">const buf = Buffer.from([0x12, 0x34, 0x56, 0x78, 0x90, 0xab]);\n\nconsole.log(buf.readUIntBE(0, 6).toString(16));\n// Prints: 1234567890ab\nconsole.log(buf.readUIntLE(0, 6).toString(16));\n// Prints: ab9078563412\nconsole.log(buf.readUIntBE(1, 6).toString(16));\n// Throws ERR_OUT_OF_RANGE\n</code></pre>"
            },
            {
              "textRaw": "buf.slice([start[, end]])",
              "type": "method",
              "name": "slice",
              "meta": {
                "added": [
                  "v0.3.0"
                ],
                "changes": [
                  {
                    "version": "v7.1.0, v6.9.2",
                    "pr-url": "https://github.com/nodejs/node/pull/9341",
                    "description": "Coercing the offsets to integers now handles values outside the 32-bit integer range properly."
                  },
                  {
                    "version": "v7.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/9101",
                    "description": "All offsets are now coerced to integers before doing any calculations with them."
                  }
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {Buffer}",
                    "name": "return",
                    "type": "Buffer"
                  },
                  "params": [
                    {
                      "textRaw": "`start` {integer} Where the new `Buffer` will start. **Default:** `0`.",
                      "name": "start",
                      "type": "integer",
                      "default": "`0`",
                      "desc": "Where the new `Buffer` will start.",
                      "optional": true
                    },
                    {
                      "textRaw": "`end` {integer} Where the new `Buffer` will end (not inclusive). **Default:** [`buf.length`].",
                      "name": "end",
                      "type": "integer",
                      "default": "[`buf.length`]",
                      "desc": "Where the new `Buffer` will end (not inclusive).",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Returns a new <code>Buffer</code> that references the same memory as the original, but\noffset and cropped by the <code>start</code> and <code>end</code> indices.</p>\n<p>Specifying <code>end</code> greater than <a href=\"#buffer_buf_length\"><code>buf.length</code></a> will return the same result as\nthat of <code>end</code> equal to <a href=\"#buffer_buf_length\"><code>buf.length</code></a>.</p>\n<p>Modifying the new <code>Buffer</code> slice will modify the memory in the original <code>Buffer</code>\nbecause the allocated memory of the two objects overlap.</p>\n<pre><code class=\"language-js\">// Create a `Buffer` with the ASCII alphabet, take a slice, and modify one byte\n// from the original `Buffer`.\n\nconst buf1 = Buffer.allocUnsafe(26);\n\nfor (let i = 0; i &#x3C; 26; i++) {\n  // 97 is the decimal ASCII value for 'a'\n  buf1[i] = i + 97;\n}\n\nconst buf2 = buf1.slice(0, 3);\n\nconsole.log(buf2.toString('ascii', 0, buf2.length));\n// Prints: abc\n\nbuf1[0] = 33;\n\nconsole.log(buf2.toString('ascii', 0, buf2.length));\n// Prints: !bc\n</code></pre>\n<p>Specifying negative indexes causes the slice to be generated relative to the\nend of <code>buf</code> rather than the beginning.</p>\n<pre><code class=\"language-js\">const buf = Buffer.from('buffer');\n\nconsole.log(buf.slice(-6, -1).toString());\n// Prints: buffe\n// (Equivalent to buf.slice(0, 5))\n\nconsole.log(buf.slice(-6, -2).toString());\n// Prints: buff\n// (Equivalent to buf.slice(0, 4))\n\nconsole.log(buf.slice(-5, -2).toString());\n// Prints: uff\n// (Equivalent to buf.slice(1, 4))\n</code></pre>"
            },
            {
              "textRaw": "buf.swap16()",
              "type": "method",
              "name": "swap16",
              "meta": {
                "added": [
                  "v5.10.0"
                ],
                "changes": []
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {Buffer} A reference to `buf`.",
                    "name": "return",
                    "type": "Buffer",
                    "desc": "A reference to `buf`."
                  },
                  "params": []
                }
              ],
              "desc": "<p>Interprets <code>buf</code> as an array of unsigned 16-bit integers and swaps the\nbyte order <em>in-place</em>. Throws <a href=\"errors.html#ERR_INVALID_BUFFER_SIZE\"><code>ERR_INVALID_BUFFER_SIZE</code></a> if <a href=\"#buffer_buf_length\"><code>buf.length</code></a> is\nnot a multiple of 2.</p>\n<pre><code class=\"language-js\">const buf1 = Buffer.from([0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8]);\n\nconsole.log(buf1);\n// Prints: &#x3C;Buffer 01 02 03 04 05 06 07 08>\n\nbuf1.swap16();\n\nconsole.log(buf1);\n// Prints: &#x3C;Buffer 02 01 04 03 06 05 08 07>\n\nconst buf2 = Buffer.from([0x1, 0x2, 0x3]);\n\nbuf2.swap16();\n// Throws ERR_INVALID_BUFFER_SIZE\n</code></pre>\n<p>One convenient use of <code>buf.swap16()</code> is to perform a fast in-place conversion\nbetween UTF-16 little-endian and UTF-16 big-endian:</p>\n<pre><code class=\"language-js\">const buf = Buffer.from('This is little-endian UTF-16', 'utf16le');\nbuf.swap16(); // Convert to big-endian UTF-16 text.\n</code></pre>"
            },
            {
              "textRaw": "buf.swap32()",
              "type": "method",
              "name": "swap32",
              "meta": {
                "added": [
                  "v5.10.0"
                ],
                "changes": []
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {Buffer} A reference to `buf`.",
                    "name": "return",
                    "type": "Buffer",
                    "desc": "A reference to `buf`."
                  },
                  "params": []
                }
              ],
              "desc": "<p>Interprets <code>buf</code> as an array of unsigned 32-bit integers and swaps the\nbyte order <em>in-place</em>. Throws <a href=\"errors.html#ERR_INVALID_BUFFER_SIZE\"><code>ERR_INVALID_BUFFER_SIZE</code></a> if <a href=\"#buffer_buf_length\"><code>buf.length</code></a> is\nnot a multiple of 4.</p>\n<pre><code class=\"language-js\">const buf1 = Buffer.from([0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8]);\n\nconsole.log(buf1);\n// Prints: &#x3C;Buffer 01 02 03 04 05 06 07 08>\n\nbuf1.swap32();\n\nconsole.log(buf1);\n// Prints: &#x3C;Buffer 04 03 02 01 08 07 06 05>\n\nconst buf2 = Buffer.from([0x1, 0x2, 0x3]);\n\nbuf2.swap32();\n// Throws ERR_INVALID_BUFFER_SIZE\n</code></pre>"
            },
            {
              "textRaw": "buf.swap64()",
              "type": "method",
              "name": "swap64",
              "meta": {
                "added": [
                  "v6.3.0"
                ],
                "changes": []
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {Buffer} A reference to `buf`.",
                    "name": "return",
                    "type": "Buffer",
                    "desc": "A reference to `buf`."
                  },
                  "params": []
                }
              ],
              "desc": "<p>Interprets <code>buf</code> as an array of 64-bit numbers and swaps byte order <em>in-place</em>.\nThrows <a href=\"errors.html#ERR_INVALID_BUFFER_SIZE\"><code>ERR_INVALID_BUFFER_SIZE</code></a> if <a href=\"#buffer_buf_length\"><code>buf.length</code></a> is not a multiple of 8.</p>\n<pre><code class=\"language-js\">const buf1 = Buffer.from([0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8]);\n\nconsole.log(buf1);\n// Prints: &#x3C;Buffer 01 02 03 04 05 06 07 08>\n\nbuf1.swap64();\n\nconsole.log(buf1);\n// Prints: &#x3C;Buffer 08 07 06 05 04 03 02 01>\n\nconst buf2 = Buffer.from([0x1, 0x2, 0x3]);\n\nbuf2.swap64();\n// Throws ERR_INVALID_BUFFER_SIZE\n</code></pre>\n<p>Note that JavaScript cannot encode 64-bit integers. This method is intended\nfor working with 64-bit floats.</p>"
            },
            {
              "textRaw": "buf.toJSON()",
              "type": "method",
              "name": "toJSON",
              "meta": {
                "added": [
                  "v0.9.2"
                ],
                "changes": []
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {Object}",
                    "name": "return",
                    "type": "Object"
                  },
                  "params": []
                }
              ],
              "desc": "<p>Returns a JSON representation of <code>buf</code>. <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify\"><code>JSON.stringify()</code></a> implicitly calls\nthis function when stringifying a <code>Buffer</code> instance.</p>\n<pre><code class=\"language-js\">const buf = Buffer.from([0x1, 0x2, 0x3, 0x4, 0x5]);\nconst json = JSON.stringify(buf);\n\nconsole.log(json);\n// Prints: {\"type\":\"Buffer\",\"data\":[1,2,3,4,5]}\n\nconst copy = JSON.parse(json, (key, value) => {\n  return value &#x26;&#x26; value.type === 'Buffer' ?\n    Buffer.from(value.data) :\n    value;\n});\n\nconsole.log(copy);\n// Prints: &#x3C;Buffer 01 02 03 04 05>\n</code></pre>"
            },
            {
              "textRaw": "buf.toString([encoding[, start[, end]]])",
              "type": "method",
              "name": "toString",
              "meta": {
                "added": [
                  "v0.1.90"
                ],
                "changes": []
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {string}",
                    "name": "return",
                    "type": "string"
                  },
                  "params": [
                    {
                      "textRaw": "`encoding` {string} The character encoding to use. **Default:** `'utf8'`.",
                      "name": "encoding",
                      "type": "string",
                      "default": "`'utf8'`",
                      "desc": "The character encoding to use.",
                      "optional": true
                    },
                    {
                      "textRaw": "`start` {integer} The byte offset to start decoding at. **Default:** `0`.",
                      "name": "start",
                      "type": "integer",
                      "default": "`0`",
                      "desc": "The byte offset to start decoding at.",
                      "optional": true
                    },
                    {
                      "textRaw": "`end` {integer} The byte offset to stop decoding at (not inclusive). **Default:** [`buf.length`].",
                      "name": "end",
                      "type": "integer",
                      "default": "[`buf.length`]",
                      "desc": "The byte offset to stop decoding at (not inclusive).",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Decodes <code>buf</code> to a string according to the specified character encoding in\n<code>encoding</code>. <code>start</code> and <code>end</code> may be passed to decode only a subset of <code>buf</code>.</p>\n<p>The maximum length of a string instance (in UTF-16 code units) is available\nas <a href=\"#buffer_buffer_constants_max_string_length\"><code>buffer.constants.MAX_STRING_LENGTH</code></a>.</p>\n<pre><code class=\"language-js\">const buf1 = Buffer.allocUnsafe(26);\n\nfor (let i = 0; i &#x3C; 26; i++) {\n  // 97 is the decimal ASCII value for 'a'\n  buf1[i] = i + 97;\n}\n\nconsole.log(buf1.toString('ascii'));\n// Prints: abcdefghijklmnopqrstuvwxyz\nconsole.log(buf1.toString('ascii', 0, 5));\n// Prints: abcde\n\nconst buf2 = Buffer.from('tést');\n\nconsole.log(buf2.toString('hex'));\n// Prints: 74c3a97374\nconsole.log(buf2.toString('utf8', 0, 3));\n// Prints: té\nconsole.log(buf2.toString(undefined, 0, 3));\n// Prints: té\n</code></pre>"
            },
            {
              "textRaw": "buf.values()",
              "type": "method",
              "name": "values",
              "meta": {
                "added": [
                  "v1.1.0"
                ],
                "changes": []
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {Iterator}",
                    "name": "return",
                    "type": "Iterator"
                  },
                  "params": []
                }
              ],
              "desc": "<p>Creates and returns an <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols\">iterator</a> for <code>buf</code> values (bytes). This function is\ncalled automatically when a <code>Buffer</code> is used in a <code>for..of</code> statement.</p>\n<pre><code class=\"language-js\">const buf = Buffer.from('buffer');\n\nfor (const value of buf.values()) {\n  console.log(value);\n}\n// Prints:\n//   98\n//   117\n//   102\n//   102\n//   101\n//   114\n\nfor (const value of buf) {\n  console.log(value);\n}\n// Prints:\n//   98\n//   117\n//   102\n//   102\n//   101\n//   114\n</code></pre>"
            },
            {
              "textRaw": "buf.write(string[, offset[, length]][, encoding])",
              "type": "method",
              "name": "write",
              "meta": {
                "added": [
                  "v0.1.90"
                ],
                "changes": []
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {integer} Number of bytes written.",
                    "name": "return",
                    "type": "integer",
                    "desc": "Number of bytes written."
                  },
                  "params": [
                    {
                      "textRaw": "`string` {string} String to write to `buf`.",
                      "name": "string",
                      "type": "string",
                      "desc": "String to write to `buf`."
                    },
                    {
                      "textRaw": "`offset` {integer} Number of bytes to skip before starting to write `string`. **Default:** `0`.",
                      "name": "offset",
                      "type": "integer",
                      "default": "`0`",
                      "desc": "Number of bytes to skip before starting to write `string`.",
                      "optional": true
                    },
                    {
                      "textRaw": "`length` {integer} Number of bytes to write. **Default:** `buf.length - offset`.",
                      "name": "length",
                      "type": "integer",
                      "default": "`buf.length - offset`",
                      "desc": "Number of bytes to write.",
                      "optional": true
                    },
                    {
                      "textRaw": "`encoding` {string} The character encoding of `string`. **Default:** `'utf8'`.",
                      "name": "encoding",
                      "type": "string",
                      "default": "`'utf8'`",
                      "desc": "The character encoding of `string`.",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Writes <code>string</code> to <code>buf</code> at <code>offset</code> according to the character encoding in\n<code>encoding</code>. The <code>length</code> parameter is the number of bytes to write. If <code>buf</code> did\nnot contain enough space to fit the entire string, only part of <code>string</code> will be\nwritten. However, partially encoded characters will not be written.</p>\n<pre><code class=\"language-js\">const buf = Buffer.alloc(256);\n\nconst len = buf.write('\\u00bd + \\u00bc = \\u00be', 0);\n\nconsole.log(`${len} bytes: ${buf.toString('utf8', 0, len)}`);\n// Prints: 12 bytes: ½ + ¼ = ¾\n</code></pre>"
            },
            {
              "textRaw": "buf.writeDoubleBE(value, offset)",
              "type": "method",
              "name": "writeDoubleBE",
              "meta": {
                "added": [
                  "v0.11.15"
                ],
                "changes": [
                  {
                    "version": "v10.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/18395",
                    "description": "Removed `noAssert` and no implicit coercion of the offset to `uint32` anymore."
                  }
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {integer} `offset` plus the number of bytes written.",
                    "name": "return",
                    "type": "integer",
                    "desc": "`offset` plus the number of bytes written."
                  },
                  "params": [
                    {
                      "textRaw": "`value` {number} Number to be written to `buf`.",
                      "name": "value",
                      "type": "number",
                      "desc": "Number to be written to `buf`."
                    },
                    {
                      "textRaw": "`offset` {integer} Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 8`.",
                      "name": "offset",
                      "type": "integer",
                      "desc": "Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 8`."
                    }
                  ]
                }
              ],
              "desc": "<p>Writes <code>value</code> to <code>buf</code> at the specified <code>offset</code> with specified endian\nformat (<code>writeDoubleBE()</code> writes big endian, <code>writeDoubleLE()</code> writes little\nendian). <code>value</code> <em>should</em> be a valid 64-bit double. Behavior is undefined when\n<code>value</code> is anything other than a 64-bit double.</p>\n<pre><code class=\"language-js\">const buf = Buffer.allocUnsafe(8);\n\nbuf.writeDoubleBE(123.456, 0);\n\nconsole.log(buf);\n// Prints: &#x3C;Buffer 40 5e dd 2f 1a 9f be 77>\n\nbuf.writeDoubleLE(123.456, 0);\n\nconsole.log(buf);\n// Prints: &#x3C;Buffer 77 be 9f 1a 2f dd 5e 40>\n</code></pre>"
            },
            {
              "textRaw": "buf.writeDoubleLE(value, offset)",
              "type": "method",
              "name": "writeDoubleLE",
              "meta": {
                "added": [
                  "v0.11.15"
                ],
                "changes": [
                  {
                    "version": "v10.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/18395",
                    "description": "Removed `noAssert` and no implicit coercion of the offset to `uint32` anymore."
                  }
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {integer} `offset` plus the number of bytes written.",
                    "name": "return",
                    "type": "integer",
                    "desc": "`offset` plus the number of bytes written."
                  },
                  "params": [
                    {
                      "textRaw": "`value` {number} Number to be written to `buf`.",
                      "name": "value",
                      "type": "number",
                      "desc": "Number to be written to `buf`."
                    },
                    {
                      "textRaw": "`offset` {integer} Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 8`.",
                      "name": "offset",
                      "type": "integer",
                      "desc": "Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 8`."
                    }
                  ]
                }
              ],
              "desc": "<p>Writes <code>value</code> to <code>buf</code> at the specified <code>offset</code> with specified endian\nformat (<code>writeDoubleBE()</code> writes big endian, <code>writeDoubleLE()</code> writes little\nendian). <code>value</code> <em>should</em> be a valid 64-bit double. Behavior is undefined when\n<code>value</code> is anything other than a 64-bit double.</p>\n<pre><code class=\"language-js\">const buf = Buffer.allocUnsafe(8);\n\nbuf.writeDoubleBE(123.456, 0);\n\nconsole.log(buf);\n// Prints: &#x3C;Buffer 40 5e dd 2f 1a 9f be 77>\n\nbuf.writeDoubleLE(123.456, 0);\n\nconsole.log(buf);\n// Prints: &#x3C;Buffer 77 be 9f 1a 2f dd 5e 40>\n</code></pre>"
            },
            {
              "textRaw": "buf.writeFloatBE(value, offset)",
              "type": "method",
              "name": "writeFloatBE",
              "meta": {
                "added": [
                  "v0.11.15"
                ],
                "changes": [
                  {
                    "version": "v10.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/18395",
                    "description": "Removed `noAssert` and no implicit coercion of the offset to `uint32` anymore."
                  }
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {integer} `offset` plus the number of bytes written.",
                    "name": "return",
                    "type": "integer",
                    "desc": "`offset` plus the number of bytes written."
                  },
                  "params": [
                    {
                      "textRaw": "`value` {number} Number to be written to `buf`.",
                      "name": "value",
                      "type": "number",
                      "desc": "Number to be written to `buf`."
                    },
                    {
                      "textRaw": "`offset` {integer} Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 4`.",
                      "name": "offset",
                      "type": "integer",
                      "desc": "Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 4`."
                    }
                  ]
                }
              ],
              "desc": "<p>Writes <code>value</code> to <code>buf</code> at the specified <code>offset</code> with specified endian\nformat (<code>writeFloatBE()</code> writes big endian, <code>writeFloatLE()</code> writes little\nendian). <code>value</code> <em>should</em> be a valid 32-bit float. Behavior is undefined when\n<code>value</code> is anything other than a 32-bit float.</p>\n<pre><code class=\"language-js\">const buf = Buffer.allocUnsafe(4);\n\nbuf.writeFloatBE(0xcafebabe, 0);\n\nconsole.log(buf);\n// Prints: &#x3C;Buffer 4f 4a fe bb>\n\nbuf.writeFloatLE(0xcafebabe, 0);\n\nconsole.log(buf);\n// Prints: &#x3C;Buffer bb fe 4a 4f>\n</code></pre>"
            },
            {
              "textRaw": "buf.writeFloatLE(value, offset)",
              "type": "method",
              "name": "writeFloatLE",
              "meta": {
                "added": [
                  "v0.11.15"
                ],
                "changes": [
                  {
                    "version": "v10.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/18395",
                    "description": "Removed `noAssert` and no implicit coercion of the offset to `uint32` anymore."
                  }
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {integer} `offset` plus the number of bytes written.",
                    "name": "return",
                    "type": "integer",
                    "desc": "`offset` plus the number of bytes written."
                  },
                  "params": [
                    {
                      "textRaw": "`value` {number} Number to be written to `buf`.",
                      "name": "value",
                      "type": "number",
                      "desc": "Number to be written to `buf`."
                    },
                    {
                      "textRaw": "`offset` {integer} Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 4`.",
                      "name": "offset",
                      "type": "integer",
                      "desc": "Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 4`."
                    }
                  ]
                }
              ],
              "desc": "<p>Writes <code>value</code> to <code>buf</code> at the specified <code>offset</code> with specified endian\nformat (<code>writeFloatBE()</code> writes big endian, <code>writeFloatLE()</code> writes little\nendian). <code>value</code> <em>should</em> be a valid 32-bit float. Behavior is undefined when\n<code>value</code> is anything other than a 32-bit float.</p>\n<pre><code class=\"language-js\">const buf = Buffer.allocUnsafe(4);\n\nbuf.writeFloatBE(0xcafebabe, 0);\n\nconsole.log(buf);\n// Prints: &#x3C;Buffer 4f 4a fe bb>\n\nbuf.writeFloatLE(0xcafebabe, 0);\n\nconsole.log(buf);\n// Prints: &#x3C;Buffer bb fe 4a 4f>\n</code></pre>"
            },
            {
              "textRaw": "buf.writeInt8(value, offset)",
              "type": "method",
              "name": "writeInt8",
              "meta": {
                "added": [
                  "v0.5.0"
                ],
                "changes": [
                  {
                    "version": "v10.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/18395",
                    "description": "Removed `noAssert` and no implicit coercion of the offset to `uint32` anymore."
                  }
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {integer} `offset` plus the number of bytes written.",
                    "name": "return",
                    "type": "integer",
                    "desc": "`offset` plus the number of bytes written."
                  },
                  "params": [
                    {
                      "textRaw": "`value` {integer} Number to be written to `buf`.",
                      "name": "value",
                      "type": "integer",
                      "desc": "Number to be written to `buf`."
                    },
                    {
                      "textRaw": "`offset` {integer} Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 1`.",
                      "name": "offset",
                      "type": "integer",
                      "desc": "Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 1`."
                    }
                  ]
                }
              ],
              "desc": "<p>Writes <code>value</code> to <code>buf</code> at the specified <code>offset</code>. <code>value</code> <em>should</em> be a valid\nsigned 8-bit integer. Behavior is undefined when <code>value</code> is anything other than\na signed 8-bit integer.</p>\n<p><code>value</code> is interpreted and written as a two's complement signed integer.</p>\n<pre><code class=\"language-js\">const buf = Buffer.allocUnsafe(2);\n\nbuf.writeInt8(2, 0);\nbuf.writeInt8(-2, 1);\n\nconsole.log(buf);\n// Prints: &#x3C;Buffer 02 fe>\n</code></pre>"
            },
            {
              "textRaw": "buf.writeInt16BE(value, offset)",
              "type": "method",
              "name": "writeInt16BE",
              "meta": {
                "added": [
                  "v0.5.5"
                ],
                "changes": [
                  {
                    "version": "v10.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/18395",
                    "description": "Removed `noAssert` and no implicit coercion of the offset to `uint32` anymore."
                  }
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {integer} `offset` plus the number of bytes written.",
                    "name": "return",
                    "type": "integer",
                    "desc": "`offset` plus the number of bytes written."
                  },
                  "params": [
                    {
                      "textRaw": "`value` {integer} Number to be written to `buf`.",
                      "name": "value",
                      "type": "integer",
                      "desc": "Number to be written to `buf`."
                    },
                    {
                      "textRaw": "`offset` {integer} Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 2`.",
                      "name": "offset",
                      "type": "integer",
                      "desc": "Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 2`."
                    }
                  ]
                }
              ],
              "desc": "<p>Writes <code>value</code> to <code>buf</code> at the specified <code>offset</code> with specified endian\nformat (<code>writeInt16BE()</code> writes big endian, <code>writeInt16LE()</code> writes little\nendian). <code>value</code> <em>should</em> be a valid signed 16-bit integer. Behavior is\nundefined when <code>value</code> is anything other than a signed 16-bit integer.</p>\n<p><code>value</code> is interpreted and written as a two's complement signed integer.</p>\n<pre><code class=\"language-js\">const buf = Buffer.allocUnsafe(4);\n\nbuf.writeInt16BE(0x0102, 0);\nbuf.writeInt16LE(0x0304, 2);\n\nconsole.log(buf);\n// Prints: &#x3C;Buffer 01 02 04 03>\n</code></pre>"
            },
            {
              "textRaw": "buf.writeInt16LE(value, offset)",
              "type": "method",
              "name": "writeInt16LE",
              "meta": {
                "added": [
                  "v0.5.5"
                ],
                "changes": [
                  {
                    "version": "v10.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/18395",
                    "description": "Removed `noAssert` and no implicit coercion of the offset to `uint32` anymore."
                  }
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {integer} `offset` plus the number of bytes written.",
                    "name": "return",
                    "type": "integer",
                    "desc": "`offset` plus the number of bytes written."
                  },
                  "params": [
                    {
                      "textRaw": "`value` {integer} Number to be written to `buf`.",
                      "name": "value",
                      "type": "integer",
                      "desc": "Number to be written to `buf`."
                    },
                    {
                      "textRaw": "`offset` {integer} Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 2`.",
                      "name": "offset",
                      "type": "integer",
                      "desc": "Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 2`."
                    }
                  ]
                }
              ],
              "desc": "<p>Writes <code>value</code> to <code>buf</code> at the specified <code>offset</code> with specified endian\nformat (<code>writeInt16BE()</code> writes big endian, <code>writeInt16LE()</code> writes little\nendian). <code>value</code> <em>should</em> be a valid signed 16-bit integer. Behavior is\nundefined when <code>value</code> is anything other than a signed 16-bit integer.</p>\n<p><code>value</code> is interpreted and written as a two's complement signed integer.</p>\n<pre><code class=\"language-js\">const buf = Buffer.allocUnsafe(4);\n\nbuf.writeInt16BE(0x0102, 0);\nbuf.writeInt16LE(0x0304, 2);\n\nconsole.log(buf);\n// Prints: &#x3C;Buffer 01 02 04 03>\n</code></pre>"
            },
            {
              "textRaw": "buf.writeInt32BE(value, offset)",
              "type": "method",
              "name": "writeInt32BE",
              "meta": {
                "added": [
                  "v0.5.5"
                ],
                "changes": [
                  {
                    "version": "v10.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/18395",
                    "description": "Removed `noAssert` and no implicit coercion of the offset to `uint32` anymore."
                  }
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {integer} `offset` plus the number of bytes written.",
                    "name": "return",
                    "type": "integer",
                    "desc": "`offset` plus the number of bytes written."
                  },
                  "params": [
                    {
                      "textRaw": "`value` {integer} Number to be written to `buf`.",
                      "name": "value",
                      "type": "integer",
                      "desc": "Number to be written to `buf`."
                    },
                    {
                      "textRaw": "`offset` {integer} Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 4`.",
                      "name": "offset",
                      "type": "integer",
                      "desc": "Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 4`."
                    }
                  ]
                }
              ],
              "desc": "<p>Writes <code>value</code> to <code>buf</code> at the specified <code>offset</code> with specified endian\nformat (<code>writeInt32BE()</code> writes big endian, <code>writeInt32LE()</code> writes little\nendian). <code>value</code> <em>should</em> be a valid signed 32-bit integer. Behavior is\nundefined when <code>value</code> is anything other than a signed 32-bit integer.</p>\n<p><code>value</code> is interpreted and written as a two's complement signed integer.</p>\n<pre><code class=\"language-js\">const buf = Buffer.allocUnsafe(8);\n\nbuf.writeInt32BE(0x01020304, 0);\nbuf.writeInt32LE(0x05060708, 4);\n\nconsole.log(buf);\n// Prints: &#x3C;Buffer 01 02 03 04 08 07 06 05>\n</code></pre>"
            },
            {
              "textRaw": "buf.writeInt32LE(value, offset)",
              "type": "method",
              "name": "writeInt32LE",
              "meta": {
                "added": [
                  "v0.5.5"
                ],
                "changes": [
                  {
                    "version": "v10.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/18395",
                    "description": "Removed `noAssert` and no implicit coercion of the offset to `uint32` anymore."
                  }
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {integer} `offset` plus the number of bytes written.",
                    "name": "return",
                    "type": "integer",
                    "desc": "`offset` plus the number of bytes written."
                  },
                  "params": [
                    {
                      "textRaw": "`value` {integer} Number to be written to `buf`.",
                      "name": "value",
                      "type": "integer",
                      "desc": "Number to be written to `buf`."
                    },
                    {
                      "textRaw": "`offset` {integer} Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 4`.",
                      "name": "offset",
                      "type": "integer",
                      "desc": "Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 4`."
                    }
                  ]
                }
              ],
              "desc": "<p>Writes <code>value</code> to <code>buf</code> at the specified <code>offset</code> with specified endian\nformat (<code>writeInt32BE()</code> writes big endian, <code>writeInt32LE()</code> writes little\nendian). <code>value</code> <em>should</em> be a valid signed 32-bit integer. Behavior is\nundefined when <code>value</code> is anything other than a signed 32-bit integer.</p>\n<p><code>value</code> is interpreted and written as a two's complement signed integer.</p>\n<pre><code class=\"language-js\">const buf = Buffer.allocUnsafe(8);\n\nbuf.writeInt32BE(0x01020304, 0);\nbuf.writeInt32LE(0x05060708, 4);\n\nconsole.log(buf);\n// Prints: &#x3C;Buffer 01 02 03 04 08 07 06 05>\n</code></pre>"
            },
            {
              "textRaw": "buf.writeIntBE(value, offset, byteLength)",
              "type": "method",
              "name": "writeIntBE",
              "meta": {
                "added": [
                  "v0.11.15"
                ],
                "changes": [
                  {
                    "version": "v10.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/18395",
                    "description": "Removed `noAssert` and no implicit coercion of the offset and `byteLength` to `uint32` anymore."
                  }
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {integer} `offset` plus the number of bytes written.",
                    "name": "return",
                    "type": "integer",
                    "desc": "`offset` plus the number of bytes written."
                  },
                  "params": [
                    {
                      "textRaw": "`value` {integer} Number to be written to `buf`.",
                      "name": "value",
                      "type": "integer",
                      "desc": "Number to be written to `buf`."
                    },
                    {
                      "textRaw": "`offset` {integer} Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - byteLength`.",
                      "name": "offset",
                      "type": "integer",
                      "desc": "Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - byteLength`."
                    },
                    {
                      "textRaw": "`byteLength` {integer} Number of bytes to write. Must satisfy `0 < byteLength <= 6`.",
                      "name": "byteLength",
                      "type": "integer",
                      "desc": "Number of bytes to write. Must satisfy `0 < byteLength <= 6`."
                    }
                  ]
                }
              ],
              "desc": "<p>Writes <code>byteLength</code> bytes of <code>value</code> to <code>buf</code> at the specified <code>offset</code>.\nSupports up to 48 bits of accuracy. Behavior is undefined when <code>value</code> is\nanything other than a signed integer.</p>\n<pre><code class=\"language-js\">const buf = Buffer.allocUnsafe(6);\n\nbuf.writeIntBE(0x1234567890ab, 0, 6);\n\nconsole.log(buf);\n// Prints: &#x3C;Buffer 12 34 56 78 90 ab>\n\nbuf.writeIntLE(0x1234567890ab, 0, 6);\n\nconsole.log(buf);\n// Prints: &#x3C;Buffer ab 90 78 56 34 12>\n</code></pre>"
            },
            {
              "textRaw": "buf.writeIntLE(value, offset, byteLength)",
              "type": "method",
              "name": "writeIntLE",
              "meta": {
                "added": [
                  "v0.11.15"
                ],
                "changes": [
                  {
                    "version": "v10.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/18395",
                    "description": "Removed `noAssert` and no implicit coercion of the offset and `byteLength` to `uint32` anymore."
                  }
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {integer} `offset` plus the number of bytes written.",
                    "name": "return",
                    "type": "integer",
                    "desc": "`offset` plus the number of bytes written."
                  },
                  "params": [
                    {
                      "textRaw": "`value` {integer} Number to be written to `buf`.",
                      "name": "value",
                      "type": "integer",
                      "desc": "Number to be written to `buf`."
                    },
                    {
                      "textRaw": "`offset` {integer} Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - byteLength`.",
                      "name": "offset",
                      "type": "integer",
                      "desc": "Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - byteLength`."
                    },
                    {
                      "textRaw": "`byteLength` {integer} Number of bytes to write. Must satisfy `0 < byteLength <= 6`.",
                      "name": "byteLength",
                      "type": "integer",
                      "desc": "Number of bytes to write. Must satisfy `0 < byteLength <= 6`."
                    }
                  ]
                }
              ],
              "desc": "<p>Writes <code>byteLength</code> bytes of <code>value</code> to <code>buf</code> at the specified <code>offset</code>.\nSupports up to 48 bits of accuracy. Behavior is undefined when <code>value</code> is\nanything other than a signed integer.</p>\n<pre><code class=\"language-js\">const buf = Buffer.allocUnsafe(6);\n\nbuf.writeIntBE(0x1234567890ab, 0, 6);\n\nconsole.log(buf);\n// Prints: &#x3C;Buffer 12 34 56 78 90 ab>\n\nbuf.writeIntLE(0x1234567890ab, 0, 6);\n\nconsole.log(buf);\n// Prints: &#x3C;Buffer ab 90 78 56 34 12>\n</code></pre>"
            },
            {
              "textRaw": "buf.writeUInt8(value, offset)",
              "type": "method",
              "name": "writeUInt8",
              "meta": {
                "added": [
                  "v0.5.0"
                ],
                "changes": [
                  {
                    "version": "v10.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/18395",
                    "description": "Removed `noAssert` and no implicit coercion of the offset to `uint32` anymore."
                  }
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {integer} `offset` plus the number of bytes written.",
                    "name": "return",
                    "type": "integer",
                    "desc": "`offset` plus the number of bytes written."
                  },
                  "params": [
                    {
                      "textRaw": "`value` {integer} Number to be written to `buf`.",
                      "name": "value",
                      "type": "integer",
                      "desc": "Number to be written to `buf`."
                    },
                    {
                      "textRaw": "`offset` {integer} Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 1`.",
                      "name": "offset",
                      "type": "integer",
                      "desc": "Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 1`."
                    }
                  ]
                }
              ],
              "desc": "<p>Writes <code>value</code> to <code>buf</code> at the specified <code>offset</code>. <code>value</code> <em>should</em> be a\nvalid unsigned 8-bit integer. Behavior is undefined when <code>value</code> is anything\nother than an unsigned 8-bit integer.</p>\n<pre><code class=\"language-js\">const buf = Buffer.allocUnsafe(4);\n\nbuf.writeUInt8(0x3, 0);\nbuf.writeUInt8(0x4, 1);\nbuf.writeUInt8(0x23, 2);\nbuf.writeUInt8(0x42, 3);\n\nconsole.log(buf);\n// Prints: &#x3C;Buffer 03 04 23 42>\n</code></pre>"
            },
            {
              "textRaw": "buf.writeUInt16BE(value, offset)",
              "type": "method",
              "name": "writeUInt16BE",
              "meta": {
                "added": [
                  "v0.5.5"
                ],
                "changes": [
                  {
                    "version": "v10.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/18395",
                    "description": "Removed `noAssert` and no implicit coercion of the offset to `uint32` anymore."
                  }
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {integer} `offset` plus the number of bytes written.",
                    "name": "return",
                    "type": "integer",
                    "desc": "`offset` plus the number of bytes written."
                  },
                  "params": [
                    {
                      "textRaw": "`value` {integer} Number to be written to `buf`.",
                      "name": "value",
                      "type": "integer",
                      "desc": "Number to be written to `buf`."
                    },
                    {
                      "textRaw": "`offset` {integer} Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 2`.",
                      "name": "offset",
                      "type": "integer",
                      "desc": "Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 2`."
                    }
                  ]
                }
              ],
              "desc": "<p>Writes <code>value</code> to <code>buf</code> at the specified <code>offset</code> with specified endian\nformat (<code>writeUInt16BE()</code> writes big endian, <code>writeUInt16LE()</code> writes little\nendian). <code>value</code> should be a valid unsigned 16-bit integer. Behavior is\nundefined when <code>value</code> is anything other than an unsigned 16-bit integer.</p>\n<pre><code class=\"language-js\">const buf = Buffer.allocUnsafe(4);\n\nbuf.writeUInt16BE(0xdead, 0);\nbuf.writeUInt16BE(0xbeef, 2);\n\nconsole.log(buf);\n// Prints: &#x3C;Buffer de ad be ef>\n\nbuf.writeUInt16LE(0xdead, 0);\nbuf.writeUInt16LE(0xbeef, 2);\n\nconsole.log(buf);\n// Prints: &#x3C;Buffer ad de ef be>\n</code></pre>"
            },
            {
              "textRaw": "buf.writeUInt16LE(value, offset)",
              "type": "method",
              "name": "writeUInt16LE",
              "meta": {
                "added": [
                  "v0.5.5"
                ],
                "changes": [
                  {
                    "version": "v10.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/18395",
                    "description": "Removed `noAssert` and no implicit coercion of the offset to `uint32` anymore."
                  }
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {integer} `offset` plus the number of bytes written.",
                    "name": "return",
                    "type": "integer",
                    "desc": "`offset` plus the number of bytes written."
                  },
                  "params": [
                    {
                      "textRaw": "`value` {integer} Number to be written to `buf`.",
                      "name": "value",
                      "type": "integer",
                      "desc": "Number to be written to `buf`."
                    },
                    {
                      "textRaw": "`offset` {integer} Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 2`.",
                      "name": "offset",
                      "type": "integer",
                      "desc": "Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 2`."
                    }
                  ]
                }
              ],
              "desc": "<p>Writes <code>value</code> to <code>buf</code> at the specified <code>offset</code> with specified endian\nformat (<code>writeUInt16BE()</code> writes big endian, <code>writeUInt16LE()</code> writes little\nendian). <code>value</code> should be a valid unsigned 16-bit integer. Behavior is\nundefined when <code>value</code> is anything other than an unsigned 16-bit integer.</p>\n<pre><code class=\"language-js\">const buf = Buffer.allocUnsafe(4);\n\nbuf.writeUInt16BE(0xdead, 0);\nbuf.writeUInt16BE(0xbeef, 2);\n\nconsole.log(buf);\n// Prints: &#x3C;Buffer de ad be ef>\n\nbuf.writeUInt16LE(0xdead, 0);\nbuf.writeUInt16LE(0xbeef, 2);\n\nconsole.log(buf);\n// Prints: &#x3C;Buffer ad de ef be>\n</code></pre>"
            },
            {
              "textRaw": "buf.writeUInt32BE(value, offset)",
              "type": "method",
              "name": "writeUInt32BE",
              "meta": {
                "added": [
                  "v0.5.5"
                ],
                "changes": [
                  {
                    "version": "v10.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/18395",
                    "description": "Removed `noAssert` and no implicit coercion of the offset to `uint32` anymore."
                  }
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {integer} `offset` plus the number of bytes written.",
                    "name": "return",
                    "type": "integer",
                    "desc": "`offset` plus the number of bytes written."
                  },
                  "params": [
                    {
                      "textRaw": "`value` {integer} Number to be written to `buf`.",
                      "name": "value",
                      "type": "integer",
                      "desc": "Number to be written to `buf`."
                    },
                    {
                      "textRaw": "`offset` {integer} Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 4`.",
                      "name": "offset",
                      "type": "integer",
                      "desc": "Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 4`."
                    }
                  ]
                }
              ],
              "desc": "<p>Writes <code>value</code> to <code>buf</code> at the specified <code>offset</code> with specified endian\nformat (<code>writeUInt32BE()</code> writes big endian, <code>writeUInt32LE()</code> writes little\nendian). <code>value</code> should be a valid unsigned 32-bit integer. Behavior is\nundefined when <code>value</code> is anything other than an unsigned 32-bit integer.</p>\n<pre><code class=\"language-js\">const buf = Buffer.allocUnsafe(4);\n\nbuf.writeUInt32BE(0xfeedface, 0);\n\nconsole.log(buf);\n// Prints: &#x3C;Buffer fe ed fa ce>\n\nbuf.writeUInt32LE(0xfeedface, 0);\n\nconsole.log(buf);\n// Prints: &#x3C;Buffer ce fa ed fe>\n</code></pre>"
            },
            {
              "textRaw": "buf.writeUInt32LE(value, offset)",
              "type": "method",
              "name": "writeUInt32LE",
              "meta": {
                "added": [
                  "v0.5.5"
                ],
                "changes": [
                  {
                    "version": "v10.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/18395",
                    "description": "Removed `noAssert` and no implicit coercion of the offset to `uint32` anymore."
                  }
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {integer} `offset` plus the number of bytes written.",
                    "name": "return",
                    "type": "integer",
                    "desc": "`offset` plus the number of bytes written."
                  },
                  "params": [
                    {
                      "textRaw": "`value` {integer} Number to be written to `buf`.",
                      "name": "value",
                      "type": "integer",
                      "desc": "Number to be written to `buf`."
                    },
                    {
                      "textRaw": "`offset` {integer} Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 4`.",
                      "name": "offset",
                      "type": "integer",
                      "desc": "Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 4`."
                    }
                  ]
                }
              ],
              "desc": "<p>Writes <code>value</code> to <code>buf</code> at the specified <code>offset</code> with specified endian\nformat (<code>writeUInt32BE()</code> writes big endian, <code>writeUInt32LE()</code> writes little\nendian). <code>value</code> should be a valid unsigned 32-bit integer. Behavior is\nundefined when <code>value</code> is anything other than an unsigned 32-bit integer.</p>\n<pre><code class=\"language-js\">const buf = Buffer.allocUnsafe(4);\n\nbuf.writeUInt32BE(0xfeedface, 0);\n\nconsole.log(buf);\n// Prints: &#x3C;Buffer fe ed fa ce>\n\nbuf.writeUInt32LE(0xfeedface, 0);\n\nconsole.log(buf);\n// Prints: &#x3C;Buffer ce fa ed fe>\n</code></pre>"
            },
            {
              "textRaw": "buf.writeUIntBE(value, offset, byteLength)",
              "type": "method",
              "name": "writeUIntBE",
              "meta": {
                "added": [
                  "v0.5.5"
                ],
                "changes": [
                  {
                    "version": "v10.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/18395",
                    "description": "Removed `noAssert` and no implicit coercion of the offset and `byteLength` to `uint32` anymore."
                  }
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {integer} `offset` plus the number of bytes written.",
                    "name": "return",
                    "type": "integer",
                    "desc": "`offset` plus the number of bytes written."
                  },
                  "params": [
                    {
                      "textRaw": "`value` {integer} Number to be written to `buf`.",
                      "name": "value",
                      "type": "integer",
                      "desc": "Number to be written to `buf`."
                    },
                    {
                      "textRaw": "`offset` {integer} Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - byteLength`.",
                      "name": "offset",
                      "type": "integer",
                      "desc": "Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - byteLength`."
                    },
                    {
                      "textRaw": "`byteLength` {integer} Number of bytes to write. Must satisfy `0 < byteLength <= 6`.",
                      "name": "byteLength",
                      "type": "integer",
                      "desc": "Number of bytes to write. Must satisfy `0 < byteLength <= 6`."
                    }
                  ]
                }
              ],
              "desc": "<p>Writes <code>byteLength</code> bytes of <code>value</code> to <code>buf</code> at the specified <code>offset</code>.\nSupports up to 48 bits of accuracy. Behavior is undefined when <code>value</code> is\nanything other than an unsigned integer.</p>\n<pre><code class=\"language-js\">const buf = Buffer.allocUnsafe(6);\n\nbuf.writeUIntBE(0x1234567890ab, 0, 6);\n\nconsole.log(buf);\n// Prints: &#x3C;Buffer 12 34 56 78 90 ab>\n\nbuf.writeUIntLE(0x1234567890ab, 0, 6);\n\nconsole.log(buf);\n// Prints: &#x3C;Buffer ab 90 78 56 34 12>\n</code></pre>"
            },
            {
              "textRaw": "buf.writeUIntLE(value, offset, byteLength)",
              "type": "method",
              "name": "writeUIntLE",
              "meta": {
                "added": [
                  "v0.5.5"
                ],
                "changes": [
                  {
                    "version": "v10.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/18395",
                    "description": "Removed `noAssert` and no implicit coercion of the offset and `byteLength` to `uint32` anymore."
                  }
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {integer} `offset` plus the number of bytes written.",
                    "name": "return",
                    "type": "integer",
                    "desc": "`offset` plus the number of bytes written."
                  },
                  "params": [
                    {
                      "textRaw": "`value` {integer} Number to be written to `buf`.",
                      "name": "value",
                      "type": "integer",
                      "desc": "Number to be written to `buf`."
                    },
                    {
                      "textRaw": "`offset` {integer} Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - byteLength`.",
                      "name": "offset",
                      "type": "integer",
                      "desc": "Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - byteLength`."
                    },
                    {
                      "textRaw": "`byteLength` {integer} Number of bytes to write. Must satisfy `0 < byteLength <= 6`.",
                      "name": "byteLength",
                      "type": "integer",
                      "desc": "Number of bytes to write. Must satisfy `0 < byteLength <= 6`."
                    }
                  ]
                }
              ],
              "desc": "<p>Writes <code>byteLength</code> bytes of <code>value</code> to <code>buf</code> at the specified <code>offset</code>.\nSupports up to 48 bits of accuracy. Behavior is undefined when <code>value</code> is\nanything other than an unsigned integer.</p>\n<pre><code class=\"language-js\">const buf = Buffer.allocUnsafe(6);\n\nbuf.writeUIntBE(0x1234567890ab, 0, 6);\n\nconsole.log(buf);\n// Prints: &#x3C;Buffer 12 34 56 78 90 ab>\n\nbuf.writeUIntLE(0x1234567890ab, 0, 6);\n\nconsole.log(buf);\n// Prints: &#x3C;Buffer ab 90 78 56 34 12>\n</code></pre>"
            }
          ],
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`array` {integer[]} An array of bytes to copy from.",
                  "name": "array",
                  "type": "integer[]",
                  "desc": "An array of bytes to copy from."
                }
              ],
              "desc": "<p>Allocates a new <code>Buffer</code> using an <code>array</code> of octets.</p>\n<pre><code class=\"language-js\">// Creates a new Buffer containing the UTF-8 bytes of the string 'buffer'\nconst buf = new Buffer([0x62, 0x75, 0x66, 0x66, 0x65, 0x72]);\n</code></pre>"
            },
            {
              "params": [
                {
                  "textRaw": "`arrayBuffer` {ArrayBuffer|SharedArrayBuffer} An [`ArrayBuffer`], [`SharedArrayBuffer`] or the `.buffer` property of a [`TypedArray`].",
                  "name": "arrayBuffer",
                  "type": "ArrayBuffer|SharedArrayBuffer",
                  "desc": "An [`ArrayBuffer`], [`SharedArrayBuffer`] or the `.buffer` property of a [`TypedArray`]."
                },
                {
                  "textRaw": "`byteOffset` {integer} Index of first byte to expose. **Default:** `0`.",
                  "name": "byteOffset",
                  "type": "integer",
                  "default": "`0`",
                  "desc": "Index of first byte to expose.",
                  "optional": true
                },
                {
                  "textRaw": "`length` {integer} Number of bytes to expose. **Default:** `arrayBuffer.length - byteOffset`.",
                  "name": "length",
                  "type": "integer",
                  "default": "`arrayBuffer.length - byteOffset`",
                  "desc": "Number of bytes to expose.",
                  "optional": true
                }
              ],
              "desc": "<p>This creates a view of the <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer\"><code>ArrayBuffer</code></a> or <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer\"><code>SharedArrayBuffer</code></a> without\ncopying the underlying memory. For example, when passed a reference to the\n<code>.buffer</code> property of a <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray\"><code>TypedArray</code></a> instance, the newly created <code>Buffer</code> will\nshare the same allocated memory as the <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray\"><code>TypedArray</code></a>.</p>\n<p>The optional <code>byteOffset</code> and <code>length</code> arguments specify a memory range within\nthe <code>arrayBuffer</code> that will be shared by the <code>Buffer</code>.</p>\n<pre><code class=\"language-js\">const arr = new Uint16Array(2);\n\narr[0] = 5000;\narr[1] = 4000;\n\n// Shares memory with `arr`\nconst buf = new Buffer(arr.buffer);\n\nconsole.log(buf);\n// Prints: &#x3C;Buffer 88 13 a0 0f>\n\n// Changing the original Uint16Array changes the Buffer also\narr[1] = 6000;\n\nconsole.log(buf);\n// Prints: &#x3C;Buffer 88 13 70 17>\n</code></pre>"
            },
            {
              "params": [
                {
                  "textRaw": "`buffer` {Buffer|Uint8Array} An existing `Buffer` or [`Uint8Array`] from which to copy data.",
                  "name": "buffer",
                  "type": "Buffer|Uint8Array",
                  "desc": "An existing `Buffer` or [`Uint8Array`] from which to copy data."
                }
              ],
              "desc": "<p>Copies the passed <code>buffer</code> data onto a new <code>Buffer</code> instance.</p>\n<pre><code class=\"language-js\">const buf1 = new Buffer('buffer');\nconst buf2 = new Buffer(buf1);\n\nbuf1[0] = 0x61;\n\nconsole.log(buf1.toString());\n// Prints: auffer\nconsole.log(buf2.toString());\n// Prints: buffer\n</code></pre>"
            },
            {
              "params": [
                {
                  "textRaw": "`size` {integer} The desired length of the new `Buffer`.",
                  "name": "size",
                  "type": "integer",
                  "desc": "The desired length of the new `Buffer`."
                }
              ],
              "desc": "<p>Allocates a new <code>Buffer</code> of <code>size</code> bytes. If <code>size</code> is larger than\n<a href=\"#buffer_buffer_constants_max_length\"><code>buffer.constants.MAX_LENGTH</code></a> or smaller than 0, <a href=\"errors.html#ERR_INVALID_OPT_VALUE\"><code>ERR_INVALID_OPT_VALUE</code></a> is\nthrown. A zero-length <code>Buffer</code> is created if <code>size</code> is 0.</p>\n<p>Prior to Node.js 8.0.0, the underlying memory for <code>Buffer</code> instances\ncreated in this way is <em>not initialized</em>. The contents of a newly created\n<code>Buffer</code> are unknown and <em>may contain sensitive data</em>. Use\n<a href=\"#buffer_class_method_buffer_alloc_size_fill_encoding\"><code>Buffer.alloc(size)</code></a> instead to initialize a <code>Buffer</code>\nwith zeroes.</p>\n<pre><code class=\"language-js\">const buf = new Buffer(10);\n\nconsole.log(buf);\n// Prints: &#x3C;Buffer 00 00 00 00 00 00 00 00 00 00>\n</code></pre>"
            },
            {
              "params": [
                {
                  "textRaw": "`string` {string} String to encode.",
                  "name": "string",
                  "type": "string",
                  "desc": "String to encode."
                },
                {
                  "textRaw": "`encoding` {string} The encoding of `string`. **Default:** `'utf8'`.",
                  "name": "encoding",
                  "type": "string",
                  "default": "`'utf8'`",
                  "desc": "The encoding of `string`.",
                  "optional": true
                }
              ],
              "desc": "<p>Creates a new <code>Buffer</code> containing <code>string</code>. The <code>encoding</code> parameter identifies\nthe character encoding of <code>string</code>.</p>\n<pre><code class=\"language-js\">const buf1 = new Buffer('this is a tést');\nconst buf2 = new Buffer('7468697320697320612074c3a97374', 'hex');\n\nconsole.log(buf1.toString());\n// Prints: this is a tést\nconsole.log(buf2.toString());\n// Prints: this is a tést\nconsole.log(buf1.toString('ascii'));\n// Prints: this is a tC)st\n</code></pre>"
            }
          ]
        },
        {
          "textRaw": "Class: SlowBuffer",
          "type": "class",
          "name": "SlowBuffer",
          "meta": {
            "deprecated": [
              "v6.0.0"
            ],
            "changes": []
          },
          "stability": 0,
          "stabilityText": "Deprecated: Use [`Buffer.allocUnsafeSlow()`] instead.",
          "desc": "<p>Returns an un-pooled <code>Buffer</code>.</p>\n<p>In order to avoid the garbage collection overhead of creating many individually\nallocated <code>Buffer</code> instances, by default allocations under 4KB are sliced from a\nsingle larger allocated object.</p>\n<p>In the case where a developer may need to retain a small chunk of memory from a\npool for an indeterminate amount of time, it may be appropriate to create an\nun-pooled <code>Buffer</code> instance using <code>SlowBuffer</code> then copy out the relevant bits.</p>\n<pre><code class=\"language-js\">// Need to keep around a few small chunks of memory\nconst store = [];\n\nsocket.on('readable', () => {\n  const data = socket.read();\n\n  // Allocate for retained data\n  const sb = SlowBuffer(10);\n\n  // Copy the data into the new allocation\n  data.copy(sb, 0, 0, 10);\n\n  store.push(sb);\n});\n</code></pre>\n<p>Use of <code>SlowBuffer</code> should be used only as a last resort <em>after</em> a developer\nhas observed undue memory retention in their applications.</p>",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`size` {integer} The desired length of the new `SlowBuffer`.",
                  "name": "size",
                  "type": "integer",
                  "desc": "The desired length of the new `SlowBuffer`."
                }
              ],
              "desc": "<p>Allocates a new <code>Buffer</code> of <code>size</code> bytes. If <code>size</code> is larger than\n<a href=\"#buffer_buffer_constants_max_length\"><code>buffer.constants.MAX_LENGTH</code></a> or smaller than 0, <a href=\"errors.html#ERR_INVALID_OPT_VALUE\"><code>ERR_INVALID_OPT_VALUE</code></a> is\nthrown. A zero-length <code>Buffer</code> is created if <code>size</code> is 0.</p>\n<p>The underlying memory for <code>SlowBuffer</code> instances is <em>not initialized</em>. The\ncontents of a newly created <code>SlowBuffer</code> are unknown and may contain sensitive\ndata. Use <a href=\"#buffer_buf_fill_value_offset_end_encoding\"><code>buf.fill(0)</code></a> to initialize a <code>SlowBuffer</code> with\nzeroes.</p>\n<pre><code class=\"language-js\">const { SlowBuffer } = require('buffer');\n\nconst buf = new SlowBuffer(5);\n\nconsole.log(buf);\n// Prints: (contents may vary): &#x3C;Buffer 78 e0 82 02 01>\n\nbuf.fill(0);\n\nconsole.log(buf);\n// Prints: &#x3C;Buffer 00 00 00 00 00>\n</code></pre>"
            }
          ]
        }
      ],
      "properties": [
        {
          "textRaw": "`INSPECT_MAX_BYTES` {integer} **Default:** `50`",
          "type": "integer",
          "name": "INSPECT_MAX_BYTES",
          "meta": {
            "added": [
              "v0.5.4"
            ],
            "changes": []
          },
          "default": "`50`",
          "desc": "<p>Returns the maximum number of bytes that will be returned when\n<code>buf.inspect()</code> is called. This can be overridden by user modules. See\n<a href=\"util.html#util_util_inspect_object_options\"><code>util.inspect()</code></a> for more details on <code>buf.inspect()</code> behavior.</p>\n<p>Note that this is a property on the <code>buffer</code> module returned by\n<code>require('buffer')</code>, not on the <code>Buffer</code> global or a <code>Buffer</code> instance.</p>"
        },
        {
          "textRaw": "`kMaxLength` {integer} The largest size allowed for a single `Buffer` instance.",
          "type": "integer",
          "name": "kMaxLength",
          "meta": {
            "added": [
              "v3.0.0"
            ],
            "changes": []
          },
          "desc": "<p>An alias for <a href=\"#buffer_buffer_constants_max_length\"><code>buffer.constants.MAX_LENGTH</code></a>.</p>\n<p>Note that this is a property on the <code>buffer</code> module returned by\n<code>require('buffer')</code>, not on the <code>Buffer</code> global or a <code>Buffer</code> instance.</p>",
          "shortDesc": "The largest size allowed for a single `Buffer` instance."
        }
      ],
      "methods": [
        {
          "textRaw": "buffer.transcode(source, fromEnc, toEnc)",
          "type": "method",
          "name": "transcode",
          "meta": {
            "added": [
              "v7.1.0"
            ],
            "changes": [
              {
                "version": "v8.0.0",
                "pr-url": "https://github.com/nodejs/node/pull/10236",
                "description": "The `source` parameter can now be a `Uint8Array`."
              }
            ]
          },
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`source` {Buffer|Uint8Array} A `Buffer` or `Uint8Array` instance.",
                  "name": "source",
                  "type": "Buffer|Uint8Array",
                  "desc": "A `Buffer` or `Uint8Array` instance."
                },
                {
                  "textRaw": "`fromEnc` {string} The current encoding.",
                  "name": "fromEnc",
                  "type": "string",
                  "desc": "The current encoding."
                },
                {
                  "textRaw": "`toEnc` {string} To target encoding.",
                  "name": "toEnc",
                  "type": "string",
                  "desc": "To target encoding."
                }
              ]
            }
          ],
          "desc": "<p>Re-encodes the given <code>Buffer</code> or <code>Uint8Array</code> instance from one character\nencoding to another. Returns a new <code>Buffer</code> instance.</p>\n<p>Throws if the <code>fromEnc</code> or <code>toEnc</code> specify invalid character encodings or if\nconversion from <code>fromEnc</code> to <code>toEnc</code> is not permitted.</p>\n<p>Encodings supported by <code>buffer.transcode()</code> are: <code>'ascii'</code>, <code>'utf8'</code>,\n<code>'utf16le'</code>, <code>'ucs2'</code>, <code>'latin1'</code>, and <code>'binary'</code>.</p>\n<p>The transcoding process will use substitution characters if a given byte\nsequence cannot be adequately represented in the target encoding. For instance:</p>\n<pre><code class=\"language-js\">const buffer = require('buffer');\n\nconst newBuf = buffer.transcode(Buffer.from('€'), 'utf8', 'ascii');\nconsole.log(newBuf.toString('ascii'));\n// Prints: '?'\n</code></pre>\n<p>Because the Euro (<code>€</code>) sign is not representable in US-ASCII, it is replaced\nwith <code>?</code> in the transcoded <code>Buffer</code>.</p>\n<p>Note that this is a property on the <code>buffer</code> module returned by\n<code>require('buffer')</code>, not on the <code>Buffer</code> global or a <code>Buffer</code> instance.</p>"
        }
      ],
      "type": "module",
      "displayName": "Buffer"
    }
  ]
}