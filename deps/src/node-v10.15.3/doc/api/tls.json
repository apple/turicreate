{
  "type": "module",
  "source": "doc/api/tls.md",
  "modules": [
    {
      "textRaw": "TLS (SSL)",
      "name": "tls_(ssl)",
      "introduced_in": "v0.10.0",
      "stability": 2,
      "stabilityText": "Stable",
      "desc": "<p>The <code>tls</code> module provides an implementation of the Transport Layer Security\n(TLS) and Secure Socket Layer (SSL) protocols that is built on top of OpenSSL.\nThe module can be accessed using:</p>\n<pre><code class=\"language-js\">const tls = require('tls');\n</code></pre>",
      "modules": [
        {
          "textRaw": "TLS/SSL Concepts",
          "name": "tls/ssl_concepts",
          "desc": "<p>The TLS/SSL is a public/private key infrastructure (PKI). For most common\ncases, each client and server must have a <em>private key</em>.</p>\n<p>Private keys can be generated in multiple ways. The example below illustrates\nuse of the OpenSSL command-line interface to generate a 2048-bit RSA private\nkey:</p>\n<pre><code class=\"language-sh\">openssl genrsa -out ryans-key.pem 2048\n</code></pre>\n<p>With TLS/SSL, all servers (and some clients) must have a <em>certificate</em>.\nCertificates are <em>public keys</em> that correspond to a private key, and that are\ndigitally signed either by a Certificate Authority or by the owner of the\nprivate key (such certificates are referred to as \"self-signed\"). The first\nstep to obtaining a certificate is to create a <em>Certificate Signing Request</em>\n(CSR) file.</p>\n<p>The OpenSSL command-line interface can be used to generate a CSR for a private\nkey:</p>\n<pre><code class=\"language-sh\">openssl req -new -sha256 -key ryans-key.pem -out ryans-csr.pem\n</code></pre>\n<p>Once the CSR file is generated, it can either be sent to a Certificate\nAuthority for signing or used to generate a self-signed certificate.</p>\n<p>Creating a self-signed certificate using the OpenSSL command-line interface\nis illustrated in the example below:</p>\n<pre><code class=\"language-sh\">openssl x509 -req -in ryans-csr.pem -signkey ryans-key.pem -out ryans-cert.pem\n</code></pre>\n<p>Once the certificate is generated, it can be used to generate a <code>.pfx</code> or\n<code>.p12</code> file:</p>\n<pre><code class=\"language-sh\">openssl pkcs12 -export -in ryans-cert.pem -inkey ryans-key.pem \\\n      -certfile ca-cert.pem -out ryans.pfx\n</code></pre>\n<p>Where:</p>\n<ul>\n<li><code>in</code>: is the signed certificate</li>\n<li><code>inkey</code>: is the associated private key</li>\n<li><code>certfile</code>: is a concatenation of all Certificate Authority (CA) certs into\na single file, e.g. <code>cat ca1-cert.pem ca2-cert.pem > ca-cert.pem</code></li>\n</ul>",
          "miscs": [
            {
              "textRaw": "Perfect Forward Secrecy",
              "name": "Perfect Forward Secrecy",
              "type": "misc",
              "desc": "<p>The term \"<a href=\"https://en.wikipedia.org/wiki/Perfect_forward_secrecy\">Forward Secrecy</a>\" or \"Perfect Forward Secrecy\" describes a feature of\nkey-agreement (i.e., key-exchange) methods. That is, the server and client keys\nare used to negotiate new temporary keys that are used specifically and only for\nthe current communication session. Practically, this means that even if the\nserver's private key is compromised, communication can only be decrypted by\neavesdroppers if the attacker manages to obtain the key-pair specifically\ngenerated for the session.</p>\n<p>Perfect Forward Secrecy is achieved by randomly generating a key pair for\nkey-agreement on every TLS/SSL handshake (in contrast to using the same key for\nall sessions). Methods implementing this technique are called \"ephemeral\".</p>\n<p>Currently two methods are commonly used to achieve Perfect Forward Secrecy (note\nthe character \"E\" appended to the traditional abbreviations):</p>\n<ul>\n<li><a href=\"https://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange\">DHE</a> - An ephemeral version of the Diffie Hellman key-agreement protocol.</li>\n<li><a href=\"https://en.wikipedia.org/wiki/Elliptic_curve_Diffie%E2%80%93Hellman\">ECDHE</a> - An ephemeral version of the Elliptic Curve Diffie Hellman\nkey-agreement protocol.</li>\n</ul>\n<p>Ephemeral methods may have some performance drawbacks, because key generation\nis expensive.</p>\n<p>To use Perfect Forward Secrecy using <code>DHE</code> with the <code>tls</code> module, it is required\nto generate Diffie-Hellman parameters and specify them with the <code>dhparam</code>\noption to <a href=\"#tls_tls_createsecurecontext_options\"><code>tls.createSecureContext()</code></a>. The following illustrates the use of\nthe OpenSSL command-line interface to generate such parameters:</p>\n<pre><code class=\"language-sh\">openssl dhparam -outform PEM -out dhparam.pem 2048\n</code></pre>\n<p>If using Perfect Forward Secrecy using <code>ECDHE</code>, Diffie-Hellman parameters are\nnot required and a default ECDHE curve will be used. The <code>ecdhCurve</code> property\ncan be used when creating a TLS Server to specify the list of names of supported\ncurves to use, see <a href=\"#tls_tls_createserver_options_secureconnectionlistener\"><code>tls.createServer()</code></a> for more info.</p>"
            },
            {
              "textRaw": "ALPN and SNI",
              "name": "ALPN and SNI",
              "type": "misc",
              "desc": "<p>ALPN (Application-Layer Protocol Negotiation Extension) and\nSNI (Server Name Indication) are TLS handshake extensions:</p>\n<ul>\n<li>ALPN - Allows the use of one TLS server for multiple protocols (HTTP, HTTP/2)</li>\n<li>SNI - Allows the use of one TLS server for multiple hostnames with different\nSSL certificates.</li>\n</ul>"
            },
            {
              "textRaw": "Client-initiated renegotiation attack mitigation",
              "name": "Client-initiated renegotiation attack mitigation",
              "type": "misc",
              "desc": "<p>The TLS protocol allows clients to renegotiate certain aspects of the TLS\nsession. Unfortunately, session renegotiation requires a disproportionate amount\nof server-side resources, making it a potential vector for denial-of-service\nattacks.</p>\n<p>To mitigate the risk, renegotiation is limited to three times every ten minutes.\nAn <code>'error'</code> event is emitted on the <a href=\"#tls_class_tls_tlssocket\"><code>tls.TLSSocket</code></a> instance when this\nthreshold is exceeded. The limits are configurable:</p>\n<ul>\n<li><code>tls.CLIENT_RENEG_LIMIT</code> <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type\" class=\"type\">&lt;number&gt;</a> Specifies the number of renegotiation\nrequests. <strong>Default:</strong> <code>3</code>.</li>\n<li><code>tls.CLIENT_RENEG_WINDOW</code> <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type\" class=\"type\">&lt;number&gt;</a> Specifies the time renegotiation window\nin seconds. <strong>Default:</strong> <code>600</code> (10 minutes).</li>\n</ul>\n<p>The default renegotiation limits should not be modified without a full\nunderstanding of the implications and risks.</p>\n<p>To test the renegotiation limits on a server, connect to it using the OpenSSL\ncommand-line client (<code>openssl s_client -connect address:port</code>) then input\n<code>R&#x3C;CR></code> (i.e., the letter <code>R</code> followed by a carriage return) multiple times.</p>"
            }
          ],
          "type": "module",
          "displayName": "TLS/SSL Concepts"
        },
        {
          "textRaw": "Modifying the Default TLS Cipher suite",
          "name": "modifying_the_default_tls_cipher_suite",
          "desc": "<p>Node.js is built with a default suite of enabled and disabled TLS ciphers.\nCurrently, the default cipher suite is:</p>\n<pre><code class=\"language-txt\">ECDHE-RSA-AES128-GCM-SHA256:\nECDHE-ECDSA-AES128-GCM-SHA256:\nECDHE-RSA-AES256-GCM-SHA384:\nECDHE-ECDSA-AES256-GCM-SHA384:\nDHE-RSA-AES128-GCM-SHA256:\nECDHE-RSA-AES128-SHA256:\nDHE-RSA-AES128-SHA256:\nECDHE-RSA-AES256-SHA384:\nDHE-RSA-AES256-SHA384:\nECDHE-RSA-AES256-SHA256:\nDHE-RSA-AES256-SHA256:\nHIGH:\n!aNULL:\n!eNULL:\n!EXPORT:\n!DES:\n!RC4:\n!MD5:\n!PSK:\n!SRP:\n!CAMELLIA\n</code></pre>\n<p>This default can be replaced entirely using the <code>--tls-cipher-list</code> command\nline switch. For instance, the following makes\n<code>ECDHE-RSA-AES128-GCM-SHA256:!RC4</code> the default TLS cipher suite:</p>\n<pre><code class=\"language-sh\">node --tls-cipher-list=\"ECDHE-RSA-AES128-GCM-SHA256:!RC4\"\n</code></pre>\n<p>The default can also be replaced on a per client or server basis using the\n<code>ciphers</code> option from <a href=\"#tls_tls_createsecurecontext_options\"><code>tls.createSecureContext()</code></a>, which is also available\nin <a href=\"#tls_tls_createserver_options_secureconnectionlistener\"><code>tls.createServer()</code></a>, <a href=\"#tls_tls_connect_options_callback\"><code>tls.connect()</code></a>, and when creating new\n<a href=\"#tls_class_tls_tlssocket\"><code>tls.TLSSocket</code></a>s.</p>\n<p>Consult <a href=\"https://www.openssl.org/docs/man1.1.0/apps/ciphers.html#CIPHER-LIST-FORMAT\">OpenSSL cipher list format documentation</a> for details on the format.</p>\n<p>The default cipher suite included within Node.js has been carefully\nselected to reflect current security best practices and risk mitigation.\nChanging the default cipher suite can have a significant impact on the security\nof an application. The <code>--tls-cipher-list</code> switch and <code>ciphers</code> option should by\nused only if absolutely necessary.</p>\n<p>The default cipher suite prefers GCM ciphers for <a href=\"https://www.chromium.org/Home/chromium-security/education/tls#TOC-Cipher-Suites\">Chrome's 'modern\ncryptography' setting</a> and also prefers ECDHE and DHE ciphers for Perfect\nForward Secrecy, while offering <em>some</em> backward compatibility.</p>\n<p>128 bit AES is preferred over 192 and 256 bit AES in light of <a href=\"https://www.schneier.com/blog/archives/2009/07/another_new_aes.html\">specific\nattacks affecting larger AES key sizes</a>.</p>\n<p>Old clients that rely on insecure and deprecated RC4 or DES-based ciphers\n(like Internet Explorer 6) cannot complete the handshaking process with\nthe default configuration. If these clients <em>must</em> be supported, the\n<a href=\"https://wiki.mozilla.org/Security/Server_Side_TLS\">TLS recommendations</a> may offer a compatible cipher suite. For more details\non the format, see the <a href=\"https://www.openssl.org/docs/man1.1.0/apps/ciphers.html#CIPHER-LIST-FORMAT\">OpenSSL cipher list format documentation</a>.</p>",
          "type": "module",
          "displayName": "Modifying the Default TLS Cipher suite"
        },
        {
          "textRaw": "Deprecated APIs",
          "name": "deprecated_apis",
          "classes": [
            {
              "textRaw": "Class: CryptoStream",
              "type": "class",
              "name": "CryptoStream",
              "meta": {
                "added": [
                  "v0.3.4"
                ],
                "deprecated": [
                  "v0.11.3"
                ],
                "changes": []
              },
              "stability": 0,
              "stabilityText": "Deprecated: Use [`tls.TLSSocket`][] instead.",
              "desc": "<p>The <code>tls.CryptoStream</code> class represents a stream of encrypted data. This class\nis deprecated and should no longer be used.</p>",
              "properties": [
                {
                  "textRaw": "cryptoStream.bytesWritten",
                  "name": "bytesWritten",
                  "meta": {
                    "added": [
                      "v0.3.4"
                    ],
                    "deprecated": [
                      "v0.11.3"
                    ],
                    "changes": []
                  },
                  "desc": "<p>The <code>cryptoStream.bytesWritten</code> property returns the total number of bytes\nwritten to the underlying socket <em>including</em> the bytes required for the\nimplementation of the TLS protocol.</p>"
                }
              ]
            },
            {
              "textRaw": "Class: SecurePair",
              "type": "class",
              "name": "SecurePair",
              "meta": {
                "added": [
                  "v0.3.2"
                ],
                "deprecated": [
                  "v0.11.3"
                ],
                "changes": []
              },
              "stability": 0,
              "stabilityText": "Deprecated: Use [`tls.TLSSocket`][] instead.",
              "desc": "<p>Returned by <a href=\"#tls_tls_createsecurepair_context_isserver_requestcert_rejectunauthorized_options\"><code>tls.createSecurePair()</code></a>.</p>",
              "events": [
                {
                  "textRaw": "Event: 'secure'",
                  "type": "event",
                  "name": "secure",
                  "meta": {
                    "added": [
                      "v0.3.2"
                    ],
                    "deprecated": [
                      "v0.11.3"
                    ],
                    "changes": []
                  },
                  "params": [],
                  "desc": "<p>The <code>'secure'</code> event is emitted by the <code>SecurePair</code> object once a secure\nconnection has been established.</p>\n<p>As with checking for the server\n<a href=\"#tls_event_secureconnection\"><code>'secureConnection'</code></a>\nevent, <code>pair.cleartext.authorized</code> should be inspected to confirm whether the\ncertificate used is properly authorized.</p>"
                }
              ]
            }
          ],
          "methods": [
            {
              "textRaw": "tls.createSecurePair([context][, isServer][, requestCert][, rejectUnauthorized][, options])",
              "type": "method",
              "name": "createSecurePair",
              "meta": {
                "added": [
                  "v0.3.2"
                ],
                "deprecated": [
                  "v0.11.3"
                ],
                "changes": [
                  {
                    "version": "v5.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/2564",
                    "description": "ALPN options are supported now."
                  }
                ]
              },
              "stability": 0,
              "stabilityText": "Deprecated: Use [`tls.TLSSocket`][] instead.",
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`context` {Object} A secure context object as returned by `tls.createSecureContext()`",
                      "name": "context",
                      "type": "Object",
                      "desc": "A secure context object as returned by `tls.createSecureContext()`",
                      "optional": true
                    },
                    {
                      "textRaw": "`isServer` {boolean} `true` to specify that this TLS connection should be opened as a server.",
                      "name": "isServer",
                      "type": "boolean",
                      "desc": "`true` to specify that this TLS connection should be opened as a server.",
                      "optional": true
                    },
                    {
                      "textRaw": "`requestCert` {boolean} `true` to specify whether a server should request a certificate from a connecting client. Only applies when `isServer` is `true`.",
                      "name": "requestCert",
                      "type": "boolean",
                      "desc": "`true` to specify whether a server should request a certificate from a connecting client. Only applies when `isServer` is `true`.",
                      "optional": true
                    },
                    {
                      "textRaw": "`rejectUnauthorized` {boolean} If not `false` a server automatically reject clients with invalid certificates. Only applies when `isServer` is `true`.",
                      "name": "rejectUnauthorized",
                      "type": "boolean",
                      "desc": "If not `false` a server automatically reject clients with invalid certificates. Only applies when `isServer` is `true`.",
                      "optional": true
                    },
                    {
                      "textRaw": "`options`",
                      "name": "options",
                      "options": [
                        {
                          "textRaw": "`secureContext`: A TLS context object from [`tls.createSecureContext()`][]",
                          "name": "secureContext",
                          "desc": "A TLS context object from [`tls.createSecureContext()`][]"
                        },
                        {
                          "textRaw": "`isServer`: If `true` the TLS socket will be instantiated in server-mode. **Default:** `false`.",
                          "name": "isServer",
                          "default": "`false`",
                          "desc": "If `true` the TLS socket will be instantiated in server-mode."
                        },
                        {
                          "textRaw": "`server` {net.Server} A [`net.Server`][] instance",
                          "name": "server",
                          "type": "net.Server",
                          "desc": "A [`net.Server`][] instance"
                        },
                        {
                          "textRaw": "`requestCert`: See [`tls.createServer()`][]",
                          "name": "requestCert",
                          "desc": "See [`tls.createServer()`][]"
                        },
                        {
                          "textRaw": "`rejectUnauthorized`: See [`tls.createServer()`][]",
                          "name": "rejectUnauthorized",
                          "desc": "See [`tls.createServer()`][]"
                        },
                        {
                          "textRaw": "`ALPNProtocols`: See [`tls.createServer()`][]",
                          "name": "ALPNProtocols",
                          "desc": "See [`tls.createServer()`][]"
                        },
                        {
                          "textRaw": "`SNICallback`: See [`tls.createServer()`][]",
                          "name": "SNICallback",
                          "desc": "See [`tls.createServer()`][]"
                        },
                        {
                          "textRaw": "`session` {Buffer} A `Buffer` instance containing a TLS session.",
                          "name": "session",
                          "type": "Buffer",
                          "desc": "A `Buffer` instance containing a TLS session."
                        },
                        {
                          "textRaw": "`requestOCSP` {boolean} If `true`, specifies that the OCSP status request extension will be added to the client hello and an `'OCSPResponse'` event will be emitted on the socket before establishing a secure communication.",
                          "name": "requestOCSP",
                          "type": "boolean",
                          "desc": "If `true`, specifies that the OCSP status request extension will be added to the client hello and an `'OCSPResponse'` event will be emitted on the socket before establishing a secure communication."
                        }
                      ],
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Creates a new secure pair object with two streams, one of which reads and writes\nthe encrypted data and the other of which reads and writes the cleartext data.\nGenerally, the encrypted stream is piped to/from an incoming encrypted data\nstream and the cleartext one is used as a replacement for the initial encrypted\nstream.</p>\n<p><code>tls.createSecurePair()</code> returns a <code>tls.SecurePair</code> object with <code>cleartext</code> and\n<code>encrypted</code> stream properties.</p>\n<p>Using <code>cleartext</code> has the same API as <a href=\"#tls_class_tls_tlssocket\"><code>tls.TLSSocket</code></a>.</p>\n<p>The <code>tls.createSecurePair()</code> method is now deprecated in favor of\n<code>tls.TLSSocket()</code>. For example, the code:</p>\n<pre><code class=\"language-js\">pair = tls.createSecurePair(/* ... */);\npair.encrypted.pipe(socket);\nsocket.pipe(pair.encrypted);\n</code></pre>\n<p>can be replaced by:</p>\n<pre><code class=\"language-js\">secureSocket = tls.TLSSocket(socket, options);\n</code></pre>\n<p>where <code>secureSocket</code> has the same API as <code>pair.cleartext</code>.</p>"
            }
          ],
          "type": "module",
          "displayName": "Deprecated APIs"
        }
      ],
      "classes": [
        {
          "textRaw": "Class: tls.Server",
          "type": "class",
          "name": "tls.Server",
          "meta": {
            "added": [
              "v0.3.2"
            ],
            "changes": []
          },
          "desc": "<p>The <code>tls.Server</code> class is a subclass of <code>net.Server</code> that accepts encrypted\nconnections using TLS or SSL.</p>",
          "events": [
            {
              "textRaw": "Event: 'newSession'",
              "type": "event",
              "name": "newSession",
              "meta": {
                "added": [
                  "v0.9.2"
                ],
                "changes": []
              },
              "params": [],
              "desc": "<p>The <code>'newSession'</code> event is emitted upon creation of a new TLS session. This may\nbe used to store sessions in external storage. The listener callback is passed\nthree arguments when called:</p>\n<ul>\n<li><code>sessionId</code> - The TLS session identifier</li>\n<li><code>sessionData</code> - The TLS session data</li>\n<li><code>callback</code> <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function\" class=\"type\">&lt;Function&gt;</a> A callback function taking no arguments that must be\ninvoked in order for data to be sent or received over the secure connection.</li>\n</ul>\n<p>Listening for this event will have an effect only on connections established\nafter the addition of the event listener.</p>"
            },
            {
              "textRaw": "Event: 'OCSPRequest'",
              "type": "event",
              "name": "OCSPRequest",
              "meta": {
                "added": [
                  "v0.11.13"
                ],
                "changes": []
              },
              "params": [],
              "desc": "<p>The <code>'OCSPRequest'</code> event is emitted when the client sends a certificate status\nrequest. The listener callback is passed three arguments when called:</p>\n<ul>\n<li><code>certificate</code> <a href=\"buffer.html#buffer_class_buffer\" class=\"type\">&lt;Buffer&gt;</a> The server certificate</li>\n<li><code>issuer</code> <a href=\"buffer.html#buffer_class_buffer\" class=\"type\">&lt;Buffer&gt;</a> The issuer's certificate</li>\n<li><code>callback</code> <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function\" class=\"type\">&lt;Function&gt;</a> A callback function that must be invoked to provide\nthe results of the OCSP request.</li>\n</ul>\n<p>The server's current certificate can be parsed to obtain the OCSP URL\nand certificate ID; after obtaining an OCSP response, <code>callback(null, resp)</code> is\nthen invoked, where <code>resp</code> is a <code>Buffer</code> instance containing the OCSP response.\nBoth <code>certificate</code> and <code>issuer</code> are <code>Buffer</code> DER-representations of the\nprimary and issuer's certificates. These can be used to obtain the OCSP\ncertificate ID and OCSP endpoint URL.</p>\n<p>Alternatively, <code>callback(null, null)</code> may be called, indicating that there was\nno OCSP response.</p>\n<p>Calling <code>callback(err)</code> will result in a <code>socket.destroy(err)</code> call.</p>\n<p>The typical flow of an OCSP Request is as follows:</p>\n<ol>\n<li>Client connects to the server and sends an <code>'OCSPRequest'</code> (via the status\ninfo extension in ClientHello).</li>\n<li>Server receives the request and emits the <code>'OCSPRequest'</code> event, calling the\nlistener if registered.</li>\n<li>Server extracts the OCSP URL from either the <code>certificate</code> or <code>issuer</code> and\nperforms an <a href=\"https://en.wikipedia.org/wiki/OCSP_stapling\">OCSP request</a> to the CA.</li>\n<li>Server receives <code>'OCSPResponse'</code> from the CA and sends it back to the client\nvia the <code>callback</code> argument</li>\n<li>Client validates the response and either destroys the socket or performs a\nhandshake.</li>\n</ol>\n<p>The <code>issuer</code> can be <code>null</code> if the certificate is either self-signed or the\nissuer is not in the root certificates list. (An issuer may be provided\nvia the <code>ca</code> option when establishing the TLS connection.)</p>\n<p>Listening for this event will have an effect only on connections established\nafter the addition of the event listener.</p>\n<p>An npm module like <a href=\"https://www.npmjs.com/package/asn1.js\">asn1.js</a> may be used to parse the certificates.</p>"
            },
            {
              "textRaw": "Event: 'resumeSession'",
              "type": "event",
              "name": "resumeSession",
              "meta": {
                "added": [
                  "v0.9.2"
                ],
                "changes": []
              },
              "params": [],
              "desc": "<p>The <code>'resumeSession'</code> event is emitted when the client requests to resume a\nprevious TLS session. The listener callback is passed two arguments when\ncalled:</p>\n<ul>\n<li><code>sessionId</code> - The TLS/SSL session identifier</li>\n<li><code>callback</code> <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function\" class=\"type\">&lt;Function&gt;</a> A callback function to be called when the prior session\nhas been recovered.</li>\n</ul>\n<p>When called, the event listener may perform a lookup in external storage using\nthe given <code>sessionId</code> and invoke <code>callback(null, sessionData)</code> once finished. If\nthe session cannot be resumed (i.e., doesn't exist in storage) the callback may\nbe invoked as <code>callback(null, null)</code>. Calling <code>callback(err)</code> will terminate the\nincoming connection and destroy the socket.</p>\n<p>Listening for this event will have an effect only on connections established\nafter the addition of the event listener.</p>\n<p>The following illustrates resuming a TLS session:</p>\n<pre><code class=\"language-js\">const tlsSessionStore = {};\nserver.on('newSession', (id, data, cb) => {\n  tlsSessionStore[id.toString('hex')] = data;\n  cb();\n});\nserver.on('resumeSession', (id, cb) => {\n  cb(null, tlsSessionStore[id.toString('hex')] || null);\n});\n</code></pre>"
            },
            {
              "textRaw": "Event: 'secureConnection'",
              "type": "event",
              "name": "secureConnection",
              "meta": {
                "added": [
                  "v0.3.2"
                ],
                "changes": []
              },
              "params": [],
              "desc": "<p>The <code>'secureConnection'</code> event is emitted after the handshaking process for a\nnew connection has successfully completed. The listener callback is passed a\nsingle argument when called:</p>\n<ul>\n<li><code>tlsSocket</code> <a href=\"tls.html#tls_class_tls_tlssocket\" class=\"type\">&lt;tls.TLSSocket&gt;</a> The established TLS socket.</li>\n</ul>\n<p>The <code>tlsSocket.authorized</code> property is a <code>boolean</code> indicating whether the\nclient has been verified by one of the supplied Certificate Authorities for the\nserver. If <code>tlsSocket.authorized</code> is <code>false</code>, then <code>socket.authorizationError</code>\nis set to describe how authorization failed. Note that depending on the settings\nof the TLS server, unauthorized connections may still be accepted.</p>\n<p>The <code>tlsSocket.alpnProtocol</code> property is a string that contains the selected\nALPN protocol. When ALPN has no selected protocol, <code>tlsSocket.alpnProtocol</code>\nequals <code>false</code>.</p>\n<p>The <code>tlsSocket.servername</code> property is a string containing the server name\nrequested via SNI.</p>"
            },
            {
              "textRaw": "Event: 'tlsClientError'",
              "type": "event",
              "name": "tlsClientError",
              "meta": {
                "added": [
                  "v6.0.0"
                ],
                "changes": []
              },
              "params": [],
              "desc": "<p>The <code>'tlsClientError'</code> event is emitted when an error occurs before a secure\nconnection is established. The listener callback is passed two arguments when\ncalled:</p>\n<ul>\n<li><code>exception</code> <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error\" class=\"type\">&lt;Error&gt;</a> The <code>Error</code> object describing the error</li>\n<li><code>tlsSocket</code> <a href=\"tls.html#tls_class_tls_tlssocket\" class=\"type\">&lt;tls.TLSSocket&gt;</a> The <code>tls.TLSSocket</code> instance from which the\nerror originated.</li>\n</ul>"
            }
          ],
          "methods": [
            {
              "textRaw": "server.addContext(hostname, context)",
              "type": "method",
              "name": "addContext",
              "meta": {
                "added": [
                  "v0.5.3"
                ],
                "changes": []
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`hostname` {string} A SNI hostname or wildcard (e.g. `'*'`)",
                      "name": "hostname",
                      "type": "string",
                      "desc": "A SNI hostname or wildcard (e.g. `'*'`)"
                    },
                    {
                      "textRaw": "`context` {Object} An object containing any of the possible properties from the [`tls.createSecureContext()`][] `options` arguments (e.g. `key`, `cert`, `ca`, etc).",
                      "name": "context",
                      "type": "Object",
                      "desc": "An object containing any of the possible properties from the [`tls.createSecureContext()`][] `options` arguments (e.g. `key`, `cert`, `ca`, etc)."
                    }
                  ]
                }
              ],
              "desc": "<p>The <code>server.addContext()</code> method adds a secure context that will be used if\nthe client request's SNI name matches the supplied <code>hostname</code> (or wildcard).</p>"
            },
            {
              "textRaw": "server.address()",
              "type": "method",
              "name": "address",
              "meta": {
                "added": [
                  "v0.6.0"
                ],
                "changes": []
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {Object}",
                    "name": "return",
                    "type": "Object"
                  },
                  "params": []
                }
              ],
              "desc": "<p>Returns the bound address, the address family name, and port of the\nserver as reported by the operating system. See <a href=\"net.html#net_server_address\"><code>net.Server.address()</code></a> for\nmore information.</p>"
            },
            {
              "textRaw": "server.close([callback])",
              "type": "method",
              "name": "close",
              "meta": {
                "added": [
                  "v0.3.2"
                ],
                "changes": []
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {tls.Server}",
                    "name": "return",
                    "type": "tls.Server"
                  },
                  "params": [
                    {
                      "textRaw": "`callback` {Function} A listener callback that will be registered to listen for the server instance's `'close'` event.",
                      "name": "callback",
                      "type": "Function",
                      "desc": "A listener callback that will be registered to listen for the server instance's `'close'` event.",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>The <code>server.close()</code> method stops the server from accepting new connections.</p>\n<p>This function operates asynchronously. The <code>'close'</code> event will be emitted\nwhen the server has no more open connections.</p>"
            },
            {
              "textRaw": "server.getTicketKeys()",
              "type": "method",
              "name": "getTicketKeys",
              "meta": {
                "added": [
                  "v3.0.0"
                ],
                "changes": []
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {Buffer}",
                    "name": "return",
                    "type": "Buffer"
                  },
                  "params": []
                }
              ],
              "desc": "<p>Returns a <code>Buffer</code> instance holding the keys currently used for\nencryption/decryption of the <a href=\"https://www.ietf.org/rfc/rfc5077.txt\">TLS Session Tickets</a>.</p>"
            },
            {
              "textRaw": "server.listen()",
              "type": "method",
              "name": "listen",
              "signatures": [
                {
                  "params": []
                }
              ],
              "desc": "<p>Starts the server listening for encrypted connections.\nThis method is identical to <a href=\"net.html#net_server_listen\"><code>server.listen()</code></a> from <a href=\"net.html#net_class_net_server\"><code>net.Server</code></a>.</p>"
            },
            {
              "textRaw": "server.setTicketKeys(keys)",
              "type": "method",
              "name": "setTicketKeys",
              "meta": {
                "added": [
                  "v3.0.0"
                ],
                "changes": []
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`keys` {Buffer} The keys used for encryption/decryption of the [TLS Session Tickets][].",
                      "name": "keys",
                      "type": "Buffer",
                      "desc": "The keys used for encryption/decryption of the [TLS Session Tickets][]."
                    }
                  ]
                }
              ],
              "desc": "<p>Updates the keys for encryption/decryption of the <a href=\"https://www.ietf.org/rfc/rfc5077.txt\">TLS Session Tickets</a>.</p>\n<p>The key's <code>Buffer</code> should be 48 bytes long. See <code>ticketKeys</code> option in\n<a href=\"#tls_tls_createserver_options_secureconnectionlistener\"><code>tls.createServer()</code></a> for more information on how it is used.</p>\n<p>Changes to the ticket keys are effective only for future server connections.\nExisting or currently pending server connections will use the previous keys.</p>"
            }
          ],
          "properties": [
            {
              "textRaw": "`connections` {number}",
              "type": "number",
              "name": "connections",
              "meta": {
                "added": [
                  "v0.3.2"
                ],
                "deprecated": [
                  "v0.9.7"
                ],
                "changes": []
              },
              "stability": 0,
              "stabilityText": "Deprecated: Use [`server.getConnections()`][] instead.",
              "desc": "<p>Returns the current number of concurrent connections on the server.</p>"
            }
          ]
        },
        {
          "textRaw": "Class: tls.TLSSocket",
          "type": "class",
          "name": "tls.TLSSocket",
          "meta": {
            "added": [
              "v0.11.4"
            ],
            "changes": []
          },
          "desc": "<p>The <code>tls.TLSSocket</code> is a subclass of <a href=\"net.html#net_class_net_socket\"><code>net.Socket</code></a> that performs transparent\nencryption of written data and all required TLS negotiation.</p>\n<p>Instances of <code>tls.TLSSocket</code> implement the duplex <a href=\"stream.html#stream_stream\">Stream</a> interface.</p>\n<p>Methods that return TLS connection metadata (e.g.\n<a href=\"#tls_tlssocket_getpeercertificate_detailed\"><code>tls.TLSSocket.getPeerCertificate()</code></a> will only return data while the\nconnection is open.</p>",
          "events": [
            {
              "textRaw": "Event: 'OCSPResponse'",
              "type": "event",
              "name": "OCSPResponse",
              "meta": {
                "added": [
                  "v0.11.13"
                ],
                "changes": []
              },
              "params": [],
              "desc": "<p>The <code>'OCSPResponse'</code> event is emitted if the <code>requestOCSP</code> option was set\nwhen the <code>tls.TLSSocket</code> was created and an OCSP response has been received.\nThe listener callback is passed a single argument when called:</p>\n<ul>\n<li><code>response</code> <a href=\"buffer.html#buffer_class_buffer\" class=\"type\">&lt;Buffer&gt;</a> The server's OCSP response</li>\n</ul>\n<p>Typically, the <code>response</code> is a digitally signed object from the server's CA that\ncontains information about server's certificate revocation status.</p>"
            },
            {
              "textRaw": "Event: 'secureConnect'",
              "type": "event",
              "name": "secureConnect",
              "meta": {
                "added": [
                  "v0.11.4"
                ],
                "changes": []
              },
              "params": [],
              "desc": "<p>The <code>'secureConnect'</code> event is emitted after the handshaking process for a new\nconnection has successfully completed. The listener callback will be called\nregardless of whether or not the server's certificate has been authorized. It\nis the client's responsibility to check the <code>tlsSocket.authorized</code> property to\ndetermine if the server certificate was signed by one of the specified CAs. If\n<code>tlsSocket.authorized === false</code>, then the error can be found by examining the\n<code>tlsSocket.authorizationError</code> property. If ALPN was used, the\n<code>tlsSocket.alpnProtocol</code> property can be checked to determine the negotiated\nprotocol.</p>"
            }
          ],
          "methods": [
            {
              "textRaw": "tlsSocket.address()",
              "type": "method",
              "name": "address",
              "meta": {
                "added": [
                  "v0.11.4"
                ],
                "changes": []
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {Object}",
                    "name": "return",
                    "type": "Object"
                  },
                  "params": []
                }
              ],
              "desc": "<p>Returns the bound <code>address</code>, the address <code>family</code> name, and <code>port</code> of the\nunderlying socket as reported by the operating system:\n<code>{ port: 12346, family: 'IPv4', address: '127.0.0.1' }</code>.</p>"
            },
            {
              "textRaw": "tlsSocket.disableRenegotiation()",
              "type": "method",
              "name": "disableRenegotiation",
              "meta": {
                "added": [
                  "v8.4.0"
                ],
                "changes": []
              },
              "signatures": [
                {
                  "params": []
                }
              ],
              "desc": "<p>Disables TLS renegotiation for this <code>TLSSocket</code> instance. Once called, attempts\nto renegotiate will trigger an <code>'error'</code> event on the <code>TLSSocket</code>.</p>"
            },
            {
              "textRaw": "tlsSocket.getCipher()",
              "type": "method",
              "name": "getCipher",
              "meta": {
                "added": [
                  "v0.11.4"
                ],
                "changes": []
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {Object}",
                    "name": "return",
                    "type": "Object"
                  },
                  "params": []
                }
              ],
              "desc": "<p>Returns an object representing the cipher name. The <code>version</code> key is a legacy\nfield which always contains the value <code>'TLSv1/SSLv3'</code>.</p>\n<p>For example: <code>{ name: 'AES256-SHA', version: 'TLSv1/SSLv3' }</code>.</p>\n<p>See <code>SSL_CIPHER_get_name()</code> in\n<a href=\"https://www.openssl.org/docs/man1.1.0/ssl/SSL_CIPHER_get_name.html\">https://www.openssl.org/docs/man1.1.0/ssl/SSL_CIPHER_get_name.html</a> for more\ninformation.</p>"
            },
            {
              "textRaw": "tlsSocket.getEphemeralKeyInfo()",
              "type": "method",
              "name": "getEphemeralKeyInfo",
              "meta": {
                "added": [
                  "v5.0.0"
                ],
                "changes": []
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {Object}",
                    "name": "return",
                    "type": "Object"
                  },
                  "params": []
                }
              ],
              "desc": "<p>Returns an object representing the type, name, and size of parameter of\nan ephemeral key exchange in <a href=\"#tls_perfect_forward_secrecy\">Perfect Forward Secrecy</a> on a client\nconnection. It returns an empty object when the key exchange is not\nephemeral. As this is only supported on a client socket; <code>null</code> is returned\nif called on a server socket. The supported types are <code>'DH'</code> and <code>'ECDH'</code>. The\n<code>name</code> property is available only when type is <code>'ECDH'</code>.</p>\n<p>For example: <code>{ type: 'ECDH', name: 'prime256v1', size: 256 }</code>.</p>"
            },
            {
              "textRaw": "tlsSocket.getFinished()",
              "type": "method",
              "name": "getFinished",
              "meta": {
                "added": [
                  "v9.9.0"
                ],
                "changes": []
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {Buffer|undefined} The latest `Finished` message that has been sent to the socket as part of a SSL/TLS handshake, or `undefined` if no `Finished` message has been sent yet.",
                    "name": "return",
                    "type": "Buffer|undefined",
                    "desc": "The latest `Finished` message that has been sent to the socket as part of a SSL/TLS handshake, or `undefined` if no `Finished` message has been sent yet."
                  },
                  "params": []
                }
              ],
              "desc": "<p>As the <code>Finished</code> messages are message digests of the complete handshake\n(with a total of 192 bits for TLS 1.0 and more for SSL 3.0), they can\nbe used for external authentication procedures when the authentication\nprovided by SSL/TLS is not desired or is not enough.</p>\n<p>Corresponds to the <code>SSL_get_finished</code> routine in OpenSSL and may be used\nto implement the <code>tls-unique</code> channel binding from <a href=\"https://tools.ietf.org/html/rfc5929\">RFC 5929</a>.</p>"
            },
            {
              "textRaw": "tlsSocket.getPeerCertificate([detailed])",
              "type": "method",
              "name": "getPeerCertificate",
              "meta": {
                "added": [
                  "v0.11.4"
                ],
                "changes": []
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {Object}",
                    "name": "return",
                    "type": "Object"
                  },
                  "params": [
                    {
                      "textRaw": "`detailed` {boolean} Include the full certificate chain if `true`, otherwise include just the peer's certificate.",
                      "name": "detailed",
                      "type": "boolean",
                      "desc": "Include the full certificate chain if `true`, otherwise include just the peer's certificate.",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Returns an object representing the peer's certificate. The returned object has\nsome properties corresponding to the fields of the certificate.</p>\n<p>If the full certificate chain was requested, each certificate will include an\n<code>issuerCertificate</code> property containing an object representing its issuer's\ncertificate.</p>\n<pre><code class=\"language-text\">{ subject:\n   { C: 'UK',\n     ST: 'Acknack Ltd',\n     L: 'Rhys Jones',\n     O: 'node.js',\n     OU: 'Test TLS Certificate',\n     CN: 'localhost' },\n  issuer:\n   { C: 'UK',\n     ST: 'Acknack Ltd',\n     L: 'Rhys Jones',\n     O: 'node.js',\n     OU: 'Test TLS Certificate',\n     CN: 'localhost' },\n  issuerCertificate:\n   { ... another certificate, possibly with an .issuerCertificate ... },\n  raw: &#x3C; RAW DER buffer >,\n  pubkey: &#x3C; RAW DER buffer >,\n  valid_from: 'Nov 11 09:52:22 2009 GMT',\n  valid_to: 'Nov 6 09:52:22 2029 GMT',\n  fingerprint: '2A:7A:C2:DD:E5:F9:CC:53:72:35:99:7A:02:5A:71:38:52:EC:8A:DF',\n  fingerprint256: '2A:7A:C2:DD:E5:F9:CC:53:72:35:99:7A:02:5A:71:38:52:EC:8A:DF:00:11:22:33:44:55:66:77:88:99:AA:BB',\n  serialNumber: 'B9B0D332A1AA5635' }\n</code></pre>\n<p>If the peer does not provide a certificate, an empty object will be returned.</p>"
            },
            {
              "textRaw": "tlsSocket.getPeerFinished()",
              "type": "method",
              "name": "getPeerFinished",
              "meta": {
                "added": [
                  "v9.9.0"
                ],
                "changes": []
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {Buffer|undefined} The latest `Finished` message that is expected or has actually been received from the socket as part of a SSL/TLS handshake, or `undefined` if there is no `Finished` message so far.",
                    "name": "return",
                    "type": "Buffer|undefined",
                    "desc": "The latest `Finished` message that is expected or has actually been received from the socket as part of a SSL/TLS handshake, or `undefined` if there is no `Finished` message so far."
                  },
                  "params": []
                }
              ],
              "desc": "<p>As the <code>Finished</code> messages are message digests of the complete handshake\n(with a total of 192 bits for TLS 1.0 and more for SSL 3.0), they can\nbe used for external authentication procedures when the authentication\nprovided by SSL/TLS is not desired or is not enough.</p>\n<p>Corresponds to the <code>SSL_get_peer_finished</code> routine in OpenSSL and may be used\nto implement the <code>tls-unique</code> channel binding from <a href=\"https://tools.ietf.org/html/rfc5929\">RFC 5929</a>.</p>"
            },
            {
              "textRaw": "tlsSocket.getProtocol()",
              "type": "method",
              "name": "getProtocol",
              "meta": {
                "added": [
                  "v5.7.0"
                ],
                "changes": []
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {string|null}",
                    "name": "return",
                    "type": "string|null"
                  },
                  "params": []
                }
              ],
              "desc": "<p>Returns a string containing the negotiated SSL/TLS protocol version of the\ncurrent connection. The value <code>'unknown'</code> will be returned for connected\nsockets that have not completed the handshaking process. The value <code>null</code> will\nbe returned for server sockets or disconnected client sockets.</p>\n<p>Protocol versions are:</p>\n<ul>\n<li><code>'TLSv1'</code></li>\n<li><code>'TLSv1.1'</code></li>\n<li><code>'TLSv1.2'</code></li>\n<li><code>'SSLv3'</code></li>\n</ul>\n<p>See <a href=\"https://www.openssl.org/docs/man1.1.0/ssl/SSL_get_version.html\">https://www.openssl.org/docs/man1.1.0/ssl/SSL_get_version.html</a> for more\ninformation.</p>"
            },
            {
              "textRaw": "tlsSocket.getSession()",
              "type": "method",
              "name": "getSession",
              "meta": {
                "added": [
                  "v0.11.4"
                ],
                "changes": []
              },
              "signatures": [
                {
                  "params": []
                }
              ],
              "desc": "<p>Returns the ASN.1 encoded TLS session or <code>undefined</code> if no session was\nnegotiated. Can be used to speed up handshake establishment when reconnecting\nto the server.</p>"
            },
            {
              "textRaw": "tlsSocket.getTLSTicket()",
              "type": "method",
              "name": "getTLSTicket",
              "meta": {
                "added": [
                  "v0.11.4"
                ],
                "changes": []
              },
              "signatures": [
                {
                  "params": []
                }
              ],
              "desc": "<p>Returns the TLS session ticket or <code>undefined</code> if no session was negotiated.</p>\n<p>This only works with client TLS sockets. Useful only for debugging, for session\nreuse provide <code>session</code> option to <a href=\"#tls_tls_connect_options_callback\"><code>tls.connect()</code></a>.</p>"
            },
            {
              "textRaw": "tlsSocket.renegotiate(options, callback)",
              "type": "method",
              "name": "renegotiate",
              "meta": {
                "added": [
                  "v0.11.8"
                ],
                "changes": []
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`options` {Object}",
                      "name": "options",
                      "type": "Object",
                      "options": [
                        {
                          "textRaw": "`rejectUnauthorized` {boolean} If not `false`, the server certificate is verified against the list of supplied CAs. An `'error'` event is emitted if verification fails; `err.code` contains the OpenSSL error code. **Default:** `true`.",
                          "name": "rejectUnauthorized",
                          "type": "boolean",
                          "default": "`true`",
                          "desc": "If not `false`, the server certificate is verified against the list of supplied CAs. An `'error'` event is emitted if verification fails; `err.code` contains the OpenSSL error code."
                        },
                        {
                          "textRaw": "`requestCert`",
                          "name": "requestCert"
                        }
                      ]
                    },
                    {
                      "textRaw": "`callback` {Function} A function that will be called when the renegotiation request has been completed.",
                      "name": "callback",
                      "type": "Function",
                      "desc": "A function that will be called when the renegotiation request has been completed."
                    }
                  ]
                }
              ],
              "desc": "<p>The <code>tlsSocket.renegotiate()</code> method initiates a TLS renegotiation process.\nUpon completion, the <code>callback</code> function will be passed a single argument\nthat is either an <code>Error</code> (if the request failed) or <code>null</code>.</p>\n<p>This method can be used to request a peer's certificate after the secure\nconnection has been established.</p>\n<p>When running as the server, the socket will be destroyed with an error after\n<code>handshakeTimeout</code> timeout.</p>"
            },
            {
              "textRaw": "tlsSocket.setMaxSendFragment(size)",
              "type": "method",
              "name": "setMaxSendFragment",
              "meta": {
                "added": [
                  "v0.11.11"
                ],
                "changes": []
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {boolean}",
                    "name": "return",
                    "type": "boolean"
                  },
                  "params": [
                    {
                      "textRaw": "`size` {number} The maximum TLS fragment size. The maximum value is `16384`. **Default:** `16384`.",
                      "name": "size",
                      "type": "number",
                      "default": "`16384`",
                      "desc": "The maximum TLS fragment size. The maximum value is `16384`."
                    }
                  ]
                }
              ],
              "desc": "<p>The <code>tlsSocket.setMaxSendFragment()</code> method sets the maximum TLS fragment size.\nReturns <code>true</code> if setting the limit succeeded; <code>false</code> otherwise.</p>\n<p>Smaller fragment sizes decrease the buffering latency on the client: larger\nfragments are buffered by the TLS layer until the entire fragment is received\nand its integrity is verified; large fragments can span multiple roundtrips\nand their processing can be delayed due to packet loss or reordering. However,\nsmaller fragments add extra TLS framing bytes and CPU overhead, which may\ndecrease overall server throughput.</p>"
            }
          ],
          "properties": [
            {
              "textRaw": "tlsSocket.authorizationError",
              "name": "authorizationError",
              "meta": {
                "added": [
                  "v0.11.4"
                ],
                "changes": []
              },
              "desc": "<p>Returns the reason why the peer's certificate was not been verified. This\nproperty is set only when <code>tlsSocket.authorized === false</code>.</p>"
            },
            {
              "textRaw": "`authorized` Returns: {boolean}",
              "type": "boolean",
              "name": "return",
              "meta": {
                "added": [
                  "v0.11.4"
                ],
                "changes": []
              },
              "desc": "<p>Returns <code>true</code> if the peer certificate was signed by one of the CAs specified\nwhen creating the <code>tls.TLSSocket</code> instance, otherwise <code>false</code>.</p>"
            },
            {
              "textRaw": "tlsSocket.encrypted",
              "name": "encrypted",
              "meta": {
                "added": [
                  "v0.11.4"
                ],
                "changes": []
              },
              "desc": "<p>Always returns <code>true</code>. This may be used to distinguish TLS sockets from regular\n<code>net.Socket</code> instances.</p>"
            },
            {
              "textRaw": "`localAddress` {string}",
              "type": "string",
              "name": "localAddress",
              "meta": {
                "added": [
                  "v0.11.4"
                ],
                "changes": []
              },
              "desc": "<p>Returns the string representation of the local IP address.</p>"
            },
            {
              "textRaw": "`localPort` {number}",
              "type": "number",
              "name": "localPort",
              "meta": {
                "added": [
                  "v0.11.4"
                ],
                "changes": []
              },
              "desc": "<p>Returns the numeric representation of the local port.</p>"
            },
            {
              "textRaw": "`remoteAddress` {string}",
              "type": "string",
              "name": "remoteAddress",
              "meta": {
                "added": [
                  "v0.11.4"
                ],
                "changes": []
              },
              "desc": "<p>Returns the string representation of the remote IP address. For example,\n<code>'74.125.127.100'</code> or <code>'2001:4860:a005::68'</code>.</p>"
            },
            {
              "textRaw": "`remoteFamily` {string}",
              "type": "string",
              "name": "remoteFamily",
              "meta": {
                "added": [
                  "v0.11.4"
                ],
                "changes": []
              },
              "desc": "<p>Returns the string representation of the remote IP family. <code>'IPv4'</code> or <code>'IPv6'</code>.</p>"
            },
            {
              "textRaw": "`remotePort` {number}",
              "type": "number",
              "name": "remotePort",
              "meta": {
                "added": [
                  "v0.11.4"
                ],
                "changes": []
              },
              "desc": "<p>Returns the numeric representation of the remote port. For example, <code>443</code>.</p>"
            }
          ],
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`socket` {net.Socket|stream.Duplex} On the server side, any `Duplex` stream. On the client side, any instance of [`net.Socket`][] (for generic `Duplex` stream support on the client side, [`tls.connect()`][] must be used).",
                  "name": "socket",
                  "type": "net.Socket|stream.Duplex",
                  "desc": "On the server side, any `Duplex` stream. On the client side, any instance of [`net.Socket`][] (for generic `Duplex` stream support on the client side, [`tls.connect()`][] must be used)."
                },
                {
                  "textRaw": "`options` {Object}",
                  "name": "options",
                  "type": "Object",
                  "options": [
                    {
                      "textRaw": "`isServer`: The SSL/TLS protocol is asymmetrical, TLSSockets must know if they are to behave as a server or a client. If `true` the TLS socket will be instantiated as a server. **Default:** `false`.",
                      "name": "isServer",
                      "default": "`false`",
                      "desc": "The SSL/TLS protocol is asymmetrical, TLSSockets must know if they are to behave as a server or a client. If `true` the TLS socket will be instantiated as a server."
                    },
                    {
                      "textRaw": "`server` {net.Server} A [`net.Server`][] instance.",
                      "name": "server",
                      "type": "net.Server",
                      "desc": "A [`net.Server`][] instance."
                    },
                    {
                      "textRaw": "`requestCert`: Whether to authenticate the remote peer by requesting a certificate. Clients always request a server certificate. Servers (`isServer` is true) may set `requestCert` to true to request a client certificate.",
                      "name": "requestCert",
                      "desc": "Whether to authenticate the remote peer by requesting a certificate. Clients always request a server certificate. Servers (`isServer` is true) may set `requestCert` to true to request a client certificate."
                    },
                    {
                      "textRaw": "`rejectUnauthorized`: See [`tls.createServer()`][]",
                      "name": "rejectUnauthorized",
                      "desc": "See [`tls.createServer()`][]"
                    },
                    {
                      "textRaw": "`ALPNProtocols`: See [`tls.createServer()`][]",
                      "name": "ALPNProtocols",
                      "desc": "See [`tls.createServer()`][]"
                    },
                    {
                      "textRaw": "`SNICallback`: See [`tls.createServer()`][]",
                      "name": "SNICallback",
                      "desc": "See [`tls.createServer()`][]"
                    },
                    {
                      "textRaw": "`session` {Buffer} A `Buffer` instance containing a TLS session.",
                      "name": "session",
                      "type": "Buffer",
                      "desc": "A `Buffer` instance containing a TLS session."
                    },
                    {
                      "textRaw": "`requestOCSP` {boolean} If `true`, specifies that the OCSP status request extension will be added to the client hello and an `'OCSPResponse'` event will be emitted on the socket before establishing a secure communication",
                      "name": "requestOCSP",
                      "type": "boolean",
                      "desc": "If `true`, specifies that the OCSP status request extension will be added to the client hello and an `'OCSPResponse'` event will be emitted on the socket before establishing a secure communication"
                    },
                    {
                      "textRaw": "`secureContext`: TLS context object created with [`tls.createSecureContext()`][]. If a `secureContext` is _not_ provided, one will be created by passing the entire `options` object to `tls.createSecureContext()`.",
                      "name": "secureContext",
                      "desc": "TLS context object created with [`tls.createSecureContext()`][]. If a `secureContext` is _not_ provided, one will be created by passing the entire `options` object to `tls.createSecureContext()`."
                    },
                    {
                      "textRaw": "...: [`tls.createSecureContext()`][] options that are used if the `secureContext` option is missing. Otherwise, they are ignored.",
                      "name": "...",
                      "desc": "[`tls.createSecureContext()`][] options that are used if the `secureContext` option is missing. Otherwise, they are ignored."
                    }
                  ],
                  "optional": true
                }
              ],
              "desc": "<p>Construct a new <code>tls.TLSSocket</code> object from an existing TCP socket.</p>"
            }
          ]
        }
      ],
      "methods": [
        {
          "textRaw": "tls.checkServerIdentity(hostname, cert)",
          "type": "method",
          "name": "checkServerIdentity",
          "meta": {
            "added": [
              "v0.8.4"
            ],
            "changes": []
          },
          "signatures": [
            {
              "return": {
                "textRaw": "Returns: {Error|undefined}",
                "name": "return",
                "type": "Error|undefined"
              },
              "params": [
                {
                  "textRaw": "`hostname` {string} The host name or IP address to verify the certificate against.",
                  "name": "hostname",
                  "type": "string",
                  "desc": "The host name or IP address to verify the certificate against."
                },
                {
                  "textRaw": "`cert` {Object} An object representing the peer's certificate. The returned object has some properties corresponding to the fields of the certificate.",
                  "name": "cert",
                  "type": "Object",
                  "desc": "An object representing the peer's certificate. The returned object has some properties corresponding to the fields of the certificate."
                }
              ]
            }
          ],
          "desc": "<p>Verifies the certificate <code>cert</code> is issued to <code>hostname</code>.</p>\n<p>Returns <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error\" class=\"type\">&lt;Error&gt;</a> object, populating it with <code>reason</code>, <code>host</code>, and <code>cert</code> on\nfailure. On success, returns <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Undefined_type\" class=\"type\">&lt;undefined&gt;</a>.</p>\n<p>This function can be overwritten by providing alternative function as part of\nthe <code>options.checkServerIdentity</code> option passed to <code>tls.connect()</code>. The\noverwriting function can call <code>tls.checkServerIdentity()</code> of course, to augment\nthe checks done with additional verification.</p>\n<p>This function is only called if the certificate passed all other checks, such as\nbeing issued by trusted CA (<code>options.ca</code>).</p>\n<p>The cert object contains the parsed certificate and will have a structure\nsimilar to:</p>\n<pre><code class=\"language-text\">{ subject:\n   { OU: [ 'Domain Control Validated', 'PositiveSSL Wildcard' ],\n     CN: '*.nodejs.org' },\n  issuer:\n   { C: 'GB',\n     ST: 'Greater Manchester',\n     L: 'Salford',\n     O: 'COMODO CA Limited',\n     CN: 'COMODO RSA Domain Validation Secure Server CA' },\n  subjectaltname: 'DNS:*.nodejs.org, DNS:nodejs.org',\n  infoAccess:\n   { 'CA Issuers - URI':\n      [ 'http://crt.comodoca.com/COMODORSADomainValidationSecureServerCA.crt' ],\n     'OCSP - URI': [ 'http://ocsp.comodoca.com' ] },\n  modulus: 'B56CE45CB740B09A13F64AC543B712FF9EE8E4C284B542A1708A27E82A8D151CA178153E12E6DDA15BF70FFD96CB8A88618641BDFCCA03527E665B70D779C8A349A6F88FD4EF6557180BD4C98192872BCFE3AF56E863C09DDD8BC1EC58DF9D94F914F0369102B2870BECFA1348A0838C9C49BD1C20124B442477572347047506B1FCD658A80D0C44BCC16BC5C5496CFE6E4A8428EF654CD3D8972BF6E5BFAD59C93006830B5EB1056BBB38B53D1464FA6E02BFDF2FF66CD949486F0775EC43034EC2602AEFBF1703AD221DAA2A88353C3B6A688EFE8387811F645CEED7B3FE46E1F8B9F59FAD028F349B9BC14211D5830994D055EEA3D547911E07A0ADDEB8A82B9188E58720D95CD478EEC9AF1F17BE8141BE80906F1A339445A7EB5B285F68039B0F294598A7D1C0005FC22B5271B0752F58CCDEF8C8FD856FB7AE21C80B8A2CE983AE94046E53EDE4CB89F42502D31B5360771C01C80155918637490550E3F555E2EE75CC8C636DDE3633CFEDD62E91BF0F7688273694EEEBA20C2FC9F14A2A435517BC1D7373922463409AB603295CEB0BB53787A334C9CA3CA8B30005C5A62FC0715083462E00719A8FA3ED0A9828C3871360A73F8B04A4FC1E71302844E9BB9940B77E745C9D91F226D71AFCAD4B113AAF68D92B24DDB4A2136B55A1CD1ADF39605B63CB639038ED0F4C987689866743A68769CC55847E4A06D6E2E3F1',\n  exponent: '0x10001',\n  pubkey: &#x3C;Buffer ... >,\n  valid_from: 'Aug 14 00:00:00 2017 GMT',\n  valid_to: 'Nov 20 23:59:59 2019 GMT',\n  fingerprint: '01:02:59:D9:C3:D2:0D:08:F7:82:4E:44:A4:B4:53:C5:E2:3A:87:4D',\n  fingerprint256: '69:AE:1A:6A:D4:3D:C6:C1:1B:EA:C6:23:DE:BA:2A:14:62:62:93:5C:7A:EA:06:41:9B:0B:BC:87:CE:48:4E:02',\n  ext_key_usage: [ '1.3.6.1.5.5.7.3.1', '1.3.6.1.5.5.7.3.2' ],\n  serialNumber: '66593D57F20CBC573E433381B5FEC280',\n  raw: &#x3C;Buffer ... > }\n</code></pre>"
        },
        {
          "textRaw": "tls.connect(options[, callback])",
          "type": "method",
          "name": "connect",
          "meta": {
            "added": [
              "v0.11.3"
            ],
            "changes": [
              {
                "version": "v8.0.0",
                "pr-url": "https://github.com/nodejs/node/pull/12839",
                "description": "The `lookup` option is supported now."
              },
              {
                "version": "v8.0.0",
                "pr-url": "https://github.com/nodejs/node/pull/11984",
                "description": "The `ALPNProtocols` option can be a `Uint8Array` now."
              },
              {
                "version": "v5.3.0, v4.7.0",
                "pr-url": "https://github.com/nodejs/node/pull/4246",
                "description": "The `secureContext` option is supported now."
              },
              {
                "version": "v5.0.0",
                "pr-url": "https://github.com/nodejs/node/pull/2564",
                "description": "ALPN options are supported now."
              }
            ]
          },
          "signatures": [
            {
              "return": {
                "textRaw": "Returns: {tls.TLSSocket}",
                "name": "return",
                "type": "tls.TLSSocket"
              },
              "params": [
                {
                  "textRaw": "`options` {Object}",
                  "name": "options",
                  "type": "Object",
                  "options": [
                    {
                      "textRaw": "`host` {string} Host the client should connect to. **Default:** `'localhost'`.",
                      "name": "host",
                      "type": "string",
                      "default": "`'localhost'`",
                      "desc": "Host the client should connect to."
                    },
                    {
                      "textRaw": "`port` {number} Port the client should connect to.",
                      "name": "port",
                      "type": "number",
                      "desc": "Port the client should connect to."
                    },
                    {
                      "textRaw": "`path` {string} Creates unix socket connection to path. If this option is specified, `host` and `port` are ignored.",
                      "name": "path",
                      "type": "string",
                      "desc": "Creates unix socket connection to path. If this option is specified, `host` and `port` are ignored."
                    },
                    {
                      "textRaw": "`socket` {stream.Duplex} Establish secure connection on a given socket rather than creating a new socket. Typically, this is an instance of [`net.Socket`][], but any `Duplex` stream is allowed. If this option is specified, `path`, `host` and `port` are ignored, except for certificate validation. Usually, a socket is already connected when passed to `tls.connect()`, but it can be connected later. Note that connection/disconnection/destruction of `socket` is the user's responsibility, calling `tls.connect()` will not cause `net.connect()` to be called.",
                      "name": "socket",
                      "type": "stream.Duplex",
                      "desc": "Establish secure connection on a given socket rather than creating a new socket. Typically, this is an instance of [`net.Socket`][], but any `Duplex` stream is allowed. If this option is specified, `path`, `host` and `port` are ignored, except for certificate validation. Usually, a socket is already connected when passed to `tls.connect()`, but it can be connected later. Note that connection/disconnection/destruction of `socket` is the user's responsibility, calling `tls.connect()` will not cause `net.connect()` to be called."
                    },
                    {
                      "textRaw": "`rejectUnauthorized` {boolean} If not `false`, the server certificate is verified against the list of supplied CAs. An `'error'` event is emitted if verification fails; `err.code` contains the OpenSSL error code. **Default:** `true`.",
                      "name": "rejectUnauthorized",
                      "type": "boolean",
                      "default": "`true`",
                      "desc": "If not `false`, the server certificate is verified against the list of supplied CAs. An `'error'` event is emitted if verification fails; `err.code` contains the OpenSSL error code."
                    },
                    {
                      "textRaw": "`ALPNProtocols`: {string[]|Buffer[]|Uint8Array[]|Buffer|Uint8Array} An array of strings, `Buffer`s or `Uint8Array`s, or a single `Buffer` or `Uint8Array` containing the supported ALPN protocols. `Buffer`s should have the format `[len][name][len][name]...` e.g. `'\\x08http/1.1\\x08http/1.0'`, where the `len` byte is the length of the next protocol name. Passing an array is usually much simpler, e.g. `['http/1.1', 'http/1.0']`. Protocols earlier in the list have higher preference than those later.",
                      "name": "ALPNProtocols",
                      "type": "string[]|Buffer[]|Uint8Array[]|Buffer|Uint8Array",
                      "desc": "An array of strings, `Buffer`s or `Uint8Array`s, or a single `Buffer` or `Uint8Array` containing the supported ALPN protocols. `Buffer`s should have the format `[len][name][len][name]...` e.g. `'\\x08http/1.1\\x08http/1.0'`, where the `len` byte is the length of the next protocol name. Passing an array is usually much simpler, e.g. `['http/1.1', 'http/1.0']`. Protocols earlier in the list have higher preference than those later."
                    },
                    {
                      "textRaw": "`servername`: {string} Server name for the SNI (Server Name Indication) TLS extension. It is the name of the host being connected to, and must be a host name, and not an IP address. It can be used by a multi-homed server to choose the correct certificate to present to the client, see the `SNICallback` option to [`tls.createServer()`][].",
                      "name": "servername",
                      "type": "string",
                      "desc": "Server name for the SNI (Server Name Indication) TLS extension. It is the name of the host being connected to, and must be a host name, and not an IP address. It can be used by a multi-homed server to choose the correct certificate to present to the client, see the `SNICallback` option to [`tls.createServer()`][]."
                    },
                    {
                      "textRaw": "`checkServerIdentity(servername, cert)` {Function} A callback function to be used (instead of the builtin `tls.checkServerIdentity()` function) when checking the server's hostname (or the provided `servername` when explicitly set) against the certificate. This should return an {Error} if verification fails. The method should return `undefined` if the `servername` and `cert` are verified.",
                      "name": "checkServerIdentity(servername,",
                      "desc": "cert)` {Function} A callback function to be used (instead of the builtin `tls.checkServerIdentity()` function) when checking the server's hostname (or the provided `servername` when explicitly set) against the certificate. This should return an {Error} if verification fails. The method should return `undefined` if the `servername` and `cert` are verified."
                    },
                    {
                      "textRaw": "`session` {Buffer} A `Buffer` instance, containing TLS session.",
                      "name": "session",
                      "type": "Buffer",
                      "desc": "A `Buffer` instance, containing TLS session."
                    },
                    {
                      "textRaw": "`minDHSize` {number} Minimum size of the DH parameter in bits to accept a TLS connection. When a server offers a DH parameter with a size less than `minDHSize`, the TLS connection is destroyed and an error is thrown. **Default:** `1024`.",
                      "name": "minDHSize",
                      "type": "number",
                      "default": "`1024`",
                      "desc": "Minimum size of the DH parameter in bits to accept a TLS connection. When a server offers a DH parameter with a size less than `minDHSize`, the TLS connection is destroyed and an error is thrown."
                    },
                    {
                      "textRaw": "`secureContext`: TLS context object created with [`tls.createSecureContext()`][]. If a `secureContext` is _not_ provided, one will be created by passing the entire `options` object to `tls.createSecureContext()`.",
                      "name": "secureContext",
                      "desc": "TLS context object created with [`tls.createSecureContext()`][]. If a `secureContext` is _not_ provided, one will be created by passing the entire `options` object to `tls.createSecureContext()`."
                    },
                    {
                      "textRaw": "`lookup`: {Function} Custom lookup function. **Default:** [`dns.lookup()`][].",
                      "name": "lookup",
                      "type": "Function",
                      "default": "[`dns.lookup()`][]",
                      "desc": "Custom lookup function."
                    },
                    {
                      "textRaw": "...: [`tls.createSecureContext()`][] options that are used if the `secureContext` option is missing, otherwise they are ignored.",
                      "name": "...",
                      "desc": "[`tls.createSecureContext()`][] options that are used if the `secureContext` option is missing, otherwise they are ignored."
                    }
                  ]
                },
                {
                  "textRaw": "`callback` {Function}",
                  "name": "callback",
                  "type": "Function",
                  "optional": true
                }
              ]
            }
          ],
          "desc": "<p>The <code>callback</code> function, if specified, will be added as a listener for the\n<a href=\"#tls_event_secureconnect\"><code>'secureConnect'</code></a> event.</p>\n<p><code>tls.connect()</code> returns a <a href=\"#tls_class_tls_tlssocket\"><code>tls.TLSSocket</code></a> object.</p>\n<p>The following illustrates a client for the echo server example from\n<a href=\"#tls_tls_createserver_options_secureconnectionlistener\"><code>tls.createServer()</code></a>:</p>\n<pre><code class=\"language-js\">// Assumes an echo server that is listening on port 8000.\nconst tls = require('tls');\nconst fs = require('fs');\n\nconst options = {\n  // Necessary only if the server requires client certificate authentication.\n  key: fs.readFileSync('client-key.pem'),\n  cert: fs.readFileSync('client-cert.pem'),\n\n  // Necessary only if the server uses a self-signed certificate.\n  ca: [ fs.readFileSync('server-cert.pem') ],\n\n  // Necessary only if the server's cert isn't for \"localhost\".\n  checkServerIdentity: () => { return null; },\n};\n\nconst socket = tls.connect(8000, options, () => {\n  console.log('client connected',\n              socket.authorized ? 'authorized' : 'unauthorized');\n  process.stdin.pipe(socket);\n  process.stdin.resume();\n});\nsocket.setEncoding('utf8');\nsocket.on('data', (data) => {\n  console.log(data);\n});\nsocket.on('end', () => {\n  console.log('server ends connection');\n});\n</code></pre>"
        },
        {
          "textRaw": "tls.connect(path[, options][, callback])",
          "type": "method",
          "name": "connect",
          "meta": {
            "added": [
              "v0.11.3"
            ],
            "changes": []
          },
          "signatures": [
            {
              "return": {
                "textRaw": "Returns: {tls.TLSSocket}",
                "name": "return",
                "type": "tls.TLSSocket"
              },
              "params": [
                {
                  "textRaw": "`path` {string} Default value for `options.path`.",
                  "name": "path",
                  "type": "string",
                  "desc": "Default value for `options.path`."
                },
                {
                  "textRaw": "`options` {Object} See [`tls.connect()`][].",
                  "name": "options",
                  "type": "Object",
                  "desc": "See [`tls.connect()`][].",
                  "optional": true
                },
                {
                  "textRaw": "`callback` {Function} See [`tls.connect()`][].",
                  "name": "callback",
                  "type": "Function",
                  "desc": "See [`tls.connect()`][].",
                  "optional": true
                }
              ]
            }
          ],
          "desc": "<p>Same as <a href=\"#tls_tls_connect_options_callback\"><code>tls.connect()</code></a> except that <code>path</code> can be provided\nas an argument instead of an option.</p>\n<p>A path option, if specified, will take precedence over the path argument.</p>"
        },
        {
          "textRaw": "tls.connect(port[, host][, options][, callback])",
          "type": "method",
          "name": "connect",
          "meta": {
            "added": [
              "v0.11.3"
            ],
            "changes": []
          },
          "signatures": [
            {
              "return": {
                "textRaw": "Returns: {tls.TLSSocket}",
                "name": "return",
                "type": "tls.TLSSocket"
              },
              "params": [
                {
                  "textRaw": "`port` {number} Default value for `options.port`.",
                  "name": "port",
                  "type": "number",
                  "desc": "Default value for `options.port`."
                },
                {
                  "textRaw": "`host` {string} Default value for `options.host`.",
                  "name": "host",
                  "type": "string",
                  "desc": "Default value for `options.host`.",
                  "optional": true
                },
                {
                  "textRaw": "`options` {Object} See [`tls.connect()`][].",
                  "name": "options",
                  "type": "Object",
                  "desc": "See [`tls.connect()`][].",
                  "optional": true
                },
                {
                  "textRaw": "`callback` {Function} See [`tls.connect()`][].",
                  "name": "callback",
                  "type": "Function",
                  "desc": "See [`tls.connect()`][].",
                  "optional": true
                }
              ]
            }
          ],
          "desc": "<p>Same as <a href=\"#tls_tls_connect_options_callback\"><code>tls.connect()</code></a> except that <code>port</code> and <code>host</code> can be provided\nas arguments instead of options.</p>\n<p>A port or host option, if specified, will take precedence over any port or host\nargument.</p>"
        },
        {
          "textRaw": "tls.createSecureContext([options])",
          "type": "method",
          "name": "createSecureContext",
          "meta": {
            "added": [
              "v0.11.13"
            ],
            "changes": [
              {
                "version": "v10.0.0",
                "pr-url": "https://github.com/nodejs/node/pull/19794",
                "description": "The `ecdhCurve` cannot be set to `false` anymore due to a change in OpenSSL."
              },
              {
                "version": "v9.3.0",
                "pr-url": "https://github.com/nodejs/node/pull/14903",
                "description": "The `options` parameter can now include `clientCertEngine`."
              },
              {
                "version": "v7.3.0",
                "pr-url": "https://github.com/nodejs/node/pull/10294",
                "description": "If the `key` option is an array, individual entries do not need a `passphrase` property anymore. `Array` entries can also just be `string`s or `Buffer`s now."
              },
              {
                "version": "v5.2.0",
                "pr-url": "https://github.com/nodejs/node/pull/4099",
                "description": "The `ca` option can now be a single string containing multiple CA certificates."
              }
            ]
          },
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`options` {Object}",
                  "name": "options",
                  "type": "Object",
                  "options": [
                    {
                      "textRaw": "`ca` {string|string[]|Buffer|Buffer[]} Optionally override the trusted CA certificates. Default is to trust the well-known CAs curated by Mozilla. Mozilla's CAs are completely replaced when CAs are explicitly specified using this option. The value can be a string or `Buffer`, or an `Array` of strings and/or `Buffer`s. Any string or `Buffer` can contain multiple PEM CAs concatenated together. The peer's certificate must be chainable to a CA trusted by the server for the connection to be authenticated. When using certificates that are not chainable to a well-known CA, the certificate's CA must be explicitly specified as a trusted or the connection will fail to authenticate. If the peer uses a certificate that doesn't match or chain to one of the default CAs, use the `ca` option to provide a CA certificate that the peer's certificate can match or chain to. For self-signed certificates, the certificate is its own CA, and must be provided.",
                      "name": "ca",
                      "type": "string|string[]|Buffer|Buffer[]",
                      "desc": "Optionally override the trusted CA certificates. Default is to trust the well-known CAs curated by Mozilla. Mozilla's CAs are completely replaced when CAs are explicitly specified using this option. The value can be a string or `Buffer`, or an `Array` of strings and/or `Buffer`s. Any string or `Buffer` can contain multiple PEM CAs concatenated together. The peer's certificate must be chainable to a CA trusted by the server for the connection to be authenticated. When using certificates that are not chainable to a well-known CA, the certificate's CA must be explicitly specified as a trusted or the connection will fail to authenticate. If the peer uses a certificate that doesn't match or chain to one of the default CAs, use the `ca` option to provide a CA certificate that the peer's certificate can match or chain to. For self-signed certificates, the certificate is its own CA, and must be provided."
                    },
                    {
                      "textRaw": "`cert` {string|string[]|Buffer|Buffer[]} Cert chains in PEM format. One cert chain should be provided per private key. Each cert chain should consist of the PEM formatted certificate for a provided private `key`, followed by the PEM formatted intermediate certificates (if any), in order, and not including the root CA (the root CA must be pre-known to the peer, see `ca`). When providing multiple cert chains, they do not have to be in the same order as their private keys in `key`. If the intermediate certificates are not provided, the peer will not be able to validate the certificate, and the handshake will fail.",
                      "name": "cert",
                      "type": "string|string[]|Buffer|Buffer[]",
                      "desc": "Cert chains in PEM format. One cert chain should be provided per private key. Each cert chain should consist of the PEM formatted certificate for a provided private `key`, followed by the PEM formatted intermediate certificates (if any), in order, and not including the root CA (the root CA must be pre-known to the peer, see `ca`). When providing multiple cert chains, they do not have to be in the same order as their private keys in `key`. If the intermediate certificates are not provided, the peer will not be able to validate the certificate, and the handshake will fail."
                    },
                    {
                      "textRaw": "`ciphers` {string} Cipher suite specification, replacing the default. For more information, see [modifying the default cipher suite][].",
                      "name": "ciphers",
                      "type": "string",
                      "desc": "Cipher suite specification, replacing the default. For more information, see [modifying the default cipher suite][]."
                    },
                    {
                      "textRaw": "`clientCertEngine` {string} Name of an OpenSSL engine which can provide the client certificate.",
                      "name": "clientCertEngine",
                      "type": "string",
                      "desc": "Name of an OpenSSL engine which can provide the client certificate."
                    },
                    {
                      "textRaw": "`crl` {string|string[]|Buffer|Buffer[]} PEM formatted CRLs (Certificate Revocation Lists).",
                      "name": "crl",
                      "type": "string|string[]|Buffer|Buffer[]",
                      "desc": "PEM formatted CRLs (Certificate Revocation Lists)."
                    },
                    {
                      "textRaw": "`dhparam` {string|Buffer} Diffie Hellman parameters, required for [Perfect Forward Secrecy][]. Use `openssl dhparam` to create the parameters. The key length must be greater than or equal to 1024 bits, otherwise an error will be thrown. It is strongly recommended to use 2048 bits or larger for stronger security. If omitted or invalid, the parameters are silently discarded and DHE ciphers will not be available.",
                      "name": "dhparam",
                      "type": "string|Buffer",
                      "desc": "Diffie Hellman parameters, required for [Perfect Forward Secrecy][]. Use `openssl dhparam` to create the parameters. The key length must be greater than or equal to 1024 bits, otherwise an error will be thrown. It is strongly recommended to use 2048 bits or larger for stronger security. If omitted or invalid, the parameters are silently discarded and DHE ciphers will not be available."
                    },
                    {
                      "textRaw": "`ecdhCurve` {string} A string describing a named curve or a colon separated list of curve NIDs or names, for example `P-521:P-384:P-256`, to use for ECDH key agreement. Set to `auto` to select the curve automatically. Use [`crypto.getCurves()`][] to obtain a list of available curve names. On recent releases, `openssl ecparam -list_curves` will also display the name and description of each available elliptic curve. **Default:** [`tls.DEFAULT_ECDH_CURVE`].",
                      "name": "ecdhCurve",
                      "type": "string",
                      "default": "[`tls.DEFAULT_ECDH_CURVE`]",
                      "desc": "A string describing a named curve or a colon separated list of curve NIDs or names, for example `P-521:P-384:P-256`, to use for ECDH key agreement. Set to `auto` to select the curve automatically. Use [`crypto.getCurves()`][] to obtain a list of available curve names. On recent releases, `openssl ecparam -list_curves` will also display the name and description of each available elliptic curve."
                    },
                    {
                      "textRaw": "`honorCipherOrder` {boolean} Attempt to use the server's cipher suite preferences instead of the client's. When `true`, causes `SSL_OP_CIPHER_SERVER_PREFERENCE` to be set in `secureOptions`, see [OpenSSL Options][] for more information.",
                      "name": "honorCipherOrder",
                      "type": "boolean",
                      "desc": "Attempt to use the server's cipher suite preferences instead of the client's. When `true`, causes `SSL_OP_CIPHER_SERVER_PREFERENCE` to be set in `secureOptions`, see [OpenSSL Options][] for more information."
                    },
                    {
                      "textRaw": "`key` {string|string[]|Buffer|Buffer[]|Object[]} Private keys in PEM format. PEM allows the option of private keys being encrypted. Encrypted keys will be decrypted with `options.passphrase`. Multiple keys using different algorithms can be provided either as an array of unencrypted key strings or buffers, or an array of objects in the form `{pem: <string|buffer>[, passphrase: <string>]}`. The object form can only occur in an array. `object.passphrase` is optional. Encrypted keys will be decrypted with `object.passphrase` if provided, or `options.passphrase` if it is not.",
                      "name": "key",
                      "type": "string|string[]|Buffer|Buffer[]|Object[]",
                      "desc": "Private keys in PEM format. PEM allows the option of private keys being encrypted. Encrypted keys will be decrypted with `options.passphrase`. Multiple keys using different algorithms can be provided either as an array of unencrypted key strings or buffers, or an array of objects in the form `{pem: <string|buffer>[, passphrase: <string>]}`. The object form can only occur in an array. `object.passphrase` is optional. Encrypted keys will be decrypted with `object.passphrase` if provided, or `options.passphrase` if it is not."
                    },
                    {
                      "textRaw": "`passphrase` {string} Shared passphrase used for a single private key and/or a PFX.",
                      "name": "passphrase",
                      "type": "string",
                      "desc": "Shared passphrase used for a single private key and/or a PFX."
                    },
                    {
                      "textRaw": "`pfx` {string|string[]|Buffer|Buffer[]|Object[]} PFX or PKCS12 encoded private key and certificate chain. `pfx` is an alternative to providing `key` and `cert` individually. PFX is usually encrypted, if it is, `passphrase` will be used to decrypt it. Multiple PFX can be provided either as an array of unencrypted PFX buffers, or an array of objects in the form `{buf: <string|buffer>[, passphrase: <string>]}`. The object form can only occur in an array. `object.passphrase` is optional. Encrypted PFX will be decrypted with `object.passphrase` if provided, or `options.passphrase` if it is not.",
                      "name": "pfx",
                      "type": "string|string[]|Buffer|Buffer[]|Object[]",
                      "desc": "PFX or PKCS12 encoded private key and certificate chain. `pfx` is an alternative to providing `key` and `cert` individually. PFX is usually encrypted, if it is, `passphrase` will be used to decrypt it. Multiple PFX can be provided either as an array of unencrypted PFX buffers, or an array of objects in the form `{buf: <string|buffer>[, passphrase: <string>]}`. The object form can only occur in an array. `object.passphrase` is optional. Encrypted PFX will be decrypted with `object.passphrase` if provided, or `options.passphrase` if it is not."
                    },
                    {
                      "textRaw": "`secureOptions` {number} Optionally affect the OpenSSL protocol behavior, which is not usually necessary. This should be used carefully if at all! Value is a numeric bitmask of the `SSL_OP_*` options from [OpenSSL Options][].",
                      "name": "secureOptions",
                      "type": "number",
                      "desc": "Optionally affect the OpenSSL protocol behavior, which is not usually necessary. This should be used carefully if at all! Value is a numeric bitmask of the `SSL_OP_*` options from [OpenSSL Options][]."
                    },
                    {
                      "textRaw": "`secureProtocol` {string} SSL method to use. The possible values are listed as [SSL_METHODS][], use the function names as strings. For example, `'TLSv1_2_method'` to force TLS version 1.2. **Default:** `'TLS_method'`.",
                      "name": "secureProtocol",
                      "type": "string",
                      "default": "`'TLS_method'`",
                      "desc": "SSL method to use. The possible values are listed as [SSL_METHODS][], use the function names as strings. For example, `'TLSv1_2_method'` to force TLS version 1.2."
                    },
                    {
                      "textRaw": "`sessionIdContext` {string} Opaque identifier used by servers to ensure session state is not shared between applications. Unused by clients.",
                      "name": "sessionIdContext",
                      "type": "string",
                      "desc": "Opaque identifier used by servers to ensure session state is not shared between applications. Unused by clients."
                    }
                  ],
                  "optional": true
                }
              ]
            }
          ],
          "desc": "<p><a href=\"#tls_tls_createserver_options_secureconnectionlistener\"><code>tls.createServer()</code></a> sets the default value of the <code>honorCipherOrder</code> option\nto <code>true</code>, other APIs that create secure contexts leave it unset.</p>\n<p><a href=\"#tls_tls_createserver_options_secureconnectionlistener\"><code>tls.createServer()</code></a> uses a 128 bit truncated SHA1 hash value generated\nfrom <code>process.argv</code> as the default value of the <code>sessionIdContext</code> option, other\nAPIs that create secure contexts have no default value.</p>\n<p>The <code>tls.createSecureContext()</code> method creates a credentials object.</p>\n<p>A key is <em>required</em> for ciphers that make use of certificates. Either <code>key</code> or\n<code>pfx</code> can be used to provide it.</p>\n<p>If the 'ca' option is not given, then Node.js will use the default\npublicly trusted list of CAs as given in\n<a href=\"https://hg.mozilla.org/mozilla-central/raw-file/tip/security/nss/lib/ckfw/builtins/certdata.txt\">https://hg.mozilla.org/mozilla-central/raw-file/tip/security/nss/lib/ckfw/builtins/certdata.txt</a>.</p>"
        },
        {
          "textRaw": "tls.createServer([options][, secureConnectionListener])",
          "type": "method",
          "name": "createServer",
          "meta": {
            "added": [
              "v0.3.2"
            ],
            "changes": [
              {
                "version": "v9.3.0",
                "pr-url": "https://github.com/nodejs/node/pull/14903",
                "description": "The `options` parameter can now include `clientCertEngine`."
              },
              {
                "version": "v8.0.0",
                "pr-url": "https://github.com/nodejs/node/pull/11984",
                "description": "The `ALPNProtocols` option can be a `Uint8Array` now."
              },
              {
                "version": "v5.0.0",
                "pr-url": "https://github.com/nodejs/node/pull/2564",
                "description": "ALPN options are supported now."
              }
            ]
          },
          "signatures": [
            {
              "return": {
                "textRaw": "Returns: {tls.Server}",
                "name": "return",
                "type": "tls.Server"
              },
              "params": [
                {
                  "textRaw": "`options` {Object}",
                  "name": "options",
                  "type": "Object",
                  "options": [
                    {
                      "textRaw": "`ALPNProtocols`: {string[]|Buffer[]|Uint8Array[]|Buffer|Uint8Array} An array of strings, `Buffer`s or `Uint8Array`s, or a single `Buffer` or `Uint8Array` containing the supported ALPN protocols. `Buffer`s should have the format `[len][name][len][name]...` e.g. `0x05hello0x05world`, where the first byte is the length of the next protocol name. Passing an array is usually much simpler, e.g. `['hello', 'world']`. (Protocols should be ordered by their priority.)",
                      "name": "ALPNProtocols",
                      "type": "string[]|Buffer[]|Uint8Array[]|Buffer|Uint8Array",
                      "desc": "An array of strings, `Buffer`s or `Uint8Array`s, or a single `Buffer` or `Uint8Array` containing the supported ALPN protocols. `Buffer`s should have the format `[len][name][len][name]...` e.g. `0x05hello0x05world`, where the first byte is the length of the next protocol name. Passing an array is usually much simpler, e.g. `['hello', 'world']`. (Protocols should be ordered by their priority.)"
                    },
                    {
                      "textRaw": "`clientCertEngine` {string} Name of an OpenSSL engine which can provide the client certificate.",
                      "name": "clientCertEngine",
                      "type": "string",
                      "desc": "Name of an OpenSSL engine which can provide the client certificate."
                    },
                    {
                      "textRaw": "`handshakeTimeout` {number} Abort the connection if the SSL/TLS handshake does not finish in the specified number of milliseconds. A `'tlsClientError'` is emitted on the `tls.Server` object whenever a handshake times out. **Default:** `120000` (120 seconds).",
                      "name": "handshakeTimeout",
                      "type": "number",
                      "default": "`120000` (120 seconds)",
                      "desc": "Abort the connection if the SSL/TLS handshake does not finish in the specified number of milliseconds. A `'tlsClientError'` is emitted on the `tls.Server` object whenever a handshake times out."
                    },
                    {
                      "textRaw": "`rejectUnauthorized` {boolean} If not `false` the server will reject any connection which is not authorized with the list of supplied CAs. This option only has an effect if `requestCert` is `true`. **Default:** `true`.",
                      "name": "rejectUnauthorized",
                      "type": "boolean",
                      "default": "`true`",
                      "desc": "If not `false` the server will reject any connection which is not authorized with the list of supplied CAs. This option only has an effect if `requestCert` is `true`."
                    },
                    {
                      "textRaw": "`requestCert` {boolean} If `true` the server will request a certificate from clients that connect and attempt to verify that certificate. **Default:** `false`.",
                      "name": "requestCert",
                      "type": "boolean",
                      "default": "`false`",
                      "desc": "If `true` the server will request a certificate from clients that connect and attempt to verify that certificate."
                    },
                    {
                      "textRaw": "`sessionTimeout` {number} An integer specifying the number of seconds after which the TLS session identifiers and TLS session tickets created by the server will time out. See [`SSL_CTX_set_timeout`] for more details.",
                      "name": "sessionTimeout",
                      "type": "number",
                      "desc": "An integer specifying the number of seconds after which the TLS session identifiers and TLS session tickets created by the server will time out. See [`SSL_CTX_set_timeout`] for more details."
                    },
                    {
                      "textRaw": "`SNICallback(servername, cb)` {Function} A function that will be called if the client supports SNI TLS extension. Two arguments will be passed when called: `servername` and `cb`. `SNICallback` should invoke `cb(null, ctx)`, where `ctx` is a `SecureContext` instance. (`tls.createSecureContext(...)` can be used to get a proper `SecureContext`.) If `SNICallback` wasn't provided the default callback with high-level API will be used (see below).",
                      "name": "SNICallback(servername,",
                      "desc": "cb)` {Function} A function that will be called if the client supports SNI TLS extension. Two arguments will be passed when called: `servername` and `cb`. `SNICallback` should invoke `cb(null, ctx)`, where `ctx` is a `SecureContext` instance. (`tls.createSecureContext(...)` can be used to get a proper `SecureContext`.) If `SNICallback` wasn't provided the default callback with high-level API will be used (see below)."
                    },
                    {
                      "textRaw": "`ticketKeys`: A 48-byte `Buffer` instance consisting of a 16-byte prefix, a 16-byte HMAC key, and a 16-byte AES key. This can be used to accept TLS session tickets on multiple instances of the TLS server.",
                      "name": "ticketKeys",
                      "desc": "A 48-byte `Buffer` instance consisting of a 16-byte prefix, a 16-byte HMAC key, and a 16-byte AES key. This can be used to accept TLS session tickets on multiple instances of the TLS server."
                    },
                    {
                      "textRaw": "...: Any [`tls.createSecureContext()`][] option can be provided. For servers, the identity options (`pfx` or `key`/`cert`) are usually required.",
                      "name": "...",
                      "desc": "Any [`tls.createSecureContext()`][] option can be provided. For servers, the identity options (`pfx` or `key`/`cert`) are usually required."
                    }
                  ],
                  "optional": true
                },
                {
                  "textRaw": "`secureConnectionListener` {Function}",
                  "name": "secureConnectionListener",
                  "type": "Function",
                  "optional": true
                }
              ]
            }
          ],
          "desc": "<p>Creates a new <a href=\"#tls_class_tls_server\"><code>tls.Server</code></a>. The <code>secureConnectionListener</code>, if provided, is\nautomatically set as a listener for the <a href=\"#tls_event_secureconnection\"><code>'secureConnection'</code></a> event.</p>\n<p>The <code>ticketKeys</code> options is automatically shared between <code>cluster</code> module\nworkers.</p>\n<p>The following illustrates a simple echo server:</p>\n<pre><code class=\"language-js\">const tls = require('tls');\nconst fs = require('fs');\n\nconst options = {\n  key: fs.readFileSync('server-key.pem'),\n  cert: fs.readFileSync('server-cert.pem'),\n\n  // This is necessary only if using client certificate authentication.\n  requestCert: true,\n\n  // This is necessary only if the client uses a self-signed certificate.\n  ca: [ fs.readFileSync('client-cert.pem') ]\n};\n\nconst server = tls.createServer(options, (socket) => {\n  console.log('server connected',\n              socket.authorized ? 'authorized' : 'unauthorized');\n  socket.write('welcome!\\n');\n  socket.setEncoding('utf8');\n  socket.pipe(socket);\n});\nserver.listen(8000, () => {\n  console.log('server bound');\n});\n</code></pre>\n<p>The server can be tested by connecting to it using the example client from\n<a href=\"#tls_tls_connect_options_callback\"><code>tls.connect()</code></a>.</p>"
        },
        {
          "textRaw": "tls.getCiphers()",
          "type": "method",
          "name": "getCiphers",
          "meta": {
            "added": [
              "v0.10.2"
            ],
            "changes": []
          },
          "signatures": [
            {
              "return": {
                "textRaw": "Returns: {string[]}",
                "name": "return",
                "type": "string[]"
              },
              "params": []
            }
          ],
          "desc": "<p>Returns an array with the names of the supported SSL ciphers.</p>\n<pre><code class=\"language-js\">console.log(tls.getCiphers()); // ['AES128-SHA', 'AES256-SHA', ...]\n</code></pre>"
        }
      ],
      "properties": [
        {
          "textRaw": "tls.DEFAULT_ECDH_CURVE",
          "name": "DEFAULT_ECDH_CURVE",
          "meta": {
            "added": [
              "v0.11.13"
            ],
            "changes": []
          },
          "desc": "<p>The default curve name to use for ECDH key agreement in a tls server. The\ndefault value is <code>'auto'</code>. See <a href=\"#tls_tls_createsecurecontext_options\"><code>tls.createSecureContext()</code></a> for further\ninformation.</p>"
        }
      ],
      "type": "module",
      "displayName": "TLS (SSL)"
    }
  ]
}