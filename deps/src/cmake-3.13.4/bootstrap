#!/bin/sh
# Distributed under the OSI-approved BSD 3-Clause License.  See accompanying
# file Copyright.txt or https://cmake.org/licensing for details.

die() {
  echo "$@" 1>&2 ; exit 1
}

# Compile flag extraction function.
cmake_extract_standard_flags()
{
  sed -n "s/ *set *( *CMAKE_${2}${3}_EXTENSION_COMPILE_OPTION *\"\{0,1\}\([^\")]*\).*/\1/p" \
    "${cmake_source_dir}/Modules/Compiler/"${1:-*}-${2}.cmake 2>/dev/null | tr ';' ' '
}

# Version number extraction function.
cmake_version_component()
{
  sed -n "
/^set(CMake_VERSION_${1}/ {s/set(CMake_VERSION_${1} *\([0-9]*\))/\1/;p;}
" "${cmake_source_dir}/Source/CMakeVersion.cmake"
}

# Install destination extraction function.
cmake_install_dest_default()
{
  sed -n '
/^ *set(CMAKE_'"${1}"'_DIR_DEFAULT.*) # '"${2}"'$/ {
  s/^ *set(CMAKE_'"${1}"'_DIR_DEFAULT *"\([^"]*\)").*$/\1/
  s/${CMake_VERSION_MAJOR}/'"${cmake_version_major}"'/
  s/${CMake_VERSION_MINOR}/'"${cmake_version_minor}"'/
  s/${CMake_VERSION_PATCH}/'"${cmake_version_patch}"'/
  p
  q
}
' "${cmake_source_dir}/Source/CMakeInstallDestinations.cmake"
}

cmake_toupper()
{
    echo "$1" | tr '[:lower:]' '[:upper:]'
}

# Detect system and directory information.
cmake_system=`uname`
cmake_source_dir=`cd "\`dirname \"$0\"\`";pwd`
cmake_binary_dir=`pwd`

# Load version information.
cmake_version_major="`cmake_version_component MAJOR`"
cmake_version_minor="`cmake_version_component MINOR`"
cmake_version_patch="`cmake_version_component PATCH`"
cmake_version="${cmake_version_major}.${cmake_version_minor}.${cmake_version_patch}"
cmake_version_rc="`cmake_version_component RC`"
if [ "$cmake_version_rc" != "" ]; then
  cmake_version="${cmake_version}-rc${cmake_version_rc}"
fi

cmake_copyright="`grep '^Copyright .* Kitware' "${cmake_source_dir}/Copyright.txt"`"

cmake_bin_dir_keyword="OTHER"
cmake_data_dir_keyword="OTHER"
cmake_doc_dir_keyword="OTHER"
cmake_man_dir_keyword="OTHER"
cmake_xdgdata_dir_keyword="OTHER"
cmake_bin_dir=""
cmake_data_dir=""
cmake_doc_dir=""
cmake_man_dir=""
cmake_xdgdata_dir=""
cmake_init_file=""
cmake_bootstrap_system_libs=""
cmake_bootstrap_qt_gui=""
cmake_bootstrap_qt_qmake=""
cmake_sphinx_info=""
cmake_sphinx_man=""
cmake_sphinx_html=""
cmake_sphinx_qthelp=""
cmake_sphinx_build=""
cmake_sphinx_flags=""

# Determine whether this is a Cygwin environment.
if echo "${cmake_system}" | grep CYGWIN >/dev/null 2>&1; then
  cmake_system_cygwin=true
  cmake_doc_dir_keyword="CYGWIN"
  cmake_man_dir_keyword="CYGWIN"
else
  cmake_system_cygwin=false
fi

# Determine whether this is a MinGW environment.
if echo "${cmake_system}" | grep 'MINGW\|MSYS' >/dev/null 2>&1; then
  cmake_system_mingw=true
else
  cmake_system_mingw=false
fi

# Determine whether this is OS X
if echo "${cmake_system}" | grep Darwin >/dev/null 2>&1; then
  cmake_system_darwin=true
else
  cmake_system_darwin=false
fi

# Determine whether this is BeOS
if echo "${cmake_system}" | grep BeOS >/dev/null 2>&1; then
  cmake_system_beos=true
  cmake_doc_dir_keyword="HAIKU"
  cmake_man_dir_keyword="HAIKU"
else
  cmake_system_beos=false
fi

# Determine whether this is Haiku
if echo "${cmake_system}" | grep Haiku >/dev/null 2>&1; then
  cmake_system_haiku=true
  cmake_doc_dir_keyword="HAIKU"
  cmake_man_dir_keyword="HAIKU"
else
  cmake_system_haiku=false
fi

# Determine whether this is OpenVMS
if echo "${cmake_system}" | grep OpenVMS >/dev/null 2>&1; then
  cmake_system_openvms=true
else
  cmake_system_openvms=false
fi

# Determine whether this is HP-UX
if echo "${cmake_system}" | grep HP-UX >/dev/null 2>&1; then
  die 'CMake no longer compiles on HP-UX.  See

  https://gitlab.kitware.com/cmake/cmake/issues/17137

Use CMake 3.9 or lower instead.'
  cmake_system_hpux=true
else
  cmake_system_hpux=false
fi

# Determine whether this is Linux
if echo "${cmake_system}" | grep Linux >/dev/null 2>&1; then
  cmake_system_linux=true
else
  cmake_system_linux=false
 fi

# Determine whether this is a PA-RISC machine
# This only works for Linux or HP-UX, not other PA-RISC OSs (BSD maybe?). Also
# may falsely detect parisc on HP-UX m68k
cmake_machine_parisc=false
if ${cmake_system_linux}; then
  if uname -m | grep parisc >/dev/null 2>&1; then
    cmake_machine_parisc=true
  fi
elif ${cmake_system_hpux}; then
  if uname -m | grep ia64 >/dev/null 2>&1; then : ; else
    cmake_machine_parisc=true
  fi
fi

# Choose the generator to use for bootstrapping.
if ${cmake_system_mingw}; then
  # Bootstrapping from an MSYS prompt.
  cmake_bootstrap_generator="MSYS Makefiles"
else
  # Bootstrapping from a standard UNIX prompt.
  cmake_bootstrap_generator="Unix Makefiles"
fi

# Choose tools and extensions for this platform.
if ${cmake_system_openvms}; then
  _tmp="_tmp"
  _cmk="_cmk"
  _diff=`which diff`
else
  _tmp=".tmp"
  _cmk=".cmk"
  _diff="diff"
fi

# Construct bootstrap directory name.
cmake_bootstrap_dir="${cmake_binary_dir}/Bootstrap${_cmk}"

# Helper function to fix windows paths.
case "${cmake_system}" in
*MINGW*)
  cmake_fix_slashes()
  {
    cmd //c echo "$(echo "$1" | sed 's/\\/\//g')" | sed 's/^"//;s/" *$//'
  }
  ;;
*)
  cmake_fix_slashes()
  {
    echo "$1" | sed 's/\\/\//g'
  }
  ;;
esac

# Choose the default install prefix.
if ${cmake_system_mingw}; then
  if [ "x${PROGRAMFILES}" != "x" ]; then
    cmake_default_prefix=`cmake_fix_slashes "${PROGRAMFILES}/CMake"`
  elif [ "x${ProgramFiles}" != "x" ]; then
    cmake_default_prefix=`cmake_fix_slashes "${ProgramFiles}/CMake"`
  elif [ "x${SYSTEMDRIVE}" != "x" ]; then
    cmake_default_prefix=`cmake_fix_slashes "${SYSTEMDRIVE}/Program Files/CMake"`
  elif [ "x${SystemDrive}" != "x" ]; then
    cmake_default_prefix=`cmake_fix_slashes "${SystemDrive}/Program Files/CMake"`
  else
    cmake_default_prefix="c:/Program Files/CMake"
  fi
elif ${cmake_system_haiku}; then
  cmake_default_prefix=`finddir B_COMMON_DIRECTORY`
else
  cmake_default_prefix="/usr/local"
fi

# Lookup default install destinations.
cmake_bin_dir_default="`cmake_install_dest_default BIN ${cmake_bin_dir_keyword}`"
cmake_data_dir_default="`cmake_install_dest_default DATA ${cmake_data_dir_keyword}`"
cmake_doc_dir_default="`cmake_install_dest_default DOC ${cmake_doc_dir_keyword}`"
cmake_man_dir_default="`cmake_install_dest_default MAN ${cmake_man_dir_keyword}`"
cmake_xdgdata_dir_default="`cmake_install_dest_default XDGDATA ${cmake_xdgdata_dir_keyword}`"

CMAKE_KNOWN_C_COMPILERS="cc gcc clang xlc icc tcc"
CMAKE_KNOWN_CXX_COMPILERS="aCC xlC CC g++ clang++ c++ icc como "
CMAKE_KNOWN_MAKE_PROCESSORS="gmake make"

CMAKE_PROBLEMATIC_FILES="\
  CMakeCache.txt \
  CMakeSystem.cmake \
  CMakeCCompiler.cmake \
  CMakeCXXCompiler.cmake \
  */CMakeSystem.cmake \
  */CMakeCCompiler.cmake \
  */CMakeCXXCompiler.cmake \
  Source/cmConfigure.h \
  Source/CTest/Curl/config.h \
  Utilities/cmexpat/expatConfig.h \
  Utilities/cmexpat/expatDllConfig.h \
  "

CMAKE_UNUSED_SOURCES="\
  cmGlobalXCodeGenerator \
  cmLocalXCodeGenerator \
  cmXCodeObject \
  cmXCode21Object \
  cmSourceGroup \
"

CMAKE_CXX_SOURCES="\
  cmAddCustomCommandCommand \
  cmAddCustomTargetCommand \
  cmAddDefinitionsCommand \
  cmAddDependenciesCommand \
  cmAddExecutableCommand \
  cmAddLibraryCommand \
  cmAddSubDirectoryCommand \
  cmAddTestCommand \
  cmBreakCommand \
  cmBuildCommand \
  cmCMakeMinimumRequired \
  cmCMakePolicyCommand \
  cmCPackPropertiesGenerator \
  cmCacheManager \
  cmCommand \
  cmCommandArgumentParserHelper \
  cmCommandArgumentsHelper \
  cmCommands \
  cmCommonTargetGenerator \
  cmComputeComponentGraph \
  cmComputeLinkDepends \
  cmComputeLinkInformation \
  cmComputeTargetDepends \
  cmConditionEvaluator \
  cmConfigureFileCommand \
  cmContinueCommand \
  cmCoreTryCompile \
  cmCreateTestSourceList \
  cmCustomCommand \
  cmCustomCommandGenerator \
  cmDefinePropertyCommand \
  cmDefinitions \
  cmDepends \
  cmDependsC \
  cmDisallowedCommand \
  cmDocumentationFormatter \
  cmEnableLanguageCommand \
  cmEnableTestingCommand \
  cmExecProgramCommand \
  cmExecuteProcessCommand \
  cmExpandedCommandArgument \
  cmExportBuildFileGenerator \
  cmExportFileGenerator \
  cmExportInstallFileGenerator \
  cmExportSet \
  cmExportSetMap \
  cmExportTryCompileFileGenerator \
  cmExprParserHelper \
  cmExternalMakefileProjectGenerator \
  cmFileCommand \
  cmFileTimeComparison \
  cmFindBase \
  cmFindCommon \
  cmFindFileCommand \
  cmFindLibraryCommand \
  cmFindPackageCommand \
  cmFindPathCommand \
  cmFindProgramCommand \
  cmForEachCommand \
  cmFunctionCommand \
  cmFSPermissions \
  cmGeneratedFileStream \
  cmGeneratorExpression \
  cmGeneratorExpressionContext \
  cmGeneratorExpressionDAGChecker \
  cmGeneratorExpressionEvaluationFile \
  cmGeneratorExpressionEvaluator \
  cmGeneratorExpressionLexer \
  cmGeneratorExpressionNode \
  cmGeneratorExpressionParser \
  cmGeneratorTarget \
  cmGetCMakePropertyCommand \
  cmGetDirectoryPropertyCommand \
  cmGetFilenameComponentCommand \
  cmGetPropertyCommand \
  cmGetSourceFilePropertyCommand \
  cmGetTargetPropertyCommand \
  cmGetTestPropertyCommand \
  cmGlobalCommonGenerator \
  cmGlobalGenerator \
  cmGlobalUnixMakefileGenerator3 \
  cmGlobVerificationManager \
  cmHexFileConverter \
  cmIfCommand \
  cmIncludeCommand \
  cmIncludeGuardCommand \
  cmIncludeDirectoryCommand \
  cmIncludeRegularExpressionCommand \
  cmInstallCommand \
  cmInstallCommandArguments \
  cmInstallDirectoryGenerator \
  cmInstallExportGenerator \
  cmInstallFilesCommand \
  cmInstallFilesGenerator \
  cmInstallGenerator \
  cmInstallScriptGenerator \
  cmInstallTargetGenerator \
  cmInstallTargetsCommand \
  cmInstalledFile \
  cmLinkDirectoriesCommand \
  cmLinkItem \
  cmLinkLineComputer \
  cmListCommand \
  cmListFileCache \
  cmLocalCommonGenerator \
  cmLocalGenerator \
  cmLocalUnixMakefileGenerator3 \
  cmMSVC60LinkLineComputer \
  cmMacroCommand \
  cmMakeDirectoryCommand \
  cmMakefile \
  cmMakefileExecutableTargetGenerator \
  cmMakefileLibraryTargetGenerator \
  cmMakefileTargetGenerator \
  cmMakefileUtilityTargetGenerator \
  cmMarkAsAdvancedCommand \
  cmMathCommand \
  cmMessageCommand \
  cmMessenger \
  cmNewLineStyle \
  cmOSXBundleGenerator \
  cmOptionCommand \
  cmOrderDirectories \
  cmOutputConverter \
  cmParseArgumentsCommand \
  cmPathLabel \
  cmPolicies \
  cmProcessOutput \
  cmProjectCommand \
  cmProperty \
  cmPropertyDefinition \
  cmPropertyDefinitionMap \
  cmPropertyMap \
  cmReturnCommand \
  cmRulePlaceholderExpander \
  cmScriptGenerator \
  cmSearchPath \
  cmSeparateArgumentsCommand \
  cmSetCommand \
  cmSetDirectoryPropertiesCommand \
  cmSetPropertyCommand \
  cmSetSourceFilesPropertiesCommand \
  cmSetTargetPropertiesCommand \
  cmSetTestsPropertiesCommand \
  cmSiteNameCommand \
  cmSourceFile \
  cmSourceFileLocation \
  cmState \
  cmStateDirectory \
  cmStateSnapshot \
  cmStringReplaceHelper \
  cmStringCommand \
  cmSubdirCommand \
  cmSystemTools \
  cmTarget \
  cmTargetCompileDefinitionsCommand \
  cmTargetCompileFeaturesCommand \
  cmTargetCompileOptionsCommand \
  cmTargetIncludeDirectoriesCommand \
  cmTargetLinkLibrariesCommand \
  cmTargetPropCommandBase \
  cmTargetPropertyComputer \
  cmTargetSourcesCommand \
  cmTest \
  cmTestGenerator \
  cmTimestamp \
  cmTryCompileCommand \
  cmTryRunCommand \
  cmUnexpectedCommand \
  cmUnsetCommand \
  cmUVHandlePtr \
  cmVersion \
  cmWhileCommand \
  cmWorkingDirectory \
  cmake  \
  cmakemain \
  cmcmd  \
"

if ${cmake_system_mingw}; then
  CMAKE_CXX_SOURCES="${CMAKE_CXX_SOURCES}\
    cmGlobalMSYSMakefileGenerator \
    cmGlobalMinGWMakefileGenerator"
fi

LexerParser_CXX_SOURCES="\
  cmCommandArgumentLexer \
  cmCommandArgumentParser \
  cmExprLexer \
  cmExprParser \
"

LexerParser_C_SOURCES="\
  cmListFileLexer \
"

if ${cmake_system_mingw}; then
  KWSYS_C_SOURCES="\
    EncodingC \
    ProcessWin32 \
    String \
    System \
    Terminal"
else
  KWSYS_C_SOURCES="\
    EncodingC \
    ProcessUNIX \
    String \
    System \
    Terminal"
fi

KWSYS_CXX_SOURCES="\
  Directory \
  EncodingCXX \
  FStream \
  Glob \
  RegularExpression \
  SystemTools"

KWSYS_FILES="\
  Directory.hxx \
  Encoding.h \
  Encoding.hxx \
  FStream.hxx \
  Glob.hxx \
  Process.h \
  RegularExpression.hxx \
  String.h \
  String.hxx \
  System.h \
  SystemTools.hxx \
  Terminal.h"

if ${cmake_system_mingw}; then
  LIBUV_C_SOURCES="\
    src/fs-poll.c \
    src/inet.c \
    src/threadpool.c \
    src/uv-common.c \
    src/win/async.c \
    src/win/core.c \
    src/win/detect-wakeup.c \
    src/win/dl.c \
    src/win/error.c \
    src/win/fs-event.c \
    src/win/fs.c \
    src/win/getaddrinfo.c \
    src/win/getnameinfo.c \
    src/win/handle.c \
    src/win/loop-watcher.c \
    src/win/pipe.c \
    src/win/poll.c \
    src/win/process-stdio.c \
    src/win/process.c \
    src/win/req.c \
    src/win/signal.c \
    src/win/stream.c \
    src/win/tcp.c \
    src/win/thread.c \
    src/win/timer.c \
    src/win/tty.c \
    src/win/udp.c \
    src/win/util.c \
    src/win/winapi.c \
    src/win/winsock.c \
    "
else
  LIBUV_C_SOURCES="\
    src/uv-common.c \
    src/unix/cmake-bootstrap.c \
    src/unix/core.c \
    src/unix/fs.c \
    src/unix/loop.c \
    src/unix/loop-watcher.c \
    src/unix/no-fsevents.c \
    src/unix/pipe.c \
    src/unix/poll.c \
    src/unix/posix-hrtime.c \
    src/unix/posix-poll.c \
    src/unix/process.c \
    src/unix/signal.c \
    src/unix/stream.c \
    src/unix/timer.c \
    "
fi

# Display CMake bootstrap usage
cmake_usage()
{
echo '
Usage: '"$0"' [<options>...] [-- <cmake-options>...]
Options: [defaults in brackets after descriptions]
Configuration:
  --help                  print this message
  --version               only print version information
  --verbose               display more information
  --parallel=n            bootstrap cmake in parallel, where n is
                          number of nodes [1]
  --enable-ccache         Enable ccache when building cmake
  --init=FILE             load FILE as script to populate cache
  --system-libs           use all system-installed third-party libraries
                          (for use only by package maintainers)
  --no-system-libs        use all cmake-provided third-party libraries
                          (default)
  --system-curl           use system-installed curl library
  --no-system-curl        use cmake-provided curl library (default)
  --system-expat          use system-installed expat library
  --no-system-expat       use cmake-provided expat library (default)
  --system-jsoncpp        use system-installed jsoncpp library
  --no-system-jsoncpp     use cmake-provided jsoncpp library (default)
  --system-zlib           use system-installed zlib library
  --no-system-zlib        use cmake-provided zlib library (default)
  --system-bzip2          use system-installed bzip2 library
  --no-system-bzip2       use cmake-provided bzip2 library (default)
  --system-liblzma        use system-installed liblzma library
  --no-system-liblzma     use cmake-provided liblzma library (default)
  --system-libarchive     use system-installed libarchive library
  --no-system-libarchive  use cmake-provided libarchive library (default)
  --system-librhash       use system-installed librhash library
  --no-system-librhash    use cmake-provided librhash library (default)
  --system-libuv          use system-installed libuv library
  --no-system-libuv       use cmake-provided libuv library (default)

  --qt-gui                build the Qt-based GUI (requires Qt >= 4.2)
  --no-qt-gui             do not build the Qt-based GUI (default)
  --qt-qmake=<qmake>      use <qmake> as the qmake executable to find Qt

  --sphinx-info           build Info manual with Sphinx
  --sphinx-man            build man pages with Sphinx
  --sphinx-html           build html help with Sphinx
  --sphinx-qthelp         build qch help with Sphinx
  --sphinx-build=<sb>     use <sb> as the sphinx-build executable
  --sphinx-flags=<flags>  pass <flags> to sphinx-build executable

Directory and file names:
  --prefix=PREFIX         install files in tree rooted at PREFIX
                          ['"${cmake_default_prefix}"']
  --bindir=DIR            install binaries in PREFIX/DIR
                          ['"${cmake_bin_dir_default}"']
  --datadir=DIR           install data files in PREFIX/DIR
                          ['"${cmake_data_dir_default}"']
  --docdir=DIR            install documentation files in PREFIX/DIR
                          ['"${cmake_doc_dir_default}"']
  --mandir=DIR            install man pages files in PREFIX/DIR/manN
                          ['"${cmake_man_dir_default}"']
  --xdgdatadir=DIR        install XDG specific files in PREFIX/DIR
                          ['"${cmake_xdgdata_dir_default}"']
'
  exit 10
}

# Display CMake bootstrap usage
cmake_version_display()
{
  echo "CMake ${cmake_version}, ${cmake_copyright}"
}

# Display CMake bootstrap error, display the log file and exit
cmake_error()
{
  res=$1
  shift 1
  echo "---------------------------------------------"
  echo "Error when bootstrapping CMake:"
  echo "$*"
  echo "---------------------------------------------"
  if [ -f cmake_bootstrap.log ]; then
    echo "Log of errors: `pwd`/cmake_bootstrap.log"
    #cat cmake_bootstrap.log
    echo "---------------------------------------------"
  fi
  exit ${res}
}

cmake_generate_file ()
{
  OUTFILE="$1"
  CONTENT="$2"
  echo "$CONTENT" > "$OUTFILE.tmp"
  if "${_diff}" "$OUTFILE.tmp" "$OUTFILE" > /dev/null 2> /dev/null ; then
    rm -f "$OUTFILE.tmp"
  else
    mv -f "$OUTFILE.tmp" "$OUTFILE"
  fi
}

# Replace KWSYS_NAMESPACE with cmsys
cmake_replace_string ()
{
  INFILE="$1"
  OUTFILE="$2"
  SEARCHFOR="$3"
  REPLACEWITH="$4"
  if [ -f "${INFILE}" ] || ${cmake_system_openvms}; then
    sed "s/\@${SEARCHFOR}\@/${REPLACEWITH}/g" "${INFILE}" > "${OUTFILE}${_tmp}"
    if [ -f "${OUTFILE}${_tmp}" ]; then
      if "${_diff}" "${OUTFILE}" "${OUTFILE}${_tmp}" > /dev/null 2> /dev/null ; then
        #echo "Files are the same"
        rm -f "${OUTFILE}${_tmp}"
      else
        mv -f "${OUTFILE}${_tmp}" "${OUTFILE}"
      fi
    fi
  else
    cmake_error 1 "Cannot find file ${INFILE}"
  fi
}

cmake_kwsys_config_replace_string ()
{
  INFILE="$1"
  OUTFILE="$2"
  shift 2
  APPEND="$*"
  if [ -f "${INFILE}" ] || ${cmake_system_openvms}; then
    echo "${APPEND}" > "${OUTFILE}${_tmp}"
    sed "/./ {s/\@KWSYS_NAMESPACE\@/cmsys/g;
              s/@KWSYS_BUILD_SHARED@/${KWSYS_BUILD_SHARED}/g;
              s/@KWSYS_LFS_AVAILABLE@/${KWSYS_LFS_AVAILABLE}/g;
              s/@KWSYS_LFS_REQUESTED@/${KWSYS_LFS_REQUESTED}/g;
              s/@KWSYS_NAME_IS_KWSYS@/${KWSYS_NAME_IS_KWSYS}/g;
              s/@KWSYS_STL_HAS_WSTRING@/${KWSYS_STL_HAS_WSTRING}/g;
              s/@KWSYS_CXX_HAS_EXT_STDIO_FILEBUF_H@/${KWSYS_CXX_HAS_EXT_STDIO_FILEBUF_H}/g;
             }" "${INFILE}" >> "${OUTFILE}${_tmp}"
    if [ -f "${OUTFILE}${_tmp}" ]; then
      if "${_diff}" "${OUTFILE}" "${OUTFILE}${_tmp}" > /dev/null 2> /dev/null ; then
        #echo "Files are the same"
        rm -f "${OUTFILE}${_tmp}"
      else
        mv -f "${OUTFILE}${_tmp}" "${OUTFILE}"
      fi
    fi
  else
    cmake_error 2 "Cannot find file ${INFILE}"
  fi
}
# Write string into a file
cmake_report ()
{
  FILE=$1
  shift
  echo "$*" >> ${FILE}
}

# Escape spaces in strings
cmake_escape ()
{
  echo $1 | sed "s/ /\\\\ /g"
}

# Encode object file names.
cmake_obj ()
{
  echo $1 | sed 's/\//-/g' | sed 's/$/\.o/'
}

# Strip prefix from argument
cmake_arg ()
{
  echo "$1" | sed "s/^${2-[^=]*=}//"
}

# Write message to the log
cmake_log ()
{
  echo "$*" >> cmake_bootstrap.log
}

# Return temp file
cmake_tmp_file ()
{
  echo "cmake_bootstrap_$$_test"
}

# Run a compiler test. First argument is compiler, second one are compiler
# flags, third one is test source file to be compiled
cmake_try_run ()
{
  COMPILER=$1
  FLAGS=$2
  TESTFILE=$3
  if [ ! -f "${TESTFILE}" ]; then
    echo "Test file ${TESTFILE} missing. Please verify your CMake source tree."
    exit 4
  fi
  TMPFILE=`cmake_tmp_file`
  echo "Try: ${COMPILER}"
  echo "Line: ${COMPILER} ${FLAGS} ${TESTFILE} -o ${TMPFILE}"
  echo "----------  file   -----------------------"
  cat "${TESTFILE}"
  echo "------------------------------------------"
  "${COMPILER}" ${FLAGS} "${TESTFILE}" -o "${TMPFILE}"
  RES=$?
  if [ "${RES}" -ne "0" ]; then
    echo "Test failed to compile"
    return 1
  fi
  if [ ! -f "${TMPFILE}" ] && [ ! -f "${TMPFILE}.exe" ]; then
    echo "Test failed to produce executable"
    return 2
  fi
  ./${TMPFILE}
  RES=$?
  rm -f "${TMPFILE}"
  if [ "${RES}" -ne "0" ]; then
    echo "Test produced non-zero return code"
    return 3
  fi
  echo "Test succeeded"
  return 0
}

# Run a make test. First argument is the make interpreter.
cmake_try_make ()
{
  MAKE_PROC="$1"
  MAKE_FLAGS="$2"
  echo "Try: ${MAKE_PROC}"
  "${MAKE_PROC}" ${MAKE_FLAGS}
  RES=$?
  if [ "${RES}" -ne "0" ]; then
    echo "${MAKE_PROC} does not work"
    return 1
  fi
  if [ ! -f "test" ] && [ ! -f "test.exe" ]; then
    echo "${COMPILER} does not produce output"
    return 2
  fi
  ./test
  RES=$?
  rm -f "test"
  if [ "${RES}" -ne "0" ]; then
    echo "${MAKE_PROC} produces strange executable"
    return 3
  fi
  echo "${MAKE_PROC} works"
  return 0
}

# Parse arguments
cmake_verbose=
cmake_parallel_make=
cmake_ccache_enabled=
cmake_prefix_dir="${cmake_default_prefix}"
while test $# != 0; do
  case "$1" in
  --prefix=*) dir=`cmake_arg "$1"`
              cmake_prefix_dir=`cmake_fix_slashes "$dir"` ;;
  --parallel=*) cmake_parallel_make=`cmake_arg "$1"` ;;
  --bindir=*) cmake_bin_dir=`cmake_arg "$1"` ;;
  --datadir=*) cmake_data_dir=`cmake_arg "$1"` ;;
  --docdir=*) cmake_doc_dir=`cmake_arg "$1"` ;;
  --mandir=*) cmake_man_dir=`cmake_arg "$1"` ;;
  --xdgdatadir=*) cmake_xdgdata_dir=`cmake_arg "$1"` ;;
  --init=*) cmake_init_file=`cmake_arg "$1"` ;;
  --system-libs) cmake_bootstrap_system_libs="${cmake_bootstrap_system_libs} -DCMAKE_USE_SYSTEM_LIBRARIES=1" ;;
  --no-system-libs) cmake_bootstrap_system_libs="${cmake_bootstrap_system_libs} -DCMAKE_USE_SYSTEM_LIBRARIES=0" ;;
  --system-bzip2|--system-curl|--system-expat|--system-jsoncpp|--system-libarchive|--system-librhash|--system-zlib|--system-liblzma|--system-libuv)
    lib=`cmake_arg "$1" "--system-"`
    cmake_bootstrap_system_libs="${cmake_bootstrap_system_libs} -DCMAKE_USE_SYSTEM_LIBRARY_`cmake_toupper $lib`=1" ;;
  --no-system-bzip2|--no-system-curl|--no-system-expat|--no-system-jsoncpp|--no-system-libarchive|--no-system-librhash|--no-system-zlib|--no-system-liblzma|--no-system-libuv)
    lib=`cmake_arg "$1" "--no-system-"`
    cmake_bootstrap_system_libs="${cmake_bootstrap_system_libs} -DCMAKE_USE_SYSTEM_LIBRARY_`cmake_toupper $lib`=0" ;;
  --qt-gui) cmake_bootstrap_qt_gui="1" ;;
  --no-qt-gui) cmake_bootstrap_qt_gui="0" ;;
  --qt-qmake=*) cmake_bootstrap_qt_qmake=`cmake_arg "$1"` ;;
  --sphinx-info) cmake_sphinx_info="1" ;;
  --sphinx-man) cmake_sphinx_man="1" ;;
  --sphinx-html) cmake_sphinx_html="1" ;;
  --sphinx-qthelp) cmake_sphinx_qthelp="1" ;;
  --sphinx-build=*) cmake_sphinx_build=`cmake_arg "$1"` ;;
  --sphinx-flags=*) cmake_sphinx_flags=`cmake_arg "$1"` ;;
  --help) cmake_usage ;;
  --version) cmake_version_display ; exit 2 ;;
  --verbose) cmake_verbose=TRUE ;;
  --enable-ccache) cmake_ccache_enabled=TRUE ;;
  CC=*) CC=`cmake_arg "$1"` ;;
  CXX=*) CXX=`cmake_arg "$1"` ;;
  CFLAGS=*) CFLAGS=`cmake_arg "$1"` ;;
  CXXFLAGS=*) CXXFLAGS=`cmake_arg "$1"` ;;
  LDFLAGS=*) LDFLAGS=`cmake_arg "$1"` ;;
  --) shift; break ;;
  *) die "Unknown option: $1" ;;
  esac
  shift
done

# If verbose, display some information about bootstrap
if [ -n "${cmake_verbose}" ]; then
  echo "---------------------------------------------"
  echo "Source directory: ${cmake_source_dir}"
  echo "Binary directory: ${cmake_binary_dir}"
  echo "Prefix directory: ${cmake_prefix_dir}"
  echo "System:           ${cmake_system}"
  if [ "x${cmake_parallel_make}" != "x" ]; then
    echo "Doing parallel make: ${cmake_parallel_make}"
  fi
  echo ""
fi

echo "---------------------------------------------"
# Get CMake version
echo "`cmake_version_display`"

# Check for in-source build
cmake_in_source_build=
if [ -f "${cmake_binary_dir}/Source/cmake.cxx" -a \
     -f "${cmake_binary_dir}/Source/cmake.h" ]; then
  if [ -n "${cmake_verbose}" ]; then
    echo "Warning: This is an in-source build"
  fi
  cmake_in_source_build=TRUE
fi

# If this is not an in-source build, then Bootstrap stuff should not exist.
if [ -z "${cmake_in_source_build}" ]; then
  # Did somebody bootstrap in the source tree?
  if [ -d "${cmake_source_dir}/Bootstrap${_cmk}" ]; then
    cmake_error 10 "Found directory \"${cmake_source_dir}/Bootstrap${_cmk}\".
Looks like somebody did bootstrap CMake in the source tree, but now you are
trying to do bootstrap in the binary tree. Please remove Bootstrap${_cmk}
directory from the source tree."
  fi
  # Is there a cache in the source tree?
  for cmake_problematic_file in ${CMAKE_PROBLEMATIC_FILES}; do
    if [ -f "${cmake_source_dir}/${cmake_problematic_file}" ]; then
      cmake_error 10 "Found \"${cmake_source_dir}/${cmake_problematic_file}\".
Looks like somebody tried to build CMake in the source tree, but now you are
trying to do bootstrap in the binary tree. Please remove \"${cmake_problematic_file}\"
from the source tree."
    fi
  done
fi

# Make bootstrap directory
[ -d "${cmake_bootstrap_dir}" ] || mkdir "${cmake_bootstrap_dir}"
if [ ! -d "${cmake_bootstrap_dir}" ]; then
  cmake_error 3 "Cannot create directory ${cmake_bootstrap_dir} to bootstrap CMake."
fi
cd "${cmake_bootstrap_dir}"

[ -d "cmsys" ] || mkdir "cmsys"
if [ ! -d "cmsys" ]; then
  cmake_error 4 "Cannot create directory ${cmake_bootstrap_dir}/cmsys"
fi

# Delete all the bootstrap files
rm -f "${cmake_bootstrap_dir}/cmake_bootstrap.log"
rm -f "${cmake_bootstrap_dir}/cmConfigure.h${_tmp}"
rm -f "${cmake_bootstrap_dir}/cmVersionConfig.h${_tmp}"

# If building in-source, remove any cmConfigure.h that may
# have been created by a previous run of the bootstrap cmake.
if [ -n "${cmake_in_source_build}" ]; then
  rm -f "${cmake_source_dir}/Source/cmConfigure.h"
fi

# If exist compiler flags, set them
cmake_c_flags=${CFLAGS}
cmake_cxx_flags=${CXXFLAGS}
cmake_ld_flags=${LDFLAGS}

# Add Cygwin-specific flags
if ${cmake_system_cygwin}; then
  cmake_ld_flags="${LDFLAGS} -Wl,--enable-auto-import"
fi

# Add CoreFoundation framework on Darwin
if ${cmake_system_darwin}; then
  cmake_ld_flags="${LDFLAGS} -framework CoreFoundation"
fi

# Add BeOS toolkits...
if ${cmake_system_beos}; then
  cmake_ld_flags="${LDFLAGS} -lroot -lbe"
fi

# Add Haiku toolkits...
if ${cmake_system_haiku}; then
  cmake_ld_flags="${LDFLAGS} -lroot -lbe"
fi

#-----------------------------------------------------------------------------
# Detect known toolchains on some platforms.
cmake_toolchains=''
case "${cmake_system}" in
  *AIX*)   cmake_toolchains='XL GNU' ;;
  *CYGWIN*) cmake_toolchains='GNU' ;;
  *Darwin*) cmake_toolchains='Clang GNU' ;;
  *Linux*) cmake_toolchains='GNU Clang XL PGI PathScale' ;;
  *MINGW*) cmake_toolchains='GNU' ;;
esac

# Toolchain compiler name table.
cmake_toolchain_Clang_CC='clang'
cmake_toolchain_Clang_CXX='clang++'
cmake_toolchain_GNU_CC='gcc'
cmake_toolchain_GNU_CXX='g++'
cmake_toolchain_PGI_CC='pgcc'
cmake_toolchain_PGI_CXX='pgCC'
cmake_toolchain_PathScale_CC='pathcc'
cmake_toolchain_PathScale_CXX='pathCC'
cmake_toolchain_XL_CC='xlc'
cmake_toolchain_XL_CXX='xlC'

cmake_toolchain_try()
{
  tc="$1"
  TMPFILE=`cmake_tmp_file`

  eval "tc_CC=\${cmake_toolchain_${tc}_CC}"
  echo 'int main() { return 0; }' > "${TMPFILE}.c"
  cmake_try_run "$tc_CC" "" "${TMPFILE}.c" >> cmake_bootstrap.log 2>&1
  tc_result_CC="$?"
  rm -f "${TMPFILE}.c"
  test "${tc_result_CC}" = "0" || return 1

  eval "tc_CXX=\${cmake_toolchain_${tc}_CXX}"
  echo 'int main() { return 0; }' > "${TMPFILE}.cpp"
  cmake_try_run "$tc_CXX" "" "${TMPFILE}.cpp" >> cmake_bootstrap.log 2>&1
  tc_result_CXX="$?"
  rm -f "${TMPFILE}.cpp"
  test "${tc_result_CXX}" = "0" || return 1

  cmake_toolchain="$tc"
}

cmake_toolchain_detect()
{
  cmake_toolchain=
  for tc in ${cmake_toolchains}; do
    echo "Checking for $tc toolchain" >> cmake_bootstrap.log 2>&1
    cmake_toolchain_try "$tc" &&
    echo "Found $tc toolchain" &&
    break
  done
}

if [ -z "${CC}" -a -z "${CXX}" ]; then
  cmake_toolchain_detect
fi

thread_flags=''
case "${cmake_system}" in
  *AIX*)   thread_flags='-pthread' ;;
esac

#-----------------------------------------------------------------------------
# Test C compiler
cmake_c_compiler=

# If CC is set, use that for compiler, otherwise use list of known compilers
if [ -n "${cmake_toolchain}" ]; then
  eval cmake_c_compilers="\${cmake_toolchain_${cmake_toolchain}_CC}"
elif [ -n "${CC}" ]; then
  cmake_c_compilers="${CC}"
else
  cmake_c_compilers="${CMAKE_KNOWN_C_COMPILERS}"
fi

# Check if C compiler works
TMPFILE=`cmake_tmp_file`
echo '
#ifdef __cplusplus
# error "The CMAKE_C_COMPILER is set to a C++ compiler"
#endif

#if defined(_AIX) && defined(__GNUC__) && !defined(_THREAD_SAFE)
#error "On AIX with GNU we need the -pthread flag."
#endif

#if defined(__sun) && __STDC_VERSION__ < 199901L
#error "On Solaris we need C99."
#endif

#include <stdio.h>

int main(int argc, char* argv[])
{
  printf("%d%c", (argv != 0), (char)0x0a);
  return argc - 1;
}
' > "${TMPFILE}.c"
for std in 11 99 90; do
  std_flags="`cmake_extract_standard_flags \"${cmake_toolchain}\" C \"${std}\"`"
  for compiler in ${cmake_c_compilers}; do
    for std_flag in '' $std_flags; do
      for thread_flag in '' $thread_flags; do
        echo "Checking whether '${compiler} ${cmake_c_flags} ${std_flag} ${thread_flag}' works." >> cmake_bootstrap.log 2>&1
        if cmake_try_run "${compiler}" "${cmake_c_flags} ${std_flag} ${thread_flag}" \
          "${TMPFILE}.c" >> cmake_bootstrap.log 2>&1; then
          cmake_c_compiler="${compiler}"
          cmake_c_flags="${cmake_c_flags} ${std_flag} ${thread_flag}"
          break 3
        fi
      done
    done
  done
done
rm -f "${TMPFILE}.c"

if [ -z "${cmake_c_compiler}" ]; then
  cmake_error 6 "Cannot find appropriate C compiler on this system.
Please specify one using environment variable CC.
See cmake_bootstrap.log for compilers attempted.
"
fi
echo "C compiler on this system is: ${cmake_c_compiler} ${cmake_c_flags}"

#-----------------------------------------------------------------------------
# Test CXX compiler
cmake_cxx_compiler=

# On Mac OSX, CC is the same as cc, so make sure not to try CC as c++ compiler.

# If CC is set, use that for compiler, otherwise use list of known compilers
if [ -n "${cmake_toolchain}" ]; then
  eval cmake_cxx_compilers="\${cmake_toolchain_${cmake_toolchain}_CXX}"
elif [ -n "${CXX}" ]; then
  cmake_cxx_compilers="${CXX}"
else
  cmake_cxx_compilers="${CMAKE_KNOWN_CXX_COMPILERS}"
fi

# Check if C++ compiler works
TMPFILE=`cmake_tmp_file`
echo '
#include <iostream>
#include <memory>
#include <unordered_map>

#if __cplusplus < 201103L
#error "Compiler is not in a mode aware of C++11."
#endif

#if defined(_AIX) && defined(__GNUC__) && !defined(_THREAD_SAFE)
#error "On AIX with GNU we need the -pthread flag."
#endif

#if defined(__SUNPRO_CC) && __SUNPRO_CC < 0x5140
#error "SunPro <= 5.13 mode not supported due to bug in move semantics."
#endif

class Class
{
public:
  int Get() const { return this->Member; }
private:
  int Member = 1;
};
int main()
{
  auto const c = std::unique_ptr<Class>(new Class);
  std::cout << c->Get() << std::endl;
  return 0;
}
' > "${TMPFILE}.cxx"
for std in 17 14 11; do
  std_flags="`cmake_extract_standard_flags \"${cmake_toolchain}\" CXX \"${std}\"`"
  for compiler in ${cmake_cxx_compilers}; do
    for std_flag in '' $std_flags; do
      for thread_flag in '' $thread_flags; do
        echo "Checking whether '${compiler} ${cmake_cxx_flags} ${std_flag} ${thread_flag}' works." >> cmake_bootstrap.log 2>&1
        if cmake_try_run "${compiler}" "${cmake_cxx_flags} ${std_flag} ${thread_flag}" \
          "${TMPFILE}.cxx" >> cmake_bootstrap.log 2>&1; then
          cmake_cxx_compiler="${compiler}"
          cmake_cxx_flags="${cmake_cxx_flags} ${std_flag} ${thread_flag} "
          break 3
        fi
      done
    done
  done
done
rm -f "${TMPFILE}.cxx"

if [ -z "${cmake_cxx_compiler}" ]; then
cmake_error 7 "Cannot find a C++ compiler that supports both C++11 and the specified C++ flags.
Please specify one using environment variable CXX.
The C++ flags are \"$cmake_cxx_flags\".
They can be changed using the environment variable CXXFLAGS.
See cmake_bootstrap.log for compilers attempted."
fi
echo "C++ compiler on this system is: ${cmake_cxx_compiler} ${cmake_cxx_flags}"

#-----------------------------------------------------------------------------
# Test Make

cmake_make_processor=
cmake_make_flags=

# If MAKE is set, use that for make processor, otherwise use list of known make
if [ -n "${MAKE}" ]; then
  cmake_make_processors="${MAKE}"
else
  cmake_make_processors="${CMAKE_KNOWN_MAKE_PROCESSORS}"
fi

TMPFILE="`cmake_tmp_file`_dir"
rm -rf "${cmake_bootstrap_dir}/${TMPFILE}"
mkdir "${cmake_bootstrap_dir}/${TMPFILE}"
cd "${cmake_bootstrap_dir}/${TMPFILE}"
echo '
test: test.c
	"'"${cmake_c_compiler}"'" '"${cmake_ld_flags} ${cmake_c_flags}"' -o test test.c
'>"Makefile"
echo '
#include <stdio.h>
int main(){ printf("1%c", (char)0x0a); return 0; }
' > "test.c"
cmake_original_make_flags="${cmake_make_flags}"
if [ "x${cmake_parallel_make}" != "x" ]; then
  cmake_make_flags="${cmake_make_flags} -j ${cmake_parallel_make}"
fi
for a in ${cmake_make_processors}; do
  if [ -z "${cmake_make_processor}" ] && cmake_try_make "${a}" "${cmake_make_flags}" >> ../cmake_bootstrap.log 2>&1; then
    cmake_make_processor="${a}"
  fi
done
cmake_full_make_flags="${cmake_make_flags}"
if [ "x${cmake_original_make_flags}" != "x${cmake_make_flags}" ]; then
  if [ -z "${cmake_make_processor}" ]; then
    cmake_make_flags="${cmake_original_make_flags}"
    for a in ${cmake_make_processors}; do
      if [ -z "${cmake_make_processor}" ] && cmake_try_make "${a}" "${cmake_make_flags}" >> ../cmake_bootstrap.log 2>&1; then
        cmake_make_processor="${a}"
      fi
    done
  fi
fi
cd "${cmake_bootstrap_dir}"

if [ -z "${cmake_make_processor}" ]; then
  cmake_error 8 "Cannot find appropriate Makefile processor on this system.
Please specify one using environment variable MAKE."
fi
rm -rf "${cmake_bootstrap_dir}/${TMPFILE}"
echo "Makefile processor on this system is: ${cmake_make_processor}"
if [ "x${cmake_full_make_flags}" != "x${cmake_make_flags}" ]; then
  echo "---------------------------------------------"
  echo "Makefile processor ${cmake_make_processor} does not support parallel build"
  echo "---------------------------------------------"
fi

# Test for kwsys features
KWSYS_NAME_IS_KWSYS=0
KWSYS_BUILD_SHARED=0
KWSYS_LFS_AVAILABLE=0
KWSYS_LFS_REQUESTED=0
KWSYS_STL_HAS_WSTRING=0
KWSYS_CXX_HAS_EXT_STDIO_FILEBUF_H=0
KWSYS_CXX_HAS_SETENV=0
KWSYS_CXX_HAS_UNSETENV=0
KWSYS_CXX_HAS_ENVIRON_IN_STDLIB_H=0
KWSYS_CXX_HAS_UTIMENSAT=0
KWSYS_CXX_HAS_UTIMES=0

if cmake_try_run "${cmake_cxx_compiler}" \
  "${cmake_cxx_flags} -DTEST_KWSYS_CXX_HAS_SETENV" \
  "${cmake_source_dir}/Source/kwsys/kwsysPlatformTestsCXX.cxx" >> cmake_bootstrap.log 2>&1; then
  KWSYS_CXX_HAS_SETENV=1
  echo "${cmake_cxx_compiler} has setenv"
else
  echo "${cmake_cxx_compiler} does not have setenv"
fi

if cmake_try_run "${cmake_cxx_compiler}" \
  "${cmake_cxx_flags} -DTEST_KWSYS_CXX_HAS_UNSETENV" \
  "${cmake_source_dir}/Source/kwsys/kwsysPlatformTestsCXX.cxx" >> cmake_bootstrap.log 2>&1; then
  KWSYS_CXX_HAS_UNSETENV=1
  echo "${cmake_cxx_compiler} has unsetenv"
else
  echo "${cmake_cxx_compiler} does not have unsetenv"
fi

if cmake_try_run "${cmake_cxx_compiler}" \
  "${cmake_cxx_flags} -DTEST_KWSYS_CXX_HAS_ENVIRON_IN_STDLIB_H" \
  "${cmake_source_dir}/Source/kwsys/kwsysPlatformTestsCXX.cxx" >> cmake_bootstrap.log 2>&1; then
  KWSYS_CXX_HAS_ENVIRON_IN_STDLIB_H=1
  echo "${cmake_cxx_compiler} has environ in stdlib.h"
else
  echo "${cmake_cxx_compiler} does not have environ in stdlib.h"
fi

if cmake_try_run "${cmake_cxx_compiler}" \
  "${cmake_cxx_flags} -DTEST_KWSYS_STL_HAS_WSTRING" \
  "${cmake_source_dir}/Source/kwsys/kwsysPlatformTestsCXX.cxx" >> cmake_bootstrap.log 2>&1; then
  KWSYS_STL_HAS_WSTRING=1
  echo "${cmake_cxx_compiler} has stl wstring"
else
  echo "${cmake_cxx_compiler} does not have stl wstring"
fi

if cmake_try_run "${cmake_cxx_compiler}" \
  "${cmake_cxx_flags} -DTEST_KWSYS_CXX_HAS_EXT_STDIO_FILEBUF_H" \
  "${cmake_source_dir}/Source/kwsys/kwsysPlatformTestsCXX.cxx" >> cmake_bootstrap.log 2>&1; then
  KWSYS_CXX_HAS_EXT_STDIO_FILEBUF_H=1
  echo "${cmake_cxx_compiler} has <ext/stdio_filebuf.h>"
else
  echo "${cmake_cxx_compiler} does not have <ext/stdio_filebuf.h>"
fi

if [ -n "${cmake_ccache_enabled}" ]; then
  echo "Building CMake with ccache"
  cmake_c_compiler="ccache ${cmake_c_compiler}"
  cmake_cxx_compiler="ccache ${cmake_cxx_compiler}"
fi

# Just to be safe, let us store compiler and flags to the header file

cmake_bootstrap_version='$Revision$'
cmake_compiler_settings_comment="/*
 * Generated by ${cmake_source_dir}/bootstrap
 * Version:     ${cmake_bootstrap_version}
 *
 * Source directory: ${cmake_source_dir}
 * Binary directory: ${cmake_bootstrap_dir}
 *
 * C compiler:   ${cmake_c_compiler}
 * C flags:      ${cmake_c_flags}
 *
 * C++ compiler: ${cmake_cxx_compiler}
 * C++ flags:    ${cmake_cxx_flags}
 *
 * Make:         ${cmake_make_processor}
 *
 * Sources:
 * ${CMAKE_CXX_SOURCES} ${CMAKE_C_SOURCES}
 * LexerParser Sources:
 * ${LexerParser_CXX_SOURCES} ${LexerParser_C_SOURCES}
 * kwSys Sources:
 * ${KWSYS_CXX_SOURCES} ${KWSYS_C_SOURCES}
 * libuv Sources:
 * ${LIBUV_C_SOURCES}
 */
"

cmake_report cmConfigure.h${_tmp} "${cmake_compiler_settings_comment}"

# When bootstrapping on MinGW with MSYS we must convert the source
# directory to a windows path.
if ${cmake_system_mingw}; then
    CMAKE_BOOTSTRAP_SOURCE_DIR=`cd "${cmake_source_dir}"; pwd -W`
    CMAKE_BOOTSTRAP_BINARY_DIR=`cd "${cmake_binary_dir}"; pwd -W`
else
    CMAKE_BOOTSTRAP_SOURCE_DIR="${cmake_source_dir}"
    CMAKE_BOOTSTRAP_BINARY_DIR="${cmake_binary_dir}"
fi

# Write CMake version
cmake_report cmVersionConfig.h${_tmp} "#define CMake_VERSION_MAJOR ${cmake_version_major}"
cmake_report cmVersionConfig.h${_tmp} "#define CMake_VERSION_MINOR ${cmake_version_minor}"
cmake_report cmVersionConfig.h${_tmp} "#define CMake_VERSION_PATCH ${cmake_version_patch}"
cmake_report cmVersionConfig.h${_tmp} "#define CMake_VERSION \"${cmake_version}\""
cmake_report cmConfigure.h${_tmp} "#define CMAKE_BOOTSTRAP_SOURCE_DIR \"${CMAKE_BOOTSTRAP_SOURCE_DIR}\""
cmake_report cmConfigure.h${_tmp} "#define CMAKE_BOOTSTRAP_BINARY_DIR \"${CMAKE_BOOTSTRAP_BINARY_DIR}\""
cmake_report cmConfigure.h${_tmp} "#define CMAKE_BIN_DIR \"/bootstrap-not-insalled\""
cmake_report cmConfigure.h${_tmp} "#define CMAKE_DATA_DIR \"/bootstrap-not-insalled\""
cmake_report cmConfigure.h${_tmp} "#define CMAKE_BOOTSTRAP"
cmake_report cmConfigure.h${_tmp} "#define CM_FALLTHROUGH"
cmake_report cmConfigure.h${_tmp} "#define CM_DISABLE_COPY(Class)"

# Regenerate configured headers
for h in Configure VersionConfig; do
  if "${_diff}" cm${h}.h cm${h}.h${_tmp} > /dev/null 2> /dev/null; then
    rm -f cm${h}.h${_tmp}
  else
    mv -f cm${h}.h${_tmp} cm${h}.h
  fi
done

# Prepare KWSYS
cmake_kwsys_config_replace_string \
  "${cmake_source_dir}/Source/kwsys/Configure.hxx.in" \
  "${cmake_bootstrap_dir}/cmsys/Configure.hxx" \
  "${cmake_compiler_settings_comment}"
cmake_kwsys_config_replace_string \
  "${cmake_source_dir}/Source/kwsys/Configure.h.in" \
  "${cmake_bootstrap_dir}/cmsys/Configure.h" \
  "${cmake_compiler_settings_comment}"

for a in ${KWSYS_FILES}; do
  cmake_replace_string "${cmake_source_dir}/Source/kwsys/${a}.in" \
     "${cmake_bootstrap_dir}/cmsys/${a}" KWSYS_NAMESPACE cmsys
done

cmake_generate_file "${cmake_bootstrap_dir}/cmThirdParty.h" ""

# Generate Makefile
dep="cmConfigure.h cmsys/*.hxx cmsys/*.h `cmake_escape \"${cmake_source_dir}\"`/Source/*.h"
objs=""
for a in ${CMAKE_CXX_SOURCES} ${CMAKE_C_SOURCES} ${LexerParser_CXX_SOURCES} ${LexerParser_C_SOURCES} ${KWSYS_CXX_SOURCES} ${KWSYS_C_SOURCES}; do
  objs="${objs} ${a}.o"
done
for a in ${LIBUV_C_SOURCES}; do
  objs="${objs} uv-`cmake_obj ${a}`"
done

libs=""

uv_c_flags=""
if ${cmake_system_mingw}; then
  uv_c_flags="${uv_c_flags} -DWIN32_LEAN_AND_MEAN -D_WIN32_WINNT=0x0600"
  libs="${libs} -lws2_32 -lpsapi -liphlpapi -lshell32 -luserenv"
else
  uv_c_flags="${uv_c_flags} -DCMAKE_BOOTSTRAP"
  case "${cmake_system}" in
    *AIX*)
      uv_c_flags="${uv_c_flags} -D_ALL_SOURCE -D_XOPEN_SOURCE=500 -D_LINUX_SOURCE_COMPAT"
      libs="${libs} -lperfstat"
      ;;
    *Darwin*)
      uv_c_flags="${uv_c_flags} -D_DARWIN_USE_64_BIT_INODE=1 -D_DARWIN_UNLIMITED_SELECT=1"
      ;;
    *Linux*)
      uv_c_flags="${uv_c_flags} -D_GNU_SOURCE"
      libs="${libs} -ldl -lrt"
      ;;
    *kFreeBSD*)
      libs="${libs} -lkvm -lfreebsd-glue"
      ;;
    *BSD*)
      libs="${libs} -lkvm"
      ;;
    *SunOS*)
      # Normally libuv uses '-D_XOPEN_SOURCE=500 -std=c90' on Solaris 5.10,
      # but we do not need to do that because we bootstrap using POSIX APIs.
      uv_c_flags="${uv_c_flags} -D__EXTENSIONS__ -D_XOPEN_SOURCE=600"
      libs="${libs} -lkstat -lnsl -lsendfile -lsocket -lrt"
      ;;
  esac
fi
uv_c_flags="${uv_c_flags} `cmake_escape "-I${cmake_source_dir}/Utilities/cmlibuv/include"`"
if ${cmake_system_mingw}; then
  uv_c_flags="${uv_c_flags} `cmake_escape "-I${cmake_source_dir}/Utilities/cmlibuv/src/win"`"
else
  uv_c_flags="${uv_c_flags} `cmake_escape "-I${cmake_source_dir}/Utilities/cmlibuv/src/unix"`"
fi
uv_c_flags="${uv_c_flags} `cmake_escape "-I${cmake_source_dir}/Utilities/cmlibuv/src"`"

if [ "x${cmake_ansi_cxx_flags}" != "x" ]; then
  cmake_cxx_flags="${cmake_ansi_cxx_flags} ${cmake_cxx_flags}"
fi

if [ "x${cmake_c_flags}" != "x" ]; then
  cmake_c_flags="${cmake_c_flags} "
fi

if [ "x${cmake_cxx_flags}" != "x" ]; then
  cmake_cxx_flags="${cmake_cxx_flags} "
fi

cmake_c_flags_String="-DKWSYS_STRING_C"
if ${cmake_system_mingw}; then
  cmake_c_flags_EncodingC="-DKWSYS_ENCODING_DEFAULT_CODEPAGE=CP_ACP"
  cmake_cxx_flags_EncodingCXX="${cmake_c_flags_EncodingC}"
  cmake_cxx_flags_cmProcessOutput="${cmake_c_flags_EncodingC}"
fi
cmake_cxx_flags_SystemTools="
  -DKWSYS_CXX_HAS_SETENV=${KWSYS_CXX_HAS_SETENV}
  -DKWSYS_CXX_HAS_UNSETENV=${KWSYS_CXX_HAS_UNSETENV}
  -DKWSYS_CXX_HAS_ENVIRON_IN_STDLIB_H=${KWSYS_CXX_HAS_ENVIRON_IN_STDLIB_H}
  -DKWSYS_CXX_HAS_UTIMENSAT=${KWSYS_CXX_HAS_UTIMENSAT}
  -DKWSYS_CXX_HAS_UTIMES=${KWSYS_CXX_HAS_UTIMES}
"
cmake_c_flags="${cmake_c_flags} \
  -I`cmake_escape \"${cmake_bootstrap_dir}\"` \
  -I`cmake_escape \"${cmake_source_dir}/Source\"` \
  -I`cmake_escape \"${cmake_source_dir}/Source/LexerParser\"` \
  -I`cmake_escape \"${cmake_source_dir}/Utilities\"`"
cmake_cxx_flags="${cmake_cxx_flags} \
  -I`cmake_escape \"${cmake_bootstrap_dir}\"` \
  -I`cmake_escape \"${cmake_source_dir}/Source\"` \
  -I`cmake_escape \"${cmake_source_dir}/Source/LexerParser\"` \
  -I`cmake_escape \"${cmake_source_dir}/Utilities\"`"
echo "cmake: ${objs}" > "${cmake_bootstrap_dir}/Makefile"
echo "	${cmake_cxx_compiler} ${cmake_ld_flags} ${cmake_cxx_flags} ${objs} ${libs} -o cmake" >> "${cmake_bootstrap_dir}/Makefile"
for a in ${CMAKE_CXX_SOURCES}; do
  src=`cmake_escape "${cmake_source_dir}/Source/${a}.cxx"`
  src_flags=`eval echo \\${cmake_cxx_flags_\${a}}`
  echo "${a}.o : ${src} ${dep}" >> "${cmake_bootstrap_dir}/Makefile"
  echo "	${cmake_cxx_compiler} ${cmake_cxx_flags} ${src_flags} -c ${src} -o ${a}.o" >> "${cmake_bootstrap_dir}/Makefile"
done
for a in ${CMAKE_C_SOURCES}; do
  src=`cmake_escape "${cmake_source_dir}/Source/${a}.c"`
  echo "${a}.o : ${src} ${dep}" >> "${cmake_bootstrap_dir}/Makefile"
  echo "	${cmake_c_compiler} ${cmake_c_flags} -c ${src} -o ${a}.o" >> "${cmake_bootstrap_dir}/Makefile"
done
for a in ${LexerParser_CXX_SOURCES}; do
  src=`cmake_escape "${cmake_source_dir}/Source/LexerParser/${a}.cxx"`
  src_flags=`eval echo \\${cmake_cxx_flags_\${a}}`
  echo "${a}.o : ${src} ${dep}" >> "${cmake_bootstrap_dir}/Makefile"
  echo "	${cmake_cxx_compiler} ${cmake_cxx_flags} ${src_flags} -c ${src} -o ${a}.o" >> "${cmake_bootstrap_dir}/Makefile"
done
for a in ${LexerParser_C_SOURCES}; do
  src=`cmake_escape "${cmake_source_dir}/Source/LexerParser/${a}.c"`
  echo "${a}.o : ${src} ${dep}" >> "${cmake_bootstrap_dir}/Makefile"
  echo "	${cmake_c_compiler} ${cmake_c_flags} -c ${src} -o ${a}.o" >> "${cmake_bootstrap_dir}/Makefile"
done
for a in ${KWSYS_C_SOURCES}; do
  src=`cmake_escape "${cmake_source_dir}/Source/kwsys/${a}.c"`
  src_flags=`eval echo \\${cmake_c_flags_\${a}}`
  echo "${a}.o : ${src} ${dep}" >> "${cmake_bootstrap_dir}/Makefile"
  echo "	${cmake_c_compiler} ${cmake_c_flags} -DKWSYS_NAMESPACE=cmsys ${src_flags} -c ${src} -o ${a}.o" >> "${cmake_bootstrap_dir}/Makefile"
done
for a in ${KWSYS_CXX_SOURCES}; do
  src=`cmake_escape "${cmake_source_dir}/Source/kwsys/${a}.cxx"`
  src_flags=`eval echo \\${cmake_cxx_flags_\${a}}`
  echo "${a}.o : ${src} ${dep}" >> "${cmake_bootstrap_dir}/Makefile"
  echo "	${cmake_cxx_compiler} ${cmake_cxx_flags} -DKWSYS_NAMESPACE=cmsys ${src_flags} -c ${src} -o ${a}.o" >> "${cmake_bootstrap_dir}/Makefile"
done
for a in ${LIBUV_C_SOURCES}; do
  src=`cmake_escape "${cmake_source_dir}/Utilities/cmlibuv/${a}"`
  echo "uv-`cmake_obj ${a}` : ${src} ${dep}" >> "${cmake_bootstrap_dir}/Makefile"
  echo "	${cmake_c_compiler} ${cmake_c_flags} ${uv_c_flags} -c ${src} -o uv-`cmake_obj ${a}`" >> "${cmake_bootstrap_dir}/Makefile"
done
echo '
rebuild_cache:
	cd "${cmake_binary_dir}" && "${cmake_source_dir}/bootstrap"
' >> "${cmake_bootstrap_dir}/Makefile"

# Write our default settings to Bootstrap${_cmk}/InitialCacheFlags.cmake.
echo '
# Generated by '"${cmake_source_dir}"'/bootstrap
# Default cmake settings.  These may be overridden any settings below.
set (CMAKE_INSTALL_PREFIX "'"${cmake_prefix_dir}"'" CACHE PATH "Install path prefix, prepended onto install directories." FORCE)
set (CMAKE_DOC_DIR "'"${cmake_doc_dir}"'" CACHE PATH "Install location for documentation (relative to prefix)." FORCE)
set (CMAKE_MAN_DIR "'"${cmake_man_dir}"'" CACHE PATH "Install location for man pages (relative to prefix)." FORCE)
set (CMAKE_BIN_DIR "'"${cmake_bin_dir}"'" CACHE PATH "Install location for binaries (relative to prefix)." FORCE)
set (CMAKE_DATA_DIR "'"${cmake_data_dir}"'" CACHE PATH "Install location for data (relative to prefix)." FORCE)
set (CMAKE_XDGDATA_DIR "'"${cmake_xdgdata_dir}"'" CACHE PATH "Install location for XDG specific files (relative to prefix)." FORCE)
' > "${cmake_bootstrap_dir}/InitialCacheFlags.cmake"

# Add configuration settings given as command-line options.
if [ "x${cmake_bootstrap_qt_gui}" != "x" ]; then
  echo '
set (BUILD_QtDialog '"${cmake_bootstrap_qt_gui}"' CACHE BOOL "Build Qt dialog for CMake" FORCE)
' >> "${cmake_bootstrap_dir}/InitialCacheFlags.cmake"
fi
if [ "x${cmake_bootstrap_qt_qmake}" != "x" ]; then
  echo '
set (QT_QMAKE_EXECUTABLE "'"${cmake_bootstrap_qt_qmake}"'" CACHE FILEPATH "Location of Qt qmake" FORCE)
' >> "${cmake_bootstrap_dir}/InitialCacheFlags.cmake"
fi
if [ "x${cmake_sphinx_info}" != "x" ]; then
  echo '
set (SPHINX_INFO "'"${cmake_sphinx_info}"'" CACHE BOOL "Build Info manual with Sphinx" FORCE)
' >> "${cmake_bootstrap_dir}/InitialCacheFlags.cmake"
fi
if [ "x${cmake_sphinx_man}" != "x" ]; then
  echo '
set (SPHINX_MAN "'"${cmake_sphinx_man}"'" CACHE BOOL "Build man pages with Sphinx" FORCE)
' >> "${cmake_bootstrap_dir}/InitialCacheFlags.cmake"
fi
if [ "x${cmake_sphinx_html}" != "x" ]; then
  echo '
set (SPHINX_HTML "'"${cmake_sphinx_html}"'" CACHE BOOL "Build html help with Sphinx" FORCE)
' >> "${cmake_bootstrap_dir}/InitialCacheFlags.cmake"
fi
if [ "x${cmake_sphinx_qthelp}" != "x" ]; then
  echo '
set (SPHINX_QTHELP "'"${cmake_sphinx_qthelp}"'" CACHE BOOL "Build qch help with Sphinx" FORCE)
' >> "${cmake_bootstrap_dir}/InitialCacheFlags.cmake"
fi
if [ "x${cmake_sphinx_build}" != "x" ]; then
  echo '
set (SPHINX_EXECUTABLE "'"${cmake_sphinx_build}"'" CACHE FILEPATH "Location of Qt sphinx-build" FORCE)
' >> "${cmake_bootstrap_dir}/InitialCacheFlags.cmake"
fi
if [ "x${cmake_sphinx_flags}" != "x" ]; then
  echo '
set (SPHINX_FLAGS [==['"${cmake_sphinx_flags}"']==] CACHE STRING "Flags to pass to sphinx-build" FORCE)
' >> "${cmake_bootstrap_dir}/InitialCacheFlags.cmake"
fi

# Add user-specified settings.  Handle relative-path case for
# specification of cmake_init_file.
(
cd "${cmake_binary_dir}"
if [ -f "${cmake_init_file}" ]; then
  cat "${cmake_init_file}" >> "${cmake_bootstrap_dir}/InitialCacheFlags.cmake"
fi
)

echo "---------------------------------------------"

# Run make to build bootstrap cmake
if [ "x${cmake_parallel_make}" != "x" ]; then
  ${cmake_make_processor} ${cmake_make_flags}
else
  ${cmake_make_processor}
fi
RES=$?
if [ "${RES}" -ne "0" ]; then
  cmake_error 9 "Problem while running ${cmake_make_processor}"
fi
cd "${cmake_binary_dir}"

# Set C, CXX, and MAKE environment variables, so that real real cmake will be
# build with same compiler and make
CC="${cmake_c_compiler}"
CXX="${cmake_cxx_compiler}"
MAKE="${cmake_make_processor}"
export CC
export CXX
export MAKE
export CFLAGS
export CXXFLAGS
export LDFLAGS

# Run bootstrap CMake to configure real CMake
cmake_options="-DCMAKE_BOOTSTRAP=1"
if [ -n "${cmake_verbose}" ]; then
  cmake_options="${cmake_options} -DCMAKE_VERBOSE_MAKEFILE=1"
fi
"${cmake_bootstrap_dir}/cmake" "${cmake_source_dir}" "-C${cmake_bootstrap_dir}/InitialCacheFlags.cmake" "-G${cmake_bootstrap_generator}" ${cmake_options} ${cmake_bootstrap_system_libs} "$@"
RES=$?
if [ "${RES}" -ne "0" ]; then
  cmake_error 11 "Problem while running initial CMake"
fi

echo "---------------------------------------------"

# And we are done. Now just run make
echo "CMake has bootstrapped.  Now run ${cmake_make_processor}."
